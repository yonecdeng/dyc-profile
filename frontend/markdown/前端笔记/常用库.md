# 还不知道怎么分类

## rxjs

### rx

Reactive Extension，也叫 ReactiveX，或者简称 Rx，指的是实践响应式编程的一套工具，在 Rx 官网http://reactivex.io/上，有这样一段介绍文字：An API for asynchronous programming with observable streams.翻译过来就是：Rx 是一套通过可监听流来做异步编程的 API。

所有语言并没有天生对响应式编程支持，简单来说就是，这些语言入门教程绝对不会用响应式编程的方法去写一个 Hello World，所以，才需要引入 Reactive Extension，等于是为这些语言增加一些功能扩展（Extension），让响应式编程方法成为开发者的第一选择。

Rx（包括 RxJS）诞生的主要目的虽然是解决异步处理的问题，但并不表示 Rx 不适合同步的数据处理，实际上，使用 RxJS 之后大部分代码不需要关心自己是被同步执行还是异步执行，所以处理起来会更加简单。

RxJS 兼具函数式和响应式（Reactive）两种编程方式的特点

### 总体思想

使用 RxJS 之后大部分代码不需要关心自己是被同步执行还是异步执行，所以处理起来会更加简单。

### Observable 和 Observer

#### 简介

RxJS 的运行就是 Observable 和 Observer 之间的互动游戏。

Observable 对象就是一个发布者，通过 Observable 对象的 subscribe 函数，可以把这个发布者和某个观察者（Observer）连接起来。

RxJS 的 Observable 就是观察者模式和迭代器模式的组合

在 RxJS 中，`Observable` 负责生产数据，而 `Observer` 负责消费数据。`Observable`（生产端）和 `Observer`（消费端）都可能涉及副作用，例如异步请求、打印日志等等。因此它们都是**不纯**的。但是，**那些夹在** `Observable` **和** `Observer` **之间的操作，例如** `map` **、** `filter` **、** `merge` **等等，这些操作专注于数据的计算，并不关心数据的来源和去处、不涉及外部环境**，因此它们总是纯的。

这也就是说，**RxJS 背靠函数式编程的思想，在** `Observable` **和** `Observer` **之间架起了一条“函数管道”** 。生产端 `Observable` 将数据“发射”出去后，数据首先会经过这条“**管道**”，在“**管道**”中完成所有的计算工作后，才会抵达消费端 `Observer`。

对于 RxJS 来说，想和外界发生交互，只能通过管道的首尾两端（也即生产端、消费端）。管道内部是由纯函数组成的，这就保证了整个计算过程的可靠性和可预测性。同时，通过这条“管道”，**生产端** `Observable` **和消费端** `Observer` **被有效地分离，实现了高度的解耦**。

<mark>一个 Observable 对象只能有一种完结形式，complete 或者 error。</mark>

例子：`boxedData` 是一个生产数据的 `Observable`，而 `subscribe` 方法所传入的回调函数则是消费数据的 `Observer`。

```js
import Rx from "rxjs";
import { Observable } from "rxjs/Observable";

// 这里我用 setTimeout 模拟一个网络请求
function fetchData() {
  return Observable.create((observer) => {
    setTimeout(() => {
      observer.next("data");
      observer.complete();
    }, 1000);
  });
}

// 处理数据的纯函数
function processData(data) {
  return data.toUpperCase();
}

// 使用副作用放进盒子的方式处理网络请求
const boxedData = Observable.of(null).flatMap(() => fetchData());

// 订阅处理结果
boxedData.map(processData).subscribe((data) => {
  console.log(data); // 输出 "DATA"
});
```

#### Hot Observable 和 Cold Observable

一个 Observable 是 Hot 还是 Cold，都是相对于生产者而言的，如果每次订阅的时候，已经有一个热的“生产者”准备好了，那就是 Hot Observable，相反，如果每次订阅都要产生一个新的生产者，新的生产者就像汽车引擎一样刚启动时肯定是冷的，所以叫 Cold Observable。

所谓 Cold Observable，就是每次被 subscribe 都产生一个全新的数据序列的数据流。

绝大部分创建的都是 Cold Observable 对象，下面几个产生的是 Hot Observable：❑ fromPromise❑ fromEvent❑ fromEventPattern 不难看出，这些产生 Hot Observable 对象的操作符数据源都在外部，或者是来自于 Promise，或者是来自于 DOM，或者是来自于 Event Emitter，真正的数据源和有没有 Observer 没有任何关系。真正的多播，必定是无论有多少 Observer 来 subscribe，推给 Observer 的都是一样的数据源，满足这种条件的，就是 Hot Observable，因为 Hot Observable 中的内容创建和订阅者无关。

Hot 和 Cold Observable 都具有“懒”的特质，不过 Cold 更“懒”一些，两者的数据管道内逻辑都是只有存在订阅者存在才执行，Cold Observable 更“懒”体现在，如果没有订阅者，连数据都不会真正产生，对于 Hot Observable，没有订阅者的情况下，数据依然会产生，只不过不传入数据管道。所以，Cold Observable 实现的是单播，Hot Observable 实现的多播。

#### 高阶 Observable

##### 简介

比如一个 Observable 对象 A 中产生的数据依然是 Observable 对象，那么 A 就是高阶 Observable 对象。

##### 高阶 Observable 的弹珠图

高阶 Observable 的弹珠图和之前见识过的一阶 Observable 的弹珠图表示方式会有不同，因为其中实际上涉及多个数据流，所以会展示多条横轴。最上面的一条横轴肯定表示的就是主要角色高阶 Observable 本身，下面的多条横轴代表的就是高阶 Observable 的某个 Observable 形式的具体数据。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-19-22-29-image-20231119222926892.png" alt="image-20231119222926892" style="zoom:50%;" />

##### 高阶 Observable 完结的时机

高阶 Observable 完结，不代表内部 Observable 完结。弹珠图中最上面的横轴，也就是高阶 Observable 的时间轴，在第 2 秒的时刻就已经完结，但是两个内部 Observable 却并不会随主干 Observable 的完结而完结，因为作为独立的 Observable，它们有自己的生命周期。

##### 高阶 Observable 的本质

高阶 Observable 的本质是用管理数据的方式来管理多个 Observable 对象

数据流虽然管理的是数据，数据流自身也可以认为是一种数据，既然数据可以用 Observable 来管理，那么数据流本身也可以用 Observable 来管理，让需要被管理的 Observable 对象成为其他 Observable 对象的数据，用现成的管理 Observable 对象的方法来管理 Observable 对象，这就是高阶 Observable 的意义。

### 流

代表“流”的变量标示符，都是用$符号结尾，这是 RxJS 编程中普遍使用的风格，被称为“芬兰式命名法”（Finnish Notation）。

### 弹珠图

竖杠符号|代表的是数据流的完结，对应调用下游的 complete 函数。符号 × 代表数据流中的异常。

一个 Observable 对象只能有一种完结形式，complete 或者 error，所以在一个 Observable 对象的弹珠图上，不可能既有符号|也有符号 ×。

为了描述操作符的功能，弹珠图中往往会出现多条时间轴，因为大部分操作符的工作都是把上游的数据转为传给下游的数据，在弹珠图上必须把上下游的数据流都展示出来，比如，最简单的 map 操作符弹珠图如图 2-7 所示：

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-19-22-16-image-20231119221655849.png" alt="image-20231119221655849" style="zoom:50%;" />

### 操作符（**operators**）

在 RxJS 中，有一系列用于产生 Observable 函数，这些函数有的凭空创造 Observable 对象，有的根据外部数据源产生 Observable 对象，更多的是根据其他的 Observable 中的数据来产生新的 Observable 对象，也就是把上游数据转化为下游数据，所有这些函数统称为操作符。<mark>每一个操作符都是创造一个新的 Observable 对象，不会对上游的 Observable 对象做任何修改。</mark>

操作符（**operators**）是用来组合 Observable 的纯函数，用于对 Observable 进行各种转换、过滤、合并等操作。如 map、filter、mergeMap、switchMap 等等。学习 RxJS 就是学习如何组合操作符来解决复杂问题。

### 工具函数（**utility functions**）

工具函数（**utility functions**）是一些不依赖于 Observable 的纯函数，用于处理 Observable 发射出来的值。例如 tap、delay、timeout 、 `fromEvent`等等。

### 多播

#### 简介

多播就是让一个数据流的内容被多个 Observer 订阅。

在 RxJS 中除了 Subject 这个类型，还有如下几个扩充的形态：❑ BehaviorSubject ❑ ReplaySubject ❑ AsyncSubject

播放内容的方式可以分为三种：❑ 单播（unicast）❑ 广播（broadcast）❑ 多播（multicast）

对于广播，并不是 RxJS 支持的目标，因为已有很多现成的解决方法，例如，Node.js 中的 EventEmitter 支持广播的模式，广播的问题是，发布消息的根本不知道听众是什么样的人，于是筛选消息的责任就完全落在了接收方的身上，而且广播中容易造成频道冲突，就像无线电的共用频段，如果不同的几组人都在用一个频段交流，有的人说的是交通拥堵情况，有的人协调的是餐厅服务，这样很容易乱套。因为广播这种方式影响全局环境，难以控制，和 RxJS 的设计初衷就违背，所以，我们不考虑用 RxJS 实现广播。

如何把 Cold Observable 变成 Hot Observable 呢？答案就是要使用 RxJS 中的 Subject。

#### Subject

要把一个 Cold Observable 对象转换成一个 Hot Observable 对象，并不是去改变这个 Cold Observable 对象本身，而是产生一个新的 Observable 对象，包装之前 Cold Observable 对象，这样在数据流管道中，新的 Observable 对象就成为了下游，想要 Hot 数据源的 Observer 要订阅的是这个作为下游的 Observable 对象。要实现这个转化，很明显需要一个“中间人”做串接的事情，这个中间人有两个职责：❑ 中间人要提供 subscribe 方法，让其他人能够订阅自己的数据源。❑ 中间人要能够有办法接受推送的数据，包括 Cold Observable 推送的数据。上面所说的第一个职责，相当于一个 Observable，第二个工作，相当于一个 Observer。在 RxJS 中，提供了名为 Subject 的类型，一个 Subject 既有 Observable 的接口，也具有 Observer 的接口，一个 Subject 就具备上述的两个职责。

业界并没有习惯把 Subject 对象的变量名加上$后缀

Subject 对象也是一个 Observable 对象，但是因为它有自己的状态，所以不像 Cold Observable 对象一样每次被 subscribe 都是一个新的开始，正因为如此，Subject 对象是不能重复使用的，所谓不能重复使用，指的是一个 Subject 对象一旦被调用了 complete 或者 error 函数，那么，它作为 Observable 的生命周期也就结束了，后续还想调用这个 Subject 对象的 next 函数传递数据给下游，就如同泥牛入大海，一去不回，没有任何反应

虽然 Subject 理论上可以合并多个数据流，但是，因为任何一个上游数据流的完结或者出错信息都可以终结 Subject 对象的生命，让 Subject 来做合并数据流的工作显得并不合适。

合并数据流应该使用 merge，只有上游所有的数据流都完结之后，产生的 Observable 对象才完结

有意思的是 Subject 有多个 Observer 的场景，如果 Subject 的某个下游数据流产生了一个错误异常，而且这个错误异常没有被 Observer 处理，那这个 Subject 其他的 Observer 都会失败。

让 Subject 的所有 Observer 都具备对异常错误的处理，这样就避免异常错误的散弹枪效果。

### 经典实践-快速切 tab

假设页面上有几个垂类 Tab，每次切换都会发送请求更新下发的数据来源。如何才能保证用户在快速切换 Tab 时下发数据来源不错乱？

思路一般分为两种：

1. 从确保顺序入手：请求携带标识，请求返回后根据标识判断是否渲染；
2. 从降低频率入手：切换行为使用 debounce 消抖，尽量确保请求的有序；（本质还是为了保证请求有序）

如果直接写如下代码：

```js
tabChange = (tabId) => {
  this.tabId = tabId;
  fetch(`/api?id=${tabId}`).then((data) => {
    if (this.tabId === data.tabId) {
      render();
    }
  });
};
onTabChange = debounce(this.tabChange, 300);
```

会有**竞态危害**：这个问题在多线程的语境下被称作“[竞态危害（Race Hazard）](https://zh.wikipedia.org/wiki/競爭危害)”，指一段代码的执行结果依赖两个异步逻辑的执行顺序。

rxjs 的解法就是通过 switchAll 操作符，每次采用最新的 observable，将最新的 observable 吐出的数据吐出。 详情参考 apollo-model 里的`createRestQuery`

```typescript
const requestStream$ = new Subject();
requestStream$.pipe(switchAll()).subscribe((value) => {
  // 订阅requestStream$ 以 修改 info数据
  info.loading = value.loading;
  if (!value.loading) {
    info.error = value.error;
    if (value.data) {
      info.data = value.data;
    }
  }
});
requestStream$.next(query$); // 每次发起请求前都会执行这个，query$会在请求回来后吐出数据，所以就保证了每次拿的都是最后发起请求的这个的数据。
```

### 扩展资料

- [What does it mean(意味着) to be Reactive?](https://www.youtube.com/watch?v=sTSQlYX5DU0)，核心思想。虽然口音很重，演讲风格也很浮夸 😂
- [javascript-getter-setter-pyramid](https://staltz.com/javascript-getter-setter-pyramid.html)，为什么要有 Observable，编程方式的底层解构。这里是英文原版，可以看这一篇[中文解析](https://zhuanlan.zhihu.com/p/98745778)；
- [What are the differences between Promises(承诺), Observables, and Streams(流)?](https://medium.com/javascript-in-plain-english/promise-vs-observable-vs-stream-165a310e886f)
- [RxJS - 封裝程式的藝術](https://www.bilibili.com/video/av60370503)，有些观点的中文视频讲解；

## axios

### 原理

主要就是用 promise 去对 ajax 封一层。至于如何封装的可以去看笔记 javascript 里的 AJAX 部分。

### 参数

接受 1-3 个参数，第二个参数里传入 params 则会根据 content-Type 来处理这个参数，如果不在第二个参数里传入 params，而是在第三个参数里传入配置 params 则会变成 query 的形式

## qs

1. qs.parse()将 URL 解析成对象的形式:

```js
let url = "user=wdx&pwd=123&appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0";
qs.parse(url);
console.log(qs.parse(url)); // {user:'wdx',pwd:'123',appToken:'7d22e38e-5717-11e7-907b-a6006ad3dba0'}
```

2. qs.stringify()将对象 序列化成 URL 的形式，以&进行拼接

```js
let obj = {
  user: "wdx",
  pwd: "123",
  appToken: "7d22e38e-5717-11e7-907b-a6006ad3dba0",
};
qs.stringify(obj);
console.log(qs.stringify(obj)); // 'user=wdx&pwd=123&appToken=7d22e38e-5717-11e7-907b-a6006ad3dba0'
```

那么当我们需要传递数组的时候，我们就可以通过下面方式进行处理：
默认情况下，它们给出明确的索引，如下代码：

```js
qs.stringify({ a: ["b", "c", "d"] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

也可以进行重写这种默认方式为 false

```js
qs.stringify({ a: ["b", "c", "d"] }, { indices: false });
// 'a=b&a=c&a=d'
```

当然，也可以通过 arrayFormat 选项进行格式化输出，如下代码所示：

```js
qs.stringify({ a: ["b", "c"] }, { arrayFormat: "indices" });
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ["b", "c"] }, { arrayFormat: "brackets" });
// 'a[]=b&a[]=c'
qs.stringify({ a: ["b", "c"] }, { arrayFormat: "repeat" });
// 'a=b&a=c'
```

在这里需要注意的是，JSON 中同样存在 stringify 方法，但是两者之间的区别是很明显的，如下所示：

```js
{"uid":"cs11","pwd":"000000als","username":"cs11","password":"000000als"}
uid=cs11&pwd=000000als&username=cs11&password=000000als
```

如上所示，前者是采用`JSON.stringify(param)`进行处理，后者是采用`Qs.stringify(param)`进行处理的。

## elementplus

### 安装引入

#### 引入指令

你需要做的是从你安装的 element-plus 中引入`InfiniteScroll`，并进行插件的注册，做法如下：

```js
import InfiniteScroll from "element-plus";
const app = createApp(App);
app.use(InfiniteScroll);
```

其次，你在谁身上设置的`v-infinite-scroll`，那它就是滚动的父容器，他必须书写`overflow: auto`

最后一定要写这个属性：`infinite-scroll-distance="1"`（触发加载的距离阈值）

必须写大于 1 的值，否则滚动到底部可能不会触发

最后有效示例如下：

```vue
<template>
  <div
    v-infinite-scroll="load"
    class="infinite-list"
    style="overflow: auto; height: calc(100vh - 45px)"
    infinite-scroll-distance="1"
  >
    <div v-for="i in count" :key="i" class="infinite-list-item">{{ i }}</div>
  </div>
</template>
```

## press

vitepress、island.js、astro
