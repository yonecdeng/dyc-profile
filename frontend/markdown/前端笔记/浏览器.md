

# 常见浏览器内核



![image-20230429103244423](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-10-32-image-20230429103244423.png)



# 进程与线程

### Chrome浏览器的进程

![image-20230429102542426](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-10-25-image-20230429102542426.png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/EibZvicb0pyanTibQrlYSYsNkgpCuC4nrA7RCCXZRGqU2kx9TGTteIuiahtAzPWdS8h18bqBlaWmlVtEtCZBa9BiahA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



这些进程的功能：

- **浏览器进程**：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
- **渲染进程**（浏览器内核进程）：把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，**Chrome 会为每个 Tab 标签创建一个渲染进程**。如果几个页面符合==同一站点（根域名和协议相同）==，那么他们将被分配到一个渲染进程里面去。iframe也会运行在单独的进程中。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的，所以渲染进程都是运行在沙箱模式下。
- **GPU 进程**：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。
- **网络进程**：主要负责页面的网络资源加载
- **插件进程**：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

**打开一个网页最少需要四个进程**：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。









### 浏览器的渲染进程里的线程

#### 总览

浏览器内核进程也就是Renderer进程

（下图的CPU进程应改为GPU进程）

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6e583f59dc742b9b4e88cf3a3b0f1d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



![](https://static001.geekbang.org/infoq/6c/6c5767c061ee34c066ac31f974131836.png)



**（1）GUI渲染线程** 负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要**重绘**或**回流**时，该线程就会执行。<strong style="color: red">GUI更新会在js引擎空闲时立即执行</strong>，所以如果js任务执行时间过长，就会导致页面卡顿。

**（2）JS引擎线程** JS引擎线程也称为JS内核，负责处理Javascript脚本程序；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；注意：<strong style="color: red">GUI渲染线程与JS引擎线程的互斥关系</strong>。

**（3）事件触发线程** 属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块或者是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等，会将对应任务添加到事件触发线程中；当对应的事件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；

注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理；

**（4）定时器触发线程** **定时器触发线程**即setInterval与setTimeout所在线程；（因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性，所以单开一个线程）；计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；

注意：<strong style="color: red">W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</strong>

**（5）网络线程**

xhr、fetch等发起请求后新开一个网络线程，检测到状态变更时，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；



#### 这么多个线程的工作流程(事件循环的本质)

![image-20230429110302039](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-11-03-image-20230429110302039.png)





#### JS引擎与渲染引擎

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-11-00-image-20230429110036274.png" alt="image-20230429110036274" style="zoom: 50%;" />



![image-20230429133117889](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-13-31-image-20230429133117889.png)





### Browser进程和浏览器内核进程（render进程）的通信

当我们打开一个页面时, Brewser进程收到我们的请求,  首先需要获取页面的内容, 随后将该任务通过RendererHost接口传递给Render进程

Renderer进程收到接口消息后, 进行简单解释, 然后交给渲染线程, 之后开始渲染

- 渲染线程接收请求, 加载网页并渲染网页, 这其中可能需要Browser进程获取资源和GPU进程帮助渲染
- 还有可能会有JS线程操作DOM, 可能引发回流重绘
- 最后渲染进程将结果传递给Browser进程

Browser进程接收到结果后将页面显示出来





### 如何实现浏览器内多个标签页之间的通信?

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：

- **使用 websocket 协议**，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。
- **使用 ShareWorker 的方式**，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。
- **使用 localStorage 的方式**，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。
- **使用 postMessage 方法**，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。



### WebWorker

为了让JS能应对CPU密集型计算任务,  在HTML5中加入了WebWorker.

> Web Worker 为内容在后台线程中运行脚本提供了一种简单的方法. 线程可以执行任务而不干扰用户界面. 此外也可以使用网络请求执行I/O. 一旦创建, 一个worker可以将消息发送到它的父线程, 反之亦然.

#### 介绍

- 同源策略的限制

  `Worker` 线程中运行的脚本文件必须与主线程的脚本文件同源

- 操作 DOM 的限制

  worker运行在==另一个全局上下文==中, 不同于主线程的window，`Worker` 线程中无法读取主线程所在视图的 `DOM` 对象，也无法使用 `window` 和 `document` 对象，但可以使用他们的子对象。不能执行`alert()`方法和`confirm()`方法。但可以使用 XMLHttpRequest 对象发出 AJAX 请求。

- 本地文件的限制

  `Worker` 线程中无法读取本地文件，即不能打开本机的文件系统（`file://`），因此它所加载的脚本必须来自于网络，可以使用 XMLHttpRequest 对象发出 AJAX 请求。

- 消息通信

  `Worker` 线程和主线程不在同一个上下文环境，它们不能直接通信，需要==序列化==对象来与线程进行特定数据的交互。它们**相互之间的通信可以传递对象和数组**，它们之间通信是通过拷贝的形式来传递数据的，进行传递的对象需要经过序列化，接下来在另一端还需要反序列化。这就意味着：

  1. **我们不能传递不能被序列化的数据**，比如函数，会抛出错误的。
  2. 在一端改变数据，另外一端不会受影响，因为数据不存在引用，是拷贝过来的。

  
  

#### [使用](https://www.ruanyifeng.com/blog/2018/07/web-worker.html)

##### 主线程环境

- 创建一个专用worker

  ```js
  const worker = new Worker('hash.worker.js', { name: 'hash_worker' })
  ```

- 消息的发送和接收

  ```js
  worker.postMessage()
  worker.addEventListener('message', ({ data }) => {
    // event.data <=> data
  })
  ```

- 终止主线程

  ```js
  worker.terminate()
  ```

  注：立即终止，并不会等待工作线程去完成它剩余的操作

##### 工作线程环境

- 消息的接收和发送

  ```js
  self.addEventListener('message', ({ data }) => {
    // event.data <=> data
  })
  self.postMessage()
  ```

- 关闭当前工作线程

  ```js
  self.close()
  ```

- 加载外部脚本或第三方库

  ```js
  self.importScripts(urlA, urlB)
  ```

  注：所引入的脚本与库都会绑定在子线程的全局对象上，即 self 或 this上

#### 判断浏览器对专用 `Worker` 的支持性

```js
if (window.hasOwnProperty('Worker')) {
  console.log('支持，请放心使用！')
} else {
  console.log('不支持，请优雅降级！')
}
```

# [从输入url到页面展示](https://mp.weixin.qq.com/s/wJxj5QbOHwH9cKmqU5eSQw)

## 总览

<mark>这个问题涵盖了两件事：网络是怎么连接的 + 浏览器渲染</mark>

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707121550640.png" alt="image-20220707121550640" style="zoom:200%;" />

<img src="https://mmbiz.qpic.cn/mmbiz_svg/5ZQ3V8nVdKqGHtgibsQKVRQfmEIGhI3zWr4A75MkibVgYlibaYPiaAt6qsGndzFeiaeibOESDdfBJBHZH3jWUxDpJtdDOfLW569iaQq/640?wx_fmt=svg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />

![image-20230429111013759](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-11-10-image-20230429111013759.png)

## **1.用户输入**

用户在`浏览器进程`输入并按下回车健后，浏览器判断用户输入的url是否为正确的url，如果不是，则使用默认的搜索引擎将该关键字拼接成url。

## **2.卸载原页面并重定向到新页面**

浏览器会将现有页面卸载掉并重定向到用户新输入的url页面，也就是图中【Process Unload Event】和【Redirect】流程。

此时浏览器会准备一个`渲染进程`用于渲染即将到来的页面，和一个`网络进程`用于发送网络请求。

浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。

## **3.处理Service Worker**

如果当前页面注册了Service Worker那么它可以拦截当前网站所有的请求，进行判断是否需要向远程发送网络请求。也就是图中【Service Worker Init】与【Service Worker Fecth Event 】步骤。如果不需要发送网络请求，则取本地文件。如果需要则进行下一步。





## **4.网络请求**

> OSI网络七层模型：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
>
> 在实际应用中物理层、数据链路层被统称为物理层，会话层、表示层、应用层被统称为应用层，所以实际使用时通常分为4个层级
>
> 【物理层】>【网络层(IP)】>【传输层(TCP/UDP)】>【应用层(HTTP)】

也就是图1中【HTTP Cache】、【DNS】、【TCP】、【Request】、【Response】步骤

![图片](https://mmbiz.qpic.cn/mmbiz_png/EibZvicb0pyanTibQrlYSYsNkgpCuC4nrA7LiaUzUyQ1JjIv6PU5QkdYGSUU4pne1OFp93XTXIhJGb1iaWpdBEdJOkA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)图2

浏览器会拿着url通过`网络进程`进行如下步骤：

1. 根据url查询本地是否已经有强制缓存，如果有则判断缓存是否过期，如果没过期则直接返回缓存内容，也就是图1中【HTTP Cache】步骤。（这样做的好处有

   - 缓解服务器端压力，提升性能（获取资源的耗时更短了）；
   - 对于网站来说，缓存是实现快速资源加载的重要组成部分。）

2. 如果没有强制缓存或者缓存已过期，则将该请求加入队列进行排队准备发送网络请求，也就是图2中【正在排队】，浏览器负责解析网址并生成HTTP消息，然后根据域名查询IP地址即进入DNS解析阶段，也就是图1中【DNS】以及图2中的【DNS查找】，DNS根据域名解析出对应的IP地址。(DNS基于UDP)。（**DNS 缓存**和**页面资源缓存**这两块数据是会被浏览器缓存的。其中，DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来）

3. 然后委托操作系统来将消息发送到网络中，使用IP寻址找到对方（如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。），然后根据IP地址+端口号创建一个TCP连接(三次握手)，也就是图1中【TCP】以及图2中的【初始连接】创建完成后利用TCP连接来传输数据。(TCP会将数据拆分为多个数据包，进行有序传输，如果丢包会重发，TCP的特点是可靠、有序)

4. 判断当前协议是否为https，如果为https，则还需要建立 TLS 连接协商，将数据进行加密，如果为http协议则不进行加密(明文传输)，也就是图2中的【SSL】。

5. 建立了 TCP 连接，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器开始发送http请求(请求行/请求头/请求体)，也就是图1中【Request】以及图2中的【已发送请求】。HTTP协议有多个版本，目前使用最多的版本为HTTP/1.1，HTTP/1.1发送完成后默认不会断开。Connection:Keep-Alive  默认打开，为了下次传输数据时复用上次创建的连接。Chrome 每个域名最多同时建立6个TCP连接，所以同一时间最多发生6个请求。

   HTTP协议的各个版本特性如下：

6. - `HTTP/0.9` 没有请求头和响应头，不区分传输的内容类型，因为当时只传输HTML。
   - `HTTP/1.0` 提供了请求头和响应头，可以传输不同类型的内容数据。根据请求响应头的不同来处理不同的资源，HTTP1.0每次发完请求都会断开TCP连接。有新的请求时再次创建TCP连接。
   - `HTTP/1.1` 默认开启了 keep-alive ，它能够让一个TCP连接中传输多个HTTP请求，也叫`链路复用`。但一个TCP连接同一时间只能发送一个HTTP请求，为了不阻塞多个请求，Chrome允许创建6个TCP连接，所以在HTTP/1.1中，最多能够同时发送6个网络请求。
   - `HTTP/2.0` HTTP/2.0使用同一个TCP连接来发送数据，他把多个请求通过二进制分贞层实现了分贞，然后把数据传输给服务器。也叫`多路复用`，多个请求复用同一个TCP连接。HTTP/2.0会将所有以`:`开头的请求头做一个映射表，然后使用`hpack`进行压缩，使用这种方式会使请求头更小。服务器可主动推送数据给客户端。
   - `HTTP/3.0` 使用UDP实现，在UDP上一层加入一层`QUIC`协议，解决了TCP协议中的队头阻塞问题。





## **5.服务端响应**

服务器收到HTTP请求后需要根据请求信息来进行解析，并返回给客户端想要的数据，这也就服务端响应。也就是图2的【等待中】在做的事情。

服务端可以响应并返回给客户端很多种类型的资源，检查响应头的媒体类型（MIME Type），如果是html文件则交给渲染进程处理，如果zip、exe等则交给下载管理器处理

目前前端处理服务端响应html请求主要分为SSR服务端渲染与CSR客户端渲染，CSR就是返回一个空的HTML模版，然后浏览器加载js后通过js动态渲染页面。SSR是服务端在接受到请求时事先在服务端渲染好html返回给客户端后，客户端再进行客户端激活。

在打开一个站点的首屏页的完整链路中，使用SSR服务端渲染时的速度要远大于CSR客户端渲染，并且SSR对SEO友好。所以对于首屏加载速度比较敏感或者需要优化SEO的站点来说，使用SSR是更好的选择。





## 6.解析响应头

网络进程接收了响应行和响应头之后，就开始解析响应头的内容了。也就是图1中【Response】以及图2中的【下载内容】步骤。

**（1）重定向**

在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始了。

可以使用 curl 来查看下请求 geekbang.org 会返回什么内容：

```bash
curl -I geekbang.org   //这里输入的参数是`-I`，和`-i`不一样，`-I`表示只需要获取响应头和响应行数据，而不需要获取响应体的数据
```

**（2）协商缓存**

如果状态码为304则直接代表协商缓存生效，直接取本地的缓存文件。如果不是则下载内容。

**（3）响应数据类型处理**

URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面， 浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。比如请求一个安装包，其 Content-Type 的值是 application/octet-stream，显示数据是**字节流类型**的，通常情况下，浏览器会按照**下载类型**来处理该请求。





## 7.准备渲染

此时的文档数据（“文档”是指 URL 请求的响应体数据）还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。

1. 浏览器进程发出==“提交文档”==的消息 给 渲染进程，然后渲染进程会和网络进程建立传输数据的“**管道**”。

2. 等文档数据传输完成之后，渲染进程会返回==“**确认提交**”==的消息给浏览器进程。

3. 浏览器进程在收到“确认提交”的消息后，会**更新浏览器界面状态**，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

   <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707131535331.png" alt="image-20220707131535331" style="zoom:200%;" />

**用户发出 URL 请求到页面开始解析的这个过程叫做导航**。到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了







# 浏览器渲染

![image-20240106140923879](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-06-14-09-image-20240106140923879.png)

## 卡顿的原理

设备的刷新频率是60次/秒，也就说是浏览器对每一帧画面的渲染工作要在16ms内完成。在一次事件循环里，一个宏任务被执行后，js 修改了样式，浏览器也不一定会重新渲染，浏览器可能等到下一次事件循环再一起渲染，而中间没有渲染的那一次，就不会再被渲染出来了，这就叫 “丢帧”。

**页面重新渲染间隔大于 16.67 毫秒，动画就会产生卡顿；**所以本质就是阻塞渲染。







## 为什么一般把CSS放在`<head>`中，将JavaScript放在`<body>`的底部

```
页面的渲染并不是在所有JavaScript执行完之后才开始的。实际上，浏览器在解析HTML文档并构建DOM（文档对象模型）的过程中，就会开始渲染页面。当浏览器遇到一个<script>标签时，它会停止HTML的解析，转而去下载并执行JavaScript代码（除非该<script>标签有async或defer属性）。JavaScript代码执行完毕后，浏览器会继续解析剩余的HTML，并渲染页面。

CSS放在<head>中：浏览器在渲染页面时，需要先知道元素的样式信息。如果CSS放在<head>中，那么在解析HTML的同时，浏览器就可以并行地下载和解析CSS，这样当浏览器解析到HTML的其他部分时，CSS已经准备好了，可以直接用于渲染。如果CSS放在HTML的其他位置，可能会导致浏览器需要等待CSS下载和解析完成后才能开始渲染，这会导致页面渲染的延迟。

这就是为什么通常建议将JavaScript放在<body>标签的底部的原因。这样做可以确保在JavaScript执行前，HTML的主体部分已经被解析并渲染出来，从而让用户更早地看到页面内容。如果JavaScript代码放在<head>标签中或<body>标签的上部，那么当浏览器执行JavaScript代码时，可能会阻塞HTML的解析和页面的渲染，导致页面显示延迟。
然而，这并不意味着页面的全部渲染都会在所有JavaScript执行完之后才完成。因为JavaScript可以动态地修改DOM，所以在JavaScript代码执行过程中和执行之后，页面的渲染可能会被更新。
```



## 渲染流程

我做了一下实验发现滑动滚动条也得占用GUI渲染线程。

### 简化版

![img](https:////upload-images.jianshu.io/upload_images/1158202-6c6f3bf9f9b2c5eb.png?imageMogr2/auto-orient/strip|imageView2/2/w/742/format/webp)

渲染流程

`JavaScript`：JavaScript实现动画效果，DOM元素操作等。
 `Style（计算样式）`：确定每个DOM元素应该应用什么CSS规则。
 `Layout（布局）`：计算每个DOM元素在最终屏幕上显示的大小和位置。由于web页面的元素布局是相对的，所以其中任意一个元素的位置发生变化，都会联动的引起其他元素发生变化，这个过程叫reflow。
 `Paint（绘制）`：在多个层上绘制DOM元素的的文字、颜色、图像、边框和阴影等。
 `Composite（渲染层合并）`：按照合理的顺序合并图层然后显示到屏幕上。

实际场景下，大概会有三种常见的渲染流程（也即是`Layout`和`Paint`步骤是可避免的）：

![img](https:////upload-images.jianshu.io/upload_images/1158202-35dabdd33093e413.png?imageMogr2/auto-orient/strip|imageView2/2/w/580/format/webp)









### [渲染流程总结](https://mp.weixin.qq.com/s/wJxj5QbOHwH9cKmqU5eSQw)

![image-20220707153356632](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707153356632.png)





由于html parser与 css parser 并行执行，所以渲染流程会有4种情况：

1. HTML中无任何CSS相关标签
2. CSS相关标签在HTML最顶部，且在解析到内容标签（`<div />`）时已经解析完CSS相关标签
3. CSS相关标签在HTML最顶部，但在解析到内容标签（`<div />`）时CSS相关标签尚未解析完
4. CSS相关标签在HTML最底部

![image-20221006210815919](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221006210815919.png)

下面的流程是对上图的文字版解析。读者可将以上4种情况分别带入到如下的渲染流程中走一遍，就能理解浏览器的完整渲染过程了。

1. 【HTML】浏览器收到html资源后先预扫描`<link />`和`<script />`并加载对应资源

   【HTML Parser】对HTML字符串从上到下逐行解析，每解析完成一部分都会拿着解析结果进入下一步骤

   【DOM Tree】*`css`相关标签跳过此步骤*

   如果当前解析结果为`<div />`相关标签，则生成DOM树（`window.document`）后进入下一步。

   如果当前解析结果为`<script />`相关标签且并且没有添加异步属性，则先停止【HTML Parser】的进行，等待`<script />`资源加载完成后，然后按照以下2种情况处理

   1. 如果HTML从未解析到过`css`相关节点则立即执行`<script />`。(此时页面会把`<script />`之前的内容都显示在页面上)
   2. 如果HTML已经解析到过`css`相关节点则等待`css`相关节点解析完成后再执行`<script />`。(在CSS解析完的一瞬间会触发之前所有等待CSS资源解析的任务，假如在解析`<script />`之前还有`<div />`的话，理论上`<div />`应该在执行`<script />`之前被绘制到页面上，但因为Chrome是按照贞为单位来进行元素的绘制的，如果绘制`<div />`与执行`<script />`的时间在一贞之内，则会因为在绘制`<div />`时被`js`阻塞，所以实际上需要等`js`执行完才会实际完成`<div />`的绘制)

   当处理完成后便停止当前`<script />`标签后续步骤的执行，并继续进行新标签【HTML Parser】步骤的解析

2. 【Style Sheets】`<div />`相关标签跳过此步骤，如果当前解析结果为`css`相关标签，则等待其CSS资源加载完成，同时继续进行下一行的【HTML Parser】

   【CSS Parser】`<div />`相关标签跳过此步骤。当CSS资源加载完毕后，对CSS从上到下逐行解析

   【Style Rules】`<div />`相关标签跳过此步骤。当CSS解析完毕后，生成CSS规则树，也叫CSSOM，也就是`window.document.styleSheets`

3. 【Attachment】根据DOM树与CSS规则树计算出每个节点的具体样式。

   分为两种情况

   1. 如果当前节点为`<div />`相关节点。如果HTML从未解析到过`css`相关标签则使用HTML默认样式，如果已经解析到过`css`相关标签则阻塞等待`css`标签也完成【Attachment】步骤后才进入下一步。

   2. 如果当前节点为`css`相关节点。则需要根据是否在之前已经渲染过CSS资源中对应的DOM节点，如果已经渲染过则需要重绘。如果未渲染过任何相关DOM节点则此步骤为最后一步。

   

4. 【Render Tree】根据DOM树与CSSOM树生成渲染树，在此阶段已经可以将具体的某个`<div />`与对应的CSS样式对应起来了。有了渲染树后浏览器就能根据当前浏览器的状态计算出某个DOM节点的样式、大小、宽度、是否独占一行等信息。计算完成后把一些节点在渲染树中删掉。如`display: none`。渲染树（render tree）代表了每个元素的视觉样式和位置。同时还决定浏览器绘制元素的顺序。如果元素刚好重叠，后绘制的元素就会出现在先绘制的元素前面。

5. 【Layout】通过渲染树进行分层（根据定位属性、透明属性、transform属性、clip属性等）生成图层树。

6. 【Painting】一个图层分成很多绘制指令，然后将这些指令按顺序组成一个绘制列表，交给合成线程。合成线程将图层分成图块，并在**光栅化线程池**中将图块进行栅格化（即转成位图，一个一个的像素点）。（合成就在GPU上执行）

7. 【Display】合成线程发送绘制图块命令**DrawQuad**给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面并显示到浏览器上。





### **浏览器处理每一帧的流程**

浏览器在渲染完页面之后还需要不间断的处理很多内容的，比如动画、用户事件、定时器等。因此当浏览器渲染完页面后，还会在之后的每一帧到来时执行以下的流程。

- 【Input events】处理用户事件，先处理【阻塞事件Blocking】包括`touch`和`wheel`事件，后处理【非阻塞事件Non-blocking】包括`click`和`keypress`
- 【JS】处理完用户事件后执行【定时器Timers】
- 【Begin frame】处理完定时器后开始进行【每帧事件Per frame events】的处理，包括窗口大小改变、滚动、媒体查询的更改、动画事件。
- 【rAF】处理完帧事件后执行`requestAnimationFrame`回调函数和`IntersectionObserver`回调函数。
- 【Layout】然后【重新计算样式Recalc style】、【更新布局Update layout】、【调整Observer回调的大小Resize Observer callbacks】
- 【Paint】然后【合成更新Compositing update】、【Paint invalidation】、【Record】





### DOMContentLoaded & Load

在 DOM树构建完成之后，DOMContentLoaded 事件触发。

当一个资源及其依赖资源已完成加载时，还加载完成了所有外部资源时将触发load事件。





### 1. 构建Dom树



构建 DOM 树的**输入内容**是一个HTML 文件，然后经由 HTML 解析器解析，==最终输出树状结构的 DOM==。HTML 文档边加载边解析，网络进程加载了多少数据，HTML 解析器便解析多少数据。

因为**JavaScript 文件的下载过程会阻塞 DOM 解析**，不过 Chrome 浏览器做了很多优化，其中一个主要的优化是==预解析操作==。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码



### 2. 样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式 --- ==最终输出 styleSheets==，这个阶段大体可分为三步来完成。

#### （1） 把 CSS 转换为浏览器能够理解的结构

![image-20220707132602700](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707132602700.png)

**当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets**。

为了加深理解，你可以在 Chrome 控制台中查看其结构，只需要在控制台中输入 document.styleSheets，然后就看到如下图所示的结构：

![image-20220707132728200](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707132728200.png)





#### （2）转换样式表中的属性值，使其标准化

现在我们已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么**接下来就要对其进行属性值的标准化操作**。

可以看到上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值。

![image-20220707133005660](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707133005660.png)







#### （3） 计算出 DOM 树中每个节点的具体样式

**涉及到 CSS 的继承规则和层叠规则**

这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。

如果你想了解每个 DOM 元素最终的计算样式，可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：

![image-20220707133316848](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707133316848.png)

上图红色方框中显示了 html.body.div.p 标签的 ComputedStyle 的值



### 生成Render树

生成DOM树的同时会生成样式结构体CSSOM（CSS Object Model）Tree，再根据CSSOM和DOM树构造渲染树Render Tree，渲染树包含带有颜色，尺寸等显示属性的矩形，这些矩形的顺序与显示顺序基本一致。（从MVC的角度来说，可以将Render树看成是V，DOM树与CSSOM树看成是M，C则是具体的调度者，比HTMLDocumentParser等）。

DOM树和Render树之间不是简单的一对一的关系。Render树是用于显示，那不可见的元素当然不会在这棵树中出现了，譬如 `<head>`。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里的。



一棵Render树大概是酱紫，左边是DOM树，右边是Render树：

![](https://ask.qcloudimg.com/http-save/yehe-3615838/s5iipjqabe.webp?imageView2/2/w/1620/format/jpg)

从上图我们可以看出，renderer与DOM元素是相对应的，但并不是一一对应，有些DOM元素没有对应的renderer，而有些DOM元素却对应了好几个renderer，对应多个renderer的情况是普遍存在的，就是为了解决一个renderer描述不清楚如何显示出来的问题，譬如有下拉列表的select元素，我们就需要三个renderer：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。



### 3.布局（Layout）阶段

Chrome 在布局阶段需要完成两个任务：创建布局树和布局计算。==最终输出 layoutTree==

#### （1）创建布局树(Layout tree)

![image-20220707133718042](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707133718042.png)



#### （2） 布局计算

现在我们有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置了。把布局运算的结果重新写回布局树中，布局阶段输出的结果称为box盒模型（width,height,margin,padding,border,left,top,…），盒模型精确表示了每一个元素的位置和大小，并且所有相对度量单位此时都转化为了绝对单位。



### 4.分层

渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的==图层树（LayerTree）==。**这些图层叠加后合成了最终的页面**。这样的目的是 进行渲染性能的优化，以层的维度，执行各自的光栅化任务。当某一个层级的UI发生了变化，需要重新渲染的时候，只需要重新光栅化这个层级，而不会影响到其他的层。



![image-20220707145200692](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707145200692.png)

**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层**。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。

通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。

**第一点，拥有层叠上下文属性的元素会被提升为单独的一层。**[参考这篇文章](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)

**第二点，需要剪裁（clip）的地方也会被创建为图层。**

例如我们把 div 的大小限定为 200 * 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 * 200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域。渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。你可以参考下图：

![image-20220707150247703](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707150247703.png)





### 5.图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，渲染引擎会把一个图层的绘制拆分成很多小的**绘制指令**，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示

![image-20220707150828641](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707150828641.png)

你也可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：

![image-20220707150949982](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707150949982.png)

区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。





### 6.栅格化（raster）操作

光栅化就是按照绘制列表中的指令生成一个个图层。绘制列表只是用来记录绘制顺序和绘制指令的列表，当图层的绘制列表准备好之后，主线程会把该绘制列表**提交（commit）**给合成线程。**合成线程会将图层划分为图块（tile）**，这些图块的大小通常是 256x256 或者 512x512，如下图所示：

![image-20220707152740453](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707152740453.png)

**合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图**。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。

![image-20220707152936014](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707152936014.png)



在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：

```
.box {
will-change: transform, opacity;
}
```

这时候渲染引擎会将该元素单独实现一层（它占用的内存也会大大增加），等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。**这也是 CSS 动画比 JavaScript 动画高效的原因**。

注意：能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影，旋转等，这些变换都不会影响到图层的内容。比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。





为了提高渲染的效率，会在不同的Layer上进一步进行分块，分成一个一个的Tile，可以看到，图中有一些浅蓝色的线，他们就是分块的切割线，chromium中由tile_manager来管理分块。

分块后，每个Tile一搬来说都会持有自己的resource，这些 resource统一从chromium的resourcePool模块进行申请的，由resourcePool来create、reuse、release这些内存空间，内存的大小，和tile的分辨率息息相关，同样，也受到色彩空间的影响。

Tile完成自己的光栅化任务以后，会提交给pendingTree，当所有当前帧所有需要光栅化的tile都完成任务时，会提交给activeTree，进行屏幕上的渲染。

看上去Layer占用的shared_images 内存就是tile占用的这些内存，约等于tile的分辨率宽高相乘再乘以色彩空间的总和，即InUsePoolResourceMemory，

但是实际上，对于这部分内存可能会残留一些未来得及释放的Memory和为常常刷新的区域备份缓存的多份resourceMemory，比如动画、轮播这些。也就是说，当我们的页面动态更新的区域越多，这部分缓存的内存就越多



### 7.合成和显示

合成就在Gpu上执行。

**合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的**。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收并根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。





## 重排&重绘&合成

### 图览

![image-20230430120032349](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-30-12-00-image-20230430120032349.png)



### 重排(reflow)

reflow 会从 `<html>`这个 `root frame` 开始递归往下，依次计算所有的结点几何尺寸和位置。比如树状目录的折叠、展开（实质上是元素的显示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲染。**重排需要更新完整的渲染流水线，所以开销也是最大的**。

![image-20220707154401990](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707154401990.png)



### 重绘(repaint)

当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来。例如修改了元素的背景颜色，那么==布局和分层阶段将不会被执行==，直接进入了绘制阶段，然后执行之后的一系列子阶段

![image-20220707154631795](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707154631795.png)





### 合成

例如使用 CSS 的 transform 来实现动画效果。在非主线程上合成，并没有占用主线程的资源，而且也避开了布局和绘制两个子阶段

![image-20220707154726500](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220707154726500.png)



### 导致回流和重绘

引起重排的属性，即布局类属性，包括：

| 类型       | 属性名                                                       |
| ---------- | ------------------------------------------------------------ |
| 盒模型     | display  padding  margin  width  height  min-height  max-height  border  border-width |
| 定位和浮动 | position  top  bottom  left  right  float  clear             |
| 文字及溢出 | font-family  font-size  font-weight  line-height  text-align  vertical-align  white-space  overflow  overflow-y |
| 操作Dom    | 添加、删除、更新DOM节点                                      |
| 用户行为   | 调整窗口大小                                                 |

激活CSS伪类

增加CSS伪元素

设置 style 属性的值，每一次设置都会触发一次reflow

查询某些属性或调用某些计算方法：offsetWidth、offsetHeight等，除此之外，当我们调用 `getComputedStyle`方法，或者IE里的 `currentStyle` 时，也会触发重排，原理是一样的，都为求一个“即时性”和“准确性”。

| 常见引起重排属性和方法  | --                       | --                 | --         |
| ----------------------- | ------------------------ | ------------------ | ---------- |
| width                   | height                   | margin             | padding    |
| display                 | border-width             | border             | position   |
| overflow                | font-size                | vertical-align     | min-height |
| clientWidth             | clientHeight             | clientTop          | clientLeft |
| offsetWudth             | offsetHeight             | offsetTop          | offsetLeft |
| scrollWidth             | scrollHeight             | scrollTop          | scrollLeft |
| scrollIntoView()        | scrollTo()               | getComputedStyle() |            |
| getBoundingClientRect() | scrollIntoViewIfNeeded() |                    |            |









引起重绘的属性，即绘制类属性，包括：

| 类型     | 属性名                                                       |
| -------- | ------------------------------------------------------------ |
| 颜色     | color                                                        |
| 边框     | border-color  border-style  border-radius                    |
| 背景     | background  background-image  background-position  background-repeat  background-size |
| 轮廓     | outline  outline-color  outline-style  outline-width         |
| 可见性   | visibility                                                   |
| 文字方向 | text-decoration                                              |
| 发光     | box-shadow                                                   |





### 避免回流和重绘

1. 避免重排：使用absolute或者fixed，使元素==脱离文档流==，这样他们发生变化就不会影响其他元素
2. 避免重排/重绘，直接进行合成，==合成层的transform 和 opacity的修改都是直接进入合成阶段的==；比如可以使用`transform:translate`代替`left/top`修改元素的位置；使用`transform:scale`代替宽度、高度的修改；



### 减少回流与重绘

重绘不一定引起回流，但回流一定引起重绘。

- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 脱离文档流(绝对定位、固定定位)，脱离文档流的元素进行重排不会影响到其他元素。
- 图片渲染时增加宽高属性，宽高固定后，图片不会根据内容动态改变高度，便不会触发重排。
- 尽量用CSS3动画，CSS3动画能最大程度减少重排与重绘。
- 使用`will-change: transform;`将元素独立为一个单独的图层。（定位、透明、transform、clip都会产生独立图层）
- 将一个DOM元素的宽高等几何信息定死，在这个元素内部触发重排，只会重新渲染该元素内部的元素，不会影响到外界

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。







## 浏览器的层

浏览器中的层分为两种：“渲染层”和“合成层“。

<strong style="color: red;">开发者工具中的layers看到的层都是合成层，document相当于一个在主线程渲染的合成层，其他合成层被浏览器独立出来，单独拿给GPU处理，而层叠上下文的“层”则是指渲染层，更像是一个概念上的层，一个合成层可以包含多个渲染层。</strong>

### 渲染层

形成渲染层的条件也就是形成层叠上下文的条件。



### 合成层

#### 简介

<font color="red">在开发者工具中看到的不是渲染层，而是合成层</font>，只有一些特殊的渲染层才会被提升为合成层，通常来说有这些情况：

1. 3Dtransform；
2. will-change 只有 opacity、transform、transform-style、perspective、filter、backdrop-filter 这 6 个属性值的时候才会新建图层。
3. 对 opacity | transform | fliter ｜all 应用了过渡和动画（transition/animation）时
4. video、canvas、iframe

可以看出，上面这些条件属于生成渲染层的“加强版”，也就是说形成合成层的条件要更苛刻。没有命中上面任何一条规则也可能形成一个单独的合成层。因为还有一种情况——隐式合成。



#### 合成层合成原因详述



|      | 类别                                      | 合成原因                                                     | 相关源码                                                     | 补充说明                                                     |
| ---- | ----------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | k3DTransform                              | 会产生的css样式：scaleZ、scale3D、translateZ、translate3D、rotate3d、rotateX、rotateY、rotateZ、matric3D perspective: 自己不会单独生成InterpolatedTransform：像是动画的中间态，暂时不知什么情况会出现 | third_party/blink/renderer/platform/transforms/transform_operation.h![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:1421019906616956924fcABO2bPSYmtfu1o2hqW5ahNn:1682654457372) |                                                              |
| 2    | kTrivial3DTransform                       | 会产生的css样式和k3DTransform基本重合，描述的是边际情况，translateZ(0)、scaleZ(1)、rotate(0)这种在低端机会被忽略，不进行合成 | third_party/blink/renderer/platform/transforms/translate_transform_operation.h![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-4637930442873500812fcABO2bPSYmtfu1o2hqW5ahNn:1682654457373) | 针对低端机的一种区分优化，低端机这种类型的合成会直接忽略     |
| 3    | kVideo                                    | 开启了硬件加速时video会自动合成该类型Layer![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-239704427296874634fcABO2bPSYmtfu1o2hqW5ahNn:1682654457373) |                                                              | 手机未开启硬件加速，合成的是kLayerForOther                   |
| 4    | kCanvas                                   | 启动了硬件加速情况的canvas会自动合成该layer                  |                                                              |                                                              |
| 5    | kPlugin                                   | flash、pdf 这些会生成 kPlugin layer                          |                                                              | 安卓移动端不会出现                                           |
| 6    | kIframe                                   | 跨域的iframe会合成该Layer                                    | third_party/blink/renderer/core/frame/local_frame_view.cc    |                                                              |
| 7    | kSVGRoot                                  | chromium渲染中间状态会使用                                   | third_party/blink/renderer/platform/graphics/compositing_reasons.h |                                                              |
| 8    | kBackfaceVisibilityHidden                 | backface-visiblility: hidden导致                             | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-7774015161081761880fcABWdNB9dGPHvrlmcwF01Dc-:1682654457373) |                                                              |
| 9    | kActiveTransformAnimation                 | 块级元素transform动画会合成该Layer，非循环动画执行完后该Layer会消失 | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc |                                                              |
| 10   | kActiveOpacityAnimation                   | 透明度动画会合成该Layer，非循环动画执行完后该Layer会消失     | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc |                                                              |
| 11   | kActiveFilterAnimation                    | filter动画会合成该Layer，非循环动画执行完后该Layer会消失     | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc |                                                              |
| 12   | kActiveBackdropFilterAnimation            | backdrop-filter动画会合成该Layer，非循环动画执行完后该Layer会消失 | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc |                                                              |
| 13   | kXrOverlay                                | WebXR技术会生成的Layer                                       | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:6322247949333951209fcABWdNB9dGPHvrlmcwF01Dc-:1682654457374) |                                                              |
| 14   | kScrollDependentPosition                  | 可滚动元素上的sticky或者fixed元素                            | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc | 这种情况即使没有z-index也会生成合成层                        |
| 15   | kOverflowScrolling                        | 有滚动条的元素会生成该类型合成层                             | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc |                                                              |
| 16   | kOverflowScrollingParent                  | 合成层在scroll Layer中时会生成该类型合成原因                 | third_party/blink/renderer/core/paint/compositing/compositing_reason_finder.cc | 这部分跟层叠上下问相关                                       |
| 17   | kOutOfFlowClipping                        | overflow:hidden的合成层上定位为absolute或者fixed的元素，会形成该类型的合成层 |                                                              | https://bugs.chromium.org/p/chromium/issues/detail?id=749349 |
| 18   | kVideoOverlay                             | video控制面板等系统面板                                      |                                                              | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-3651861599729640126fcABWdNB9dGPHvrlmcwF01Dc-:1682654457375)比如这个 |
| 19   | kWillChangeTransform                      | will-change:transform属性会合成该类型合成层                  |                                                              |                                                              |
| 20   | kWillChangeOpacity                        | will-change:opacity属性会合成该类型合成层                    |                                                              |                                                              |
| 21   | kWillChangeFilter                         | will-change:filter属性会合成该类型合成层                     |                                                              |                                                              |
| 22   | kWillChangeBackdropFilter                 | will-change:backdrop-filter属性会合成该类型合成层            |                                                              |                                                              |
| 23   | kWillChangeOther                          | 定位非static的时候，will-change:top、left、right、bottom属性会合成该类型合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:8603194598202070179fcABWdNB9dGPHvrlmcwF01Dc-:1682654457375) |                                                              |
| 24   | kBackdropFilter                           | backdrop-filter 样式会合成该类型合成层                       |                                                              |                                                              |
| 25   | kBackdropFilterMask                       | 当前版本内核有bug，暂时不会命中该类型clip-path和backdrop-filter |                                                              | https://chromium-review.googlesource.com/c/chromium/src/+/2518440/3/third_party/blink/web_tests/external/wpt/css/css-masking/clip-path/clip-path-svg-text-backdrop-filter.html#4 |
| 26   | kRootScroller                             | document.rootScroller，即使文档没有overflow，也默认存在      | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-8738122333803725625fcABWdNB9dGPHvrlmcwF01Dc-:1682654457375) |                                                              |
| 27   | kAssumedOverlap                           | 当前合成层可能会遮盖其他合成层，跟position:fixed或者z-index有关 |                                                              | position:fixed的元素会生成该类型合成层其他的目前看跟z-index有关 |
| 28   | kOverlap                                  | 当前合成层计算后的确会遮盖，跟position:fixed或者z-index有关  |                                                              | position:fixed的元素会生成该类型合成层                       |
| 29   | kNegativeZIndexChildren                   | 子元素有合成并且z-index为负的情况时，会生成该类型Layer。     | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:5851997224795463673fcABWdNB9dGPHvrlmcwF01Dc-:1682654457376) | demo:`<div class="parent">    <div class="children">1</div> </div> // 多元素 .parent {  position: relative;  z-index: -20; } .children {  transform: scale3d(1.3, 1.3, 1.3); } // 1元素独美 .parent {  position: relative;  z-index: -20;  transform: scale3d(1.3, 1.3, 1.3); } ` |
| 30   | kSquashingDisallowed                      | kScrollsWithRespectToSquashingLayer                          | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-3020664082345522370fcABWdNB9dGPHvrlmcwF01Dc-:1682654457376) |                                                              |
| 31   | kOpacityWithCompositedDescendants         | 元素opacity非1，子孙元素有被合成时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-713474163820075698fcABWdNB9dGPHvrlmcwF01Dc-:1682654457376) |                                                              |
| 32   | kMaskWithCompositedDescendants            | 元素有clip-path属性，子孙元素有被合成时，该元素会生成这种类型的合成层mask-image为url(a.pic)，子孙元素有被合成时，该元素会生成这种类型的合成层mask属性指定了图片，子孙元素有被合成时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:3902998305197739502fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377)![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:869795435827381048fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) |                                                              |
| 33   | kReflectionWithCompositedDescendants      | 元素有-webkit-box-reflect属性，子孙元素有被合成时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-2423202244917463407fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) |                                                              |
| 34   | kFilterWithCompositedDescendants          | 元素有-webkit-box-reflect属性，子孙元素有被合成时，该元素会生成这种类型的合成层元素有filter属性，子孙元素有被合成时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-27297802719165547fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) |                                                              |
| 35   | kBlendingWithCompositedDescendants        | 元素有mix-blend-mode属性(非normal)，子孙元素有被合成时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-3358733437830678334fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) |                                                              |
| 36   | kPerspectiveWith3DDescendants             | 元素有perspective属性，子孙元素有3DTransform相关合成原因时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:5531590180989820332fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) |                                                              |
| 37   | kPreserve3DWith3DDescendants              | 元素的transform-style为preserve-3d，子孙元素有3DTransform相关合成原因时，该元素会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:5075005381349681580fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) |                                                              |
| 38   | kIsolateCompositedDescendants             | 元素isolation为isolate且子孙元素有合成层有mix-blend-mode属性会生成这种类型的合成层 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:5132975758057979644fcABWdNB9dGPHvrlmcwF01Dc-:1682654457377) | https://www.zhangxinxu.com/wordpress/2016/01/understand-css3-isolation-isolate/ |
| 39   | kFullscreenVideoWithCompositedDescendants | 当全屏的video子孙元素有合成层是会生成这种类型的合成层but：从代码维度看是这样，但是实验没复现 | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:-869490618718239364fcABWdNB9dGPHvrlmcwF01Dc-:1682654457378) |                                                              |
| 40   | kRoot                                     | 页面的rootLayer                                              |                                                              | 我们版本的内核主文档未发现返回这种reason，但是iframe的document会返回 |
| 41   | kLayerForHorizontalScrollbar              | 横向滚动条生成的合成层，kswebview中设置了滚动条特殊样式的时候会生成该Layer |                                                              | https://segmentfault.com/a/1190000003708894                  |
| 42   | kLayerForVerticalScrollbar                | 纵向滚动条生成的合成层，kswebview中设置了滚动条特殊样式的时候会生成该Layer |                                                              | https://segmentfault.com/a/1190000003708894                  |
| 43   | kLayerForScrollCorner                     | 滚动条边角生成的合成层                                       |                                                              | https://segmentfault.com/a/1190000003708894                  |
| 44   | kLayerForScrollingContents                | 滚动内容的容器                                               | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:2903620785730835876fcABWdNB9dGPHvrlmcwF01Dc-:1682654457378) |                                                              |
| 45   | kLayerForSquashingContents                | 不滚动，但是会产生层叠（仅仅满足kOverlap或者kAssumedOverlap）的元素生成的Layer，一般跟最近一个定位非static的父元素为根节点，自己是position:  absolute有关（比如水印）PS：最新的chromium中不会对此进行合成，delete | third_party/blink/renderer/core/paint/compositing/composited_layer_mapping.cc![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:1780987941178045753fcABWdNB9dGPHvrlmcwF01Dc-:1682654457378)![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:2425751317567895209fcABWdNB9dGPHvrlmcwF01Dc-:1682654457378) ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:4222098900361819130fcABWdNB9dGPHvrlmcwF01Dc-:1682654457378) |                                                              |
| 46   | kLayerForForeground                       | 伴随kNegativeZIndexChildren一起存在，负责承载negative z-index layer上其他元素的衍生容器Layer | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:1884440356076690651fcABWdNB9dGPHvrlmcwF01Dc-:1682654457378) |                                                              |
| 47   | kLayerForMask                             | clip-path和backdrop-filter一起使用会生成该类型Layermask-image为url(a.pic)，子孙元素有被合成时，该元素会生成这种类型的合成层mask属性指定了图片，子孙元素有被合成时，该元素会生成这种类型的合成层 |                                                              |                                                              |
| 48   | kLayerForDecoration                       | 滚动且合成的元素上用outline设置了边框时会合成该类型Layer     | ![img](https://docs.corp.kuaishou.com/image/api/external/load/out?code=fcAAPdLwSJuaBGhVlZltMTlAM:8903493439904317639fcABWdNB9dGPHvrlmcwF01Dc-:1682654457379) | `<div id="scroller">    <div class="spacer">1</div> </div> #scroller {  outline: 5px solid rgba(0, 255, 0, 0.6);  outline-offset: -4px;  overflow: scroll;  width: 200px;  height: 200px; } .spacer {  width: 300px;  height: 300px; }`https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/web_tests/compositing/overflow/overflow-scroll-with-negative-offset-translucent-outline.html;bpv=1 |
| 49   | kLayerForOther                            | 未归类的其他类型Layer                                        |                                                              |                                                              |
| 50   | kBackfaceInvisibility3DAncestor           | 元素和后代共用一个3D渲染环境并且backface-visibility为hidden，transform-style为preserve-3d |                                                              | `.parent {  backface-visibility: hidden;  transform-style: preserve-3d; } .child {  transform: translate3d(10px, 10px, 10px); }` |



#### 为什么一个网页要分为不同的图层

页面中的不同部分，重绘频率是不一样的，比如 video、canvas、动画这种就要高频重绘，而且现代浏览器都支持通过 GPU 做计算来加速渲染（硬件加速），怎么综合高频重绘和低频重绘、CPU 渲染和 GPU 渲染呢？

答案就是分成不同的图层，每个图层单独做自己的绘制，最后由 Compositor 线程把它们合并到一起。



#### **隐式合成**

当出现一个合成层后，层级顺序高于它的堆叠元素就会发生隐式合成。

比如我们给C、D元素设置层级，z-index分别是3和4；又在C元素上使用3D变换，提升成了合成层。此时，层级高于它的D元素就发生了隐式合成，也变成了一个合成层。

隐式合成出现的根本原因是，元素发生了堆叠，浏览器为了保证最后的展示效果，不得不把层级顺序更高的元素拎出来盖在已有合成层上面。





#### 合成层对内存的影响

![image-20230428112509530](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-28-11-25-image-20230428112509530.png)

在分层后，chromium为了让底层的硬件能够把这块的图像绘制出来，需要生成对应的纹理，在实际上生成纹理的时候，为了提高渲染的效率，会在不同的Layer上进一步进行分块，分成一个一个的Tile，chromium中由tile_manager来管理分块。

分块后，每个Tile一搬来说都会持有自己的resource，这些 resource统一从chromium的resourcePool模块进行申请的，由resourcePool来create、reuse、release这些内存空间，内存的大小，和tile的分辨率息息相关，同样，也受到色彩空间的影响。

Tile完成自己的光栅化任务以后，会提交给pendingTree，当所有当前帧所有需要光栅化的tile都完成任务时，会提交给activeTree，进行屏幕上的渲染。

看上去Layer占用的shared_images 内存就是tile占用的这些内存，约等于tile的分辨率宽高相乘再乘以色彩空间的总和，即InUsePoolResourceMemory，

但是实际上，对于这部分内存可能会残留一些未来得及释放的Memory和为常常刷新的区域备份缓存的多份resourceMemory，比如动画、轮播这些。也就是说，当我们的页面动态更新的区域越多，这部分缓存的内存就越多





### 层爆炸与层压缩

层爆炸指的是大量元素意料之外被提升成合成层，即隐式合成；层压缩是浏览器对隐式合成的优化。

这是我在项目中实际遇到的一个问题：一个页面在低端机器上滚动时非常卡顿，排查了很久，最后发现原因就在于隐式合成带来的层爆炸。

隐式合成产生了很多预期外的合成层——页面中所有 z-index 高于它的节点全部被提升，这些合成层都是相当消耗内存和GPU的。所以带给我们的启示是给合成层一个大的z-index值==，避免出现隐式合成。

还好浏览器逐渐进行了优化，也就是层压缩机制——多个渲染层同一个合成层重叠时，会自动将他们压缩到一起，避免“层爆炸”带来的损耗。





### 硬件加速

硬件加速并不是前端专有的东西，它是一个很宽泛的计算机概念——把软件的工作交给特定的硬件，更高效的完成某项任务。对于前端来说，就是使用特定的CSS属性，把元素提升成合成层，交给GPU处理，比在主线程（CPU）上效率更高。



浏览器会使用GPU进行以下操作的渲染：

1. CSS动画和过渡：浏览器会尽可能地使用GPU来渲染CSS动画和过渡，特别是涉及到transform和opacity的动画。
2. Canvas和WebGL：这两种技术都是直接使用GPU进行渲染的。
3. 视频解码和播放：大多数现代浏览器都会使用GPU来解码和播放视频，特别是高清视频。
4. 复杂的CSS效果：一些复杂的CSS效果，如阴影、模糊、渐变等，也可能会使用GPU进行渲染。
5. 3D CSS变换：使用CSS的3D变换功能会触发GPU渲染。
6. 硬件加速：当开启硬件加速时，浏览器会尽可能地使用GPU进行渲染。









### 使用Chrome DevTools来了解页面的合成层情况

开启 `Timeline>Paint`选项，然后录制一段时间的操作，选择单独的帧，看到每个帧的渲染细节，在ESC弹出框有个Layers选项，可以看到渲染层的细节，有多少渲染层以及为何被创建。



## 浏览器渲染优化

### 结合渲染流程怎么优化渲染性能呢？

结合上述的渲染流程，我们可以去针对性的分析并优化每个步骤。

- 优化JavaScript的执行效率

- 降低样式计算的范围和复杂度

- 避免大规模、复杂的布局

- 简化绘制的复杂度、减少绘制区域

- 优先使用渲染层合并属性（即变成合成层）、控制层数量

  

### **（1）针对JavaScript**：优化JavaScript的执行效率

JavaScript可以修改CSSOM和DOM，因此会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：

##### （1）尽量将JavaScript文件放在body的最后

##### （2）`<script>`标签的引入资源方式有三种

有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：

- **script** 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
- **async** 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；
- **defer** 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。

##### 	（3）动画实现使用requestAnimationFrame

setTimeout(callback)和setInterval(callback)无法保证callback函数的执行时机，很可能在帧结束的时候执行，从而导致丢帧，如下图：

![img](https://ask.qcloudimg.com/http-save/yehe-3615838/1jahxrlde2.webp?imageView2/2/w/1620/format/jpg)

`requestAnimationFrame(callback)`可以保证callback函数在每帧动画开始的时候执行。

#####  （4） 长耗时的JS代码放到Web Workers中执行

##### （5）分时任务

比如 把DOM元素的更新划分为多个小任务，分别在多个frame中去完成

由于Web Workers不能操作DOM元素的限制，所以只能做一些纯计算的工作，对于很多需要操作DOM元素的逻辑，可以考虑分步处理，把任务分为若干个小任务，每个任务都放到requestAnimationFrame中回调执行



```jsx
var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);

requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
    var nextTask = taskList.pop();

    // 执行小任务
    processTask(nextTask);

    if (taskList.length > 0) {
        requestAnimationFrame(processTaskList);
    }
}
```





##### （6）避免强制同步布局事件的发生

浏览器是做了优化的，<font color="red">reflow和repaint是异步的</font>，但是如果你在改完样式后要读里面的属性，浏览器就只能立马先按你改的样式reflow或repaint一下。

在JS脚本运行的时候，它能获取到的元素样式属性值都是上一帧画面的，都是旧的值。如果你对元素节点改动之后想获取当前帧属性，那就会导致浏览器必须先应用属性修改，结果执行布局过程，最后再执行JS逻辑。

```js
/**举例*/
requestAnimationFrame(logBoxHeight);

// 先写后读，触发强制布局
function logBoxHeight() {
    // 更新box样式
    box.classList.add('super-big');

    // 为了返回box的offersetHeight值
    // 浏览器必须先应用属性修改，接着执行布局过程
    console.log(box.offsetHeight);
}

// 先读后写，避免强制布局              或者可以把读操作变成异步的，不要马上就读
function logBoxHeight() {
    // 获取box.offsetHeight
    console.log(box.offsetHeight);

    // 更新box样式
    box.classList.add('super-big');
}
```

##### （7）避免使用运行时间过长的输入事件处理函数

理想情况下，当用户和页面交互，页面的合并线程将接收到这个事件并移动元素。这个响应过程是不需要主线程参与，不会导致JavaScript、布局和绘制过程发生。但是如果被触摸的元素绑定了输入事件处理函数，比如touchstart/touchmove/touchend，那么合并线程必须等待这些被绑定的处理函数执行完毕才能执行，也就是用户的滚动页面操作被阻塞了，表现出的行为就是滚动出现延迟或者卡顿。

简而言之就是你必须确保用户输入事件绑定的任何处理函数都能够快速的执行完毕，以便腾出时间来让渲染层合并线程完成他的工作。





### **（2）针对CSS**：降低样式计算的范围和复杂度

###### 加载css

**\**使用CSS有三种方式：使用\**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：

- **link**：浏览器会派发一个新的线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
- **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(==阻碍==浏览器渲染).所以，在开发过程中，导入外部样式使用link，而不用@import。
- **style**：GUI直接渲染

外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器默认样式确保首次渲染的速度。所以CSS一般写在header中，让浏览器尽快发送请求去获取css样式。



###### 降低样式选择器的复杂度

尽量保持class的简短，或者使用Web Components框架。



```rust
.box:nth-last-child(-n+1) .title {
}
// 改善后
.final-box-title {
}
```

###### 减少需要执行样式计算的元素个数

由于浏览器的优化，现代浏览器的样式计算直接对目标元素执行，而不是对整个页面执行，所以我们应该尽可能减少需要执行样式计算的元素的个数









### **（3）避免大规模、复杂的布局**

###### 减少回流和重绘

重绘不一定引起回流，但回流一定引起重绘。

- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 脱离文档流(绝对定位、固定定位)，脱离文档流的元素进行重排不会影响到其他元素。
- 图片渲染时增加宽高属性，宽高固定后，图片不会根据内容动态改变高度，便不会触发重排。
- 使用`will-change: transform;`将元素独立为一个单独的图层。（定位、透明、transform、clip都会产生独立图层）

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层。

- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。

- 为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。用一次回流替代多次回流

  

  

  

  

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**。**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**

 通过Chrome DevTools来分析绘制复杂度和时间消耗，尽可能降低这些指标。打开DevTools，在弹出的面板中，选中 `MoreTools>Rendering`选项卡下的Paint flashing，这样每当页面发生绘制的时候，屏幕就会闪现绿色的方框。通过该工具可以检查Paint发生的区域和时机是不是可以被优化。通过Chrome DevTools中的 `Timeline>Paint`选项可以查看更细节的Paint信息



### （4）针对层

1. 避免重排：使用absolute或者fixed，使元素==脱离文档流==，这样他们发生变化就不会影响其他元素
2. 避免重排/重绘，直接进行合成，==transform 和 opacity的动画效果都是直接进入合成阶段的==；比如可以使用`transform:translate`代替`left/top`修改元素的位置；使用`transform:scale`代替宽度、高度的修改；
3. 如果实在没法避免回流、重绘，可以使用硬件加速，让这个元素成为合成层单独回流、重绘，减少绘制的面积。
4. 注意隐式合成，给合成层一个较大的z-index值，虽然大部分浏览器已经实现了层压缩的能力，但是依旧有无法处理的情况，最好的办法就是一开始就避免层爆炸；
5. 减小合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的，如果要实现一个100X100的元素，可以给宽高都设置为10px，再使用transform:scale(10)放大10倍，这样占用的内存只有直接设置的1/100；



## CSS 如何阻塞文档解析

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。***所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析***，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。









# 浏览器缓存

### 浏览器的缓存机制

**浏览器缓存的全过程：**

- 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并==缓存资源文件与 response header==，以供下次加载时对比使用；
- 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 `cache-control` 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 `expires` 头判断是否过期；
- 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 `If-None-Match`（`If-None-Match` 会将当前 `ETag` 发送给服务器，询问该资源 `ETag` 是否变动）和 `If-Modified-Since` 的请求；
- 服务器收到请求后，优先根据 `Etag` 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，==命中协商缓存，返回 `304`==；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；如果服务器收到的请求没有 Etag 值，则将 `If-Modified-Since` 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 `304`；不一致则返回新的 `last-modified` 和文件并返回 200；

![业务流程图1.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f6837d8d1c74cf2894d8967a20115d9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp) 很多网站的资源后面都加了版本号，这样每次升级了 JS 或 CSS 文件后，客户端浏览器就会重新下载新的 JS 或 CSS 文件 



### 如果服务端主动更新了东西

浏览器是根据URL进行缓存，所以可以一旦内容有所更新时，我们就让浏览器发起新的URL请求，使得新内容能够被客户端更新。一般的更新机制有如下两种。

❑ 每次发布，路径中跟随Web应用的版本号：http://url.com/?v=20130501。

❑ 每次发布，路径中跟随该文件内容的hash值：http://url.com/?hash=afadfadwe。（用这个）

大体来说，根据文件内容的hash值进行缓存淘汰会更加高效，因为文件内容不一定随着Web应用的版本而更新，而内容没有更新时，版本号的改动导致的更新毫无意义，因此以文件内容形成的hash值更精准。





### 资源放强缓存或协商缓存的选择

通常来说，POST、DELETE、PUT这类带行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中。

一般可以根据以下几个因素来决定哪些资源使用强缓存，哪些资源使用协商缓存：

1. 资源的类型：静态资源（如CSS、JavaScript、图片等）一般适合使用强缓存，而动态资源（如API接口、数据接口等返回的数据）则更适合使用协商缓存。
2. 资源的更新频率：对于更新频率较低的资源，使用强缓存可以减少请求次数，加快页面加载速度。对于更新频率较高的资源，使用协商缓存可以更好地控制缓存策略，保证用户获取到最新的资源。
3. 资源的重要性：对于关键资源（如页面HTML内容），可以考虑使用强缓存，以提高用户体验，同时也能减轻服务器压力。对于非关键资源（如图片、视频等），可以考虑使用协商缓存，以保证用户能够获取到最新的资源。

根据上述的因素，一般可以将静态资源如CSS、JavaScript、图片等使用强缓存，而动态资源如API接口、数据接口等使用协商缓存。当然，实际情况还需要根据具体的业务特点和用户体验考虑。





### 普通刷新和强制刷新的区别

- **普通刷新：** 
  - 操作：点击刷新按钮 或者 win下按 F5

  - 作用：浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。

- **强制刷新：** 
  - 三种操作方法：
    1. 在Windows和Linux操作系统下，使用Ctrl + F5命令即可在当前选项卡执行强制刷新。在Mac操作系统下，使用Command + Shift + R命令同样可以达到相同效果。
    2. 打开Chrome开发者工具，然后按住shift键，点击浏览器刷新按钮即可完成强制刷新。
    3. 通过Javascript代码执行强制刷新 `location.reload(true);`
  - 作用：浏览器不仅会对本地文件过期（使本地缓存失效），而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。









### Service Worker

Service Worker 是运行在浏览器背后的**独立线程**，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 **HTTPS**。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。

Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 `install` 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：

```javascript
// index.js
if (navigator.serviceWorker) {
  navigator.serviceWorker
    .register('sw.js')
    .then(function(registration) {
      console.log('service worker 注册成功')
    })
    .catch(function(err) {
      console.log('servcie worker 注册失败')
    })
}
// sw.js
// 监听 `install` 事件，回调中缓存所需文件
self.addEventListener('install', e => {
  e.waitUntil(
    caches.open('my-cache').then(function(cache) {
      return cache.addAll(['./index.html', './index.js'])
    })
  )
})
// 拦截所有请求事件
// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(function(response) {
      if (response) {
        return response
      }
      console.log('fetch source')
    })
  )
})
复制代码
```

打开页面，可以在开发者工具中的 `Application` 看到 Service Worker 已经启动了： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ef126ed3be8463a8e04d4156b2addd9~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp) 在 Cache 中也可以发现所需的文件已被缓存： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a223ee3c073d47188ecee7c410ee557c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)





### 浏览器资源缓存的位置

资源缓存的位置一共有 3 种，按优先级从高到低分别是：

1. **Service Worker：\**Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们\**自由控制**缓存哪些文件、如何匹配缓存、如何读取缓存，并且**缓存是持续性的**。当 Service Worker 没有命中缓存的时候，需要去调用 `fetch` 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。**但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。**
2. **Memory Cache：** Memory Cache 就是内存缓存，它的效率最快，**但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。**一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。
3. **Disk Cache：** Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache **胜在容量和存储时效性上。**在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。**并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。**

**Push Cache：** Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。其具有以下特点：

- 所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好
- 可以推送 `no-cache` 和 `no-store` 的资源
- 一旦连接被关闭，Push Cache 就被释放
- 多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存
- Push Cache 中的缓存只能被使用一次
- 浏览器可以拒绝接受已经存在的资源推送
- 可以给其他域名推送资源****







# 浏览器本地存储

## 总对比图

![image-20230429140324103](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-14-03-image-20230429140324103.png)



## 浏览器本地存储方式及使用场景

### 总对比图

![image-20230429134454632](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-13-44-image-20230429134454632.png)

### （1）Cookie

Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。

#### **Cookie的特性：**

- <font color="red">cookie遵循的是跨站而不是跨域：cookie在不同域名之间是无法共享的，但是在顶级域名、二级域名、三级域名中是可以共享的（向下兼容）</font> [该文档下面有更详细讲解](#cookie-cross)

  - 在setcookie中省略domain参数，那么domain默认为当前域名
    domain参数可以设置父域名以及自身，但不能设置其它域名，包括子域名，否则cookie不起作用
    如果cookie设置为顶级域名，则全部的域名，包括顶级域名、二级域名、三级域名等，都可以共享该cookie
    如果cookie设置为当前域名，则当前域名及其下面的所有子域名可以共享该cookie

  

- Cookie一旦创建成功，名称就无法修改

- 每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb

- 有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的

- Cookie在请求一个新的页面的时候都会被发送过去

如果需要域名之间跨域共享Cookie，有两种方法：

1. 使用Nginx反向代理
2. 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId















#### **Cookie的使用场景：**

- 最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。
- 可以用来统计页面的访问次数



#### js设置cookie

```js
/**w3c官网的代码*/
//设置cookie
function` `setCookie(cname, cvalue, exdays) {
  ``var` `d = ``new` `Date``();
  ``d.setTime(d.getTime() + (exdays*24*60*60*1000));
  ``var` `expires = ``"expires="``+d.toUTCString();
  ``document.cookie = cname + ``"="` `+ cvalue + ``"; "` `+ expires;
}
//获取cookie
function` `getCookie(cname) {
  ``var` `name = cname + ``"="``;
  ``var` `ca = document.cookie.split(``';'``);
  ``for``(``var` `i=0; i<ca.length; i++) {
    ``var` `c = ca[i];
    ``while` `(c.charAt(0)==``' '``) c = c.substring(1);
    ``if` `(c.indexOf(name) != -1) ``return` `c.substring(name.length, c.length);
  ``}
  ``return` `""``;
}
//清除cookie 
function` `clearCookie(name) { 
  ``setCookie(name, ``""``, -1); 
} 
```



### （2）LocalStorage

LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求

**LocalStorage的优点：**

- 在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息
- LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在

**LocalStorage的缺点：**

- 存在浏览器兼容问题，IE8以下版本的浏览器不支持
- 如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage
- LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问。（实现**在domain2.com中使用domain1.com的localStorage**，可以在domain2.com的页面中嵌入一个src为domain1.com的iframe，此时这个iframe里可以调用domain1.com的localstorage。然后用postMessage方法实现页面与iframe之间的通信。我们也可以在domain1.com中专门写一个负责共享localstorage的页面，这样可以防止无用的资源加载到iframe中。）

**LocalStorage的常用API：**

```javascript
// 保存数据到 localStorage
localStorage.setItem('key', 'value');

// 从 localStorage 获取数据
let data = localStorage.getItem('key');

// 从 localStorage 删除保存的数据
localStorage.removeItem('key');

// 从 localStorage 删除所有保存的数据
localStorage.clear();

// 获取某个索引的Key
localStorage.key(index)
复制代码
```

**LocalStorage的使用场景：**

- 有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可
- 在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中

### （3）SessionStorage

SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存==同一标签页==的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。

**SessionStorage与LocalStorage对比：**

- SessionStorage和LocalStorage都在**本地进行数据存储**；
- SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage**只有在同一浏览器的同一窗口下才能够共享**；如果一个页面包含多个iframe且他们属于同源页面，那么他们之间是可以共享sessionStorage的
- LocalStorage和SessionStorage**都不能被爬虫爬取**；

**SessionStorage的常用API：**

```javascript
// 保存数据到 sessionStorage
sessionStorage.setItem('key', 'value');

// 从 sessionStorage 获取数据
let data = sessionStorage.getItem('key');

// 从 sessionStorage 删除保存的数据
sessionStorage.removeItem('key');

// 从 sessionStorage 删除所有保存的数据
sessionStorage.clear();

// 获取某个索引的Key
sessionStorage.key(index)
```

**SessionStorage的使用场景**

- 由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。



### 三者区别

#### 存储大小

cookie：一般不超过4k

sessionStorage：5M甚至更多

localStorage：5M甚至更多

#### 数据有效期

cookie:一般由服务器生成，可以设置失效时间；若没有设置时间，关闭浏览器cookie失效，如果设置了时间，cookie就会存储在硬盘中，过期失效

sessionStorage：仅在当前浏览器窗口关闭之前有效，关闭页面或者浏览器会被清除

localStorage：永久有效，窗口或者浏览器关闭也会一直保存，除非手动永久删除

#### 作用域

cookie：在所有同源窗口中都是共享的

sessionStorage：在同一个浏览器窗口是共享的（不同浏览器，即使是统一页面也不共享）

localStorage：在所有同源窗口中共享

#### 通信

cookie：cookie在浏览器和服务器之间来回传递，如果使用cookie保存过多数据会造成性能问题

sessionStorage：仅在客户端（浏览器）中保存，不参与服务器的通信

localStorage：仅在客户端（浏览器）中保存，不参与服务器的通信

####  应用场景

cookie：判断用户是否登录过网站，以便实现下次自动登录或记住密码；保存事件信息（比如用来记录购物车或者记录用户使用偏好来制定推送、记录用户浏览轨迹）

sessionStorage：敏感账号一次性登录，单页面用的较多

localStorage：用于长期登录，适于长期保存在本地的数据







## IndexedDB有哪些特点？

- **键值对储存**：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以"键值对"的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。
- **异步**：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。
- **支持事务**：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。
- **同源限制：** IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。
- **储存空间大**：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。
- **支持二进制储存**：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。













# 浏览器的一些机制

## t cp连接

主流浏览器对于==同一个域名==默认允许同时建立 2-8 个 TCP 持久连接，`HTTP/1.1`中，单个TCP连接，在同一时间只能处理一个http请求。`HTTP2`提供了多路传输功能，多个http请求，可以同时在同一个TCP连接中进行传输。

![](https://img-blog.csdnimg.cn/20201202094620737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5ODE2Njcz,size_16,color_FFFFFF,t_70#pic_center)

持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上`Connection: close`。



## 资源请求


浏览器在处理 CSS 和 JS 文件中的相对 URL 时存在一些区别。这些区别取决于资源的引入方式以及浏览器的工作原理。

1. **CSS 文件**：
   - 在 CSS 文件中，相对 URL 通常是相对于包含 CSS 文件的样式表的 URL。这意味着在 CSS 文件中引用的相对 URL 会相对于包含 CSS 文件的 URL 进行解析。
   - 浏览器会自动处理 CSS 文件中的相对 URL，确保它们正确解析为相对于 CSS 文件的位置。
2. **JS 文件**：
   - 在 JS 文件中，相对 URL 通常是相对于包含 HTML 文件的 URL，而不是相对于包含 JS 文件的 URL。
   - 如果你在 JS 文件中使用相对 URL，浏览器不会自动处理它们。相对 URL 在 JS 文件中需要手动解析，通常是通过构建工具或框架提供的特定功能来处理。



## 大小写

HTML 和 CSS 是不区分大小写的，但是，推荐使用小写，因为一些服务器是区分大小写的。


JavaScript 是区分大小写的。例如，变量名、函数名、方法名、对象名都是区分大小写的。在 HTML 属性名及属性内容 和 CSS 选择器中是区分大小写的。例如，id="MyId" 和 id="myid" 是不同的。




在 XHTML（基于 XML 的 HTML 版本）中，所有的标记必须小写，因为 XML 是区分大小写的。





# 浏览器同源策略

## 什么是同源策略

<span style="color:red">`<script>` 与其他一些元素（`<audio>、<img>、<link>、和 <video>`）默认都不会有跨域的限制。跨域tm是限制ajax的</span>

**同源策略：protocol（协议）、domain（域名）（二级域名或三级域名不一致也会算跨域）、port（端口）三者必须一致**

举例来说，`http://www.example.com/dir/page.html`这个网址，协议是`http://`，域名是`www.example.com`，端口是`80`（默认端口可以省略）。它的同源情况如下：

> - `http://www.example.com/dir2/other.html`：同源
> - `http://example.com/dir/other.html`：不同源（域名不同）
> - `http://v2.www.example.com/dir/other.html`：不同源（域名不同）
> - `http://www.example.com:81/dir/other.html`：不同源（端口不同）



是否跨域是**浏览器**自己来进行判断的。其过程大致如下：

1. 判断是否跨域，跨域则在请求头加origin属性。
2. 服务器返回数据。
3. 浏览器判断服务器返回数据响应头中有无Access-Control-Allow-Origin，无或不匹配则为跨域。报错就会如约而至。匹配成功则无事发生。 不过此处仅是[简单请求](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FCORS%23%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82)，复杂请求时需要预检请求option，但其核心还是在服务端的配置。



## 为什么需要同源策略

### 同源政策为了限制三个方面

（1） Cookie、LocalStorage 和 IndexDB 无法读取。

（2） DOM 无法获得：  禁止操作非源页面的DOM与JS对象。

- 这里主要场景是iframe跨域的情况，非同源的iframe是限制互相访问的

（3） AJAX 请求不能发送。

- 主要用来防止[CSRF](https://link.juejin.cn/?target=.%2Fsafe.md%23csrf)（跨站请求伪造）攻击

<font color="red">注意，响应其实是成功到达客户端了，是被浏览器拦截了</font>









### 如果没有同源策略

例1:**如果iframe可以跨域，就会有以下攻击场景**

1. 一个假网站`https://a.com`，内部嵌套一个全屏的iframe标签指向一个银行网站 `https://b.com`
2. 用户访问假网站除了域名，别的部分和银行的网站没有任何差别
3. 开发者可以在假网站中注入输入事件监听脚本，跨域访问`https://b.com`节点中的内容
4. 此时用户的输入都能被监听到，这样假网站就拿到了用户的账号密码

这样一次攻击就完成了

例2:**如果ajax可以跨域，就会有以下攻击场景**

1. 用户在银行网站`https://b.com`进行了登录，网站使用cookie鉴权
2. 攻击者直接从网站`https://a.com`发起一个指向银行网站的攻击请求，此跨域请求会携带上目标站点上的cookie
3. 银行服务端验证用户cookie无误，返回对应的响应数据
4. 此时就造成了用户信息泄露，用户是无法感知到的

这样一次攻击就完成了





## 跨站

只要两个 URL 的 eTLD+1 相同即是同站,不需要考虑协议和端口

**eTLD**: (effective top-level domain) 有效顶级域名，注册于 Mozilla 维护的公共后缀列表（Public Suffix List）中,如`.com`、`.co.uk`、`.github.io`,`.top` 等

**eTLD+1**: 有效顶级域名+二级域名，如 `taobao.com`,`baidu.com`,`sugarat.top`

> tips: 这里的一级,二级域名主要指计算机网络中规定的，与通常业务开发中所指的一二级域名有些许差异













## <span id="cookie-cross">顶级域名和子级域名之间的Cookie</span>



### 设置Cookie

Domain 指定了 Cookie 可以送达的主机名。<font color="red">假如没有指定，则忽略子域名，就是主域名私有的！。</font>

<font color="red">设置`cookie`的话只能在本域名下或者`domain`级别高于自身的域名下才会生效！。</font>

例如`www.yangbai.com`在浏览器设置`cookie`的情况如下：

```js
setcookie("name1", "yangbai", time() + 1000);//yangbai.com自己可以看到
 
setcookie("name2", "yangbai", time() + 1000, "/", "www.yangbai.com");// *.www.yangbai.com都可以看到
 
setcookie("name3", "yangbai", time() + 1000, "/", "yangbai.com");// *.yangbai.com都可以看到
 
setcookie("name4", "yangbai", time() + 1000, "/", "login.yangbai.com");//设置无效
```

不能跨域设置 Cookie，比如阿里域名下的页面把 Domain 设置成百度是无效的：

```
Set-Cookie: qwerty=219ffwef9w0f; Domain=baidu.com; Path=/; Expires=Wed, 30 Aug 2020 00:00:00 GMT
```





### 读取COOKIE

子域名可以读取父域名的cookie， 父域名不能读取子域名的cookie



### 删除COOKIE

删除cookie是修改cookie的一种特殊场景，只需将`expire`设置为过期、值设置为`null`即可





### 两网页一级域名相同，二级域名不同时如何共享cookie

cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。但是，两个网页一级域名相同，只是二级域名不同，浏览器允许通过设置`document.domain`共享 Cookie。

举例来说，A网页是`http://w1.example.com/a.html`，B网页是`http://w2.example.com/b.html`，那么只要设置相同的`document.domain`，两个网页就可以共享Cookie。

> ```javascript
> document.domain = 'example.com';
> ```

现在，A网页通过脚本设置一个 Cookie。

> ```javascript
> document.cookie = "test1=hello";
> ```

B网页就可以读到这个 Cookie。

> ```javascript
> var allCookie = document.cookie;
> ```

另外，服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如`.example.com`。这样的话，二级域名和三级域名不用做任何设置，都可以读取这个Cookie。

> ```http
> Set-Cookie: key=value; domain=.example.com; path=/
> ```







## 规避LocalStorage的同源策略

通过`window.postMessage`，读写其他窗口的 LocalStorage 也成为了可能。（本质还是只能同源的去读，只不过是读完后通过postMessage发给其他窗口）

下面是一个例子，主窗口写入iframe子窗口的`localStorage`。

> ```javascript
> window.onmessage = function(e) {
>   if (e.origin !== 'http://bbb.com') {
>     return;
>   }
>   var payload = JSON.parse(e.data);
>   localStorage.setItem(payload.key, JSON.stringify(payload.data));
> };
> ```

上面代码中，子窗口将父窗口发来的消息，写入自己的LocalStorage。

父窗口发送消息的代码如下。

> ```javascript
> var win = document.getElementsByTagName('iframe')[0].contentWindow;
> var obj = { name: 'Jack' };
> win.postMessage(JSON.stringify({key: 'storage', data: obj}), 'http://bbb.com');
> ```

加强版的子窗口接收消息的代码如下。

> ```javascript
> window.onmessage = function(e) {
>   if (e.origin !== 'http://bbb.com') return;
>   var payload = JSON.parse(e.data);
>   switch (payload.method) {
>     case 'set':
>       localStorage.setItem(payload.key, JSON.stringify(payload.data));
>       break;
>     case 'get':
>       var parent = window.parent;
>       var data = localStorage.getItem(payload.key);
>       parent.postMessage(data, 'http://aaa.com');
>       break;
>     case 'remove':
>       localStorage.removeItem(payload.key);
>       break;
>   }
> };
> ```

加强版的父窗口发送消息代码如下。

> ```javascript
> var win = document.getElementsByTagName('iframe')[0].contentWindow;
> var obj = { name: 'Jack' };
> // 存入对象
> win.postMessage(JSON.stringify({key: 'storage', method: 'set', data: obj}), 'http://bbb.com');
> // 读取对象
> win.postMessage(JSON.stringify({key: 'storage', method: "get"}), "*");
> window.onmessage = function(e) {
>   if (e.origin != 'http://aaa.com') return;
>   // "Jack"
>   console.log(JSON.parse(e.data).name);
> };
> ```











## 规避跨域进行窗口间的通信

### 主窗口与子窗口（如：iframe）

#### 规避主域名相同，子域名不同的跨域

##### document.domain + iframe

实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

 父窗口：(domain.com/a.html)

```javascript
<iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
<script>
    document.domain = 'domain.com';
    var user = 'admin';
</script>
```

子窗口：(child.domain.com/a.html)

```javascript
<script>
    document.domain = 'domain.com';
    // 获取父窗口中变量
    console.log(window.parent.user);
</script>
```



#### 规避完全不同源的跨域





##### 片段识别符

片段标识符（fragment identifier）指的是，URL的`#`号后面的部分，比如`http://example.com/x.html#fragment`的`#fragment`。如果只是改变片段标识符，页面不会重新刷新。

父窗口可以把信息，写入子窗口的片段标识符。

> ```javascript
> var src = originURL + '#' + data;
> document.getElementById('myIFrame').src = src;
> ```

子窗口通过监听`hashchange`事件得到通知。

> ```javascript
> window.onhashchange = checkMessage;
> 
> function checkMessage() {
>   var message = window.location.hash;
>   // ...
> }
> ```

同样的，子窗口也可以改变父窗口的片段标识符。

> ```javascript
> parent.location.href= target + "#" + hash;
> ```







### 任何窗口之间

#### postMessage 跨域

##### 介绍

HTML5引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为`window`对象新增了一个`window.postMessage`方法，允许跨窗口通信，不论这两个窗口是否同源。

##### 用法

###### 1.发送信息

postMessage(data,origin)方法接受两个参数：

- **data**： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
- **origin**： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。



###### 2.接收信息

通过`message`事件，监听对方的消息。

> ```javascript
> window.addEventListener('message', function(e) {
>   console.log(e.data);
> },false);
> ```

`message`事件的事件对象`event`，提供以下三个属性。

> - `event.source`：发送消息的窗口
> - `event.origin`: 消息发向的网址
> - `event.data`: 消息内容

下面的例子是，子窗口通过`event.source`属性引用父窗口，然后发送消息。

> ```javascript
> window.addEventListener('message', receiveMessage);
> function receiveMessage(event) {
>   event.source.postMessage('Nice to see you!', '*');
> }
> ```

`event.origin`属性可以过滤不是发给本窗口的消息。

> ```javascript
> window.addEventListener('message', receiveMessage);
> function receiveMessage(event) {
>   if (event.origin !== 'http://aaa.com') return;
>   if (event.data === 'Hello World') {
>       event.source.postMessage('Hello', event.origin);
>   } else {
>     console.log(event.data);
>   }
> }
> ```





##### 示例

1）a.html：(domain1.com/a.html)

```javascript
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>       
    var iframe = document.getElementById('iframe');
    iframe.onload = function() {
        var data = {
            name: 'aym'
        };
        // 向domain2传送跨域数据
        iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com');
    };
    //通过message事件，监听对方的消息 接受domain2返回数据
    window.addEventListener('message', function(e) {
        alert('data from domain2 ---> ' + e.data);
    }, false);
</script>
```

2）b.html：(domain2.com/b.html)

```javascript
<script>
    //通过message事件，监听对方的消息 接收domain1的数据
    window.addEventListener('message', function(e) {
        alert('data from domain1 ---> ' + e.data);
        var data = JSON.parse(e.data);
        if (data) {
            data.number = 16;
            // 处理后再发回domain1
            window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com');
        }
    }, false);
```





## 解决跨域AJAX请求

### WebSocket协议跨域

#### 简介

WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，使用`ws://`（非加密）和`wss://`（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。且是server push技术的一种很好的实现。

下面是一个例子，浏览器发出的WebSocket请求的头信息（摘自[维基百科](https://en.wikipedia.org/wiki/WebSocket)）。

> ```http
> GET /chat HTTP/1.1
> Host: server.example.com
> Upgrade: websocket
> Connection: Upgrade
> Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
> Sec-WebSocket-Protocol: chat, superchat
> Sec-WebSocket-Version: 13
> Origin: http://example.com
> ```

上面代码中，有一个字段是`Origin`，表示该请求的请求源（origin），即发自哪个域名。

正是因为有了`Origin`这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。

> ```http
> HTTP/1.1 101 Switching Protocols
> Upgrade: websocket
> Connection: Upgrade
> Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
> Sec-WebSocket-Protocol: chat
> ```



#### 示例

原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。

1）前端代码：

```javascript
<div>user input：<input type="text"></div>
<script src="https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js"></script>
<script>
var socket = io('http://www.domain2.com:8080');
// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---> ' + msg); 
    });
    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});
document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
</script>
复制代码
```

2）Nodejs socket后台：

```javascript
var http = require('http');
var socket = require('socket.io');
// 启http服务
var server = http.createServer(function(req, res) {
    res.writeHead(200, {
        'Content-type': 'text/html'
    });
    res.end();
});
server.listen('8080');
console.log('Server is running at port 8080...');
// 监听socket连接
socket.listen(server).on('connection', function(client) {
    // 接收信息
    client.on('message', function(msg) {
        client.send('hello：' + msg);
        console.log('data from client: ---> ' + msg);
    });
    // 断开处理
    client.on('disconnect', function() {
        console.log('Client socket has closed.'); 
    });
});
```



### CORS（纯后端）

#### 简介

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）

它<font color="red">允许浏览器向跨源服务器发出[`XMLHttpRequest`](https://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求</font>，从而克服了AJAX只能[同源](https://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制  （源跟域是一样的）

整个CORS通信过程，都是浏览器自动完成。<font color="red">cors的目的是为了将跨域逻辑后移，让服务器决定谁能跨域。</font>只要服务器实现了CORS接口，就可以跨源通信。

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

#### 与CORS请求相关的字段

都以`Access-Control-`开头。

##### 服务器响应

例如：

```http
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Credentials: true
Access-Control-Expose-Headers: FooBar
```

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。设为`true`，即表示服务器明确==许可Cookie可以包含在请求中一起发给服务器==。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。

同时前端需要在AJAX请求中打开==`withCredentials`属性==。

```javascript
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;
```

如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`。

```javascript
xhr.withCredentials = false;
```

需要注意的是，==***如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名***==。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定后，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。



##### "预检"请求的头信息

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。









##### “预检”请求的响应的头信息

服务器回应的其他CORS相关字段如下。

```http
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）Access-Control-Allow-Methods**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Allow-Origin**

表示可以允许请求的源，可以填具体的源名，也可以填`*`表示允许任意源请求。

**（5）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。在此期间不用发出另一条预检请求。



#### 简单请求

##### 什么是简单请求

若请求 **满足所有下述条件**，则该请求可视为“简单请求”：

- 请求方法为 GET、POST 或者 HEAD

- 除了被自动设置的首部字段（例如`Connection`，`User-Agent`）之外，只允许人为设置的字段为 Fetch 规范定义的对 CORS 安全的首部字段集合。该集合为：

  - [`Accept`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)
  - [`Accept-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language)
  - [`Content-Language`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Language)
  - [`Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 且 `Content-Type`的值仅限于下列三者之一：

    - `text/plain`

    - `multipart/form-data`

    - `application/x-www-form-urlencoded`

凡是不同时满足上面两个条件，就属于非简单请求。



##### 简单请求的流程

浏览器发现这次跨源AJAX请求是简单请求，就==自动==在头信息之中添加一个`Origin`字段。

下面是一个例子：

```http
GET /cors HTTP/1.1
Origin: http://api.bob.com  /*用来说明，本次请求来自哪个源（协议 + 域名 + 端口）*/
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段，就知道出错了，从而抛出一个错误。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应会多出一些以`Access-Control-`开头的字段：



#### 复杂请求

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

##### 预检请求

###### 预检请求的请求

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

下面是一段浏览器的JavaScript脚本。

```javascript
var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value'); //自定义头信息
xhr.send();
```

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com 												//（*）
Access-Control-Request-Method: PUT								//（*）
Access-Control-Request-Headers: X-Custom-Header 	//（*）
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。



###### 预检请求的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```bash
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```



######  浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样







### JSONP（JSON with Padding）

最大特点老式浏览器全部支持。本质就是利用了同源策略只限制了ajax和fetch，html标签的请求可以跨域。



#### 简介

一句话概括：前端代码里声明了函数A，服务器把数据放到一个函数调用里，然后返回`A(data)`这样的字符串，由于返回的东西是在`<script>`标签里，所以直接被当成代码执行。

它的基本思想是，网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。前端有这个函数的定义。

<mark>弊端是客户端没法发带请求体的请求。</mark>

#### 步骤

首先，网页动态插入`<script>`元素，由它向跨源网址发出请求。

```javascript
window.onload = function () {
	addScriptTag('http://example.com/ip?callback=foo');
}

function foo(data) {
	console.log('Your public IP address is: ' + data.ip);
};

function addScriptTag(src) {
  var script = document.createElement('script');
  script.setAttribute("type","text/javascript");
  script.src = src;
  document.body.appendChild(script);
}
```

上面代码通过动态添加`<script>`元素，向服务器`example.com`发出请求。注意，该请求的查询字符串有一个`callback`参数，用来指定回调函数的名字，这对于JSONP是必需的。

服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。

```javascript
foo({
"ip": "8.8.8.8"
});
```

由于<font color="red">`<script>`元素请求的脚本直接作为代码运行。这时，只要浏览器定义了`foo`函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象(代码)，而不是字符串，因此避免了使用`JSON.parse`的步骤。</font>









### nginx代理跨域（纯后端）

nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。

1）nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。

```http
location / {
  add_header Access-Control-Allow-Origin *;
}
```

2）nginx反向代理接口跨域 跨域问题：实现思路：通过Nginx配置一个域名与客户端域名相同，端口不同的代理服务器做跳板机（在这个服务器上做CORS，设置请求响应头Access-Control-Allow-Origin…等字段），再由这个代理服务器向服务器接口发送请求，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。

nginx具体配置：

```javascript
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;
        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```



### nodejs 中间件代理跨域

node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。

**1）非vue框架的跨域** 使用node + express + http-proxy-middleware搭建一个proxy服务器。

- 前端代码：

```javascript
var xhr = new XMLHttpRequest();
// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;
// 访问http-proxy-middleware代理服务器
xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);
xhr.send();
复制代码
```

- 中间件服务器代码：

```javascript
var express = require('express');
var proxy = require('http-proxy-middleware');
var app = express();
app.use('/', proxy({
    // 代理跨域目标接口
    target: 'http://www.domain2.com:8080',
    changeOrigin: true,
    // 修改响应头信息，实现跨域并允许带cookie
    onProxyRes: function(proxyRes, req, res) {
        res.header('Access-Control-Allow-Origin', 'http://www.domain1.com');
        res.header('Access-Control-Allow-Credentials', 'true');
    },
    // 修改响应信息中的cookie域名
    cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
}));
app.listen(3000);
console.log('Proxy server is listen at port 3000...');
复制代码
```

**2）vue框架的跨域**

node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。

webpack.config.js部分配置：

```javascript
module.exports = {
    entry: {},
    module: {},
    ...
    devServer: {
        historyApiFallback: true,
        proxy: [{
            context: '/login',
            target: 'http://www.domain2.com:8080',  // 代理跨域目标接口
            changeOrigin: true,
            secure: false,  // 当代理某些https服务报错时用
            cookieDomainRewrite: 'www.domain1.com'  // 可以为false，表示不修改
        }],
        noInfo: true
    }
}
复制代码
```





### location.hash + iframe跨域

实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。

1）a.html：(domain1.com/a.html)

```javascript
<iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 向b.html传hash值
    setTimeout(function() {
        iframe.src = iframe.src + '#user=admin';
    }, 1000);
    
    // 开放给同域c.html的回调方法
    function onCallback(res) {
        alert('data from c.html ---> ' + res);
    }
</script>
复制代码
```

2）b.html：(.domain2.com/b.html)

```
<iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
<script>
    var iframe = document.getElementById('iframe');
    // 监听a.html传来的hash值，再传给c.html
    window.onhashchange = function () {
        iframe.src = iframe.src + location.hash;
    };
</script>
复制代码
```

3）c.html：([www.domain1.com/c.html](https://link.juejin.cn?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Fwww.domain1.com%2Fc.html))

```javascript
<script>
    // 监听b.html传来的hash值
    window.onhashchange = function () {
        // 再通过操作同域a.html的js回调，将结果传回
        window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
    };
</script>
复制代码
```

### window.name + iframe跨域

#### 简介

浏览器窗口有`window.name`属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。这种方法的优点是，`window.name`容量很大（2MB），可以放置非常长的字符串；缺点是必须监听子窗口`window.name`属性的变化，影响网页性能。

父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入`window.name`属性。

> ```javascript
> window.name = data;
> ```

接着，子窗口跳回一个与主窗口同域的网址。

> ```javascript
> location = 'http://parent.url.com/xxx.html';
> ```

然后，主窗口就可以读取子窗口的`window.name`了。

> ```javascript
> var data = document.getElementById('myFrame').contentWindow.name;
> ```



#### 示例

1）a.html：(domain1.com/a.html)

```javascript
var proxy = function(url, callback) {
    var state = 0;
    var iframe = document.createElement('iframe');
    // 先加载跨域页面
    iframe.src = url;
    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
    iframe.onload = function() {
        if (state === 1) {
            // 这是第2次onload(同域proxy页)成功后，读取同域window.name中数据
            callback(iframe.contentWindow.name);
            destoryFrame();
        } else if (state === 0) {
            // 这是第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.contentWindow.location = 'http://www.domain1.com/proxy.html';
            state = 1;
        }
    };
    document.body.appendChild(iframe);
    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）
    function destoryFrame() {
        iframe.contentWindow.document.write('');
        iframe.contentWindow.close();
        document.body.removeChild(iframe);
    }
};
// 请求跨域b页面数据
proxy('http://www.domain2.com/b.html', function(data){
    alert(data);
});
```

2）proxy.html：(domain1.com/proxy.html)

中间代理页，与a.html同域，内容为空即可。

 3）b.html：(domain2.com/b.html)

```javascript
<script>    
    window.name = 'This is domain2 data!';
</script>
```

通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。





## 正向代理和反向代理的区别

- **正向代理：**

客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。

- **反向代理：**

服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。 一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。

两者区别如图示： ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97e92248f2654185808f80b65f3ca0f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp) 

正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。







# chrome插件

##### Chrome 插件的大概架构

Chrome 插件中可以访问网页的 DOM 的部分叫做 Content Script，随页面启动而生效，可以写一些操作 DOM 的逻辑。还有一部分是后台运行的，叫做 Background，浏览器启动就生效了，生命周期比较长，可以做一些常驻的逻辑。

如果是扩展 DevTools 的 Chrome 插件，那还有一部分 DevTools Page，是在 DevTools 里显示的页面：

![image-20230918154253381](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-18-15-42-image-20230918154253381.png)

Content Script 部分可以操作 DOM，可以监听 DOM Event。

Backgroud 部分可以访问 extension api，可以和 Content Script 还有 DevTools Page 通信。

DevTools Page 部分可以访问 devtools api，可以向当前 window 注入 JS 执行。



