



# 学习数据结构和算法的框架思维

## 数据结构

- **数据结构的存储方式只有两种：数组（顺序存储）和链表（链式存储）**。其它所有数据结构都是利用这个实现的。

- 数据结构的基本操作---增删查改。**数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改**。

- 数据结构的增删改查无非两种方式：线性的和非线性的。线性就是 for/while 迭代为代表，非线性就是递归为代表。

链表遍历框架，兼具迭代和递归结构：

```javascript
/* 基本的单链表节点 */
class ListNode {
    constructor(val) {
        this.val = val;
        this.next = null;
    }
}

function traverse(head) {
    for (var p = head; p != null; p = p.next) {
        // 迭代访问 p.val
    }
}

function traverse(head) {
    // 递归访问 head.val
    traverse(head.next);
}
```





二叉树遍历框架，典型的非线性递归遍历结构：

```javascript
/* 基本的二叉树节点 */
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }
}

var traverse = function(root) {
  if (root === null) return;
  traverse(root.left);
  traverse(root.right);
};
```



二叉树框架可以扩展为 N 叉树的遍历框架：

```javascript
/* 基本的 N 叉树节点 */
var TreeNode = function(val, children) {
  this.val = val;
  this.children = children;
};

// 遍历 N 叉树
var traverse = function(root) {
  for (var i = 0; i < root.children.length; i++) {
    traverse(root.children[i]);
  }
};
```

`N` 叉树的遍历又可以扩展为图的遍历，因为图就是好几 `N` 叉棵树的结合体。你说图是可能出现环的？这个很好办，用个布尔数组 `visited` 做标记就行了，这里就不写代码了。





## 算法

数据结构是工具，算法是通过合适的工具解决特定问题的方法。

**只要涉及递归的问题，都是树的问题**。











# 算法时空复杂度

非递归算法的空间复杂度看它有没有申请数组之类的存储空间就行了，时间复杂度看具体算法执行



**递归算法的时间复杂度** **=** **递归树的节点个数** **x** **每个节点的时间复杂度**

**递归算法的空间复杂度** **=** **递归树的高度** **+** **算法申请的存储空间**



# JS

## 求数组的和

```javascript
const total = nums.reduce((a, b) => a + b, 0);
```









# 其它算法

## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

```javascript
/*本质就是计算有多少对相同的字符，（如果除了成对的字符外还有剩余的字符，可以再加1个做为奇数回文串的中心节点，但是仅仅只能加1个，因为只有1个中心节点）*/
var longestPalindrome = function(s) {
    let len = s.length,set = new Set(),count = 0
    for(let i=0;i<len;i++){
        if(set.has(s[i])){
            count+=2
            set.delete(s[i])
        }else{
            set.add(s[i])
        }
    }
    return count+= set.size?1:0
};
```



## 缓存算法

### LRU(Least Recently Used)

[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

#### 哈希双向链表

LRU 缓存算法的核心数据结构是双向链表和哈希表的结合体

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-10-20-01-image-20240110200155477.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-10-20-01-image-20240110200155477.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-10-20-01-image-20240110200155477.png" alt="image-20240110200155477" style="zoom:33%;" loading="lazy"/>
  </picture>

**注意我们实现的双链表 API 只能从尾部插入，也就是说靠尾部的数据是最近使用的，靠头部的数据是最久未使用的**。

「为什么必须要用双向链表」，因为我们需要删除操作。删除一个节点不光要得到该节点本身的指针，也需要操作其前驱节点的指针，而双向链表才能支持直接查找前驱，保证操作的时间复杂度 O(1)。

「为什么要在链表中同时存储 key 和 val，而不是只存储 val」，因为当缓存容量已满，我们不仅仅要删除最后一个 `Node` 节点，还要把 `map` 中映射到该节点的 `key` 同时删除。如果 `Node` 结构中只存储 `val`，那么我们就无法得知 `key` 是什么，就无法删除 `map` 中的键，造成错误。



因为要O(1)的快速查找，所以用哈希表

因为要快速增删，如果单向链表，删除节点需要访问前驱节点，只能花 O(n)O(n) 从前遍历查找。不行。
					如果双向链表，结点有前驱指针，删除/移动节点都是纯纯的指针变动，都是 O(1)。所以选它。

哈希表的key存传进来的key，value存对应的链表节点

链表存传进来的key和value

> 最近使用过的放到==最前==



```js
function ListNode(key,value){
    this.key=key
    this.value=value
    this.pre = null
    this.next=null
}

/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.cache = new Map()
    this.size = capacity
    this.dummyHead = new ListNode() //虚拟头节点
    this.dummyTail = new ListNode() //虚拟尾节点
    this.dummyHead.next = this.dummyTail //修改头节点的下一个指向
    this.dummyTail.pre = this.dummyHead //修改头节点的下一个指向
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if(!this.cache.has(key)) return -1
    const node = this.cache.get(key) //值是存在链表上的
    this.moveToHead(node) //使用过就调到链表的最前端
    return node.value //返回这个key的值
};

function removeListNode(node){
    /**删掉链表上的一个节点就是把它的前面那个节点和后面那个节点处理好 */
    const preTemp = node.pre
    const nextTemp = node.next
    preTemp.next = nextTemp
    nextTemp.pre = preTemp
}

LRUCache.prototype.moveToHead=function(node){
    removeListNode(node)//先把自己从链表中移除
    this.addToHead(node)//再将node添加到头部
}

LRUCache.prototype.addToHead = function(node){
    /**在链表上的增加一个节点先把它的前面那个节点和后面那个节点处理好再处理自己 */
    const headNextTemp = this.dummyHead.next
    headNextTemp.pre=node
    this.dummyHead.next = node
    node.pre = this.dummyHead
    node.next = headNextTemp
}


/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if(this.cache.has(key)) { //已经存在这个key
        const node = this.cache.get(key)
        node.value = value
        this.moveToHead(node) //放到最前去
    }else{ //新节点
        const node = new ListNode(key,value)
        /*对哈希双向链表进行增删操作时，要同时操作链表和哈希表*/ 
        this.addToHead(node) //先操作链表
        this.cache.set(key,node) //再操作哈希表
        if(this.cache.size>this.size){ 
            const tailNode = this.ListNodePop()
            this.cache.delete(tailNode.key)
        }
    }
};

LRUCache.prototype.ListNodePop = function(){
    const tail = this.dummyTail.pre
    removeListNode(tail)
    return tail
}
```





#### 只用map

> 最近使用过的放到==最后==（即直接set进去）

```javascript
/**
 * @param {number} capacity
 */
var LRUCache = function(capacity) {
    this.cache = new Map()
    this.size = capacity
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if(!this.cache.has(key)) return -1
    const value = this.cache.get(key)
    this.cache.delete(key)
    this.cache.set(key,value) // 删除后，再 set ，相当于更新到 map 最后一位
    return value
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    if(this.cache.has(key)) {
        this.cache.delete(key)
    }
    this.cache.set(key,value)
    if(this.cache.size>this.size){
        const firstKey = this.cache.keys().next().value
        this.cache.delete(firstKey)
    }
    
};
```







### LFU(Least Frequently Used)

https://leetcode.cn/problems/lfu-cache/description/

 LFU 算法是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。



## 笛卡尔积

笛卡尔积（Cartesian product）是集合论中的一个概念，它用来表示两个或多个集合的所有可能的有序对组合。

数学上，笛卡尔积 A × B 可以用以下方式表示：

A × B = `{(a, b) | a ∈ A, b ∈ B}`

举例来说，如果集合 A 包含`{1, 2}`，集合 B 包含`{a, b}`，那么它们的笛卡尔积 A × B 就是：

A × B = `{(1, a), (1, b), (2, a), (2, b)}`

这个结果集合包含了 A 和 B 的所有可能的有序对组合。笛卡尔积在数学、计算机科学和其他领域中都有广泛的应用，特别是在关系数据库中，用于描述表之间的关联关系。

### [401. 二进制手表](https://leetcode.cn/problems/binary-watch/)

由题意可知，小时由 44 个比特表示，分钟由 66 个比特表示，比特位值为 00 表示灯灭，为 11 表示灯亮。

我们可以枚举小时的所有可能值 [0,11][0,11]，以及分钟的所有可能值 [0,59][0,59]，并计算二者的二进制中 11 的个数之和，若为 \textit{turnedOn}turnedOn，则将其加入到答案中。

```js
var readBinaryWatch = function(turnedOn) {
    const ans = [];
    for (let h = 0; h < 12; ++h) {
        for (let m = 0; m < 60; ++m) {
            if (h.toString(2).split('0').join('').length + m.toString(2).split('0').join('').length === turnedOn) {
                ans.push(h + ":" + (m < 10 ? "0" : "") + m);
            }
        }
    }
    return ans;
};

```

### [816. 模糊坐标](https://leetcode.cn/problems/ambiguous-coordinates/)

```js
var ambiguousCoordinates = function(s) {
    s=s.slice(1,-1)
    const noAllowReg = /(^0\d)|(\d*\.\d*0$)/
    const res = [],len = s.length
    for(let i=1;i<len;i++){
        const x = s.substring(0,i) //将字符串分成左右两部分
        const y = s.substring(i)
        
        for(let f=1;f<=x.length;f++){ //遍历x的所有可能
            const resX = getComma(x,f)
            if(noAllowReg.test(resX)) continue

            for(let yy = 1;yy<=y.length;yy++){ //遍历y的所有可能
                const resY = getComma(y,yy)
                if(noAllowReg.test(resY)) continue

                res.push(`(${resX}, ${resY})`)
            }
        }
    }

    function getComma(str,segmantation){ //返回小数点形式
        const first = str.substring(0,segmantation)
        const second = str.substring(segmantation)
        if(second.length==0){
            return first
        }else{
            return `${first}.${second}`
        }
    }
    return res
};
```





## 状态机

**有限状态机**（英语：finite-state machine，[缩写](https://zh.wikipedia.org/wiki/縮寫)：**FSM**）又称**有限状态自动机**（英语：finite-state automaton，[缩写](https://zh.wikipedia.org/wiki/縮寫)：**FSA**），简称**状态机**，是表示有限个[状态](https://zh.wikipedia.org/wiki/状态)以及在这些状态之间的转移和动作等行为的[数学计算模型](https://zh.wikipedia.org/wiki/计算模型_(数学))。

简单说，它有三个特征：

>   * 状态总数（state）是有限的。
>   * 任一时刻，只处在一种状态之中。
>   * 某种条件下，会从一种状态转变（transition）到另一种状态。

前端常用：https://xstate.js.org/docs/zh/





# 位运算

考察的就是位运算：与、非、或、异或、左移、右移

##### [191. 位1的个数](https://leetcode.cn/problems/number-of-1-bits/)

```js
var hammingWeight = function(n) {
    let ret = 0;
    while (n) { //直到 nnn 变为 000 
        n &= n - 1; // n 的最低位的 1 会被翻转
        ret++;
    }
    return ret;
};
```







#### 异或

找缺失数、找出现一次数都是异或的经典应用。

##### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

异或运算规律:

任何数和自己做异或运算，结果为 0，即 `a⊕a=0。`
任何数和 0 做异或运算，结果还是自己，即 `a⊕0=a`。
异或运算中，满足交换律和结合律，也就是 `a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b`

```js
var singleNumber = function(nums) {
    let res = 0
    for(const num of nums){
        res ^= num
    }
    return res
};
```





##### [268. 丢失的数字](https://leetcode.cn/problems/missing-number/)

异或运算规律:

任何数和自己做异或运算，结果为 0，即 `a⊕a=0。`
任何数和 0 做异或运算，结果还是自己，即 `a⊕0=a`。
异或运算中，满足交换律和结合律，也就是 `a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b`

```typescript
var missingNumber = function(nums) {
    let res = 0
    const len = nums.length
    for(const num of nums){
        res ^=num
    }
    for(let i = 0;i<=len;i++){
        res^=i
    }
    return res
};
```







# 数组

## 实现数组循环

取余就能实现数组循环



## 数组的遍历优化

无非是双指针。

- 对撞指针能优化单次遍历的速度

- 快慢指针
  - 将O(n)的空间复杂度优化到O(1))
  - 跳跃式递进（看冒泡排序的优化一）省略一些循环）
  - 将两次循环优化成只需一次



## 二维数组的遍历方向

正向遍历：

```java
int[][] dp = new int[m][n];
for (int i = 0; i < m; i++)
    for (int j = 0; j < n; j++)
        // 计算 dp[i][j]
```

反向遍历：

```java
for (int i = m - 1; i >= 0; i--)
    for (int j = n - 1; j >= 0; j--)
        // 计算 dp[i][j]
```

斜向遍历：

```java
// 斜着遍历数组
for (int l = 2; l <= n; l++) {
    for (int i = 0; i <= n - l; i++) {
        int j = l + i - 1;
        // 计算 dp[i][j]
    }
```



## 前缀和

### 应用场景

区间和，当然区间和也可能用滑动窗口

### 作用

前缀和的作用：preSum是前缀和数组，如果我想求nums索引区间 `[1, 4]`(左闭右闭) 内的所有元素之和，就可以通过 `preSum[5] - preSum[1]` (左闭右闭) 得出。（理论就是用nums里 [0-5]的和 减去[0-1]的和 那不就等于[2-5]的和 嘛）

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-12-12-01-image-20230912120135717.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-12-12-01-image-20230912120135717.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-12-12-01-image-20230912120135717.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-12-12-01-image-20230912120135717.png" loading="lazy"/>
  </picture>



### 建立前缀和

```js
    const len = nums.length
    const preNum = new Array(len+1)
    preNum[0]=0
    for(let i = 0;i<len;i++){
        preNum[i+1] = nums[i]+preNum[i]
    }
```





### 例题

#### [1352. 最后 K 个数的乘积](https://leetcode.cn/problems/product-of-the-last-k-numbers/)

```js
var ProductOfNumbers = function() {
    this.multiplicationArr = [1]
};

/** 
 * @param {number} num
 * @return {void}
 */
ProductOfNumbers.prototype.add = function(num) {
    if(num===0){
        this.multiplicationArr=[1]
        return
    }
    const len = this.multiplicationArr.length
    this.multiplicationArr.push(this.multiplicationArr[len-1]*num)
};

/** 
 * @param {number} k
 * @return {number}
 */
ProductOfNumbers.prototype.getProduct = function(k) {
    const len = this.multiplicationArr.length
    if(len<=k){ // 前缀乘积数组比 原数组多一个元素，所以这里等于也不行。
        return 0
    }
    return this.multiplicationArr[len-1]/this.multiplicationArr[len-1-k]
};
```





#### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

```js
/*
*记数组的全部元素之和为 total，当遍历到第 i 个元素时，设其左侧元素之和为sum,则其右侧元素之和为total-nums[i]-sum。左右侧元素相等即sum=toal-nums[i]-sum,即2*sum+nums[i]=total
*/
var pivotIndex = function (nums) {
  const total = nums.reduce((pre,cur)=>pre+cur,0)
  let leftSum = 0
  for(let i=0;i<nums.length;i++){
      if(leftSum*2+nums[i]===total){
          return i
      }
      leftSum+=nums[i]
  }
  return -1
};
```







#### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

```js
var productExceptSelf = function(nums) {
    const len = nums.length
    const preArr=[1],sufArr = [1]
    for(let i = 0,j=len-1;i<len-1,j>0;i++,j--){
        const preLen = preArr.length
        preArr.push(preArr[preLen-1]*nums[i])
        sufArr.unshift(sufArr[0]*nums[j])
    }
    const res = []
    for(let i=0;i<len;i++){
        res[i] = preArr[i]*sufArr[i]
    }
    return res
};
```











#### [930.和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/description/)

假设原数组的前缀和数组为 sum，且子数组 (i,j]的区间和为 goal，那么 sum[j]−sum[i]=goal。因此我们可以枚举 j ，每次查询满足该等式的 i 的数量。(相当于每轮循环都是固定尾边界去找合适的情况)

```js
// 法一 前缀和 + 哈希表
var numSubarraysWithSum = function(nums, goal) {
    const len = nums.length
    let curSum = 0
    let res = 0
    const sumMap = {}
    for(let i = 0;i<len;i++){
        sumMap[curSum]?sumMap[curSum]++:sumMap[curSum]=1
        curSum+=nums[i]
        res+=(sumMap[curSum-goal]||0) // 这方法也适用于不是二元数组，因为这里是精准判断(curSum - goal)
    }
    return res
};

// 法二：结合了 前缀和 的思想 的 滑动弹窗 (可不看)
var numSubarraysWithSum = function(nums, goal) {
    let slow1=0,slow2=0,fast=0
    let resSum=0,s1Sum=0,s2Sum=0
    while(fast<nums.length){
        s1Sum+=nums[fast]
        while(slow1<=fast&&s1Sum>goal){
            s1Sum-=nums[slow1]
            slow1++
        }
// 这种方法只满足二元数组，因为只有二元数组才可以保证代码执行到这个位置时 s1Sum === goal
        s2Sum+=nums[fast]
        while(slow2<=fast&&s2Sum>=goal){
            s2Sum-=nums[slow2]
            slow2++
        }
        resSum+=slow2-slow1
        fast++
    }
    return resSum
};
```





#### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)

```js
// preSum为前缀和
// 题目转化为满足 (preSum[j]−preSum[i]) mod K==0  即 preSum[j] mod K == preSum[i] mod K
// 若preSum[i] 为负数：数学上-1 % K 应该为 3，但js中 -1 % K = -1，所以负数要额外处理
var subarraysDivByK = function(nums, k) {
    let preSumModMap = {0:1}
    let curSumMod = 0
    let res = 0
    for(let i=0;i<nums.length;i++){
        curSumMod=(curSumMod+nums[i])%k
        if (curSumMod < 0) {
            curSumMod += k;
        }
        if(preSumModMap[curSumMod]){
            res+=preSumModMap[curSumMod]
            preSumModMap[curSumMod]++
        }else{
            preSumModMap[curSumMod]=1
        }
    }
    return res
};
```





#### [523. 连续的子数组和](https://leetcode.cn/problems/continuous-subarray-sum/)

```js
/**
只要满足 sum[j] 和 sum[i] 对 k 取余相同，就能满足sum[j]-sum[i]的差值能整除k
也就是说，我们只需要枚举右端点 j，然后在枚举右端点 j 的时候检查之前是否出现过左端点 i，使得 sum[j] 和 sum[i] 对 k 取余相同。
 */
var checkSubarraySum = function(nums, k) {
    let sumIndexMap = new Map(),curSum=0
    sumIndexMap.set(0,-1)
    for(let i=0;i<nums.length;i++){
        curSum+=nums[i]
        const mod = curSum%k
        if(sumIndexMap.has(mod)){
            if(i-sumIndexMap.get(mod)>1){
                return true
            }
        }else{ // 只记录第一次该值出现的坐标，所以这里如果之前就有了就不再更新它的index值了。
            sumIndexMap.set(mod,i)
        }
    }
    return false
};
```







#### [525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

```js
 // 把0视为-1，变成求区间和为0的最长连续子数组
var findMaxLength = function(nums) {
    let max = 0,curSum = 0,sumIndexMap = new Map()
    sumIndexMap.set(0,-1)
    for(let i=0;i<nums.length;i++){
        if(nums[i]===0){
            curSum+=-1
        }else{
            curSum+=1
        }
        if(sumIndexMap.has(curSum)){
            max = Math.max(max,i-sumIndexMap.get(curSum))
        }else{
            sumIndexMap.set(curSum,i) // 只记录第一次该值出现的坐标，所以这里如果之前就有了就不再更新它的index值了。
        }
    }
    return max
};
```







## 两个数组

常用两个指针指向这两个数组

### [415. 字符串相加](https://leetcode.cn/problems/add-strings/)

```javascript
var addStrings = function(num1, num2) {
    let p1 = num1.length-1,p2 = num2.length-1,result = [],carry=0
    while(p1>=0||p2>=0||carry!==0){
        const n1 = p1<0?0:num1[p1--]*1
        const n2 = p2<0?0:num2[p2--]*1
        const sum= n1 + n2+carry
        result.unshift(sum%10)
        carry = Math.floor(sum/10)
    }
    return result.join('')
};
```



### [844. 比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

```js
var backspaceCompare = function (s, t) {
  const sLen = s.length,
    tLen = t.length;
  let sSkip = 0,
    sFast = sLen - 1,
    tSkip = 0,
    tFast = tLen - 1;
  while (sFast >= 0 || tFast >= 0) {
    while (sFast>=0) {
      if (s[sFast] === '#') {
        sSkip++;
        sFast--;
      } else if(sSkip) {
        sSkip--;
        sFast--;
      }else{
          break
      }
    }
    while (tFast>=0) {
      if (t[tFast] === '#') {
        tSkip++;
        tFast--;
      } else if(tSkip) {
        tSkip--;
        tFast--;
      }else{
          break
      }
    }
    if (s[sFast] !== t[tFast]) return false;
    sFast--;
    tFast--;
  }
  return true;
};
```







## 快慢指针

### 应用场景

优化数组的遍历：

- 将O(n)的空间复杂度优化到O(1))
- 跳跃式递进（看冒泡排序的优化一）省略一些循环）
- 将两次循环优化成只需一次



还可以用于处理数组填充类问题（但是这份资料中未遇到填充类问题）：**数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在*<u>从后向前</u>*进行操作**，这样的好处是：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前先后填充元素要来的 每次添加元素都要将添加元素之后的所有元素向后移动。

### 模板

1. 先保证前面是好的，不考虑大小排序（所以快慢指针适合无序题）。
2. slow负责保证是好的，fast负责遍历。

```javascript
while（fast<length){
	if(){
    slow++
  }
  fast++
}
```



### [27.移除元素](https://leetcode-cn.com/problems/remove-element/)

```javascript
//快慢指针法： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
var removeElement = function(nums, val) {
    let slow=0,fast=-1
    while(++fast<nums.length){
        if(nums[fast]!==val) {
            nums[slow]=nums[fast]//不是val就可以存下来
            slow++  
        }
    }
    return slow
};
```



### [905. 按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArrayByParity = function(nums) {
    let slow=fast=0
    while(fast<nums.length){
        if(nums[fast]%2===0){//偶数就换到前面去
            [nums[slow],nums[fast]]=[nums[fast],nums[slow]]
            slow++
        }
        fast++
    }
    return nums
};
```

### [922. 按奇偶排序数组 II](https://leetcode-cn.com/problems/sort-array-by-parity-ii/)

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArrayByParityII = function(nums) {
    let slow=fast=0
    while(fast<nums.length){
        if(slow%2===nums[fast]%2){
            [nums[slow],nums[fast]]=[nums[fast],nums[slow]]
            slow++
        }else{
            fast++
        }
    }
    return nums
};
```



### [283.移动零](https://leetcode-cn.com/problems/move-zeroes/)

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    let [slow ,fast] =[0,0]
    while(fast<nums.length){
        if(nums[fast]!==0) {
            [nums[slow],nums[fast]]=[nums[fast],nums[slow]]
            slow++
        }
        fast++
    }
};
```













### 典藏题目

#### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```js
var removeDuplicates = function(nums) {
    const len = nums.length
    if(len<2) return len
    let slow = 1,fast=1
    while(fast<len){
        if(nums[fast-1]!==nums[fast]){
            nums[slow]=nums[fast]
            slow++
        }
            fast++
    }
    return slow
};
```









## 滑动窗口

### 应用场景

滑动窗口主要用来处理<mark>连续且能找到窗口收缩的时机的问题</mark>。比如题目求解“<font color="red">连续</font>子串 xxxx”，“连续子数组 xxxx”。左右指针就形成这个窗口，如果左右指针的下标关系不能直接反映我们要的窗口，就声明个窗口变量。

从类型上说主要有：

- 固定窗口大小：左边界和右边界同时移动。

- 可变窗口：窗口大小不固定，求解最大/最小的满足条件的窗口 。不断增加窗口右边界，找到可行解之后收缩窗口。

  <font color="red">无脑扩张，关键是找到收缩的时机。</font>





### 可变窗口模板

1. 先无脑移动右边界扩大窗口

2. 再移动左边界缩小窗口---先思考满足条件的情况，再思考窗口需要收缩的情况。

```javascript
/* 滑动窗口算法框架 --- 核心是两重循环 */
	let slow = 0, fast = -1 // 建议这样初始化fast，好理解每个fast都会被遍历到
		/*有两个循环*/
    while(++fast<str.length){//扩充窗口

        if/while(window needs shrink){// 收缩窗口
						//... 收缩窗口前处理即将失去的这个值
            slow++//缩小窗口
        }
      //... 扩充窗口要处理加进来的这个值
    }
```





### 固定窗口(可以不看)

对于固定窗口，我们只需要固定初始化左右指针 l 和 r，分别表示的窗口的左右顶点，并且保证：

1. l初始化为 0
2. 初始化 r，使得 r - l + 1 等于窗口大小
3. 同时移动 l 和 r
4. 判断窗口内的连续元素是否满足题目限定的条件
   - 4.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解
   - 4.2 如果不满足，则继续。



### 可变窗口(可以不看)

对于可变窗口，我们同样固定初始化左右指针 l 和 r，分别表示的窗口的左右顶点。后面有所不同，我们需要保证：

1. l 和 r 都初始化为 0
2. r 指针移动一步
3. 判断窗口内的连续元素是否满足题目限定的条件
   - 3.1 如果满足，再判断是否需要更新最优解，如果需要则更新最优解。并尝试通过移动 l 指针缩小窗口大小。循环执行 3.1
   - 3.2 如果不满足，则继续。

不断增加窗口右边界，寻找一个可行解，在找到可行解的情况下增加窗口左边界，优化可行解，找到最优解。







### 可变窗口例题

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

```js
/**
 * @param {number} target
 * @return {number[][]}
 */
var findContinuousSequence = function(target) {
    let slow=1,fast = 0,curSum=0
    const res = []
    while(++fast<target){
        curSum+=fast
        while(curSum>target){
            curSum-=slow
            slow++
        }
        if(curSum===target){
            const subRes=[]
            for(let i=slow;i<=fast;i++){
                subRes.push(i)
            }
            res.push(subRes)
            curSum-=slow
            slow++
        }
    }
    return res
};
```





#### [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

```javascript
/**
 * @param {string} s1
 * @param {string} s2
 * @return {boolean}
 */
var checkInclusion = function(s1, s2) {
    let need={},//需要的字符及其频数
        window={},//此为满足条件的窗口，里面包含现在窗口中有的need里的字符及其频数
        valid=0,//窗口中能完全包含的字符数，（如need中有‘a‘有两个，window中也’a'有两个，那么就算window中能完全包含a，则valid++）
        slow=0,fast=-1
    for (let i of s1) {
        need[i] = (need[i] || 0) + 1;//统计t中字符及其频数
    }

    while(fast<s2.length){//此循环快指针逐渐右移，扩大窗口
        fast++// 增大窗口,char移入窗口
        if(valid===Object.keys(need).length) return true

        let char=s2[fast] //char是即将移入窗口的字符
        if(need[char]){
            window[char]=(window[char]||0)+1
            if(need[char]===window[char]){
                valid++
            }
        }

        while(fast-slow+1>s1.length){//此循环慢指针逐渐右移，缩小窗口
            let char=s2[slow] //char是即将移出窗口的字符
            slow++//缩小窗口，char移出窗口
            if(need[char]){
                if(need[char]===window[char]) {valid--}
                window[char]--
            }
        }
    }
    return false
};
```



#### [438. 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

```javascript
/**
 * @param {string} s
 * @param {string} p
 * @return {number[]}
 */
var findAnagrams = function(s, p) {
    let slow = 0,
    fast = -1,
    lackPMap = {},
    validPNum = 0
    res = []
    for(const str of p){
        if(lackPMap[str]){
            lackPMap[str]++
        }else{
            lackPMap[str]=1
        }
    }
    const pKeysNum = Object.keys(lackPMap).length
    while(fast<s.length){
        fast++
        while(validPNum===pKeysNum){
            if(fast-slow===p.length){
                res.push(slow)
            }
            if(lackPMap[s[slow]]!==undefined){
                lackPMap[s[slow]]++
                if(lackPMap[s[slow]]>0){
                    validPNum--
                }
            }
                slow++
        }
        if(lackPMap[s[fast]]!==undefined){
                lackPMap[s[fast]]--
                if(lackPMap[s[fast]]===0){
                    validPNum++
                }
        }
    }
    return res
};
```



#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

```javascript
var minWindow = function (s, t) {
  let slow = 0;
  let fast = 0;
  let resSubStr = null;
  let validTstrNum = 0; 
  const lackTMap = {}; // 记录t中的每个字符分别还缺几个
  for (const tstr of t) {
    if (lackTMap[tstr]) {
      lackTMap[tstr]++;
    } else {
      lackTMap[tstr] = 1;
    }
  }
  const lackTMapKeysLen = Object.keys(lackTMap).length;
  while (fast < s.length) {
    const curStr = s[fast];
    if (lackTMap[curStr] != undefined) {
      lackTMap[curStr]--;
      if (lackTMap[curStr] === 0) {
        validTstrNum++;
      }
    }
    while (validTstrNum === lackTMapKeysLen) {
      if (resSubStr === null || resSubStr.length > fast - slow + 1) {
        resSubStr = s.substring(slow, fast + 1);
      }
      const needShiftStr = s[slow];
      slow++;
      if (lackTMap[needShiftStr] != undefined) {
        lackTMap[needShiftStr]++;
        if (lackTMap[needShiftStr] > 0) {
          validTstrNum--;
        }
      }
    }
    fast++;
  }
  return resSubStr === null ? '' : resSubStr;
};
```



#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

```javascript
var lengthOfLongestSubstring = function(s) {
    let slow = 0,fast = 0,max = Number.MIN_SAFE_INTEGER
    while(fast<s.length){
        while(s.substring(slow,fast).includes(s[fast])){
            slow++
        }
        max= Math.max(max,fast-slow+1)
        fast++
    }
    return max===Number.MIN_SAFE_INTEGER?0:max
};
```

#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```javascript
var minSubArrayLen = function(target, nums) {
    let res = Number.MAX_SAFE_INTEGER,acc = 0
    let slow = 0
    for(let fast = 0;fast<nums.length;fast++){
        acc+=nums[fast]
        while(acc>=target){
            res = Math.min(res,fast-slow+1)
            acc-=nums[slow]
            slow++
        }
    }
    return res==Number.MAX_SAFE_INTEGER?0:res
};
```



#### [930. 和相同的二元子数组](https://leetcode.cn/problems/binary-subarrays-with-sum/)(可以不看)

结合了前缀和思想的滑动弹窗。相当于每一轮循环右边界都是固定的，找此时以fast为右边界时的左边界可在的位置。从左边界到右边界都是满足条件的子数组。

```js
//滑窗，左边两个指针l1,l2 右边界为r
//l1~r之间的和为s1，l2~r之间的和为s2
//对于每一个右边界r：
//当l1~r之间的和大于goal时，令l1右移，直到区间和s1等于goal为止
//同理求取l2与l1之间的下标差值，这里停止l2右移的条件变成了区间和s2小于goal，即第一个s2不再大于等于goal的区间。
//意味着在以r为右边界，以l1为左边界的大区间内，以[l1~l2)之间任意下标为左边界，以r为右边界的小区间区间和都为goal
//符合区间之和等于goal的对应左下标有l2-l1个。
var numSubarraysWithSum = function(nums, goal) {
    let slow1=0,slow2=0,fast=0
    let resSum=0,s1Sum=0,s2Sum=0
    while(fast<nums.length){
        s1Sum+=nums[fast]
        while(slow1<=fast&&s1Sum>goal){
            s1Sum-=nums[slow1]
            slow1++
        }
// 这种方法只满足二元数组，因为只有二元数组才可以保证代码执行到这个位置时 s1Sum === goal
        s2Sum+=nums[fast]
        while(slow2<=fast&&s2Sum>=goal){
            s2Sum-=nums[slow2]
            slow2++
        }
        resSum+=slow2-slow1
        fast++
    }
    return resSum
};
```



#### 典藏

##### [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)

```js
 /*
 * 逆向思考:我们剩下的数组一定是原数组的中间部分。由于我们的目标是最小操作数，因此我们只要找和为定值的最长子序列的长度 即可。
 */
var minOperations = function(nums, x) {
  const arrSum = nums.reduce((pre,cur)=>pre+cur,0)
  const target = arrSum-x //找到和为target的最长子序列，然后 答案 = len - 最长子序列的长度 
  let slow =0,fast = 0;
  let curSum = 0;
  let max =  -1
  while(fast<nums.length){
      curSum+=nums[fast]
    while(curSum>target){
      curSum-=nums[slow]
      slow++
    }
    if(curSum===target){
      max = Math.max(max,fast-slow+1)
    }
    fast++
  }
  return max===-1?max:nums.length-max
};
```









##### [1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)

```js
var longestOnes = function (nums, k) {
  let slow = 0,
    fast = -1;
  let curZeroNums = 0;
  let max = 0;
  while (++fast < nums.length) {
    if (nums[fast] === 0) {
      curZeroNums++;
      while (curZeroNums > k) {
        if (nums[slow] === 0) {
          curZeroNums--;
        }
        slow++;
      }
    }
    max = Math.max(max, fast - slow + 1);
  }
  return max;
};
```







##### [978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/)

```ts
function maxTurbulenceSize(arr: number[]): number {
  let slow = 0,
    fast = 0,
    max = 1;
  let lastCampare: 'left' | 'right' | 'equal' | undefined = void 0;
  function campare(pre: number, cur: number): 'left' | 'right' | 'equal' {
    if (pre > cur) {
      return 'left';
    } else if (pre < cur) {
      return 'right';
    } else {
      return 'equal';
    }
  }
  while (++fast < arr.length) {
    const curCampare = campare(arr[fast - 1], arr[fast]);
    if (curCampare === 'equal') {
      slow = fast;
    } else if (curCampare === lastCampare) {
      slow = fast - 1;
    }
    lastCampare = curCampare;
    max = Math.max(max, fast - slow + 1);
  }
  return max;
}
```





#### 加强版



##### [904. 水果成篮](https://leetcode-cn.com/problems/fruit-into-baskets/)

```javascript
/**
 * @param {number[]} fruits
 * @return {number}
 */
var totalFruit = function(fruits) {
    let slow=fast=0,
        maxLength=0,
        typeArr=[],//存放现在在滑动窗口里的两种种类
        n=0
    while(fast<fruits.length){
        if(!typeArr.includes(fruits[fast])){//新种类要来了
            if(typeArr.length<2){//一开始的时候typeArr还没有值，所以直接push
                typeArr.push(fruits[fast])
            }else{//更新typeArr里存放的种类
                slow=n//移动左边界到fast最近一个不同种类的位置
                typeArr[0]=fruits[fast-1]//新种类前面那一个种类
                typeArr[1]=fruits[fast]//新种类
            }
        }
        if(fruits[n]!==fruits[fast]){
            n=fast//这样就可以让n始终记录着前面离fast最近一个不同种类的位置
        }
        maxLength=Math.max(maxLength,fast-slow+1)//fast-slow+1是计算现在滑动窗口的大小
        fast++
    }
    return maxLength
};
```







##### [1234. 替换子串得到平衡字符串](https://leetcode.cn/problems/replace-the-substring-for-balanced-string/)

```js
//不断增加窗口右边界，寻找一个可行解，在找到可行解的情况下增加窗口左边界，优化可行解，找到最优解。
var balancedString = function(s) {
    const n = s.length;
    const avg = n / 4;
    const map = { Q: 0, W: 0, E: 0, R: 0};
    for (const c of s) {
        map[c]++;
    }
    if (map.Q === avg && map.W === avg && map.E === avg && map.R === avg) {
        return 0;
    }
    let minLength = n, slow = 0, fast = 0; //fast和slow形成要换的窗口
    while (fast < n) {
        const cur = s[fast]
        map[cur]--; //因为fast表示要换掉的窗口，所以遍历到这个元素就相当于这个元素要被换掉了。
        while (slow <= fast  && map.Q <= avg && map.W <= avg && map.E <= avg && map.R <= avg) { //所有 要么达到要求要么还不够，那这种时候更换窗口内的元素就一定能满足要求（因为字符串的总数一定是4的倍数）
            minLength = Math.min(minLength, fast - slow + 1);
            const slowChar = s[slow]
            map[slowChar]++ //窗口即将离开这个字符，所以这个字符不用被替换，所以++
            slow++
        }
        fast++;
    }
    return minLength
};

```

##### [1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

```js
 /*
 *统计第 1 个奇数左边的偶数个数 leftEvenCnt。 这 leftEvenCnt 个偶数都可以作为「优美子数组」的起点，因此起点的选择有 leftEvenCnt + 1 种（因为可以一个偶数都不取，因此别忘了 +1 喔）。
统计第 k 个奇数右边的偶数个数 rightEvenCnt 。 这 rightEvenCnt 个偶数都可以作为「优美子数组」的终点，因此终点的选择有 rightEvenCnt + 1 种（因为可以一个偶数都不取，因此别忘了 +1 喔）。
因此「优美子数组」左右起点的选择组合数为 (leftEvenCnt + 1) * (rightEvenCnt + 1)。
*/
var numberOfSubarrays = function(nums, k) {
    const len = nums.length
    let slow = fast = 0 //slow指向满足要求的子数组的第一个奇数的左边的第一个偶数，fast指向满足要求的子数组的最后一个奇数
    let resNum = 0,jiNum = 0
    while(fast<len){
        if(nums[fast]%2==1){
            jiNum++
        }
        if(jiNum==k){
            let rightOuNum = 0
            fast++
            while(nums[fast]%2==0&&fast<len){
                rightOuNum++
                fast++
            } //这个循环走完出来fast指向的肯定是个奇数

            let leftOuNum = 0
            while(nums[slow]%2==0&&slow<=fast){
                slow++
                leftOuNum++
            }
            resNum+=(rightOuNum+1)*(leftOuNum+1)
            //此时slow指向第一个奇数，所以要++
            slow++ 
            jiNum-- //推出一个奇数
        }else{
            fast++
        }
    }
    return resNum
};
```









## 对撞指针

### 应用场景

反转啥啥啥



### 模板

> 多用于处理有序数组

```javascript
let left=0,right=length-1//左闭右闭

while（left<right）{
	if()
}
```

### 字符串（直接转成数组）

#### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

```javascript
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
    function reverse(arr,left,right){
        while(left<=right){
            [arr[left],arr[right]]=[arr[right],arr[left]]
            left++
            right--
        }
    }

    let arr = Array.from(s),length=arr.length//直接转成数组处理
    for(let i=0;i<length;i=i+2*k){
        reverse(arr,i,i+k-1)
    }
    return arr.join('')
};
```

#### [151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

```javascript
var reverseWords = function (s) {
  const newS = s
    .replace(/^\s+/, '')
    .replace(/\s+$/, '')
    .replace(/\s{2,}/g, ' ');
  const a = newS.split(' ');
  let left = 0,
    right = a.length - 1;
  while (left < right) {
    [a[left], a[right]] = [a[right], a[left]];
    left++;
    right--;
  }
  return a.join(' ');
};

//法二：我们将整个字符串都反转过来，那么单词的顺序指定是倒序了，只不过单词本身也倒序了，那么再把单词反转一下，单词不就正过来了（代码自己搞搞，so easy）
```



#### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

> 提升一下本题难度：**不能申请额外空间，只能在本串上操作**
>
> 上一题是使用  **整体反转+局部**  反转就可以实现，本题通过  **局部反转+整体反转** 达到左旋转的目的。
>
> 具体步骤为：
>
> 1. 反转区间为前n的子串
> 2. 反转区间为n到末尾的子串
> 3. 反转整个字符串

```javascript
/**
 * @param {string} s
 * @param {number} n
 * @return {string}
 */
var reverseLeftWords = function(s, n) {
    function reverse(arr,left,right){
        while(left<=right){
            [arr[left],arr[right]]=[arr[right],arr[left]]
            left++
            right--
        }
        return arr
    }
    let strArr = Array.from(s)
    let length=strArr.length
    reverse(strArr,0,n-1)
    reverse(strArr,n,length-1)
    return reverse(strArr,0,length-1).join('')
};
```



#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

> 反向对撞指针，不过这种情况也就回文串这类问题会遇到

```javascript
/*每个一字符都可以作为回文串的中心点，而回文串又有奇数回文串和偶数回文串，所以遍历字符串的每个字符，分别对奇数回文串和偶数回文串取最长的*/
var longestPalindrome = function(s) {
    const getPalindrome = function(left,right){
        while(left>=0&&right<len&&s[left]===s[right]){
            left--
            right++
        }
        return s.slice(++left,right)
    }

    let result = ''
    const len = s.length
    for(let i= 0;i<len;i++){
        const jiPalindrome = getPalindrome(i,i)
        if(result.length<jiPalindrome.length) result = jiPalindrome
        const ouPalindrome = getPalindrome(i,i+1)
        if(result.length<ouPalindrome.length) result=ouPalindrome
    }
    return result
};
```





### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

```javascript
var maxArea = function(height) {
    const len=height.length
    let left=0,right=len-1,area=Number.MIN_SAFE_INTEGER
    while(left<=right){
        if(height[left]<=height[right]) {
            area=Math.max(area,(right-left)*height[left])
            left++
        }
        else {
            area=Math.max(area,(right-left)*height[right])
            right--
        }
    }
    return area
};
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

对于任意一个位置 `i`，能够装的水为：

```python
water[i] = min(
           # 左边最高的柱子
           max(height[0..i]),
           # 右边最高的柱子
           max(height[i..end])
        ) - height[i]
```

**如果`l_max < r_max` ，至于这个 `r_max` 是不是left的右边最大的，不重要。重要的是 `height[left]` 能够装的水只和较低的 `l_max` 之差有关。right同理，只跟r_max有关**

```javascript
var trap = function(height) {
    const len = height.length
    let left = 0,right = len-1,lMax= 0,rMax = 0,result = 0
    while(left<right){
        lMax = Math.max(lMax,height[left])
        rMax = Math.max(rMax,height[right])
        if(lMax<rMax){
            result+=lMax-height[left]
            left++
        }else{
            result+=rMax-height[right]
            right--
        }
    }
    return result
};
```





### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
 function searchRange(nums,target){
     let leftBorder=searchBorder(nums,target,true)
     let rightBorder=searchBorder(nums,target,false)
     return [leftBorder,rightBorder]
     function searchBorder(nums,target,isLeft){
         let mid ,left=0,right=nums.length-1
         while(left<=right){
             mid=(left+right)>>>1
             if(nums[mid]===target){
                 if(isLeft){//找左边界
                    right=mid-1
                    if(nums[right]!==target) return mid
                 }
                 if(!isLeft){//找右边界
                     left=mid+1
                     if(nums[left]!==target) return mid
                 }
             }else if(nums[mid]<target){
                 left=mid+1
             }else{
                 right=mid-1
             }
         }
         return -1
     }
 }
```



### [977.有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

```javascript
/*双指针*/
var sortedSquares = function(nums) {
    let n=nums.length
    let result =new Array(n).fill(0),k=n-1,left=0,right=n-1
    while(left<=right){
        if(nums[left]*nums[left]<nums[right]*nums[right]){
            result[k--]=nums[right]*nums[right]
            right--
        }else{
            result[k--]=nums[left]*nums[left]
            left++   
        }
    }
    return result
};

/**基数排序 */
var sortedSquares = function(nums) {
    let max = 0
    for(let i=0;i<nums.length;i++){
        nums[i] = nums[i]*nums[i]
        if(max<nums[i]){
            max=nums[i]
        }
        nums[i]=nums[i]+''
    }

    max = max+''
    const base = new Array(10).fill(0).map(()=>[])
    for(let digitsOffset=1;digitsOffset<=max.length;digitsOffset++){
        for(let i=0;i<nums.length;i++){
            const digits = nums[i].length
            const nowCampareDigits = digits-digitsOffset
            if(nowCampareDigits<0){ //如果这个数没有这个位上的数则放到0的桶里
                base[0].push(nums[i])
                continue
            }
            const curWeiNum = nums[i][digits-digitsOffset]*1
            base[curWeiNum].push(nums[i])
        }
        let rawIdx = 0
        for(let i=0;i<base.length;i++){
            const curBox = base[i]
            while(curBox.length){
                nums[rawIdx++] = curBox.shift()
            }
        }
    }
    return nums
};
```



### [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

```javascript
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    let left=0,right=numbers.length-1
    while(left<=right){
        if(numbers[left]+numbers[right]===target){
            return [left+1,right+1]
        }else if(numbers[left]+numbers[right]<target){
            left++
        }else{
            right--
        }
    }
    return [-1,-1]
};
```



### [75.颜色分类](https://leetcode-cn.com/problems/sort-colors/submissions/)

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
 //对撞指针
var sortColors = function(nums) {
    let p0=0,p2=nums.length-1//其实是三指针，p0和p2负责边界（类似对撞指针），i负责遍历
    for(let i=0;i<=p2;i++){
        while(nums[i]===2&&i<p2){//因为i是往后走的，所以如果p2本来指的就是2，那这个2就被换到i的位置了，然后i++就走过这个位置了，所以为了避免这种情况，这里用while
            [nums[i],nums[p2]]=[nums[p2],nums[i]]
            p2--
        }
        if(nums[i]===0){//因为i是往后走的，所以哪怕本来p0此时指向的就是0也没关系，因为是换到后面去，即使i++后也终究会遍历到它的
            [nums[i],nums[p0]]=[nums[p0],nums[i]]
            p0++
        }
    }
};
```



### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

思路：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-z7qS0O.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-z7qS0O.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-z7qS0O.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-z7qS0O.png" loading="lazy"/>
  </picture>

```javascript
var rotate = function(matrix) {
    let rows=matrix.length,cols=matrix[0].length
    for(let i=0;i<rows;i++){//沿对角线镜像反转
        for(let j=i+1;j<cols;j++){
            [matrix[i][j],matrix[j][i]]=[matrix[j][i],matrix[i][j]]
        }
    }

    const reverseRow = row =>{ //把这一行反转过来
        let left=0,right=row.length-1
        while(left<right){
            [row[left],row[right]]=[row[right],row[left]]
            left++
            right--
        }
    }

    for(const row of matrix){ //传进去每一行
        reverseRow(row)
    }

};
```

还可以逆时针旋转90度：

<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/5.jpeg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/5.jpeg?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/5.jpeg" alt="https://labuladong.gitee.io/algo/images/%e8%8a%b1%e5%bc%8f%e9%81%8d%e5%8e%86/5.jpeg" loading="lazy"/>
  </picture>





### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

```javascript
/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function (matrix) {
    if (matrix.length == 0) return []
    const res = []
    let top = 0, bottom = matrix.length-1 , left = 0, right = matrix[0].length-1  //其实就是对撞指针，上下对撞和左右对撞
    while (top <= bottom && left <= right) {//循环条件
        for (let i = left; i <= right; i++) res.push(matrix[top][i])//循环完上面一行 top++
        top++
        for (let i = top; i <= bottom; i++) res.push(matrix[i][right])//循环右边一行 right--
        right--
        if (top > bottom || left > right) break
        for (let i = right; i >= left; i--) res.push(matrix[bottom][i])
        bottom--
        for (let i = bottom; i >= top; i--) res.push(matrix[i][left])
        left++
    }
    return res
};
```



### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

> 其实就是对撞指针，只不过是二维的，上下对撞和左右对撞

```javascript
/**
 * @param {number} n
 * @return {number[][]}
 */
var generateMatrix = function(n) {
    let res = new Array(n).fill(0).map(()=>new Array(n))
    let top=left=0,bottom=right=n-1
    let count =1
    while(top<=bottom&&left<=right){
        for(let i=left;i<right;i++){
            res[top][i]=count++
        }
        for(let i=top;i<bottom;i++){
            res[i][right]=count++
        }
        for(let i=right;i>left;i--){
            res[bottom][i]=count++
        }
        for(let i=bottom;i>top;i--){
            res[i][left]=count++
        }
        top++
        bottom--
        left++
        right--
    }
    if(n%2) res[n>>>1][n>>>1]=count
    return res
};
```





### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)（两数之和的升级版）

​		看不懂代码可以来这[代码讲解](https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q)

> `n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举每一个数字，然后递归调用计算 `(n-1)Sum`，组装答案

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {

    nums = nums.sort((a,b)=>a-b)
    const len = nums.length,result = []

    function twoSum(start,target){
        const res = []
        let left = start,right = len-1
        while(left<right){
            const sum = nums[left]+nums[right]
            if(sum===target) {
                res.push([nums[left], nums[right]])
                while (nums[left + 1] === nums[left]) { left++ }
                while (nums[right - 1] === nums[right]) { right-- }
                left++
                right--
            }
            else if(sum<target){
                while(nums[left+1]===nums[left]) {left++}
                left++
            }else{
                while(nums[right-1]===nums[right]){right--}
                right--
            }
        }
        return res
    }

    for(let i = 0;i<len;i++){
        if(nums[i]>0) break
        while(i>0&&nums[i]===nums[i-1]) {i++}
        const res = twoSum(i+1,0-nums[i])
        if(!res.length) continue
        res.forEach(e=>{
            result.push([nums[i],...e])
        })
    }
    return result
};
```



### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)（直接用那个封装好的函数）

​		看不懂代码可以来这[代码讲解](https://mp.weixin.qq.com/s/fSyJVvggxHq28a0SdmZm6Q)

> `n == 2` 时是 `twoSum` 的双指针解法，`n > 2` 时就是穷举每一个数字，然后递归调用计算 `(n-1)Sum`，组装答案

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[][]}
 */
var fourSum = function(nums, target) {
    nums = nums.sort((a,b)=>a-b)
    const len = nums.length
    return nSum(4,0,target)

    function twoSum(start,target){
        const res = []
        let left = start,right=len-1
        while(left<right){
            const sum = nums[left]+nums[right]
            if (sum === target) {
                res.push([nums[left],nums[right]])
                while(nums[left]===nums[left+1]){left++}
                while(nums[right]===nums[right-1]){right--}
                left++
                right--
            }
            else if (sum < target) {
                while(nums[left]===nums[left+1]){left++}
                left++
            }
            else {
                while(nums[right]===nums[right-1]){right--}
                right--
            }
        }
        return res
    }

    function nSum(n,start,target){
        let res=[]
        if(n===2){
            res =  twoSum(start,target)
        }else{
            for(let i = start;i<len;i++){
                if(nums[i]>=0&&nums[i]>target) break //因为数组是已经排好序的，所以如果这个值是大于0的且已经比target大，那么加上后面的值也一定比target大
                const sub = nSum(n-1,i+1,target-nums[i])
                sub.forEach(e=>{
                    res.push([nums[i],...e])
                })
                while(i<len-1&&nums[i]===nums[i+1]) {i++}
            }
        }
        return res
    }
};
```



### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

```javascript
var nextPermutation = function(nums) {
    const len = nums.length
    let i=len-2
    for(;i>=0;i--) {//从倒数第二个开始，因为后面要i+1
        if(nums[i]<nums[i+1]){//从右往左，找到第一个比右邻居小的数
            for(let j = len-1;j>i;j--){ //找到这个数的 右边 从右往左第一个比它大的数
                if(nums[j]>nums[i]){
                    [nums[j],nums[i]]=[nums[i],nums[j]] //交换两个数
                    break
                }
            }
            break
        } 
    }
    //if(i===-1)说明不存在比右邻居小的数，直接全部反转
    //使数的变化最小
    let left = i+1,right=len-1
    while(left<right){//这个区间内的数一定是左边的比右边的大
        [nums[left],nums[right]]=[nums[right],nums[left]]
        left++
        right--
    }
};
```







## 二分查找

### 除于2并向下取整

用`left+((right-left)>>1)`来表示除于2并向下取整，避免`left+right`可能导致溢出。



### 模板

> 二分查找其实就是对撞指针，而且使用二分查找也需要<font color="red">有序数组</font>
>
> 二分查找还有找左边界和找右边界的情况（*让mid不断去逼近左或右边界*）

```javascript
//普通二分    
let left=0,right=length-1//左闭右闭
    while(left<=right){
        let mid = (right+left)>>>1
        if(===) {
           
         }
        else if(){
            right=mid-1
        }else{
            left=mid+1
        }
    }

//找左边界
let left = 0, right = nums.length - 1;
while (left <= right) {//终止的时候一定是left=right+1
    let mid = (left+right)>>>1
    if (nums[mid] < target) {
        left = mid + 1;
    } else if (nums[mid] > target) {
        right = mid - 1;
    } else if (nums[mid] == target) {//继续收缩mid，让mid去逼近更左的地方
        right = mid - 1;
    }
}
// 最后要检查 left 越界的情况
if (left >= nums.length || nums[left] != target) {
    return -1;
}
return left;



//找右边界
let left = 0, right = nums.length - 1;
while (left <= right) {//终止的时候一定是left=right+1
    let mid = (left+right)>>>1
    if (nums[mid] < target) {
        left = mid + 1;
    } else if (nums[mid] > target) {
        right = mid - 1;
    } else if (nums[mid] == target) {//继续扩张mid，让mid去探测更右的地方
        left = mid + 1;
    }
}
// 最后要检查 right 越界的情况
if (right < 0 || nums[right] != target) {
    return -1;
}
return right;
```





### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let guess,left=0,right=nums.length
    while(left<right){
        guess=(left+right)>>>1
        if(nums[guess]<target){
            left=guess+1
        }else if(target<nums[guess]){
            right=guess
        }else{
            return guess
        }
    }
    return -1
};
```





### [69. x 的平方根](https://leetcode.cn/problems/sqrtx/)

```js
var mySqrt = function(x) {
    if(x<2) return x
    let left = 1,right = x-1
    while(left<=right){
        const mid= left+((right-left)>>1)
        if(mid*mid<x){
            left=mid+1
        }
        else if(mid*mid>x){
            right=mid-1
        }else{
            return mid
        }
    }
    return right
};
```







### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

```js
var searchInsert = function(nums, target) {
    let left = 0,right=nums.length
    while(left<right){
        const mid = (left+right)>>1
        if(nums[mid]<target){
            left=mid+1
        }else if(nums[mid]>target){
            right=mid
        }else{
            return mid
        }
    }
    return left
};
```







### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```javascript
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
 function searchRange(nums,target){
     let leftBorder=searchLeftBorder(nums,target)
     let rightBorder=searchRightBorder(nums,target)
     return [leftBorder,rightBorder]
     function searchLeftBorder(nums,target){
         let mid ,left=0,right=nums.length-1
         while(left<=right){
             mid=(left+right)>>>1
            if(nums[mid]<target){
                 left=mid+1
             }else{
                 right=mid-1
             }
         }
        
        if(left===nums.length||nums[left]!==target){
         return -1
        }
        else{
            return left
        }
     }
     function searchRightBorder(nums,target){
         let mid ,left=0,right=nums.length-1
         while(left<=right){
             mid=(left+right)>>>1
            if(nums[mid]<=target){
                 left=mid+1
             }else{
                 right=mid-1
             }
         }
        if(right<0||nums[right]!==target){
         return -1
        }
        else{
            return right
        }
     }
 }
```



### 什么问题可以运用二分搜索算法？

- **函数的参数是一个数组和一个值的且题目是跟查找有关的就很有可能用二分搜索算法**

-  **O(NlogN) 这样存在对数的复杂度，一般都要往二分查找的方向上靠**

> **如果算法中存在如下形式的 for 循环**：
>
> ```java
> // func(i) 是 i 的单调函数（递增递减都可以）
> int func(int i);
> 
> // 形如这种 for 循环可以用二分查找技巧优化效率
> for (int i = 0; i < n; i++) {
>     if (func(i) == target)
>         return i;
> }
> ```
>
> **如果 `func(i)` 函数是在 `i` 上单调的函数，一定可以使用二分查找技巧优化 for 循环**。
>
> 为什么满足这个条件就可以使用二分查找？**因为这个逻辑和「在有序数组中查找一个元素」是完全一样的呀**！
>
> 在**有序数组** `nums` 中查找某一个数 `target`，是不是最简单二分查找形式？我们看下普通的 for 循环遍历算法：
>
> ```java
> // nums 是一个有序数组
> int[] nums;
> // target 是要搜索的元素
> int target;
> 
> // 搜索 target 在 nums 中的索引
> for (int i = 0; i < nums.length; i++) {
>     if (nums[i] == target)
>         return i;
> ```



可以看此 [讲解什么时候使用二分搜索](https://labuladong.gitee.io/algo/2/22/62/)

**首先，你要从题目中抽象出一个自变量 `x`，一个关于 `x` 的函数 `f(x)`，以及一个目标值 `target`**。

同时，`x, f(x), target` 还要满足以下条件：

**1、`f(x)` 必须是在 `x` 上的单调函数（单调增单调减都可以）**。

**2、题目是让你计算满足约束条件 `f(x) == target` 时的 `x` 的值**。（注意也可能是找左边界或者右边界）

（例如704.二分查找这道题，函数f就是数组本身，x是坐标，f(x)就是数组里的值arr[x] ）

**如果遇到一个算法问题，能够把它抽象成这幅图，就可以对它运用二分搜索算法**。

具体来说，想要用二分搜索算法解决问题，分为以下几步：

**1、确定 `x, f(x), target` 分别是什么，并写出函数 `f` 的代码**。

**2、找到 `x` 的取值范围作为二分搜索的搜索区间，初始化 `left` 和 `right` 变量**。



### [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)

```javascript
var findPeakElement = function(nums) {
    let [left,right]=[0,nums.length-1]
    while(left<right){
        const mid = (left+right)>>1
        if(nums[mid]<nums[mid+1]){
            left=mid+1
        }else{
            right=mid
        }
    }
    return left
};
```





### [875. 爱吃香蕉的珂珂](https://leetcode-cn.com/problems/koko-eating-bananas/)

```javascript
/**
 * @param {number[]} piles
 * @param {number} h
 * @return {number}
 */

 /*
 x=速度k
 f(x)=需要多少小时h
 f：速度与时间的关系
 */
var minEatingSpeed = function(piles, h) {//单调函数，h最大的时候，k就最小; 
    let k,left = 1,right=Math.max(...piles)
    while(left<=right){//终止的时候一定是left=right+1
        k=(left+right)>>>1
        if(f(piles,k)===h){//k要尽可能小，所以是找左边界，找左边界的意思是要让左边界尽可能小，那就要不断收缩右边，这样可以让k去往左边,用k来探测
            right=k-1
        }else if(f(piles,k)<h){//时间小于h，说明速度快了即mid大了，可以再慢点
            right=k-1
        }else{
            left=k+1
        }
    }
    return left
    
    function f(piles,k){//这是y=时间，x=速度的函数
        let h=0
        piles.forEach(e=>{
            h+=Math.floor(e/k)
            if(e%k){
                h++
            }
        })
        return h
    }
  
  //function f可以改写如下更优雅：
      function f(piles,k){//这是y=时间，x=速度的函数
        return piles.reduce((p, c) => p += Math.ceil(c / k), 0)
    }
};
```

### [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/)

```javascript
/**
 * @param {number[]} weights
 * @param {number} days
 * @return {number}
 */
 /*
 x=船的运载能力
 f(x)=days
 f：x与days的函数关系
 */
var shipWithinDays = function(weights, days) {
    let left = Math.max(...weights),//每次至少要运走一个货物
    right=weights.reduce((pre,cur)=>cur+=pre,0)//最大肯定是一次性运走所有货物
    while(left<=right){
        let mid = (left+right)>>>1
        if(f(weights,mid)>days){
            left=mid+1
        }else{
            right=mid-1
        }
    }
    return left
  function f(weights,x){
      let days=0
      for(let i=0;i<weights.length;){
                let cap=x //船还剩下的运载能力
              days++

          while(i<weights.length){
                    if(weights[i]>cap) break
                    else{
                        cap-=weights[i]
                        i++
                    }
          }
      }
    return days
  }  
};
```



# 链表

## 概念

链表其实就是一个个节点（对象），只不过是这个对象里会有一个key的值是表示它下一个指向谁

各种数据结构，不管是队列，栈等线性数据结构还是树，图等非线性数据结构，从根本上底层都是数组和链表。不管你用的是数组还是链表，用的都是计算机内存，物理内存是一个个大小相同的内存单元构成的

数组和链表虽然用的都是物理内存，但是两者在对物理的使用上是非常不一样的，如图：数组和链表只是使用物理内存的两种方式。数组是连续的内存空间，通常每一个单位的大小也是固定的，因此可以按下标随机访问。而链表则不一定连续，因此其查找只能依靠别的方式，一般我们是通过一个叫 next 指针来遍历查找。





## 与数组的区别

数组（Array）和链表（Linked List）是常见的两种数据结构，它们都可以用来存储线性数据。它们的主要区别在于以下几个方面：

1. 存储方式：数组是一块连续的存储空间，元素的内存地址是连续的，可以随机访问每个元素，而链表是由若干个节点（Node）组成的，每个节点包含两部分，其中一部分是数据，另一部分是指向下一个节点的指针（或称为“引用”），因此链表中的元素并不是连续存储的，需要遍历整个链表才能访问某个元素。
2. 插入和删除操作的效率：对于数组来说，在中间插入或删除一个元素时，需要将后面的元素顺序向后或向前移动，因此效率较低。而对于链表来说，在中间插入或删除一个节点时，只需要修改相邻节点的指针即可，因此效率较高。
3. 访问操作的效率：对于数组来说，由于元素的内存地址是连续的，因此可以根据下标直接访问某个元素，效率很高。而对于链表来说，需要从头节点开始遍历整个链表才能访问某个节点，因此效率相对较低。
4. 空间的利用率：对于数组来说，需要一次性分配一段连续的内存空间，因此空间利用率较低；而对于链表来说，每个节点只需要分配所需的内存空间，因此空间利用率较高。

总的来说，数组适用于随机访问的场景，而链表适用于插入和删除操作较多的场景。在实际应用中，需要根据具体的场景和需求选择合适的数据结构。





## 链表的基本操作

### 插入

插入需要考虑要插入位置前驱节点和后继节点（双向链表的情况下需要更新后继节点），其他节点不受影响，因此在给定前驱节点的情况下插入的操作时间复杂度为`O(1)`。

三步走

```js
temp = cur.next // 1.留下下一个的联系方式 （改指针前记得先保留即将损失联系方式的那个节点的联系方式）
cur.next = 待插入指针 // 2. 前驱的next指向插入的
待插入指针.next = temp // 3. 插入的 next 指向 下一个
```



### 删除

只需要将需要删除的节点的前驱指针的 next 指针修正为其下下个节点即可，注意考虑**边界条件**。

伪代码：

```
待删除位置的节点 = 待删除位置的前驱节点.next
待删除位置的前驱节点.next = 待删除位置的前驱节点.next.next
待删除位置的节点.next = null
```

### 遍历

迭代伪代码：

```js
while (cur != null) { // 结束循环逻辑
    print(cur.val) // do something
   	cur = cur.next // 递进
}
```

> 前序遍历 和 递归

一个前序遍历的递归的伪代码：

```js
dfs(cur) {
​    if 当前节点为空 return // 结束循环逻辑
​    print(cur.val)	// do something
​    return dfs(cur.next) // 递进
}
```



### 手写链表

```javascript
function LinkList() {
  this.length = 0
  this.head = null

  function Node(val) {
    this.val = val
    this.next = null
  }

  LinkList.prototype.append = function (val) {
    let node = new Node(val)
    if (this.head) {
      let current = this.head
      while (current.next) {
        current = current.next
      }
      current.next = node
    } else {
      this.head = node
    }
    this.length++
  }

  LinkList.prototype.toString = function () {
    let cur = this.head,
      result = ''
    while (cur) {
      result += ',' + cur.val
      cur = cur.next
    }
    return result.slice(1)
  }

  LinkList.prototype.insert = function (index, val) {
    if (index < 0 || index > this.length) return -1
    let node = new Node(val)
    if (index === 0) {
      node.next = this.head
      this.head = node
    } else {
      let pre = this.head,
        cur = pre.next,
        i = 1
      while (i++ < index) {
        pre = cur
        cur = cur.next
      }
      pre.next = node
      node.next = cur
    }
    this.length++
    return true
  }

  LinkList.prototype.getVal = function (index) {
    if (index < 0 || index > this.length) return -1
    let i =0,cur=this.head
    while (i++ < index) {
      cur=cur.next
    }
    return cur.val
  }

  LinkList.prototype.update = function (index, newVal) {
    if (index < 0 || index > this.length) return -1
        let i =0,cur=this.head
    while (i++ < index) {
      cur=cur.next
    }
    cur.val = newVal
    return true
  }

  LinkList.prototype.removeAt = function (index) {
    if (index < 0 || index > this.length) return -1
    if (index === 0) {
      let headNext = this.head.next
      this.head = headNext
    } else {
      let i = 1,
        pre = this.head,
        cur = pre.next
      while (i++ < index) { //遍历到那个位置
        pre = cur
        cur = cur.next
      }
      pre.next = cur.next //删除

    }
    this.length++
    return true
  }

  LinkList.prototype.indexOf = function (val) {
    let i = 0,
      cur = this.head
    while (cur) {
      if (cur.val === val) {
        return i
      } else {
        cur = cur.next
        i++
      }
    }
    return -1
  }

  LinkList.prototype.removeVal = function (val) {
    let index = this.indexOf(val)
    return this.removeAt(index)
  }
  // 判断链表是否为空
  LinkList.prototype.isEmpty = function () {
    return this.length == 0
  }

  // 获取链表的长度
  LinkList.prototype.size = function () {
    return this.length
  }

  // 获取第一个节点
  LinkList.prototype.getFirst = function () {
    return this.head.element
  }
}

//测试
let l = new LinkList()
l.append(1)
l.append(2)
l.append(3)
l.insert(0, 0)
l.insert(4, 4)
l.insert(3, 0)
console.log(l.toString())
l.removeAt(3)
console.log(l.toString())
console.log(l.indexOf(0))
console.log(l.indexOf(3))
console.log(l.indexOf(4))
console.log(l.indexOf(5))

// console.log(JSON.stringify(l))
```



## 链表的考点

一个原则就是 **画图**

### 两个考点

- 指针的修改 --- 典型例题：反转链表。（改指针前记得先保留即将损失联系方式的那个节点的联系方式）
- 链表的拼接 --- 增加、删除、遍历，（对这三个基本操作要熟）



### 四个注意

#### 保留联系方式

改指针前记得先保留即将损失联系方式的那个节点的联系方式

#### 出现了环，造成死循环。

- 题目本身就有可能有环，让你判断是否有环，以及环的位置。 ---  快慢指针法 
- 题目链表没环，但是被你操作指针整出环了。 ---  画出子结构

#### 分不清边界，导致边界条件出错。

- 如果题目的头节点可能被移除，**那么考虑使用虚拟节点**
- 题目让你返回的不是原本的头节点，而是尾部节点或者其他中间节点，这个时候要注意指针的变化。

#### <span id="dfsToIterate">搞不懂递归怎么做</span>

- 链表天然就是一个递归结构，所以只需要考虑其子结构怎么处理就可以了。无非就是要注意前序遍历还是后序遍历（因为链表相当于一叉树），**如果是前序遍历，那么你可以想象前面的链表都处理好了**。相应地**如果是后序遍历，那么你可以想象后面的链表都处理好了**。我们一般都会采用前序迭代的方式去写链表题。

  

  > 前序递归遍历容易改成不需要栈的迭代（就把递归函数的前序所有内容写到一个循环里），而后续迭代遍历需要借助栈来完成（把递归函数的前序所有内容写到一个循环里且循环里让要操作的元素入栈，后序部分通过一个一个元素出栈来执行）。这也不难理解，由于后续遍历的主逻辑在函数调用栈的弹出过程，而前序遍历则不需要。

   ```js
   //举例：反转部分链表
   function reverse(head, tail) { // 左闭右闭
       let pre = null,cur=head
       while (cur!==tail.next) { //前序迭代遍历
           let next = cur.next //留下下一个的联系方式
           cur.next = pre // 修改指针
           pre = cur //往下走
           cur=next
       }
       return {head,tail}
   }
   
   function reversePreDfs(pre, cur) { //前序递归遍历
       if(!cur) return
       const next = cur.next
       cur.next = pre
       reversePreDfs(cur,next)
   }
   
   function reverseBackDfs(cur) { //后序递归遍历
       if(!cur||!cur.next) return
       reverseBackDfs(cur.next)
       cur.next.next = cur
       cur.next = null // 如果没有这一步则回溯到头的时候会有环
   }
   
   var reverseList = function(head) { //后序迭代遍历
       const stack = []
       while(head&&head.next){
           stack.push(head)
           head=head.next
       }
       while(stack.length){
           const cur = stack.pop()
           if(cur.next) cur.next.next=cur
           cur.next=null
       }
       return head
   };
   ```

### 四个技巧

#### 虚拟头

两个作用：

1. 当要对原本的头节点进行什么操作时，就利用虚拟头使原本的头节点成为一个正常节点。
2. 如果题目需要返回链表中间的某个节点也可借助虚拟节点。新建一个虚拟头然后让虚拟头在恰当的时候（刚好指向需要返回的节点）断开连接，这样我们就可以返回虚拟头的 next 就 ok 了。

#### 快慢指针

作用： 跟单条链表的环，两条链表的交点相关 或者 找链表中的某个位置的节点

如果想要获取数组中间项和倒数第几项等特定元素就需要一些特殊的手段，而这个手段就是快慢指针。比如要找链表中间项就**搞两个指针，一个大步走（一次走两步），一个小步走（一次走一步）**，这样快指针走到头，慢指针刚好在中间。 如果要求链表倒数第 2 个，那就**让快指针先走一步，慢指针再走**，这样快指针走到头，慢指针刚好在倒数第二个。



#### 穿针引线

作用： 拼接链表。

 a，d 分别是需要反转的链表部分的前驱和后继（不参与反转），而 b 和 c 是需要反转的部分的头和尾（参与反转）。

==除了 cur， 在遍历的时候多用两个指针 pre 和 next去记录==， 即可找到 a，b，c，d。

找到后就直接**穿针引线**即可把拼接起来。

```js
a.next = c
b.next = d
```



#### 先修改指针再排代码顺序再判空

假如有十行**修改指针**的代码，我们很多时候没有必要全考虑。我们**需要考虑的仅仅是被改变 next 指针的部分**。比如 cur.next = pre 的 cur 被改了 next。因此下面用到了 cur.next 的地方就要考虑放哪。其他代码不需要考虑。

## 指针的修改

### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

```js
// 反转数组
function reverseArr(arr) {
    let left = 0, right = arr.length - 1
    while (left < right) {
        [arr[left], arr[right]] = [arr[right], arr[left]]
        left++
        right--
    }
}
const arr = [0, 1, 2, 3, 4, 5, 6, 7, 8]
reverseArr(arr)
console.log(arr)

//反转部分链表
function reverse(head, tail) { // 左闭右闭
    let pre = null,cur=head
    while (cur!==tail.next) { //前序迭代遍历
        let next = cur.next //留下下一个的联系方式
        cur.next = pre // 修改指针
        pre = cur //往下遍历
        cur=next
    }
    return {head,tail}
}

function reversePreDfs(pre, cur) { //前序递归遍历
    if(!cur) return
    const next = cur.next
    cur.next = pre
    reversePreDfs(cur,next)
}

function reverseBackDfs(cur) { //后序递归遍历
    if(!cur.next) return
    reverseBackDfs(cur.next)
    cur.next.next = cur
    cur.next = null // 如果没有这一步则回溯到头的时候会有环
}

var reverseList = function(head) { //后序迭代遍历 --- 后序迭代常常要用stack
    const stack = []
    while(head&&head.next){
        stack.push(head)
        head=head.next
    }
    while(stack.length){
        const cur = stack.pop()
        if(cur.next) cur.next.next=cur
        cur.next=null
    }
    return head
};

```

### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

```javascript
//切出要反转的那一部分进行反转再拼接回去
var reverseBetween = function(head, left, right) {
    if(!head||!head.next) return head //没有节点或者之后一个节点的情况直接返回
    let pre = dummy=new ListNode(0,head),cur=head,next = head.next
    for(let i=1;i<left&&cur;i++){ //找到left位置对应的节点
        cur=cur.next
        pre=pre.next
        next=next.next
    }
    const leftHead = pre,reverseHead = cur //记录left的前继节点和left节点
    for(let i=1;i<=right-left&&cur;i++){ //找到right位置对应的节点
        cur=cur.next
        next=next.next
    }
    const rightTail = next,reverseTail = cur //记录right的后继节点和right节点
    leftHead.next = null // 截出要反转的那段链表
    reverseTail.next = null

    reverse(reverseHead) 

    leftHead.next = reverseTail //反转完后拼接回去
    reverseHead.next = rightTail

    function reverse(head){
        let pre = null
        while(head){
            let next = head.next
            head.next = pre
            pre=head
            head=next
        }
        return pre
    }
    return dummy.next
};
```









### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

> 结合了反转和找中点

```javascript
var isPalindrome = function(head) {

    //找中点和中点的前继节点
    let slow = fast = head,pre = new ListNode(0,head)
    while(fast&&fast.next){
        slow = slow.next
        pre = pre.next
        fast=fast.next.next
    }
    let h2 //接收链表反转后的头
    if(fast){ //如果fast不是null说明链表长度为奇数
        let reverseHead = slow.next
        slow.next=null
        h2 = reverse(reverseHead)
    }else{ //如果fast是null说明链表长度为偶数
        pre.next = null
        h2 = reverse(slow)
    }

    while(head&&h2){
        if(head.val!==h2.val) return false
        head = head.next
        h2 = h2.next
    }
    return true


    function reverse(head){
        let pre = null
        while(head){
            let next = head.next
            head.next = pre
            pre= head
            head = next
        }
        return pre
    }
};
```



### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)

```javascript
var reverseKGroup = function(head, k) {
    if(!head||!head.next||k===1)return head
    let reverseHeadPre = dummy = new ListNode(0,head)
    let cur = head
    while(cur){
        for(let i = 1;i<k&&cur;i++){
            cur=cur.next
        }
        if(cur){ //cur为空则说明凑不够一组，那就不用反转了呗
            // 把要反转的那一段切出来
            let reverseHead=reverseHeadPre.next
            reverseHeadPre.next= null
            let reverseTailSucc = cur.next
            cur.next = null //cur就是reverseTail

            reverse(reverseHead) //反转之后原本的头变成尾，尾变成头

            //拼接回去(注意 反转之后原本的头变成尾，尾变成头)
            reverseHeadPre.next = cur
            reverseHead.next = reverseTailSucc

            //更新此时的reverseHeadPre为上一段链表反转完后的尾，cur为上一段链表的后继节点
            reverseHeadPre = reverseHead
            cur = reverseTailSucc
        }
    }
    return dummy.next

    function reverse(cur){
        let pre = null
        while(cur){
            let next = cur.next
            cur.next = pre
            pre=cur
            cur = next
        }
        return pre
    }
};
```











### 后序递归

#### [138. 复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

```js
var copyRandomList = function(head) {
    let pre = dummy = new Node()
    let map =new Map()
    function dfs(pre,cur){
        if(!cur) return

        //前序部分
        let node = new Node(cur.val) //新建一个节点
        pre.next = node 
        map.set(cur,node) //记录新节点与旧节点的对应关系

        dfs(pre.next,cur.next)

        //后序回溯部分
        node.random = map.get(cur.random)
    }
    dfs(pre,head)
    return dummy.next
};
```











## 链表的拼接（链表基本操作）

> 增加、删除、遍历，（对这三个基本操作要熟）

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) 

```javascript
var swapPairs = function(head) {
    let pre =dummy= new ListNode(0,head)
    let cur = head
    while(pre.next&&cur.next){

        //删除
        let next = cur.next
        cur.next = cur.next.next
        next.next = null

        //插入
        pre.next = next
        next.next = cur

        //递进
        pre = cur
        cur = cur.next
    }
    return dummy.next
};
```





### [83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)

```js
var deleteDuplicates = function(head) {
    let pre =head
    while(pre&&pre.next){
        if(pre.val===pre.next.val){
            pre.next=pre.next.next
        }else{
            pre=pre.next
        }
    }
    return head
};
```



### [82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

```js
var deleteDuplicates = function(head) {
    let cur = head,pre = dummy = new ListNode(0,head)
    while(cur){
        if(cur.next&&cur.val === cur.next.val){
            while(cur.next&&cur.val === cur.next.val){
                cur=cur.next
            }
            pre.next = cur.next
        }else{
            pre=cur
        }
        cur=cur.next
    }
    return dummy.next
};
```



### [143. 重排链表](https://leetcode.cn/problems/reorder-list/)

分为三步：

1. 找到原链表的中点，并拆成两个链表（参考「[876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)」）。
2. 将右边的链表反转（参考「[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)」）。
3. 将两个链表交替合并。

- 时间复杂度：O(N)，其中 *N* 是链表中的节点数。
- 空间复杂度：O(1)。

```js
var reorderList = function(head) { //找到中点，将后半部分翻转，再交替合并链表
    
    function findMid(cur){
        let pre = dummy = new ListNode(0,cur)
        let slow = fast = cur
        while(fast&&fast.next){
            fast = fast.next.next
            slow=slow.next
            pre=pre.next
        }
        return [pre,slow] //返回中间节点和中间节点的前继节点
    }

    function mergeList(h1,h2){ // 在循环过程中只要h1不是最后一个节点就把第二个链表的每一次头节点都截取出来添加到第一个链表上，如果h1是最后一个节点则把整个第二个链表拼接上去
        let dummy2 = new ListNode(0,h2) //用于做第二个链表的删除头节点操作
        while(dummy2.next){ //因为我是把第二个链表的节点截取出来，所以只要第二个链表还有节点就可以继续循环
            let node2 = dummy2.next
            if(h1.next){ //还没有到货h1的最后一个节点

                //截取出第二个链表的头节点
                dummy2.next = dummy2.next.next 
                node2.next = null 

                //把截取出来的节点拼接到第一个链表上
                let next1 = h1.next
                h1.next = node2
                node2.next = next1

                //移动到第一个链表的原来的下一个节点
                h1=next1
            }else{ //h1的最后一个节点了
                h1.next = node2 //把第二个链表拼接到h1上
                dummy2.next = null //把第二个链表删光
            }

        }
        return h1
    }
    function reverse(cur){
        let pre=null
        while(cur){
            let next = cur.next
            cur.next = pre
            pre=cur
            cur= next
        }
        return pre
    }
    if(!head||!head.next) return head
    let [pre,mid] = findMid(head)
    pre.next = null //切成两个链表
    let h2 = reverse(mid) //将后半部分那个链表反转
    return mergeList(head,h2)
};
```





### [148. 排序链表](https://leetcode.cn/problems/sort-list/)

```js
//归并排序
var sortList = function(head) {
    function mergeSort(head){
        if(!head||!head.next) return head
        let pre = new ListNode(0,head)

        //找中点
        let slow = fast = head
        while(fast&&fast.next){
            pre=pre.next
            slow = slow.next
            fast = fast.next.next
        }

        pre.next = null //切割出两个链表

        //获得排好顺序的头
        let h1 = mergeSort(head) 
        let h2 = mergeSort(slow)

        return merge(h1,h2) //合并两个链表
    }

    function merge(h1,h2){
        let pre = dummy = new ListNode()
        let preH1 = new ListNode(0,h1),preH2 = new ListNode(0,h2)
        while(preH1.next&&preH2.next){
            if(preH1.next.val<=preH2.next.val){
                //从h1中删除一个节点
                let node=preH1.next
                preH1.next =preH1.next.next
                node.next=null

                pre.next = node //拼接到第三者上
            }else{
                //从h2中删除一个节点
                let node=preH2.next
                preH2.next =preH2.next.next
                node.next=null

                pre.next = node //拼接到第三者上
            }
            pre = pre.next
        }
        if(preH1.next) pre.next = preH1.next
        if(preH2.next) pre.next = preH2.next
        return dummy.next
    }
    return mergeSort(head)
};
```

### <span id="mergeKOrderList">[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)</span>

#### 归并

两两合并成一个新链表然后返回

```js
var mergeKLists = function(lists) {
    function split(left,right){
        if(left>=right) return lists[left]
        let mid = (left+right)>>1
        let mergedHead1 = split(left,mid)
        let mergeHead2 = split(mid+1,right)
        return merge(mergedHead1,mergeHead2)
    }
    function merge(h1,h2){
        let pre = dummy = new ListNode()
        let pre1 = new ListNode(0,h1),pre2 = new ListNode(0,h2)
        while(pre1.next&&pre2.next){
            if(pre1.next.val<pre2.next.val){
                let node = pre1.next
                pre1.next = pre1.next.next
                node.next = null
                pre.next = node
            }else{
                let node = pre2.next
                pre2.next = pre2.next.next
                node.next = null
                pre.next = node 
            }
            pre=pre.next
        }
        if(pre1.next){
            pre.next = pre1.next
            pre1.next = null
        }
        if(pre2.next){
            pre.next = pre2.next
            pre2.next = null
        }
        return dummy.next
    }
    if(lists.length===0) return null
    return split(0,lists.length)
};
```



#### 优先级队列

```js

var mergeKLists = function(lists) {
        //最小堆
    class PriorityQueue {
        constructor() {
            this.queue = []
        }
        // 父节点的索引
        getParentIndex(nodeIndex) {
            return ~~((nodeIndex-1) / 2);//向下取整
        }
        // 左孩子的索引
        getLeftChildIndex(nodeIndex) {
            return nodeIndex * 2+1;
        }
        // 右孩子的索引
        getRightChildIndex(nodeIndex) {
            return nodeIndex * 2 + 2;
        }

        getSize(){
            return this.queue.length
        }

        // 存在数组里的每个元素可能是数字也可能是一个对象，所以把比较大小单独抽离成一个方法，到时候只要改这个方法就可以服用这个优先级队列类了
        isVar1LessVar2(var1,var2) {
            return var1.val<var2.val
        }
        swimMax(nodeIndex) { //上浮
            while (nodeIndex > 0){ // 上浮到最顶上
                let parentIndex = this.getParentIndex(nodeIndex)
                if (this.isVar1LessVar2(this.queue[nodeIndex], this.queue[parentIndex])) { 
                    [this.queue[nodeIndex], this.queue[parentIndex]]=[this.queue[parentIndex],this.queue[nodeIndex]] //交换
                    nodeIndex = parentIndex //上浮 继续往上调整
                } else { 
                    break
                }
            }
        }

        sinkMax(nodeIndex) { //下沉
            const size = this.queue.length
            while (nodeIndex < size) { // 下沉到最底下
                let leftChildIndex = this.getLeftChildIndex(nodeIndex)
                let rightChildIndex = this.getRightChildIndex(nodeIndex)
                if (leftChildIndex >= size) break //越界了，调整结束 
                let minIndex = leftChildIndex
                if (rightChildIndex < size) {
                    minIndex = this.isVar1LessVar2(this.queue[leftChildIndex], this.queue[rightChildIndex]) ? leftChildIndex : rightChildIndex
                }

                if (this.isVar1LessVar2(this.queue[nodeIndex], this.queue[minIndex])) { 
                    break
                } else { 
                    [this.queue[nodeIndex], this.queue[minIndex]] = [this.queue[minIndex], this.queue[nodeIndex]] 
                    nodeIndex=minIndex //下沉，继续往下调整
                }
            }
        }

        insert(node) { //insert 方法。 先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置
            this.queue.push(node)
            this.swimMax(this.queue.length-1)
        }

        delTop() { //delTop 方法删除堆顶元素。 先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。
            const size = this.queue.length;
            [this.queue[0], this.queue[size - 1]] = [this.queue[size - 1],this.queue[0]]
            const top = this.queue.pop()
            this.sinkMax(0)
            return top
        }
    }


    const p = new PriorityQueue()
    let pre=dummy =new ListNode() //存放结果链表
    lists.forEach(item=>{ //把每个链表的头节点放进优先级队列
        if(item) p.insert(item)
    })
    while(p.getSize()>0){
        let cur = p.delTop() //拿出现在头节点最小的那个节点
        let next = cur.next 
        cur.next = null //把这个头节点截取出来

        pre.next = cur // 将这个节点拼接到结果中
        pre=pre.next // 往后移动结果节点

        if(next) p.insert(next) //如果next不是null，则放进队列中
    }
    return dummy.next
};
```



### 设计twitter

```js
var timestamp = 0; // Tweet 类要用到一个全局时间戳 timestamp用以记录每个tweet的时间

function Tweet(id, time) {
    var id = id;
    var time = time;
    var next = null; //推文列表应该由链表这种数据结构储存，以便于进行有序合并。
}

class User {
    constructor(userId) {
        this.id = userId;
        this.followed = new Set(); // 存自己关注的人
        this.head = null; //存储自己发的tweet的链表的头地址
        this.follow(this.id);// 关注一下自己
    }

    follow(userId) {
        this.followed.add(userId);
    }

    unfollow(userId) {
        // 不可以取消关注自己
        if (userId !== this.id) {
            this.followed.delete(userId);
        }
    }

    post(tweetId) {
        var twt = new Tweet(tweetId, timestamp);
        timestamp++;
        // 将新建的推文插入链表头，越靠前的推文 time 值越大
        twt.next = this.head;
        this.head = twt;
    }
}

var Twitter = function() {
     var timestamp = 0;
     var Tweet = function() {};
     var User = function() {}; 
     var userMap = {}; // 存userId对应的user实例

};

/** 
 * @param {number} userId 
 * @param {number} tweetId
 * @return {void}
 */
Twitter.prototype.postTweet = function(userId, tweetId) {
        // 若 userId 不存在，则新建
        if (!userMap[userId]) {
            userMap[userId] = new User(userId);
        }
        var u = userMap[userId];
        u.post(tweetId);
};

/** 
 * @param {number} userId
 * @return {number[]}
 */
Twitter.prototype.getNewsFeed = function(userId) {
        var res = [];
        if (!userMap.hasOwnProperty(userId)) return res;
        // 关注列表的用户 Id
        var users = userMap[userId].followed;
        // 利用优先级队列自动通过 time 属性从大到小排序，容量为 users 的大小
        var pq = new PriorityQueue(users.size(), function(a, b) { return b.time - a.time; });

        // 先将所有链表头节点插入优先级队列
        for (var id in users) {
            var twt = userMap[id].head;
            if (!twt) continue;
            pq.add(twt);
        }

        while (!pq.isEmpty()) {
            // 最多返回 10 条就够了
            if (res.length == 10) break;
            // 弹出 time 值最大的（最近发表的）
            var twt = pq.poll();
            res.push(twt.id);
            // 将下一篇 Tweet 插入进行排序
            if (twt.next) 
                pq.add(twt.next);
        }
        return res;
};

/** 
 * @param {number} followerId 
 * @param {number} followeeId
 * @return {void}
 */
Twitter.prototype.follow = function(followerId, followeeId) {
        // 若 follower 不存在，则新建
        if(!userMap[followerId]) {
            var u = new User(followerId);
            userMap[followerId] = u;
        }
        // 若 followee 不存在，则新建
        if(!userMap[followeeId]) {
            var u = new User(followeeId);
            userMap[followeeId] = u;
        }   
        userMap[followerId].follow(followeeId);

};

/** 
 * @param {number} followerId 
 * @param {number} followeeId
 * @return {void}
 */
Twitter.prototype.unfollow = function(followerId, followeeId) {
        if (userMap[followerId]) {
            var flwer = userMap[followerId];
            flwer.unfollow(followeeId);
        }   

};

/**
 * Your Twitter object will be instantiated and called as such:
 * var obj = new Twitter()
 * obj.postTweet(userId,tweetId)
 * var param_2 = obj.getNewsFeed(userId)
 * obj.follow(followerId,followeeId)
 * obj.unfollow(followerId,followeeId)
 */
```





### 遍历

#### [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

> 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var middleNode = function(head) {//每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。
    let slow=fast=head
    while(fast&&fast.next){
        fast=fast.next.next
        slow=slow.next
    }
    return slow
};
```

#### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```javascript
var removeNthFromEnd = function(head, n) {
    const findFromEnd=(head,n)=>{//找到倒数第n个节点
        let slow=fast=head
        for(let i=0;i<n;i++){
            fast=fast.next
        }
        while(fast){
            fast=fast.next
            slow=slow.next
        }
        return slow
    }
    let dummy=new ListNode(0,head)
    let target=findFromEnd(dummy,n+1)// 删除倒数第 n 个，要先找到它的前一个节点（即倒数第n+1个）
    target.next=target.next.next
    return dummy.next
};
```



#### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)

追及问题：每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```javascript
var hasCycle = function(head) {
    let slow = fast = head
    while(fast&&fast.next){
        fast=fast.next.next
        slow=slow.next
        if(slow===fast) return true
    }
    return false
};
```

#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步;

`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」；

假设相遇点距环的起点的距离为 `m`，那么结合图1的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`;

而且如果从相遇点继续前进 `k - m` 步，也恰好到达环起点；

所以，只要我们在第一次相遇后把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，再次相遇之处就是环的起点了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-SNDuQr.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-SNDuQr.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-SNDuQr.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-SNDuQr.jpg" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VRHNNL.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VRHNNL.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VRHNNL.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VRHNNL.jpg" loading="lazy"/>
  </picture>

```javascript
//当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置
var detectCycle = function(head) {
    let  fast = slow = head;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (fast == slow) break;
    }
    if (fast == null || fast.next == null) {
        // 如果上面退出循环是因为fast 遇到空指针说明没有环（因为有环的单链表是不会有null的）
        return null;
    }

    // 重新指向头结点
    slow = head;
    // 快慢指针同步前进，相交点就是环起点
    while (slow != fast) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
};
```





#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */

/**
 * @param {ListNode} headA
 * @param {ListNode} headB
 * @return {ListNode}
 */
//「寻找两条链表的交点」的核心在于让 p1 和 p2 两个指针能够同时到达相交节点 c1，那么可以通过预先计算两条链表的长度来做到这一点
var getIntersectionNode = function(headA, headB) {
    let lenA=lenB=0
    let pa=headA,pb=headB
    while(pa){
        lenA++
        pa=pa.next
    }
    while(pb){
        lenB++
        pb=pb.next
    }
    pa=headA,pb=headB//指回起点
    if(lenA>lenB){
        let cha=lenA-lenB
        for(let i=0;i<cha;i++){
            pa=pa.next
        }
    }else{
        let cha=lenB-lenA
        for(let i=0;i<cha;i++){
            pb=pb.next
        }
    }//现在pa和pb同一起跑线了(即分别距离终点的距离是一样的)
    while(pa!==pb){
        pa=pa.next
        pb=pb.next
    }
    return pa//已经包含了无交点的情况
};
```













### 借用第三者

> 拿个第三者来帮助拼接链表，这样可避免直接在链表上进行插入删除操作（*也能做出来，但是很不好理解*）

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

```javascript
var mergeTwoLists = function(list1, list2) {
    let dummy=new ListNode(),pre = dummy
    let cur1=list1,cur2=list2
    while(cur1&&cur2){
        if(cur1.val<=cur2.val){
            pre.next=cur1
            pre=cur1
            cur1=cur1.next
        }else{
            pre.next=cur2
            pre=cur2
            cur2=cur2.next
        }
    }
    if(cur1){
      pre.next=cur1  
    }
    if(cur2){
        pre.next=cur2
    }
    return dummy.next
};
```

#### [86. 分隔链表](https://leetcode.cn/problems/partition-list/)

```js
/**用了第三者*/
var partition = function(head, x) { //分割出一个大链表和一个小链表，再合并回去
    let smallHead = new ListNode()
    let smallCur= smallHead
    let bigHead = new ListNode()
    let bigCur = bigHead
    let cur = head
    while(cur){
        if(cur.val<x){
            smallCur.next = cur
            smallCur=smallCur.next
        }else{
            bigCur.next=cur
            bigCur=bigCur.next
        }
        cur=cur.next
    }
    smallCur.next=bigHead.next
    bigCur.next=null
    return smallHead.next
};

/**没有用第三者*/
var partition = function(head, x) { //先删除再插入
    let dummy=new ListNode(-999,head)
    let cur = smallLast = bigFirst=dummy
    while(cur&&cur.next){
        if(cur.val<x&&cur.next.val>=x){
            smallLast=cur
            bigFirst = cur.next
            while(cur.next&&cur.next.val>=x){ //找到要移除的那个位置的前驱节点
                cur=cur.next
            }
            let del = cur.next //保留联系方式
            if(del){
                cur.next=cur.next.next
                smallLast.next=del
                smallLast=smallLast.next
                del.next=bigFirst
            }
        }else if(cur.val>=x&&cur.next.val<x){
            let del = cur.next
            if(del){
                cur.next=cur.next.next
                smallLast.next=del
                smallLast=smallLast.next
                del.next=bigFirst
            }
        }else{
            cur=cur.next
        }
    }
    return dummy.next
};
```



#### [2. 链表两数相加](https://leetcode.cn/problems/add-two-numbers/)

```javascript
var addTwoNumbers = function(l1, l2) {
    let jin = 0
    let cur = dummy = new ListNode()
    while(l1||l2||jin){
        let v1 = l1?l1.val:0,v2 = l2?l2.val:0
        l1 = l1?l1.next:l1
        l2=l2?l2.next:l2
        let sum = v1 + v2+jin
        if(sum>9){
            jin  = 1
            sum = sum%10
        }else{
            jin=0
        }
        let node = new ListNode(sum,null)
        cur.next = node
        cur = cur.next
    }
    return dummy.next
};
```











# 哈希表

> **一般哈希表都是用来快速判断一个元素是否出现集合里**，一个元素是否重复出现（***查找***）



## 使用数组

> 数组就是简单的哈希表，凡是固定大小的且连续的都用数组来做哈希表
>
> 
>
> 如果题目没有限制数值的大小，就无法使用数组来做哈希表了。因为：
>
> - 数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。
> - 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。

### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

```javascript
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if(s.length !== t.length) return false;
    let table=new Array(26).fill(0)
        base='a'.charCodeAt(0)
    for(let i of s){
        table[i.charCodeAt(0)-base]++
    }
    for(let i of t){
        table[i.charCodeAt(0)-base]--
        if(table[i.charCodeAt(0)-base]<0) return false
    }
    return true
};
```

### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

> 与上一题一样，都是26个字母，直接用数组来模拟哈希表即可

```javascript
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    let table=new Array(26).fill(0),base='a'.charCodeAt(0)
    
    for(const i of magazine){
        table[i.charCodeAt(0)-base]++
    }
    for(const i of ransomNote){
        table[i.charCodeAt(0)-base]--
        if(table[i.charCodeAt(0)-base]<0)return false
    }
    return true
};
```







## 使用Set

> 使用数组来做哈希的题目，是因为题目都限制了数值的大小。
>
> 若没有限制数值的大小，就无法使用数组来做哈希表了。
>
> 而且如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费
>
> 使用set也有缺点  不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的



### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    let resSet=new Set()
    if(nums1.length>nums2.length){
        var numsSet=new Set(nums1)
        for(let i=0;i<nums2.length;i++){
            numsSet.has(nums2[i])&&resSet.add(nums2[i])
        }
    }else{
        var numsSet=new Set(nums2)
        for(let i=0;i<nums1.length;i++){
            numsSet.has(nums1[i])&&resSet.add(nums1[i])
        }
    }
    return Array.from(resSet)
};
```

### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

```javascript
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    function getNext(value){
        return value.toString().split('').map(i=>i**2).reduce((pre,cur)=>pre+cur,0)
    }

    let set=new Set()
    while(n!==1&&!set.has(n)){
        set.add(n)
        n=getNext(n)
    }
    return n===1
};
```



## 使用Map

> 数组和set来做哈希法的局限：
>
> - 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
> - set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。
>
> map是一种key value的存储结构



### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

> map用key保存数值，用value在保存数值所在的下标

```javascript
var twoSum = function(nums, target) {
    const map = new Map(),length = nums.length
    for(let i = 0;i<length;i++){
        const cur = nums[i]
        const gap = target - cur
        if(map.has(cur)) {
            return [map.get(cur),i]
        }else{
            map.set(gap,i) //map存gap和这个值的坐标
        }
    }
};
```

### [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

> 跟上面那题思路差不多

```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number[]} nums3
 * @param {number[]} nums4
 * @return {number}
 */
var fourSumCount = function(nums1, nums2, nums3, nums4) {
    let n=nums1.length,map=new Map(),count=0
    for(let i=0;i<n;i++){
        for(let j=0;j<n;j++){
            let sum =nums1[i]+nums2[j]
            map.set(sum,(map.get(sum)||0)+1)
        }
    }
    for(let i=0;i<n;i++){
        for(let j=0;j<n;j++){
            let sum =nums3[i]+nums4[j]
            if(map.has(0-sum)){count+=map.get(0-sum)}
        }
    }
    return count
};
```





# 栈与队列

> 匹配问题都是栈的强项

### [71. 简化路径](https://leetcode.cn/problems/simplify-path/)

```javascript
var simplifyPath = function(path) {
    const stack = [],arr=path.split('/')
    for(const name of arr){
        if(name=='..'){
            if(!stack.length) continue
            stack.pop()
        }else if(name=='.'||name=='') {
            continue
        }else{
            stack.push(name)
        }
    }
    return '/'+stack.join('/')
};
```





### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```javascript
var MyQueue = function() {
    this.stackIn=[]
    this.stackOut=[] //两个数组里装的加起来就是队列里装的
};

/** 
 * @param {number} x
 * @return {void}
 */
MyQueue.prototype.push = function(x) {
    this.stackIn.push(x)
};

/**
 * @return {number}
 */
MyQueue.prototype.pop = function() {
    if(!this.stackOut.length){
        while(this.stackIn.length){
            this.stackOut.push(this.stackIn.pop())
        }
    }
    return this.stackOut.pop()

};

/**
 * @return {number}
 */
MyQueue.prototype.peek = function() {
   const x = this.pop();
   this.stackOut.push(x);
   return x;
};

/**
 * @return {boolean}
 */
MyQueue.prototype.empty = function() {
    return !this.stackOut.length&&!this.stackIn.length
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * var obj = new MyQueue()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.peek()
 * var param_4 = obj.empty()
 */
```

### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```javascript
//用两个队列实现栈
var MyStack = function() {
    this.queue=[]
    this.queueBackup=[] // 辅助队列，用来pop的时候进行备份
};

/** 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue.push(x)
};

/**
 * @return {number}
 */
MyStack.prototype.pop = function() {
    while(this.queue.length>1){
        this.queueBackup.push(this.queue.shift())
    }
    const result = this.queue.shift()
    while(this.queueBackup.length){
        this.queue.push(this.queueBackup.shift())
    }
    return result
};

/**
 * @return {number}
 */
MyStack.prototype.top = function() {
    const result = this.pop()
    this.queue.push(result)
    return result
};

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return !this.queue.length
};

/**
 * Your MyStack object will be instantiated and called as such:
 * var obj = new MyStack()
 * obj.push(x)
 * var param_2 = obj.pop()
 * var param_3 = obj.top()
 * var param_4 = obj.empty()
 */
```

```javascript
// 使用一个队列实现
/**
 * Initialize your data structure here.
 */
var MyStack = function() {
    this.queue = [];
};

/**
 * Push element x onto stack. 
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function(x) {
    this.queue.push(x);
};

/**
 * Removes the element on top of the stack and returns that element.
 * @return {number}
 */
MyStack.prototype.pop = function() {
    let size = this.queue.length;
    while(size-- > 1) {
        this.queue.push(this.queue.shift());
    }
    return this.queue.shift();
};

/**
 * Get the top element.
 * @return {number}
 */
MyStack.prototype.top = function() {
    return this.queue.slice(-1)[0];
};

/**
 * Returns whether the stack is empty.
 * @return {boolean}
 */
MyStack.prototype.empty = function() {
    return !this.queue.length;
};

```



### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)

```javascript
var decodeString = function(s) {
    let numStack = [];        // 存倍数
    let strStack = [];        // 存 待拼接的str
    let num = '';              // 倍数的“搬运工”
    let result = '';          // 字符串的“搬运工”
    for(const char of s){
        if(/\d/.test(char)){
            num+=char
        }else if(char==='['){
            numStack.push(+num)
            num=''
            strStack.push(result)
            result=''
        }else if(char===']'){
            const repeatNum = numStack.pop()
            result=strStack.pop()+result.repeat(repeatNum)
        }else{ //字母
            result+=char
        }
    }
    return result
};
```





### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```javascript
/**
 * @param {string} s
 * @return {boolean}
 */
 //因为后遇到的左括号要先闭合（后入先出），所以将左括号放入栈顶
var isValid = function(s) {
  	let sl = s.length;
    if (sl % 2) return false;//如果是奇数肯定就是不对的了
    let stack=[]//栈里面存的都是左括号
    // let map = new Map(
    //     [
    //         [')','('],['}','{'],[']','[']
    //     ]
    // )
    //这题可以用obj来代替map
    let mapObj={')':'(','}':'{',']':'['}//key是右括号，value是左括号
    for(const char of s){
        if(mapObj[char]){//如果匹配到右括号
            if(mapObj[char]===stack[stack.length-1]) stack.pop()
            else return false
        }else{
            stack.push(char)
        }
    }
    return !stack.length//如果最后stack是空的则说明左括号都被匹配掉了。否则说明左括号还有剩余
};
```



### [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var removeDuplicates = function(s) {
    let arr=Array.from(s)/*也可以不转数组，用for(const char of s){}来循环*/,resArr=[]
    for(let i=0,length=arr.length;i<length;i++){
        let resArrLen=resArr.length
        if(!resArrLen||arr[i]!==resArr[resArrLen-1]){
            resArr.push(arr[i])  
        }else{
            resArr.pop()
        }
    }
    return resArr.join('')
};
```



### [227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var calculate = function(s) {
    let preSign = '+',num=""
    const stack=[]
    for(let i=0;i<s.length;i++){
        if(/\d/.test(s[i])){ //当前是数字
            num+=s[i]
        }
        if((/\D/.test(s[i])&&s[i]!==' ')||i===s.length-1){ //当前是运算符或者是到了最后一个数,则说明前面的两个数可以运算了，num存的就是前一个数，stack的末尾就是前前一个数，pre是前一个运算符
                switch(preSign){
                    case '+':
                        stack.push(+num)
                        break
                    case '-':
                        stack.push(-num)
                        break
                    case '*':
                        const preNum = stack.pop()
                        stack.push(preNum*num)
                        break
                    case '/':
                        const preNu = stack.pop()
                        stack.push(~~(preNu / num))
                        break
                }
            preSign=s[i]
            num=""
        }
    }
    return stack.reduce((pre,cur)=>{
        return pre+cur
    },0)

};
```





### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

> 逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。
>
> 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
>
> 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
>
> 逆波兰表达式主要有以下两个优点：
>
> - 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
> - 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

```javascript
/**
 * @param {string[]} tokens
 * @return {number}
 */
//还用到了哈希表
var evalRPN = function(tokens) {
    let stack=[]//存数字
    let map=new Map([
        ['+',(a,b)=>a*1+b*1],
        ['*',(a,b)=>a*b],
        ['-',(a,b)=>b-a],
        ['/',(a,b)=>(b/a)|0]
    ])
    for(const i of tokens){
        if(map.has(i)){
            stack.push(map.get(i)(stack.pop(),stack.pop()))
        }else{
            stack.push(i)
        }
    }
    return stack[0]
};
```





## 栈

### 单调栈

栈中的元素全都是单调递增（或递减）的。

既能够维护栈元素「先进后出」的时间顺序，又能够正确维护栈中所有元素的最值。因为影响单调的元素直接被删了:laughing:，所以一般都是辅助某些算法才用的，好处是每个方法的均摊复杂度都是O(1)。

只用于处理一类典型的问题，比如「下一个更大元素」，「上一个更小元素」等。

```js
// 单调栈
class MonotonicStack{
  this.stack = []
	this.push = (item)=>{
         while (this.stack.length && this.stack[this.stack.length - 1] <= item) { // 把栈里小于等于【即将插进来的元素】的都剔除出去。 由于栈的特性，所以剔除出去的都是从离当前元素最近的元素开始剔。
            this.stack.pop();
        }
    		this.stack.push(item)
  }
	this.pop = ()=>{
    this.stack.pop()
  }
  this.min = ()=>{
    this.stack[this.stack.length-1]
  }
}
```





```js
/** 找出数组里每个元素的最近的下一个更大元素 */
function findNextBiggerItem(nums){
    let len = nums.length
    let res = new Map()
    let stack = [] // 栈里不许有比现在插入进来的元素大/小
    for (var i = len - 1; i >= 0; i--) {// 倒着往栈里放，这样出栈的元素就是原先在数组里的 目前要插进来的元素 的后面的元素。
        while (stack.length && stack[stack.length - 1] <= nums[i]) { // 把栈里小于等于【即将插进来的元素】的都剔除出去。 由于栈的特性，所以剔除出去的都是从离当前元素最近的元素开始剔。
            stack.pop();
        }
        res.set(nums[i],stack.length?stack[stack.length-1]:-1)
        stack.push(nums[i]);
    }
    return res;
}
```









##### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

```js
var nextGreaterElement = function(nums1, nums2) {
    let nums2BiggerMap = findNextBiggerItem(nums2)
    let res = []
    for(let item of nums1){
        res.push(nums2BiggerMap.get(item))
    }
    return res
};
```







##### 如果数组是可循环的：[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

解法是：**将数组长度翻倍**。（没有用求余去实现真循环是因为要用单调栈，真循环不好搞。）

```js
var nextGreaterElements = function(nums) {
    var n = nums.length;
    var res = new Array(n).fill(0);
    var s = [];
    // 数组长度加倍模拟环形数组
    for (var i = 2 * n - 1; i >= 0; i--) {
        // 索引 i 要求模，其他的和模板一样
        while (s.length > 0 && s[s.length-1] <= nums[i % n]) {
            s.pop();
        }
        res[i % n] = s.length == 0 ? -1 : s[s.length-1];
        s.push(nums[i % n]);
    }
    return res;
};
```







## 队列



### 双端队列

在计算机科学中，双端队列的一个常见应用是存储一系列的可撤销操作。每当用户在软件中进行了一个操作，该操作会被存在一个双端队列中（就像在一个栈里）。当用户点击撤销按钮时，该操作会被从双端队列中弹出，表示它被从后面移除了。在进行了预先定义的一定数量的操作后，最先进行的操作会被从双端队列的前端移除。



#### 例题

##### 判断是否是回文串

```js
  while (queue.length > 1) {
    const front = queue.shift();
    const end = queue.pop();
    if (front !== end) {
      return false;
    }
  }
  return true;
```







##### 击鼓传花

击鼓传花游戏（hot potato）。在这个游戏中，孩子们围成一个圆圈，把花尽快地传递给旁边的人。某一时刻传花停止，这个时候花在谁手里，谁就退出圆圈、结束游戏。重复这个过程，直到只剩一个孩子（胜者）。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-11-44-image-20240115114435217.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-11-44-image-20240115114435217.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-11-44-image-20240115114435217.png" alt="image-20240115114435217" style="zoom:50%;" loading="lazy"/>
  </picture>

```js
function hotPotato(children, num){
	while(children.length>1){
		for(let i =0;i<num;i++){
			const cur = children.shift()
			children.push(cur)
		}
		children.shift()//淘汰
	}
	return children[0]
}
```













### 单调队列

队列中的元素全都是单调递增（或递减）的。

既能够维护队列元素「先进先出」的时间顺序，又能够正确维护队列中所有元素的最值。因为影响单调的元素直接被删了:laughing:，所以一般都是辅助某些算法才用的，好处是每个方法的均摊复杂度都是O(1)。

「单调队列」这个数据结构主要用来辅助解决滑动窗口相关的问题

```javascript
/* 单调队列的实现 */
function MonotonicQueue() {
    this.maxq = [];
    this.push = function(n) { 
        // 将小于 n 的元素全部删除
        while (this.maxq.length > 0 && this.maxq[this.maxq.length - 1] < n) {
            this.maxq.pop(); 
        } 
        // 然后将 n 加入尾部
        this.maxq.push(n); 
    }
    this.max = function() { 
        return this.maxq[0]; 
    }
  
  // 队头元素如果是 n，删除它
    this.pop = function(n) {
        if (n == this.maxq[0]) {
            this.maxq.shift(); 
        }
    }
}
```







##### [LCR 184. 设计自助结算系统](https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/)

##### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)









# 二叉堆（堆）

## 概念

下沉和上浮的时间复杂度是O(logn) 。

二叉堆在逻辑上其实是一种完全二叉树，只不过是存储在数组里。

- 如果子节点的数组下标是i，那么其父节点就是（i-1）/2
- 如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2

二叉堆的操作主要就是上浮和下沉来维护堆有序。上浮某个节点 A，只需要 A 和其父节点比较大小即可；下沉某个节点 A，需要 A 和其**两个子节点**比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。（插入和删除都是尾操作，因为要保证满足完全二叉树。）

<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/3.jpeg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/3.jpeg?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/3.jpeg" alt="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/3.jpeg" loading="lazy"/>
  </picture>



<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/heap/1.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/heap/1.png?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/heap/1.png" alt="https://labuladong.gitee.io/algo/images/heap/1.png" loading="lazy"/>
  </picture>







## 优先级队列

### 简介

先有一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素。保证这两种操作（删除最大元素和插入元素）的效率最高。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-21-10-20-image-20230821102015536.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-21-10-20-image-20230821102015536.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-21-10-20-image-20230821102015536.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-21-10-20-image-20230821102015536.png" loading="lazy"/>
  </picture>





### 基于二叉堆实现优先级队列代码思路

主要操作是尾部插入和删除堆顶。插入是先插到最后，然后上浮到正确位置；删除堆顶是先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，再让 B 下沉到正确位置。下沉和上浮的时间复杂度是O(logn)。

二叉堆在逻辑上其实是一种完全二叉树，只不过是存储在数组里。

- 如果子节点的数组下标是i，那么其父节点就是（i-1）/2
- 如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2

### 最大堆实现

```js
/*
*根据不同情况修改一下这个类里的比较函数就可以完全复用这个最大堆了
*/
//最大堆
class PriorityQueue {
    constructor() {
        this.queue = []
    }
    // 父节点的索引
    getParentIndex(nodeIndex) {
        return ~~((nodeIndex-1) / 2);//向下取整
    }
    // 左孩子的索引
    getLeftChildIndex(nodeIndex) {
        return nodeIndex * 2+1;
    }
    // 右孩子的索引
    getRightChildIndex(nodeIndex) {
        return nodeIndex * 2 + 2;
    }

    getSize(){
        return this.queue.length
    }

    // 存在数组里的每个元素可能是数字也可能是一个对象，所以把比较大小单独抽离成一个方法，到时候只要改这个方法就可以服用这个优先级队列类了
    isVar1BiggerVar2(var1,var2) {
        return var1>var2
    }
  
    swimMax(nodeIndex) { //上浮
        while (nodeIndex > 0){ // 上浮到最顶上
            let parentIndex = this.getParentIndex(nodeIndex)
            if (this.isVar1BiggerVar2(this.queue[nodeIndex], this.queue[parentIndex])) { // 如果当前的值比父节点的大，那就换
                [this.queue[nodeIndex], this.queue[parentIndex]]=[this.queue[parentIndex],this.queue[nodeIndex]] //交换
                nodeIndex = parentIndex //上浮 继续往上调整
            } else { //如果当前的值不比父节点的大，那就不用调整了
                break
            }
        }
    }

    sinkMax(nodeIndex) { //下沉
        const size = this.queue.length
        while (nodeIndex < size) { // 下沉到最底下
            let leftChildIndex = this.getLeftChildIndex(nodeIndex)
            let rightChildIndex = this.getRightChildIndex(nodeIndex)
            if(leftChildIndex<size){
                let maxIndex=leftChildIndex
                if(rightChildIndex<size&&this.isVar1BiggerVar2(this.queue[rightChildIndex],this.queue[leftChildIndex])){
                    maxIndex= rightChildIndex
                }
                if(this.isVar1BiggerVar2(this.queue[nodeIndex],this.queue[maxIndex])){
                    break
                }else{
                    [this.queue[nodeIndex],this.queue[maxIndex]]=[this.queue[maxIndex],this.queue[nodeIndex]]
                    nodeIndex = maxIndex
                }
            }
            else{
                break
            }
        }
    }

    insert(node) { //insert 方法。 先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置
        this.queue.push(node)
        this.swimMax(this.queue.length-1)
    }

    delTop() { //delTop 方法删除最大的那个元素即堆顶元素。 先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。
        const size = this.queue.length;
        [this.queue[0], this.queue[size - 1]] = [this.queue[size - 1],this.queue[0]]
        const top = this.queue.pop()
        this.sinkMax(0)
        return top
    }
}

//测试
const q = new PriorityQueue()
q.insert(20)
q.insert(200)
q.insert(2)
q.delTop()
q.insert(2000)
q.delTop()
q.insert(20000)
console.log(q.queue)
```



### 最小堆实现

```js
/*
*根据不同情况修改一下这个类里的比较函数就可以完全复用这个最小堆了
*/       
//最小堆
    class PriorityQueue {
        constructor() {
            this.queue = []
        }
        // 父节点的索引
        getParentIndex(nodeIndex) {
            return ~~((nodeIndex-1) / 2);//向下取整
        }
        // 左孩子的索引
        getLeftChildIndex(nodeIndex) {
            return nodeIndex * 2+1;
        }
        // 右孩子的索引
        getRightChildIndex(nodeIndex) {
            return nodeIndex * 2 + 2;
        }

        getSize(){
            return this.queue.length
        }

        // 存在数组里的每个元素可能是数字也可能是一个对象，所以把比较大小单独抽离成一个方法，到时候只要改这个方法就可以服用这个优先级队列类了
        isVar1LessVar2(var1,var2) {
            return var1.val<var2.val
        }
        swimMax(nodeIndex) { //上浮
            while (nodeIndex > 0){ // 上浮到最顶上
                let parentIndex = this.getParentIndex(nodeIndex)
                if (this.isVar1LessVar2(this.queue[nodeIndex], this.queue[parentIndex])) { 
                    [this.queue[nodeIndex], this.queue[parentIndex]]=[this.queue[parentIndex],this.queue[nodeIndex]] //交换
                    nodeIndex = parentIndex //上浮 继续往上调整
                } else { 
                    break
                }
            }
        }

        sinkMax(nodeIndex) { //下沉
            const size = this.queue.length
            while (nodeIndex < size) { // 下沉到最底下
                let leftChildIndex = this.getLeftChildIndex(nodeIndex)
                let rightChildIndex = this.getRightChildIndex(nodeIndex)
                if (leftChildIndex >= size) break //越界了，调整结束 
                let minIndex = leftChildIndex
                if (rightChildIndex < size) {
                    minIndex = this.isVar1LessVar2(this.queue[leftChildIndex], this.queue[rightChildIndex]) ? leftChildIndex : rightChildIndex
                }

                if (this.isVar1LessVar2(this.queue[nodeIndex], this.queue[minIndex])) { 
                    break
                } else { 
                    [this.queue[nodeIndex], this.queue[minIndex]] = [this.queue[minIndex], this.queue[nodeIndex]] 
                    nodeIndex=minIndex //下沉，继续往下调整
                }
            }
        }

        insert(node) { //insert 方法。 先把要插入的元素添加到堆底的最后，然后让其上浮到正确位置
            this.queue.push(node)
            this.swimMax(this.queue.length-1)
        }

        delTop() { //delTop 方法删除堆顶元素。 先把堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。
            const size = this.queue.length;
            [this.queue[0], this.queue[size - 1]] = [this.queue[size - 1],this.queue[0]]
            const top = this.queue.pop()
            this.sinkMax(0)
            return top
        }
    }
```







## 题目

### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

[写过了](#mergeKOrderList) 

### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```js

var topKFrequent = function(nums, k) {
    class PriorityQueue{
        constructor(){
            this.queue=[]
        }
        getParentIndex(nodeIndex){
            return (nodeIndex-1)>>1
        }
        getLeftChildIndex(nodeIndex){
            return nodeIndex*2+1
        }
        getRightChildIndex(nodeIndex){
            return nodeIndex*2+2
        }
        getSize(){
            return this.queue.length
        }
        isVar1BiggerVar2(var1,var2){
            return var1[1]>var2[1]
        }


        swimMax(nodeIndex){
            while(nodeIndex>0){
                let parentIndex = this.getParentIndex(nodeIndex)
                if(this.isVar1BiggerVar2(this.queue[nodeIndex],this.queue[parentIndex])){
                    [this.queue[parentIndex],this.queue[nodeIndex]]=[this.queue[nodeIndex],this.queue[parentIndex]]
                    nodeIndex = parentIndex
                }else{
                    break
                }
            }
        }
        sinkMax(nodeIndex){
            const size = this.getSize()
            while(nodeIndex<size){
                let leftChildIndex = this.getLeftChildIndex(nodeIndex)
                let rightChildIndex = this.getRightChildIndex(nodeIndex)
                if(leftChildIndex<size){
                    let maxIndex=leftChildIndex
                    if(rightChildIndex<size&&this.isVar1BiggerVar2(this.queue[rightChildIndex],this.queue[leftChildIndex])){
                        maxIndex= rightChildIndex
                    }
                    if(this.isVar1BiggerVar2(this.queue[nodeIndex],this.queue[maxIndex])){
                        break
                    }else{
                        [this.queue[nodeIndex],this.queue[maxIndex]]=[this.queue[maxIndex],this.queue[nodeIndex]]
                        nodeIndex = maxIndex
                    }
                }
                else{
                    break
                }
            }
        }

        insert(node){
            this.queue.push(node)
            const size = this.getSize()
            this.swimMax(size-1)
        }

        delTop(){
            const size = this.getSize();
            [this.queue[size-1],this.queue[0]]=[this.queue[0],this.queue[size-1]]
            const max = this.queue.pop()
            this.sinkMax(0)
            return max
        }

    }
    let map = new Map()
    for(const item of nums){
        if(map.has(item)){
            let num = map.get(item)
            num++
            map.set(item,num)
        }else{
            map.set(item,1)
        }
    }
    let q = new PriorityQueue()
    const arr = map.entries()
    for(const item of arr){
        q.insert(item)
    }
    let res = []
    while(k--){
        const item = q.delTop()
        res.push(item[0])
    }
    return res
};
```





# 递归

## 递归三部曲



1. **确定递归函数的参数和返回值：** 确哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数。<mark>就跟访问服务器一样，通过入参和返回值进行交互。</mark>
   1. 关于递归函数什么时候需要返回值？这里以树为例总结如下三点：
      - 如果需要搜索==整棵==二叉树且==不用处理递归返回值==，递归函数就不要返回值。（例如[113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)）
      - 如果需要搜索==整棵==二叉树且==需要处理递归返回值==，递归函数就需要返回值。 （例如[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)）
      - 如果要搜索**==其中一条符合条件==**的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（例如[112. 路径总和](https://leetcode-cn.com/problems/path-sum/)）

2. **确定终止条件**
3. **确定单层递归的逻辑**

> 写递归的技巧： 想象我们已经处理好了一部分数据，并把他们用手挡起来，但是还有一部分等待处理，接下来思考”如何根据已经处理的数据和当前的数据来推导还没有处理的数据“就行了。



## 递归转迭代

前序递归遍历容易改成不需要栈的迭代（就把递归函数的前序所有内容写到一个循环里），而后续迭代遍历需要借助栈来完成（把递归函数的前序所有内容写到一个循环里且循环里让要操作的元素入栈，后序部分通过一个一个元素出栈来执行）。这也不难理解，由于后续遍历的主逻辑在函数调用栈的弹出过程，而前序遍历则不需要。

[点击跳到这个文档里反转链表的例子](#dfsToIterate)



## 时间复杂度

**递归相关的算法，时间复杂度这样计算（递归次数）\*（递归函数本身的时间复杂度）**。

以https://leetcode.cn/problems/generate-parentheses/submissions/491205977/本题为例

`backtrack` 就是我们的递归函数，其中没有任何 for 循环代码，所以递归函数本身的时间复杂度是 O(1)，但关键是这个函数的递归次数是多少？换句话说，给定一个 `n`，`backtrack` 函数递归被调用了多少次？

我们前面怎么分析动态规划算法的递归次数的？主要是看「状态」的个数对吧。其实回溯算法和动态规划的本质都是穷举，只不过动态规划存在「重叠子问题」可以优化，而回溯算法不存在而已。

所以说这里也可以用「状态」这个概念，**对于 `backtrack` 函数，状态有三个，分别是 `left, right, track`**，这三个变量的所有组合个数就是 `backtrack` 函数的状态个数（调用次数）。

`left` 和 `right` 的组合好办，他俩取值就是 0~n 嘛，组合起来也就 `n^2` 种而已；这个 `track` 的长度虽然取在 0~2n，但对于每一个长度，它还有指数级的括号组合，这个是不好算的。

说了这么多，就是想让大家知道这个算法的复杂度是指数级，而且不好算，这里就不具体展开了，是 `4^n / sqrt(n)`，有兴趣的读者可以搜索一下「卡特兰数」相关的知识了解一下这个复杂度是怎么算的。





## 记忆化递归

在普通的递归函数上满足以下几个条件：

1. 递归函数不依赖外部变量
2. 递归函数不改变外部变量



### 什么是记忆化和重叠子问题？

我们通过一个例子来切入：

一个人爬楼梯，每次只能爬 1 个或 2 个台阶，假设有 n 个台阶，那么这个人有多少种不同的爬楼梯方法？

思路：

由于**第 n 级台阶一定是从 n - 1 级台阶或者 n - 2 级台阶来的**，因此到第 n 级台阶的数目就是 `到第 n - 1 级台阶的数目加上到第 n - 2 级台阶的数目`。

```js
function climbStairs(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  return climbStairs(n - 1) + climbStairs(n - 2);
}
```

我们用一个递归树来直观感受以下（每一个圆圈表示一个子问题）：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-UvsGn6.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-UvsGn6.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-UvsGn6.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-UvsGn6.jpg" loading="lazy"/>
  </picture>

重叠子问题

红色表示重复的计算。即 Fib(N-2) 和 Fib(N-3) 都被计算了两次，实际上计算一次就够了。比如第一次计算出了 Fib(N-2) 的值，那么下次再次需要计算 Fib(N-2)的时候，可以直接将上次计算的结果返回。之所以可以这么做的原因正是前文提到的**我们的递归函数是数学中的函数，也就是说参数一定，那么返回值也一定不会变**，因此下次如果碰到相同的参数，我们就可以**将上次计算过的值直接返回，而不必重新计算**。这样节省的时间就等价于重叠子问题的个数。

**以这道题来说，本来需要计算 $2^n$ 次，而如果使用了记忆化，只需要计算 n 次，就是这么神奇。**

代码上，我们可以使用一个 hashtable 去缓存中间计算结果，从而省去不必要的计算。

我们使用记忆化来改造上面的代码：

```py
memo = {} #这里我使用了一个名为 memo 的哈希表来存储递归函数的返回值，其中 key 为参数，value 为递归函数的返回值。
def climbStairs(n):
  if n == 1:return 1
  if n == 2: return 2
  if n in memo: return memo[n]
  ans = func(n - 1) + func(n-2)
  memo[n] = ans
  return ans
climbStairs(10)
```



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-Pi68P9.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-Pi68P9.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-Pi68P9.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-Pi68P9.jpg" loading="lazy"/>
  </picture>

> key 的形式为 (x, y)，表示的是一个元祖。通常动态规划的参数有多个，我们就可以使用元祖的方式来记忆化。或者也可采取多维数组的形式。对于上图来说，就可使用二维数组来表示。



### 什么时候使用记忆化递归

递归中**如果**存在重复计算（我们称重叠子问题，下文会讲到），那就是使用记忆化递归（或动态规划）解题的强有力信号之一。可以看出动态规划的核心就是使用记忆化的手段消除重复子问题的计算，如果这种重复子问题的规模是指数或者更高规模，那么记忆化递归（或动态规划）带来的收益会非常大。

为了消除这种重复计算，我们可使用查表的方式。即一边递归一边使用“记录表”（比如哈希表或者数组）记录我们已经计算过的情况，当下次再次碰到的时候，如果之前已经计算了，那么直接返回即可，这样就避免了重复计算。下文要讲的**动态规划中 DP 数组其实和这里“记录表”的作用是一样的**。



# 二叉树

### 二叉树解题方法（labuladong）

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。（一般会有两种返回的情况）

无论使用哪种思维模式，你都需要思考：

**单独抽出一个二叉树节点，需要在什么时候（前/中/后序位置）做**？**它需要做什么事情？**其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。



## 一些概念

- 树的高度：节点到叶子节点的最大值就是其高度。根节点的深度究竟是1 还是 0，不同的地方有不一样的标准，leetcode的题目中都是以节点为一度，即根节点深度是1。但维基百科上定义用边为一度，即根节点的深度是0

- 树的深度：高度和深度是相反的，高度是从下往上数，深度是从上往下。

使用前序求的就是深度，使用后序求的是高度。

- 树的层：根开始定义，根为第一层，根的孩子为第二层。

- 节点的「度 degree」：节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 。



- 满二叉树：每个节点要么没有子节点，要么有两个子节点。除了最后一层每一层都被填满。
- 完全二叉树：除了最后一层外，其他所有层的节点都被填满，最后一层的节点从左到右连续填充，不能有空缺。
- 完美二叉树：每个内部节点都有两个子节点，并且所有叶子节点都位于同一层上。每一层都被填满。

完美二叉树的 节点数跟树高呈指数关系： `nodeSum = Math.pow(2, height) - 1`

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012095839289.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012095839289.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012095839289.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012095839289.png" loading="lazy"/>
  </picture>

完全二叉树的作用：

1. 我们可以给完全二叉树编号，这样数组中的父子之间就可以通过编号轻松求出。（比如二叉堆就是完全二叉树的一个应用。）
2.   它的所有子树都是完全二叉树，有的子树是 perfect binary tree



二叉搜索树

> BST 相关的问题，都会用上它的性质：左小右大 或者 利用中序遍历的特性（**二叉搜索树的中序遍历的结果是一个有序数组**。）。
>
> BST 的性质如下：
>
> - 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
> - 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
> - 左、右子树也分别为二叉搜索树；
> - 没有键值相等的节点；



## 二叉树的退化[¶](https://www.hello-algo.com/chapter_tree/binary_tree/#714)

图 7-8 展示了二叉树的理想与退化状态。当二叉树的每层节点都被填满时，达到“完美二叉树”；而当所有节点都偏向一侧时，二叉树退化为“链表”。

- 完美二叉树是理想情况，可以充分发挥二叉树“分治”的优势。
- 链表则是另一个极端，各项操作都变为线性操作，时间复杂度退化至 O(n) 。

[<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-FhC8RO.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-FhC8RO.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-FhC8RO.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-FhC8RO.png" loading="lazy"/>
  </picture>](https://www.hello-algo.com/chapter_tree/binary_tree.assets/binary_tree_best_worst_cases.png)



## 二叉树的数组表示

通过层序遍历得出：

完全二叉树：

- 如果子节点的数组下标是i，那么其父节点就是（i-1）/2
- 如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2



其它二叉树也满足这个公式，但是得用null表示出空节点。



#### 优势与局限性[¶](https://www.hello-algo.com/chapter_tree/array_representation_of_tree/#733)

二叉树的数组表示主要有以下优点。

- 数组存储在连续的内存空间中，对缓存友好，访问与遍历速度较快。
- 不需要存储指针，比较节省空间。
- 允许随机访问节点。

然而，数组表示也存在一些局限性。

- 数组存储需要连续内存空间，因此不适合存储数据量过大的树。
- 增删节点需要通过数组插入与删除操作实现，效率较低。
- 当二叉树中存在大量 None 时，数组中包含的节点数据比重较低，空间利用率较低。

## 前中后序

#### 概念

> 前中后序指的是处理根结点的顺序
>
> **前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候**

<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/1.jpeg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/1.jpeg?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/1.jpeg" alt="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/1.jpeg" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg" alt="https://labuladong.gitee.io/algo/images/%e4%ba%8c%e5%8f%89%e6%a0%91%e6%94%b6%e5%ae%98/2.jpeg" loading="lazy"/>
  </picture>

前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的。因为前序位置是刚刚进入节点的时刻，后序位置是即将离开节点的时刻。

**这就意味着前序位置的代码只能从函数参数中获取父节点传递来的数据，而==后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。

#### 用迭代来实现前中后序遍历 

<mark>本质是用栈模拟了递归，递归利用了天然的函数栈。</mark>

思路：

1. 使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。栈里面存对象，对象里包含了该节点和该节点的颜色。

2. 如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。

3. 如果遇到的节点为灰色，则将节点的值输出。

(实际上 WHITE 就表示的是递归中的第一次进入过程，Gray 则表示递归中的从叶子节点返回的过程。 因此这种迭代的写法更接近递归写法的本质。)

```javascript
/*前序、中序、后序遍历只需调整左右子节点的入栈顺序即可，其他部分无需任何变化*/

/*前序遍历*/
var preorderTraversal = function(root) {
    const res = []
    const WHITE=0,GREY=1
    const stack= [{color:WHITE,node:root}]
    while(stack.length){
        const {color,node} = stack.pop()
        if(node==null) continue
        if(color===WHITE){ // 注意插入的顺序是反过来的（因为是栈）
            stack.push({color:WHITE,node:node.right})
            stack.push({color:WHITE,node:node.left})
            stack.push({color:GREY,node:node})
        }else{
            res.push(node.val)
        }
    }
    return res
};

/*后序遍历*/
var postorderTraversal = function(root) {
    const res=[]
    const WHITE=0,GREY=1
    const stack=[{color:WHITE,node:root}]
    while(stack.length){
        const {color,node}=stack.pop()
        if(node==null) continue
        if(color===WHITE){ // 注意插入的顺序是反过来的（因为是栈）
            stack.push({color:GREY,node:node})
            stack.push({color:WHITE,node:node.right})
            stack.push({color:WHITE,node:node.left})
        }else{
            res.push(node.val)
        }
    }    
    return res
};

/*中序遍历*/
var inorderTraversal = function(root) {
    const res = []
    const WHITE = 0, GRAY = 1 
    const stack = [{ color: WHITE, node: root }] 
    while (stack.length) { // 注意插入的顺序是反过来的（因为是栈）
        const { color, node } = stack.pop()
        if (!node) continue
        if (color === WHITE) {
            stack.push({color:WHITE,node:node.right})
            stack.push({color:GRAY,node:node})
            stack.push({color:WHITE,node:node.left})
        } else {
            res.push(node.val)
        }
    }
    return res
};
```







## 二叉树解题方法（Charley）

如果需要删除 且 会有可能删掉根节点，常常用到dummy。dummy.left = root

### 深度优先搜索（dfs）

#### 简介

树和子树的关系，类似原问题和子问题的关系，所以树天然地具有递归的特点。（Depth-First-Search，DFS）DFS是一种用于遍历树或图的算法，通常借助于栈来完成（函数调用栈也算）， 适合做一些暴力枚举的题目



#### 算法模板

##### 通用的 DFS 模板

visited 是为了防止由于环的存在造成的死循环，就记录访问过的就不要再访问了。

```js
const visited = {}
function dfs(i) {
	if (满足特定条件）{
		// 返回结果 or 退出搜索空间
	}

	visited[i] = true // 将当前状态标为已搜索
	for (根据i能到达的下个状态j) {
		if (!visited[j]) { // 如果状态j没有被搜索过
			dfs(j)
		}
	}
}
```



##### 树的 DFS 模板

我们知道树是不存在环的，因此树的题目大多数不需要 visited，除非你对树的结构做了修改，比如就左子树的 left 指针指向自身，此时会有环。

因此一个树的 DFS 模板是：

```js
function dfs(root) {
	if (满足特定条件）{
		// 返回结果 or 退出搜索空间
	}
	for (const child of root.children) {
        dfs(child)
	}
}
```

##### 二叉树的模板

而几乎所有的题目几乎都是二叉树，因此下面这个模板更常见。

```js
function dfs(root) {
	if (满足特定条件）{
		// 返回结果 or 退出搜索空间
	}
    dfs(root.left)
    dfs(root.right)
}
```

而我们不同的题目除了 if (满足特定条件部分不同之外)，还会写一些特有的逻辑，这些逻辑写的位置不同，效果也截然不同（即前中后序）。



（下面这一段可删之）

- 就是类似回溯的模板，不同点在于：

  1. 把for循环改成二叉树形式 （因为二叉树的选择列表就是两个分支要么左要么右）
  2. 选择和撤销选择改成在（前中后）哪个位置做

- 前序是自顶向下的做事情，后序是自底向上的做事情。（即后序一定是把树先遍历了一遍了再做事情，而前序做完事情再往下遍历，所以不一定会把树遍历完）

  **单独抽出一个二叉树节点，需要在什么时候（前/中/后序位置）做**？**它需要做什么事情？**

  > （选前中后序位置时注意：前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据。）

- ```javascript
  //二叉树遍历
  function traverse(node) {
      if (root == null) { 
        // 到达叶子节点的下一层
        ……
          return;
      }
      // 前序位置   （如果在前序位置找某个值，找到了就返回的话，那么不一定会遍历整颗树）
      traverse(root.left);
      // 中序位置
      traverse(root.right);
      // 后序位置		（如果在后序位置找某个值，找到了就返回，一定是早就遍历了一遍先了，再从叶子开始往上找的。因为后序就是要先遍历到底再往上找。）
  }
  ```



#### 二叉树dfs的六个技巧

##### dfs（root）

dfs函数的形参名叫root。这样写相当于把 root 当成是 current 指针来用了。最开始 current 指针指向 root，然后不断修改指向树的其它节点。这样就概念就简化了，只有一个当前指针的概念。如果形参名叫 node，就是当前指针 + root 指针两个概念了。





##### 前中后序

中序除了二叉搜索树，其他地方用的并不多。

如果是前序遍历，那么你可以想象上面的节点都处理好。如果是后序遍历，那么你可以想象下面的树都处理好了

- 如果你能使用参数和节点本身的值来决定什么应该是传递给它子节点的参数，那就用前序遍历。
- 如果对于树中的任意一个节点，如果你知道它子节点的答案，你能计算出当前节点的答案，那就用后序遍历（通过返回值把值传回给其父亲节点）。
- 如果遇到二叉搜索树则考虑中序遍历

​	



##### 虚拟节点

两种情况下使用：

1. 当你需要对树的根节点进行修改的时候。
2. 题目需要返回树中间的某个节点（不是返回根节点）。你可以新建一个虚拟头，然后让虚拟头在恰当的时候（刚好指向需要返回的节点）断开连接，这样我们就可以返回虚拟头的 next 就 ok 了。



##### 参数扩展

用在当你需要传递额外信息给==子节点==时。所以参数扩展通常都是用于前序遍历。而且参数无论在什么位置拿都一定是只拿到沿着父亲那条线的那些参数值，一定不会拿到其他分支线上的参数值。

携带父亲或者爷爷的信息

```python
def dfs(root, parent):
    if not root: return
    dfs(root.left, root)
    dfs(root.right, root)
```





##### 全局变量

1. 携带路径信息，可以是路径和或者具体的路径数组等。

2. 二叉搜索树用于记录前一个节点

题目说 ”从任意节点出发.......“ 看完这个描述大概率是要么全局记录最大值（每一次都对最大值进行更新），要么双递归。

**双递归**是指第一个递归是指遍历所有节点，第二个递归是指方法函数。



##### 返回值

接收返回值的时候 即整个函数最后return的时候 就是完全离开这个节点，把这个节点的信息交给他的父节点





### 	广度优先搜索（bfs）

#### 简介

BFS 也是图论中算法的一种，在数据结构上通常采用队列结构。 适合找**最短（或最远）距离/路径**和**某一个距离的目标**。

**BFS 的核心在于求最短问题时候可以提前终止，层次遍历是一种不需要提前终止的 BFS 的副产物**。（如果找到任意一个满足条件的节点就好了而不必最近的，那DFS 和 BFS 是一样的。）





#### 算法模板

##### 通用BFS模板(非二叉树)

```js
/*层序遍历框架*/    
const visited = {} //记录这个元素是否访问过，访问过就不要再访问了，不然就死循环了。
function bfs() {
	let q = new Queue()
	q.push(初始状态)
	while(q.length) {
		let i = q.pop()
        if (visited[i]) continue
        if (i 是我们要找的目标) return 结果
		for (i的可抵达状态j) {
			if (j 合法) {
				q.push(j)
			}
		}
    }
    return 没找到
}
```



##### 二叉树BFS模板（**标记层**）

如果我需要求距离某个节点距离等于 k 的所有节点（小于 k 或者 大于 k 同理），这个时候第几步这个信息就要被记录了。这时用标记层的模板。

```python
class Solution:
    def bfs(k):
        # 使用双端队列，而不是数组。因为数组从头部删除元素的时间复杂度为 N，双端队列的底层实现其实是链表。
        queue = collections.deque([root])
        # 记录层数
        steps = 0
        # 需要返回的节点
        ans = []
        # 队列不空，生命不止！
        while queue: // 这个循环遍历所有层
            size = len(queue)
            # 遍历当前层的所有节点
            for _ in range(size): //这个循环遍历这一层的所有节点
                node = queue.popleft()
                if (step == k) ans.append(node)
                if node.right:
                    queue.append(node.right)
                if node.left:
                    queue.append(node.left)
            # 遍历完当前层所有的节点后 steps + 1
            steps += 1
        return ans
```





##### **二叉树BFS模板（不标记层**）

如果我需要求的是最短距离/路径，我是不关心我走到第几步的，这个时候可是用不标记层的模板。

```js
function bfs(k){
     let queue = []
     //队列不空，生命不止！
     while (queue.length){ 
         node = queue.popleft()
         # 由于没有记录 steps，因此我们肯定是不需要根据层的信息去判断的。否则就用带层的模板了。
         if (node 是我们要找到的) return node
         if node.right:
             queue.append(node.right)
         if node.left:
             queue.append(node.left)
     }

     return -1
}
    
```



## 搜索类例题

### BFS例题

#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```js
// 本题就是BFS的思路，迭代和递归都能做
var isSymmetric = function(root) {
    function compare(left,right){
        if(left===right){
            return true
        }else if(!left||!right||right.val!==left.val){
            return false
        }
        const outside = compare(left.left,right.right)
        const inside = compare(left.right,right.left)
        return outside&&inside
    }

    if(!root) return true
    return compare(root.left,root.right)
};

var isSymmetric = function(root) {
    if(!root) return true
    const queue = [root.left,root.right]
    while(queue.length){
        const left = queue.shift()
        const right = queue.shift()
        if(left===right){
             continue
        }else if(!left||!right||right.val!==left.val){
            return false
        }
        queue.push(left.left)
        queue.push(right.right)
        queue.push(left.right)
        queue.push(right.left)
    }
    return true
};
```





#### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

```js
// BFS
var findBottomLeftValue = function(root) {
    const queue = []
    queue.push(root)
    let result = []
    while(queue.length){
        result=[]
        let length = queue.length
        while(length--){
            const cur=queue.shift()
            result.push(cur.val)
            cur.left&&queue.push(cur.left)
            cur.right&&queue.push(cur.right)
        }
    }
    return result.shift()
};

//DFS
var findBottomLeftValue = function(root) {
    let res = {n:root,d:0}
    function traverse(node,depth){
        if(!node) return null
        const l = traverse(node.left,depth+1)
        const r = traverse(node.right,depth+1)
        if(l===null&&r===null){
            if(res.d<depth){
                res = {n:node,d:depth}
            }
        }
    }
    traverse(root,0)
    return res.n.val
};
```







#### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```javascript
var minDepth = function(root) { 
  let queue = [], step = 1
  if (root) queue.push(root)
  else {
    return 0
  }
  while (queue.length) {
    let size = queue.length
    for (let i = 0; i < size; i++){
      let cur = queue.shift()
      if (cur.left === null && cur.right === null) return step
      if (cur.left) queue.push(cur.left)
      if(cur.right) queue.push(cur.right)
    }
    step++
  }
};
```

```javascript
/*可以用dfs来做但是没那么好理解，自己练习的时候做做而已*/
var minDepth = function (root) { 
  const backtrack = (node) => {
    if (!node.left && !node.right) {
      return 1
    }
    let leftStep=node.left?backtrack(node.left):Number.MAX_SAFE_INTEGER
    let rightStep=node.right?backtrack(node.right):Number.MAX_SAFE_INTEGER
    let step=1+Math.min(leftStep,rightStep)
    return step
  }
  if(!root) return 0
  return  backtrack(root)
};
```



#### [863. 二叉树中所有距离为 K 的结点](https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/)

```ts
function distanceK(root: TreeNode | null, target: TreeNode | null, k: number): number[] {
    const nodeParentMap = new Map() //用hashMap来记录每个节点的父节点

      // 遍历所有节点，记录每个节点的父节点
    function traverse(root,parent){
        if(root==null) return
        nodeParentMap.set(root,parent)
        traverse(root.left,root)
        traverse(root.right,root)
    }
    traverse(root,null)

    // 从目标节点开始向父节点、左右子节点扩散
    let distance=0 //距离目标节点的距离
    const res=[],visited=new Set()
    const queue=[target]
    while(queue.length){ // 这个循环遍历所有层
        let len = queue.length
        while(len--){ //这个循环遍历这一层的所有节点
            const cur=queue.shift()
            visited.add(cur)
            if(distance==k){
                res.push(cur.val)
            }else{
                const parent = nodeParentMap.get(cur)
                if(parent&&!visited.has(parent)){
                    queue.push(parent)
                }
                
                if(cur.left&&!visited.has(cur.left)){
                    queue.push(cur.left)
                }
                if(cur.right&&!visited.has(cur.right)){
                    queue.push(cur.right)
                }
            }
        }
        distance++
    }
    return res
};
```







#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

该题dfs也行，见递归那里

```javascript
var isSymmetric = function(root) {
    if(!root) return false
    const queue=[]
    queue.push(root.left)
    queue.push(root.right)
    while(queue.length){
        const left = queue.shift()
            const right = queue.shift()
            if(!left&&!right) continue //要么都是null
            if(!left||!right||(left.val!==right.val)) {return false} //有一个是null或者两个的值不相等则返回false

            left&&queue.push(left.left)
            right&&queue.push(right.right)
            left&&queue.push(left.right)
            right&&queue.push(right.left)
    }
    return true
};
```





#### [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```javascript
var largestValues = function(root) {
    let res=[]
    const levelTraverse=(node)=>{
        if(!node) return //如果传进来的参数是空的，直接return了，都不用走下面的逻辑了
        let queue=[]
        queue.push(node)
        while(queue.length){
            let length=queue.length//存下此时队列的长度
            let max=Number.MIN_SAFE_INTEGER
            while(length--){
                let cur=queue.shift()
                max=Math.max(max,cur.val)
                cur.left&&queue.push(cur.left)
                cur.right&&queue.push(cur.right)
            }
            res.push(max)
        }
    }
    levelTraverse(root)
    return res
};
```

#### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

```javascript
var zigzagLevelOrder = function(root) {
    if(!root) return []
    const queue=[],result=[]
    let leftToRight=false
    queue.push(root)
    while(queue.length){
        leftToRight = !leftToRight
        const len = queue.length,levelResult=[]
        for(let i=0;i<len;i++){
            const cur = queue.shift()
            if(leftToRight){
                levelResult.push(cur.val)
            }else{
                levelResult.unshift(cur.val)
            }
            cur.left&&queue.push(cur.left)
            cur.right&&queue.push(cur.right) 
        }
        result.push(levelResult)
    }
    return result
};
```





### DFS例题

#### 基本操作

##### 计算这棵树所有节点的和

```js
function calculateTreeSum(root){
    if(root==null) return 0
    let leftChildSum = calculateTreeSum(root.left)
    let rightChildSum = calculateTreeSum(root.right)
    return leftChildSum+rightChildSum+root.val
}
```



##### 序列化输出二叉树结构

这不是leetcode，是我自己想实现一下的

```js
var serialize = function(root) {
   let res=''
   const traverse=function(node){
       if(!node) {
        res+='null'
        return undefined
       }
       res += '{"val":' + node.val + ','
       res+='"left":'
       traverse(node.left)
       res+=',"right":'
       traverse(node.right)
       res+='}'
   } 
   traverse(root)
   return res
};
console.log(serialize(root)) === console.log(JSON.stringify(root))
```





#### 遍历

##### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

```javascript
 // DFS
var invertTree = function(root) {
    function traverse(node){
        if(node === null){
            return null
        }

        const left = traverse(node.left)
        const right = traverse(node.right)

        node.right = left
        node.left = right
        return node
    }
    return traverse(root)
};

// BFS
var invertTree = function(root){
    const queue = []
    root&&queue.push(root)
    while(queue.length){
        const len = queue.length
        for(let i=0;i<len;i++){
            const cur = queue.shift()
            const left = cur.left
            const right = cur.right
            cur.left = right
            cur.right = left
            cur.left&&queue.push(cur.left)
            cur.right&&queue.push(cur.right)
        }
    }
    return root
}
```





##### [1372. 二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)

对于这种交错类的题目，一个好用的技巧是使用 -1 和 1 来记录方向，这样我们就可以通过乘以 -1 得到另外一个方向。

> [886. 可能的二分法]() 和 [785. 判断二分图]() 都用了这个技巧。

用代码表示就是：

`next_direction = cur_direction * - 1`

但我做这道题并没有用到以上这个技巧

```js
 /*
 我们可以为每个节点缓存两个值，一个l表示到达当前节点时，该节点为左子树时的路径数，一个r表示该节点为右子树时的到达路径。
 当然，一个节点要么是左子树，要么是右子树，所以l和r其中只有一个有值。
 那么在遍历该节点的子节点时，如果子节点是左子树，那么它的l值就是父节点的r值加1. 如果是右子树，就是父节点的l值加1.
 */
var longestZigZag = function(root) {
    let maxLength = 0

    function traverse(root,l,r){
        if(root==null) {
            return 
        }
        maxLength = Math.max(maxLength,l,r)
        traverse(root.left,r+1,0)
        traverse(root.right,0,l+1)
        return
    }
    traverse(root,0,0)
    return maxLength
};
```



##### [971. 翻转二叉树以匹配先序遍历](https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal/)

```js
var flipMatchVoyage = function(root, voyage) {
    let res = [];
    let p = -1;
    function dfs(node = root) {
        if (node === null) return;
        if (res === null) return;
        p += 1;
        if (node.val !== voyage[p]) {
            res = null; // 匹配失败
            return;
        }
        if (node.left === null && node.right === null) return;
        if ((node.left === null && node.right.val === voyage[p+1]) || (node.left !== null && node.left.val === voyage[p+1])) {
        } else {
            // 先右后左
            res.push(node.val);
            [node.left,node.right]=[node.right,node.left]
        }
        dfs(node.left);
        dfs(node.right);
    }
    dfs();
    return res === null ? [-1] : res;
};
```



##### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)

```js
var verticalTraversal = function(root) {
    const nodes=[]
    function traverse(root,row,col){//从根节点开始，对整棵树进行一次遍历，在遍历的过程中使用数组nodes 记录下每个节点的行号 row，列号 col 以及值 value
        if(root==null) return
        nodes.push([root.val,row,col])
        traverse(root.left,row+1,col-1)
        traverse(root.right,row+1,col+1)
    }
    traverse(root,0,0)

    if(nodes.length==0) return nodes
  
    nodes.sort((a,b)=>{ //按照 col 为第一关键字升序，row 为第二关键字升序，value 为第三关键字升序，对所有的节点进行排序
        if(a[2]!==b[2]){
            return a[2]-b[2]
        }else if(a[1]!==b[1]){
            return a[1]-b[1]
        }else{
            return a[0]-b[0]
        }
    })
    
    let res=[]
    for(let i=0,lastCol = Number.MIN_SAFE_INTEGER;i<nodes.length;i++){//对 nodes 进行一次遍历，并在遍历的过程中记录上一个节点的列号 lastcol。如果当前遍历到的节点的列号 col 与 lastcol 相等，则将该节点放入与上一个节点相同的数组中，否则放入不同的数组中。
        if(nodes[i][2]===lastCol){
            res[res.length-1].push(nodes[i][0])
        }else{
            res.push([nodes[i][0]])
            lastCol=nodes[i][2]
        }
    }
    return res
};
```







#### 虚拟节点

##### [814. 二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/)

```js
var pruneTree = function(root) {
    let dummy = new TreeNode(-1,root,null) //因为有可能把根节点也移除了,所以来个虚拟节点
    function dfs(root){
        if(root==null) return null
        const l = dfs(root.left)
        const r = dfs(root.right)
        if(l<=0) root.left=null
        if(r<=0) root.right = null
        return l+r+root.val
    }
    dfs(dummy)
    return dummy.left
};
```



##### [1325. 删除给定值的叶子节点](https://leetcode.cn/problems/delete-leaves-with-a-given-value/)

```js
var removeLeafNodes = function(root, target) {
    const dummy = new TreeNode(1.1,root,null)
    function dfs(root){
        if(root==null) return null
        root.left=dfs(root.left)
        root.right=dfs(root.right)
        if(root.left==null&&root.right==null&&root.val==target) return null
        else{
            return root
        }
    }
    dfs(dummy)
    return dummy.left
};
```

#### 参数扩展

##### [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/)

```js
var goodNodes = function(root) {
    let sum = 0
    function traverse(root,max){ // 参数max表示从前面到现在这个节点的最大值
        if(root==null) return 
        if(root.val>=max) sum++
        max=Math.max(max,root.val)
        traverse(root.left,max)
        traverse(root.right,max)
    }
    traverse(root,Number.MIN_SAFE_INTEGER)
    return sum
};
```







##### <span id="1026canshukuozhan">[1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)</span>

```js
var maxAncestorDiff = function(root) {
    let res=0
    function dfs(root,lower,upper){
        if(root==null) return 
        res = Math.max(res,Math.abs(root.val-lower),Math.abs(root.val-upper)) //拿到的参数一定是沿着父亲那条线的，不会是其他分支的。
        if(root.val<lower) lower=root.val
        if(root.val>upper) upper=root.val
        dfs(root.left,lower,upper)
        dfs(root.right,lower,upper)
    }
    dfs(root,root.val,root.val)
    return res
};
```

[方法二（利用返回值）](#1026fanhuizhi)





##### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```js
//前序遍历
var isSymmetric = function(root) {
    function check(left,right){
        if(left==null&&right==null){
            return true
        }else if(left==null||right==null){
            return false
        }else{
            if(left.val!=right.val) return false
            else{
                if(check(left.left,right.right)&&check(left.right,right.left)) return true
                else return false
            }
        }
    }
    return check(root.left,root.right)
};

//层序遍历
var isSymmetric = function(root) {
    const queue = [root.left,root.right]
    while(queue.length){
        let len = queue.length
        while(len){
            len-=2
            const left = queue.shift()
            const right = queue.shift()
            if(left==null&&right==null){
                continue
            }else if(left==null||right==null){
                return false
            }else {
                if(left.val!=right.val) return false
                else queue.push(left.left,right.right,left.right,right.left)
            }
        }
    }
    return true
};
```





#### 全局变量





##### [783. 二叉搜索树节点最小距离](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

```js
var minDiffInBST = function(root) {
    let min = Number.MAX_SAFE_INTEGER
    let pre = null
    function dfs(root){
        if(root==null) return 
        dfs(root.left)
        if(pre){
            const cha = Math.abs(pre.val-root.val)
            if(cha<min){
                min=cha
            }
        }
        pre = root
        dfs(root.right)
        return
    }
    dfs(root)
    return min
};
```





##### [563. 二叉树的坡度](https://leetcode.cn/problems/binary-tree-tilt/)

```js
var findTilt = function(root) {
    let res = 0 //记录坡度
    function calculateTreeSum(root){
        if(root==null) return 0
        let leftChildSum = calculateTreeSum(root.left)
        let rightChildSum = calculateTreeSum(root.right)

        res += Math.abs(leftChildSum-rightChildSum)  //不要这一行就是一个正常计算 整棵树节点值的和 的算法

        return leftChildSum+rightChildSum + root.val
    }
    calculateTreeSum(root)
    return res
};
```













#### 返回值

##### <span id="1026fanhuizhi">[1026. 节点与其祖先之间的最大差值](https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/)</span>

```js
var maxAncestorDiff = function(root) {
    let res = 0
    function dfs(root){ //找到以当前节点为根节点的树的最大和最小值,然后比较 最大值跟根节点相减 和 最小值跟根节点相减 的值
        if(root==null) return [Number.MAX_SAFE_INTEGER,Number.MIN_VALUE]
        let [leftMin,leftMax] = dfs(root.left)
        let [rightMin,rightMax] = dfs(root.right)
        let rootMin = Math.min(leftMin,rightMin,root.val),rootMax = Math.max(leftMax,rightMax,root.val)
        res = Math.max(rootMax-root.val,root.val-rootMin,res)
        return [rootMin,rootMax]
    }
    dfs(root)
    return res
};
```

[方法二（利用参数扩展）](#1026canshukuozhan)



##### [865. 具有所有最深节点的最小子树](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/)

```js
/*
*题目本质上是让我们求那些「最深」的叶子节点的最近公共祖先
*你想想，一个节点需要知道哪些信息，才能确定自己是最深叶子节点的最近公共祖先？
*1.它需要知道自己的左右子树的最大深度
*2.如果左右子树一样深，那么当前节点就是最近公共祖先；
*3.如果左右子树不一样深，那么最深叶子节点的最近公共祖先肯定在左右子树上。
*/
var subtreeWithAllDeepest = function(root) {
    function dfs(root,depth){
        if(root==null) return [null,depth]
        const [leftResNode,leftResdepth] = dfs(root.left,depth+1)
        const [rightResNode,rightResdepth] = dfs(root.right,depth+1)
        if(leftResdepth===rightResdepth){
            return [root,leftResdepth]
        }else if(leftResdepth>rightResdepth){
            return [leftResNode,leftResdepth]
        }else{
            return [rightResNode,rightResdepth]
        }
    }
    const [res,depth] = dfs(root,0)
    return res
};
```









#### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

> **平时我们解二叉树的题目时，已经习惯了通过节点的左右孩子判断本节点的属性，而本题我们要通过节点的父节点判断本节点的属性。**
>
> 希望通过这道题目，可以扩展大家对二叉树的解题思路。

```javascript
var sumOfLeftLeaves = function (root) {
  let sum=0
  const backtrack = (node) => {
    if(!node) return
    if (node.left && node.left.left == null && node.left.right == null) sum += node.left.val
    
    backtrack(node.left)
    backtrack(node.right)
    return
  }
  backtrack(root)
  return sum
};

// 我的方法：
var sumOfLeftLeaves = function(root) {
    let res = 0
    function traverse(node){
        if(!node){
            return null
        }
        const l = traverse(node.left)
        const r = traverse(node.right)
        if(l===null&&r===null){
            return 'yezi'
        }else if(l==='yezi'){
            res+=node.left.val
        }
    }
    traverse(root)
    return res
};
```



#### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

```javascript
var isSameTree = function(p, q) {
    if(!p||!q) return p==q
    if(p.val!=q.val) return false
    
    return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right)
};
```

```javascript
/*JS奇技淫巧：站前端的角度这道题可以变相理解为判断两个对象是否相等*/
var isSameTree = function(p, q) {
    return JSON.stringify(p) === JSON.stringify(q)
};
```



#### [572. 另一棵树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

```javascript
var isSubtree = function(root, subRoot) {
    const backtrack = (node,subNode) => { //这个函数就是 100.相同的树 的代码
        if(!node||!subNode) return node==subNode
        if(node.val!=subNode.val) return false
        return backtrack(node.left,subNode.left)&&backtrack(node.right,subNode.right)
    }
    const findEntrance = (node)=>{
        if(!node) return false
        if(node.val==subRoot.val) {
            if(backtrack(node,subRoot)) return true//找到一个入口就去判断是否为同个树，判断完发现不是同个树就继续往下找直到主树被找完为止
        }
        return findEntrance(node.left)||findEntrance(node.right)
    }

    return findEntrance(root)
};
```







#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

（用层序遍历更好理解）

```javascript
var maxDepth = function(root) {
  const backtrack = (node) => {
    if (!node.left && !node.right) return 1
    
    let leftStep=node.left?backtrack(node.left):-1
    let rightStep = node.right ? backtrack(node.right) : -1
    let step = 1 + Math.max(leftStep, rightStep) //后序遍历其实是在算高度，只不过刚好根结点的高度就是树的最大深度
    return step
  }
  if (!root) return 0
  return backtrack(root)
};
```



```javascript
var maxDepth = function(root) {
  const backtrack = (node) => {
    if(!node)return 0
    if (!node.left && !node.right) return 1
    
    let leftStep=backtrack(node.left)
    let rightStep =backtrack(node.right)
    let step = 1 + Math.max(leftStep, rightStep)
    return step
  }
  return backtrack(root)
};
```



```javascript
//思路一：遍历二叉树得到答案的思路
var maxDepth = function(root) {
    let res=0,depth=0
    traverse(root)
    function traverse(node){
        if(!node){
            res=Math.max(res,depth)
            return undefined
        }
        depth++
        traverse(node.left)
        traverse(node.right)
        depth--
    }
    return res
};
```

```javascript
//思路二：分解问题计算答案的思路  （分解成子树的最大高度）
var maxDepth = function(root) {
    if(!root){
        return 0
    }

    let leftMax = maxDepth(root.left)
    let rightMax = maxDepth(root.right)
    return Math.max(leftMax,rightMax)+1
};
```



#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

（层序遍历更好理解）

> 这道题怎么做呢？来默念二叉树解题总纲：
>
> **1、这题能不能用「遍历」的思维模式解决**？
>
> 很显然，一定可以。
>
> 每个节点要做的事也很简单，把自己的 `next` 指针指向右侧节点就行了

```javascript
//思路一
var connect = function(root) {
    const traverse=function(node1,node2){
        if(!node1||!node2){
            return 
        }
        //每次遍历将传入的两个节点穿起来
        node1.next=node2

        traverse(node1.left,node1.right)
        traverse(node2.left,node2.right)
        traverse(node1.right,node2.left)
    }
    if(root){
        traverse(root.left,root.right)
    }
    return root
};
```



#### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

```javascript
var isBalanced = function(root) {
    function traverse(node){
        if(!node) return 0
        const left = traverse(node.left)
        const right = traverse(node.right)
        if(left===false||right===false){
            return false
        }
        if(Math.abs(left-right)>1) return false
        const cur = Math.max(left,right)+1
        return cur
    }
    if(traverse(root)===false){
        return false
    }else{
        return true
    }
};
```



#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

> **如果一个节点能够在它的左右子树中分别找到`p`和`q`，则该节点为`LCA`节点**。

```javascript
 // 用后序遍历才能知道这个节点的子节点里是否包含p和q。（后序遍历才知晓该节点的子节点情况）
var lowestCommonAncestor = function(root, p, q) {
    let hasP = false,hasQ = false,res = null
    function traverse(node){
        if(!node||res!==null) {
            return [false,false]
        }
        const [lhp,lhq] = traverse(node.left)
        const [rhp,rhq] = traverse(node.right)
        const curp = node.val===p.val
        const curq = node.val===q.val
        hasP = lhp||rhp||curp
        hasQ = lhq||rhq||curq
        if(hasP&&hasQ&&res===null){
            res = node
        }
        return [hasP,hasQ]
    }
    traverse(root)
    return res
}

// 保证了p和q一定在树中，才能这么做
var lowestCommonAncestor = function(root, p, q) {
    function traverse(node){
        if(!node) {
            return null
        }
        if(node.val===p.val||node.val===q.val){
            return node
        }
        const l = traverse(node.left)
        const r = traverse(node.right)
        if(l&&r){
            return node
        }
        return l||r
    }
    return traverse(root)
}
```

leetcode 1676 与之一样的只不过是两个节点变成了很多节点。（记得判断某个东西是否存在用哈希表）



#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```javascript
//思路二
//定义：传入一个根节点，将以此为根的树拉成链表
var flatten = function(root) {
    if(!root) return undefined
    
    flatten(root.left)
    flatten(root.right)

    //后序位置
    let left=root.left
    let right=root.right
    root.left=null
    root.right=left
    let p=root //p是个移动的指针,从这里开始其实就是做链表了
    while(p.right){
        p=p.right
    }
    p.right=right//把right插到最后面
};
```



#### [652. 寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

```javascript
var findDuplicateSubtrees = function(root) {
    let map=new Map(),res=[]
    let traverse=function(node){
        if(!node) return '#'
        let key='&'+node.val+traverse(node.left)+traverse(node.right)//key就是子树，同时也是map里的键值
        let count=map.get(key)||0
        if(count==1){// 保证多次重复也只会被加入结果集一次
            res.unshift(node)
        }
        map.set(key,count+1)
        return key
    }
    traverse(root)
    return res
};
```



#### 回溯

##### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```javascript
var binaryTreePaths = function(root) {
    const res = []
    const curPath = []
    function traverse(node){
        if(!node) return null

        curPath.push(node.val)
        const l = traverse(node.left)
        const r = traverse(node.right)
        if(l===null&&r===null){ // 只有都是null的时候才会相等
            res.push(curPath.join('->'))
        }
        curPath.pop()
    }   
    traverse(root)
    return res
};
```





##### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```javascript
var hasPathSum = function(root, targetSum) {
    let sum = 0
    function traverse(node){
        if(!node){
            return null
        }
        sum+=node.val
        const l = traverse(node.left)
        const r = traverse(node.right)
        if(l===null&&r===null){
            if(sum===targetSum) return true
        }
        if(l===true||r===true){
            return true
        }
        sum-=node.val
        return sum
    }
    
    return traverse(root)===true?true:false
};
```



##### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```javascript
var pathSum = function(root, targetSum) {
    const res = []
    const curSumArr = []
    let curSum = 0
    function traverse(node){
        if(!node) return null
        curSum+=node.val
        curSumArr.push(node.val)
        const l = traverse(node.left)
        const r = traverse(node.right)
        if(l===null&&r===null){
            if(curSum===targetSum){
                res.push(curSumArr.slice())
            }
        }
        curSum-=node.val
        curSumArr.pop()
    }
    traverse(root)
    return res
};
```



##### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

```javascript
var sumNumbers = function(root) {
    const res = []
    let num=[]
    function traverse(root){
        if(root==null) return
        if(!root.left&!root.right) {
            num.push(root.val)
            res.push((num.join(''))*1)
            num.pop()
            return
        }
        num.push(root.val)
        traverse(root.left)
        traverse(root.right)
        num.pop()
    }
    traverse(root)
    return res.reduce((pre,cur)=>cur+pre,0)
};
```





#### 完全二叉树

完全二叉树的作用：（做题就跟这两个相关）

1. 我们可以给完全二叉树编号，这样数组中的父子之间就可以通过编号轻松求出。（比如二叉堆就是完全二叉树的一个应用。）
2.   它的所有子树都是完全二叉树，有的子树是 perfect binary tree

###### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

```javascript
/*
对于一个完全二叉树 complete binary tree：
  它的所有子树都是完全二叉树
  有的子树是 perfect binary tree
  perfect binary tree 的节点个数很好计算：2^h-1，h为高度
  如果不是 perfect binary tree，那就是规模小一点的完全二叉树，递归处理。
*/
var countNodes = function(root) {
    if(!root) return null
    let lH = rH= 0,left=right=root
    while(left){
        lH++
        left=left.left
    }
    while(right){
        rH++
        right=right.right
    }
    if(lH===rH) { //说明是一个完全二叉树
        return 2**rH-1
    }
    return 1+countNodes(root.left)+countNodes(root.right)
};
```

###### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

```js
//看成是完全二叉树，利用父子节点位置计算公式
//注意有大数，用BigInt
var widthOfBinaryTree = function(root) {
    let res= BigInt(0)
    function levelTraverse(root){
        const queue = [{node:root,index:BigInt(0)}]
        while(queue.length){
            let len = queue.length
            const width = BigInt(queue[len-1].index-queue[0].index+BigInt(1))
            res = width>res?width:res
            while(len--){
                const cur = queue.shift()
                cur.node.left&&queue.push({node:cur.node.left,index:BigInt(cur.index*BigInt(2)+BigInt(1))})
                cur.node.right&&queue.push({node:cur.node.right,index:BigInt(cur.index*BigInt(2)+BigInt(2))})
            }
        }
    }
    levelTraverse(root)
    return res
};
```







#### 路径

两个节点的最短路径长度 = 这两个节点跟其最近公共祖先的距离相加

###### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

```js
var pathSum = function(root, targetSum) {
    const res = [],path=[]
    let sum=0
    function traverse(root){
        if(root==null) return
        if(!root.left&&!root.right){
            if(root.val+sum==targetSum){
                const arr = path.slice()
                arr.push(root.val)
                res.push(arr)
            }
            return
        }

        path.push(root.val)
        sum+=root.val
        traverse(root.left)
        traverse(root.right)
        path.pop()
        sum-=root.val
        return
    }
    traverse(root)
    return res
};
```

###### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

题目说 ”从任意节点出发.......“ 看完这个描述大概率是要么全局记录最大值，要么双递归。

```js
var maxPathSum = function(root) {
    if(root==null) return null
    let max = root.val
    function oneSidePath(root){
        if(root==null) return 0
        const leftPath = oneSidePath(root.left)
        const rightPath = oneSidePath(root.right)

        /*找最大pathSum*/
        const pathSum = root.val+leftPath+rightPath // pathSum是包括左边和右边的，所以应该是两边的路径和加起来。
        max=Math.max(max,pathSum) //每次更新最大的那一个

        /*返回左边和右边之中的最大值*/
        const sidePath = root.val+ Math.max(leftPath,rightPath)  // 只能去子树的其中一边,所以返回给父节点的是sidePath。
        return sidePath<0?0:sidePath
    }
    oneSidePath(root)
    return max
};
```



###### <span id='qiuhelujing'>[面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/)</span>

```js
var pathSum = function(root, sum) {
    let res = 0,curSum=0
    function dfsWholeTree(root){
        if(root==null) return 
        dfsEachNode(root)
        dfsWholeTree(root.left)
        dfsWholeTree(root.right)
    }

    function dfsEachNode(root){
        if(root==null) return 
        curSum +=root.val
        if(curSum===sum){
            res++
        }
        dfsEachNode(root.left)
        curSum-=root.val

        curSum+=root.val
        dfsEachNode(root.right)
        curSum-=root.val
    }
    dfsWholeTree(root)
    return res
};
```





###### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

```js
var pathSum = function(root, target) {
    let singleResult=[],result=[],sum=0
    function dfs(root){
        if(root==null) return
        sum+=root.val
        singleResult.push(root.val)
        if(sum===target&&root.left==null&&root.right==null){
            result.push(singleResult.slice())
            sum -= root.val
            singleResult.pop()
            return
        }
        dfs(root.left)
        dfs(root.right)
        sum-=root.val
        singleResult.pop()
    }
    dfs(root)
    return result

};
```

###### [1530. 好叶子节点对的数量](https://leetcode.cn/problems/number-of-good-leaf-nodes-pairs/)

```js
//两个节点的路径长度 = 这两个节点跟其最近公共祖先的距离相加
//每次都返回以这个节点为根节点 的子树 的所有叶子节点与这个根节点之间的距离 （比如如果其子节点有 8 个叶子节点，那么就返回一个长度为 8 的数组， 数组每一项的值就是其到对应叶子节点的距离。）
//如果子树的结果计算出来了，那么父节点只需要把子树的每一项加 1 即可。因为父到各个叶子节点的距离就是父节点到子节点的距离（1） + 子节点到各个叶子节点的距离。

var countPairs = function(root, distance) {
    let res = 0
    function dfs(root){
        if(root==null) return []
        if(!root.left&&!root.right) return [0]

        //如果子树的结果计算出来了，那么父节点只需要把子树的每一项加 1 即可。因为父到各个叶子节点的距离就是父节点到子节点的距离（1） + 子节点到各个叶子节点的距离。
        const leftLeafDistanceCurArr = dfs(root.left).map(x=>x+1) //往上走一层距离加1
        const rightLeafDistanceCurArr = dfs(root.right).map(x=>x+1)

        //遍历这个根节点的左右所有叶子节点
        for(const l of leftLeafDistanceCurArr){
            for(const r of rightLeafDistanceCurArr){
                if(l+r<=distance) res++
            }
        }

        return [...leftLeafDistanceCurArr,...rightLeafDistanceCurArr] //每次都返回以这个节点为根节点 的子树 的所有叶子节点与这个根节点之间的距离 （比如如果其子节点有 8 个叶子节点，那么就返回一个长度为 8 的数组， 数组每一项的值就是其到对应叶子节点的距离。）
    }
    dfs(root)
    return res
};
```





###### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

两个节点的路径长度 = 这两个节点跟其最近公共祖先的距离相加

```javascript
var diameterOfBinaryTree = function(root) {
    let maxDistance=Number.MIN_SAFE_INTEGER
    function traverse(root,depth){
        if(root==null) return depth-1 //null不计算在内，所以要减1
        const leftDep = traverse(root.left,depth+1) //左子树最深的深度
        const rightDep = traverse(root.right,depth+1) //右子树最深的深度
        maxDistance = Math.max(maxDistance,leftDep-depth+rightDep-depth) //left-depth就是相当于左节点距离本节点的距离
        return Math.max(leftDep,rightDep)
    }
    traverse(root,1)
    return maxDistance
};
```







## 构造类问题

普通二叉树无法根据一种序列重构的原因是只知道根节点，无法区分左右子树。==（但如果遍历序列里包含了空节点则可以仅根据一种序列重构普通二叉树，【例题297】）==。如果是二叉搜索树，就可以根据**一种遍历序列**构造出来。 原因就在于二叉搜索树的根节点的值大于所有的左子树的值，且小于所有的右子树的值。因此我们可以根据这一特性去确定左右子树的位置。

- 构造树采用前序遍历，因为先构造中间节点，然后递归构造左子树和右子树。（根据数组构造一棵二叉树。**本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**。）
- 构造二叉树的时候不需要重新定义左右区间数组，可以通过传入左下标left和右下标right来操作原数组。
- 前序遍历的特点是， 根节点 始终出现在数组的 第一位。
- 中序遍历的特点是， 对于一个结点，结点左侧是该结点的左子树，结点右侧是该结点的右子树。（前提是这棵树的节点必须都是不重复的）
- 后序遍历的特点是，根节点是在最后。

### DFS例题

#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)（单靠一种含null的遍历结果还原二叉树）

```javascript
/**
一般语境下，单单前序遍历结果是不能还原二叉树结构的，因为缺少空指针的信息，至少要得到前、中、后序遍历中的两种才能还原二叉树。但是这里的 `node` 列表包含空指针的信息，所以只使用 `node` 列表就可以还原二叉树
 */
//前序遍历（后序遍历也能实现，方法同前序遍历），中序遍历可以实现序列化但不能实现反序列化，因为无法知道根结点的位置(如果告诉你根节点位置那也就可以了)
var serialize = function(root) {
   let res=[]
   const traverse=function(node){
       if(!node) {
        res.push('none')
        return undefined
       }
        res.push(node.val)
        traverse(node.left)
        traverse(node.right)
   } 
   traverse(root)
   return res.join(',')
};


var deserialize = function(data) {
    let dataArr=data.split(',')

    const traverse=function(arr){
        let rootVal=arr.shift()
        if(rootVal==='none') return null
        let root=new TreeNode(rootVal)
        root.left=traverse(arr)
        root.right=traverse(arr)
        return root
    }
    return traverse(dataArr)
};
```

```js
/*把上面那个serialize函数改装一下，就变成了一个序列化输出二叉树结构的函数*/
var serialize = function(root) {
   let res=''
   const traverse=function(node){
       if(!node) {
        res+='null'
        return undefined
       }
       res += '{"val":' + node.val + ','
       res+='"left":'
       traverse(node.left)
       res+=',"right":'
       traverse(node.right)
       res+='}'
   } 
   traverse(root)
   return res
};
console.log(serialize(root))
console.log(JSON.stringify(root))
```







#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

根据给出的两个数组，首先我们就可以拼出 根节点，它就是 3。题目上已说明数组中不存在重复元素，那么由 3 就可以定位到中序数组的位置，中序数组中 3 左边的部分就是左子树，3 右边部分就是右子树

```javascript
var buildTree = function(preorder, inorder) {
  if (!preorder.length||!inorder.length) return null
  const curVal = preorder.shift()
  const curIndex = inorder.indexOf(curVal)
  const cur = new TreeNode(curVal)
  cur.left=buildTree(preorder,inorder.slice(0,curIndex))
  cur.right=buildTree(preorder,inorder.slice(curIndex+1))
  return cur
};
```

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

与上题思路相同，只是对于后序遍历来说，根节点是在最后，所以每次是读取后序遍历数组最后一个，而且注意从后往前读是先读出右节点

```javascript
var buildTree = function(inorder, postorder) {
    if(!inorder.length) return null
    let rootVal=postorder.pop()
    let root=new TreeNode(rootVal)
    let index = inorder.indexOf(rootVal)
    root.right=buildTree(inorder.slice(index+1),postorder)//
    root.left=buildTree(inorder.slice(0,index),postorder)
    return root
};
```



#### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

> **前序和后序不能唯一确定一棵二叉树！**，因为没有中序遍历无法确定左右部分，也就是无法分辩左右子树。

```javascript
var constructFromPrePost = function(preorder, postorder) {
    if(!preorder.length) return null
    let rootVal=preorder.shift() 
    postorder.pop()//rootVal就是前序的第一个同时也是后序的最后一个
    let root=new TreeNode(rootVal)
    let nextRight=postorder[postorder.length-1]//找到root节点的右节点 （后序的后面是右子树）
    let nextLeft=preorder[0] //找到root节点的左节点 （前序的前面是左子树）
    let preIndex = preorder.indexOf(nextRight) //找到root节点的右节点在前序中的坐标，用于在前序数组中切分出左右子树
    let postIndex = postorder.indexOf(nextLeft) //找到root节点的左节点在后序中的坐标，用于在后序数组中切分出左右子树
    root.left=constructFromPrePost(preorder.slice(0,preIndex),postorder.slice(0,postIndex+1))
    root.right=constructFromPrePost(preorder.slice(preIndex),postorder.slice(postorder+1))
    return root
};
```





#### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```javascript
var constructMaximumBinaryTree = function(nums) {
    if(nums.length==0) return null
    const max = Math.max(...nums)
    const maxIndex = nums.indexOf(max)
    const root = new TreeNode(max)
    root.left=constructMaximumBinaryTree(nums.slice(0,maxIndex))
    root.right=constructMaximumBinaryTree(nums.slice(maxIndex+1))
    return root
};
```

#### [894. 所有可能的真二叉树](https://leetcode.cn/problems/all-possible-full-binary-trees/)







#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```javascript
/*自己做出来的思路，还是下面那个方法的思路好*/
var mergeTrees = function (root1, root2) {//同时操作两颗树
  let resRoot=new TreeNode()
  if (!root1 && !root2) return null
  else if (!root1 && root2) {
    resRoot.val = root2.val
    resRoot.left = mergeTrees(null, root2.left)
    resRoot.right = mergeTrees(null, root2.right)
  }
  else if (root1 && !root2) {
    resRoot.val = root1.val
    resRoot.left = mergeTrees(root1.left, null)
    resRoot.right = mergeTrees(root1.right, null)
  }
  else {
    resRoot.val = root1.val + root2.val
  resRoot.left=mergeTrees(root1.left,root2.left)
  resRoot.right=mergeTrees(root1.right, root2.right)
  }

  return resRoot
};
```



```javascript
/*参考了代码随想录的思路*/
var mergeTrees = function (root1, root2) { //同时操作两颗树
  if (!root1) return root2
  if (!root2) return root1
  
  root1.val+=root2.val
  root1.left=mergeTrees(root1.left,root2.left)
  root1.right=mergeTrees(root1.right, root2.right)
  return root1
};
```





### BFS例题

#### 根据符合完全二叉树的层序遍历结果构建二叉树

```js
/**根据层序遍历出来的数组构建二叉树 --- 用于调试leetcode二叉树的题目*/
function TreeNode(val, left, right) {
    this.val = val
    this.left = left
    this.right = right
}
function createBinaryTreeFromWholeLevelTraversal(arr) {
    function createNode(index) {
        if(index>=arr.length) return null
        let leftNode = createNode(index*2+1)
        let rightNode = createNode(index*2+2)
        return new TreeNode(arr[index],leftNode,rightNode)
    }

    return createNode(0)
}
let root = createBinaryTreeFromWholeLevelTraversal([1,2,3])
```





#### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

```javascript
//层序遍历
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
var serialize = function(root) { //序列化成 leetcode里二叉树题给的二叉树参数那种形式
    const queue = [root]
    let res =[]
    while(queue.length){
        let length=queue.length
        while(length--){
            const cur = queue.shift()
            if(cur){
                res.push(cur.val+'')
                queue.push(cur.left)
                queue.push(cur.right)
            }else{
                res.push('null')
            }
        }
    }
    return res.join(',')
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
var deserialize = function(data) {
    const arr = data.split(',')
    const rootQueue=[]
    const rootVal = arr.shift()
    let rootNode = null
    if(rootVal!='null'){
        rootNode=new TreeNode(rootVal*1)
        rootQueue.push(rootNode)
    }
    while(rootQueue.length&&arr.length){
        const curRoot = rootQueue.shift()
        if(arr.length){
            const val = arr.shift()
            if(val!='null'){
                const left= new TreeNode(val)
                curRoot.left=left
                rootQueue.push(left)
            }
        }
        if(arr.length){
            const val = arr.shift()
            if(val!='null'){
                const right= new TreeNode(val)
                curRoot.right=right
                rootQueue.push(right)
            }
        }
    }
    return rootNode
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```





#### 根据含部分null的层序遍历结果还原二叉树(LeetCode给出的二叉树节点列表参数就是这样的)

注意不是包含所有的null：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012114410995.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012114410995.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012114410995.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221012114410995.png" loading="lazy"/>
  </picture>

LeetCode给出的二叉树节点列表参数就是上面这样的

```js
function TreeNode(val, left=null, right=null) {
    this.val = val
    this.left = left
    this.right = right
}

function createBinaryTreeFromLevelTraversal(arr) {
    const rootQueue=[]
    const rootVal = arr.shift()
    let rootNode = null
    if(rootVal!='null'){
        rootNode=new TreeNode(rootVal*1)
        rootQueue.push(rootNode)
    }
    while(rootQueue.length&&arr.length){
        const curRoot = rootQueue.shift()
        if(arr.length){
            const val = arr.shift()
            if(val!=null){
                const left= new TreeNode(val)
                curRoot.left=left
                rootQueue.push(left)
            }
        }
        if(arr.length){
            const val = arr.shift()
            if(val!=null){
                const right= new TreeNode(val)
                curRoot.right=right
                rootQueue.push(right)
            }
        }
    }
    return rootNode
}
```



#### [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 */
var CBTInserter = function(root) {
    this.root = root
    this.lackChildNode = []
    const queue = [root]
    while(queue.length){
        const cur=queue.shift()
        if(cur.left){
            queue.push(cur.left)
        }else{
            this.lackChildNode.push(cur) //左节点是空的，可以插入一次
        }
        if(cur.right){
            queue.push(cur.right)
        }else{
            this.lackChildNode.push(cur) //右节点是空的，又可以插入一次
        }
    }
};

/** 
 * @param {number} val
 * @return {number}
 */
CBTInserter.prototype.insert = function(val) {
    const child = new TreeNode(val)
    const node = this.lackChildNode.shift()
    if(!node.left){
        node.left=child
    }else{
        node.right=child
    }
    this.lackChildNode.push(child,child) //child这个节点的左右节点都是空的，都是可以接入儿子的
    return node.val
};

/**
 * @return {TreeNode}
 */
CBTInserter.prototype.get_root = function() {
    return this.root
};

/**
 * Your CBTInserter object will be instantiated and called as such:
 * var obj = new CBTInserter(root)
 * var param_1 = obj.insert(val)
 * var param_2 = obj.get_root()
 */
```







## 修改类例题

也是要搜索的，其实没必要额外开一个分类出来。

### BFS例题

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

```js
function connect(root: Node | null): Node | null {
    if(root==null) return null
    const queue=[root]
    while(queue.length){
        let pre=queue.shift()
        let len=queue.length
        pre.left&&queue.push(pre.left)
        pre.right&&queue.push(pre.right)
        while(len--){
            const cur = queue.shift()
            cur.left&&queue.push(cur.left)
            cur.right&&queue.push(cur.right)
            pre.next=cur
            pre=cur
        }
    }
    return root
};
```



### DFS例题

暂无



## 二叉搜索树

如果是利用左小右大的特性去遍历二叉搜索树 其实是在遍历一条单链，因为一般就是大于就去右边，小于就去左边，不是两边都去的，所以其实是单链在递归。

> BST 相关的问题，都会用上它的性质：左小右大 或者 利用中序遍历的特性（**二叉搜索树的中序遍历的结果是一个有序数组**。）。
>
> BST 的性质如下：
>
> - 若左子树不空，则左子树上所有节点的值均小于它的根节点的值；
> - 若右子树不空，则右子树上所有节点的值均大于它的根节点的值；
> - 左、右子树也分别为二叉搜索树；
> - 没有键值相等的节点；（不好说了）



### 手写二叉搜索树

```javascript
let dataArr = []

function handler(data) {
  dataArr.push(data)
}

function BinarySearchTree() {
  this.root = null

  function Node(data) {
    this.data = data
    this.left = null
    this.right = null
  }

  BinarySearchTree.prototype.max = function () {
    let node = this.root
    while (node) {
      node = node.right
    }
    return node.data
  }
  BinarySearchTree.prototype.min = function () {
    let node = this.root
    while (node) {
      node = node.left
    }
    return node.data
  }

  function privateInsert(node, newNode) {
    if (newNode.data < node.data) {
      if (node.left) {
        privateInsert(node.left, newNode)
      } else {
        node.left = newNode

      }
    } else {
      if (node.right) {
        privateInsert(node.right, newNode)
      } else {
        node.right = newNode

      }
    }
  }
  BinarySearchTree.prototype.insert = function (data) {
    let node = new Node(data)
    if (this.root) {
      privateInsert(this.root, node)
    } else {
      this.root = node
    }
  }

  // function privateSearch(node, data) {

  //   if(!node) return false 
  //   if (data === node.data) {
  //     return true
  //   }
  //   else if (data > node.data) {
  //     return privateSearch(node.right,data)
  //   } else {
  //     return privateSearch(node.left,data)
  //   }
  // }
  BinarySearchTree.prototype.search = function (data) {
    let node = this.root
    while (node) {
      if (node.data === data) {
        return true
      } else if (data < node.data) {
        node = node.left
      } else {
        node = node.right
      }
    }
    return false
  }

  //先序遍历
  function privatePreOrderTranversal(node, handler) {
    if (node !== null) {
      // 1.打印当前经过的节点
      handler(node.data)
      // 2.遍历所有的左子树
      privatePreOrderTranversal(node.left, handler)
      // 3.遍历所有的右子树
      privatePreOrderTranversal(node.right, handler)
    }
  }

  BinarySearchTree.prototype.preOrderTraversal = function (handler) {
    privatePreOrderTranversal(this.root, handler)
  }

  // 中序遍历
  BinarySearchTree.prototype.inOrderTraversal = function (handler) {
    privateInOrderTraversal(this.root, handler)
  }

  function privateInOrderTraversal(node, handler) {
    if (node !== null) {
      privateInOrderTraversal(node.left, handler)
      handler(node.data)
      privateInOrderTraversal(node.right, handler)
    }
  }

  // 后续遍历
  BinarySearchTree.prototype.postOrderTraversal = function (handler) {
    privatePostOrderTraversal(this.root, handler)
  }

  function privatePostOrderTraversal(node, handler) {
    if (node !== null) {
      privatePostOrderTraversal(node.left, handler)
      privatePostOrderTraversal(node.right, handler)
      handler(node.data)
    }
  }

  BinarySearchTree.prototype.remove = function (data) {

    //寻找后继节点
    function getSuccessor(delNode) {
      let current = delNode.right,
        successor = delNode,
        successorParent = delNode
      while (current) {
        successorParent = successor
        successor = current
        current = current.left
      }

      //下面这一段看不懂可以到https://www.jianshu.com/p/ad811c95aad3
      if (successor != delNode.right) {
        successorParent.left = successor.right
        successor.right = delNode.right
      }
      return successor
    }

    let parent = this.root,
      delNode = this.root,
      isLeftChild = false

    //找到要删除的节点
    while (delNode && delNode.data !== data) {
      parent = delNode
      if (data < delNode.data) {
        delNode = delNode.left
        isLeftChild = true
      } else {
        delNode = delNode.right
        isLeftChild = false

      }
    }
    if (!delNode) return new Error('no such data')

    //删除的节点是叶子节点
    if (!delNode.left && !delNode.right) {
      if (delNode === this.root) {
        this.root = null
      } else {
        if (isLeftChild) {
          parent.left = null
        } else {
          parent.right = null
        }
      }

    } else if (!delNode.left) { //删除有一个子节点的节点
      if (delNode === this.root) {
        this.root = delNode.right
      } else {
        if (isLeftChild) {
          parent.left = delNode.right
        } else {
          parent.right = delNode.right
        }
      }

    } else if (!delNode.right) { //删除有一个子节点的节点
      if (delNode === this.root) {
        this.root = delNode.left
      } else {
        if (isLeftChild) {
          parent.left = delNode.left
        } else {
          parent.right = delNode.left
        }
      }

    } else { //删除有两个节点的节点
      let successor = getSuccessor(delNode)
      if (delNode === this.root) {
        this.root = successor
      } else {
        if (isLeftChild) {
          parent.left = successor
        } else {
          parent.right = successor
        }
      }
      successor.left = delNode.left
    }
  }

}

let bst = new BinarySearchTree()
bst.insert(10)
bst.insert(11)
bst.insert(0)
bst.insert(15)
bst.insert(9)
console.log(JSON.stringify(bst))
bst.remove(11)
console.log(bst.search(11))

console.log(JSON.stringify(bst))
```



### 搜索类

##### [面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)

用全局变量去记录上一个节点，注意不要使用参数扩展去记录，因为穿进去的是父节点，而不是前一个节点

```js
var inorderSuccessor = function(root, p) {
    let res=null,pre = null
    function traverse(root){
        if(root==null) return null
        traverse(root.left)
        if(pre==p) {
            res=root
        }
        pre=root
        traverse(root.right)
    }
    traverse(root)
    return res
};
```





##### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

```javascript
//递归
var kthSmallest = function(root, k) {
    function traverse(node){
        if(!node) return null
        const resl = traverse(node.left)
        k--
        if(k==0) return node.val
        const resr = traverse(node.right)
        if(resl) return resl
        if(resr) return resr
        return null
    }
    return traverse(root)
};

//迭代
var kthSmallest = function(root, k) {
    function traverse(root){
        const stack=[]
        let cur = root
        while(stack.length||cur){
            if(cur){
                stack.push(cur)
                cur=cur.left
            }else{
                cur = stack.pop()
                k--
                if(k===0) return cur.val
                cur=cur.right
            }
        }
    }
    return traverse(root)
};
```

##### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

```javascript
var convertBST = function(root) {
    let curSum = 0
    function traverse(node){
        if(!node){
            return null
        }
        traverse(node.right)
        const raw = node.val
        node.val +=curSum
        curSum +=raw
        traverse(node.left)
        return node
    }
    return traverse(root)
};
```

##### [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

> **遇到在二叉搜索树上求什么最值，求差值之类的，都是用中序遍历的特性**

```javascript
var getMinimumDifference = function(root) {
  let min = Number.MAX_SAFE_INTEGER, preNode = null
  const inorderTraverse = node => {
    if (!node) return

    inorderTraverse(node.left)
    if(preNode)min=Math.min(min,node.val-preNode.val)
    preNode=node
    inorderTraverse(node.right)
    return
  }
  inorderTraverse(root)
  return min
};
```



##### [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```javascript
var findMode = function(root) {
  let res = [],preNode=null,maxCount=1,count=1
  const inorderTraverse = node => {
    if (!node) return
    
    inorderTraverse(node.left)
    if (preNode) {
      if (preNode.val == node.val) count++
      else count = 1
    }
    if (count > maxCount) {
      maxCount = count
      res=[]
    }
    if(count==maxCount) res.push(node.val)
    preNode = node
    inorderTraverse(node.right)
  }
  inorderTraverse(root)
  return res
};
```

还有一种思路就是在遍历的同时用哈希表去记录每个数的出现次数（如果本题改成是二叉树就只能这么做了，但是是二叉搜索树，所以可以利用中序遍历的特性去做，不用多开辟一个空间）





##### [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```javascript
var searchBST = function(root, val) {
    if(!root) return null
    if(root.val==val) return root
    else if(val<root.val) {
        return searchBST(root.left,val)
    }else{
        return searchBST(root.right,val)
    }
};
```



#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```javascript
function isValidBST(root: TreeNode | null): boolean {
    let pre = Number.MIN_SAFE_INTEGER
    function traverse(root){
        if(root==null) return true
        const res1 = traverse(root.left)
        if(root.val<=pre) return false
        pre=root.val
        const res2 = traverse(root.right)
        return res1&&res2
    }
    return traverse(root)
};
```



#### [99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

```ts
function recoverTree(root: TreeNode | null): void {
    let pre = new TreeNode(Number.MIN_SAFE_INTEGER)
    let [first,second]=[null,null] // 分别记录两个被交换的节点
    
    function inorderTraverse(root){
        if(root==null) return
        inorderTraverse(root.left)
        if(root.val<pre.val){
            if(first==null) first=pre // root 不符合有序性，第一个错位节点是 prev，第二个错位节点是 root
            second=root
        }
        pre=root
        inorderTraverse(root.right)
    }
    inorderTraverse(root);
    [first.val,second.val]=[second.val,first.val];
};
```







#### [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```javascript
var lowestCommonAncestor = function(root, p, q) {
    function traverse(node){
        if(!node){
            return null
        }

        if(node.val<Math.min(p.val,q.val)){
            return traverse(node.right)// 向右子树查询
        }
        else if(node.val>Math.max(p.val,q.val)){
            return traverse(node.left) // 向左子树查询
        }else{
            return node
        }
    }
    return traverse(root)
};
```





#### [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

> 遍历二叉搜索树，找到空节点 插入元素就可以了

```javascript
var insertIntoBST = function(root, val) {
    if(root==null) return new TreeNode(val)
    if(val<root.val){
        root.left=insertIntoBST(root.left,val)
    }else{
        root.right=insertIntoBST(root.right,val)
    }
    return root
};
```









#### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

> 数组构造二叉树，构成平衡树是自然而然的事情，因为大家默认都是从数组中间位置取值作为节点元素。在[二叉树：构造二叉树登场！ (opens new window)](https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html)和[二叉树：构造一棵最大的二叉树 (opens new window)](https://programmercarl.com/0654.最大二叉树.html)中其实已经讲过了，如果根据数组构造一棵二叉树。
>
> **本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**。



```javascript
/*如果数组长度为偶数，中间节点有两个，取哪一个都可以，只不过构成了不同的平衡二叉搜索树。*/
    const main = (left,right) => {
        if(left>right) return null
        let midIndex=(left+right)>>1
        let midNode= new TreeNode(nums[midIndex])
        midNode.left=main(left,midIndex-1)
        midNode.right=main(midIndex+1,right)
        return midNode
    }
    return main(0,nums.length-1)
```





#### [783. 二叉搜索树节点最小距离](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

```js
var minDiffInBST = function(root) {
    let min = Number.MAX_SAFE_INTEGER
    let pre = null
    function dfs(root){
        if(root==null) return 
        dfs(root.left)
        if(pre){
            const cha = Math.abs(pre.val-root.val)
            if(cha<min){
                min=cha
            }
        }
        pre = root
        dfs(root.right)
        return
    }
    dfs(root)
    return min
};
```



### 构造类

#### [1008. 前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)

```js
function bstFromPreorder(preorder: number[]): TreeNode | null {
        if(preorder.length==0) return null
        const rootVal= preorder.shift()
        const root=new TreeNode(rootVal)
        root.left=bstFromPreorder(preorder.filter(x=>x<rootVal))
        root.right=bstFromPreorder(preorder.filter(x=>x>rootVal))
        return root
};
```



#### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

````js
var sortedArrayToBST = function(nums) {
    function buildTree(left,right){
        if(left>right){
            return null
        }
        const mid = left+((right-left)>>1)
        const node = new TreeNode(nums[mid])
        node.left = buildTree(left,mid-1)
        node.right= buildTree(mid+1,right)
        return node
    }
    const len = nums.length
    return buildTree(0,len-1)
};
````





### 修改类

#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182542316.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182542316.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182542316.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182542316.png" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182610419.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182610419.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182610419.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20221011182610419.png" loading="lazy"/>
  </picture>



> 实际工程中，我们也可以不删除节点，而是给节点做一个标记，表示已经被删除了，这叫做软删除。

```ts
function deleteNode(root: TreeNode | null, key: number): TreeNode | null {
    const dummy = new TreeNode(Number.MAX_SAFE_INTEGER,root) //因为有可能删的是根结点
    function traverseDelete(root){
        if(root==null) return null
        if(root.val==key){
            if(!root.left&&!root.right) return null //情况1
            else if(!root.left||!root.right){ //情况2
                if(root.left){
                    return root.left
                }else{
                    return root.right
                }
            }else{ //情况3
                const target = getRightMin(root)
                deleteNode(root,target.val)
                root.val=target.val //换个值就相当于把root节点给删除，不是真的删掉这个节点。 真正会从树中消失的是target!!!
            }
        }else if(root.val<key){
            root.right = traverseDelete(root.right)
        }else{
            root.left = traverseDelete(root.left)
        }
        return root
    }
    function getRightMin(root){
        let target = root.right
        while(target.left){
            target=target.left
        }
        return target
    }  
    traverseDelete(dummy)
    return dummy.left
};
```



#### [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```javascript
/*
后序遍历，从底部开始。
root.val < lo，这种情况下 root 节点本身和 root 的左子树全都是小于 lo 的，都需要被剪掉
root.val > hi，这种情况下 root 节点本身和 root 的右子树全都是大于 hi 的，都需要被剪掉
*/
function trimBST(root: TreeNode | null, low: number, high: number): TreeNode | null {
        const dummy = new TreeNode(Number.MAX_SAFE_INTEGER,root)
         
        function traverseDelete(root){
            if(root==null) return null
            root.left=traverseDelete(root.left)
            root.right=traverseDelete(root.right)
            if(root.val<low){
                return root.right
            }
            if(root.val>high){
                return root.left
            }
            return root
        }

        traverseDelete(dummy)
        return dummy.left
};
```



#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

```js
var treeToDoublyList = function(root) {
    let preNode = null
    let head = null
    function traverse(root){ //递归完之后preNode指向的就是尾节点
        if(root==null){
            return
        }
        traverse(root.left)
        root.left=preNode
        if(preNode){
            preNode.right=root
        }else{
            head=root
        }
        preNode=root
        traverse(root.right)
    }
    traverse(root)
    if(preNode)preNode.right= head
    if(head)head.left=preNode
    return head
};
```









### 平衡二叉搜索树(AVL树/红黑树)

这种就是明确用于 搜索场景的数据结构。

BST存在一个问题：树的一条边可能会非常深，而其他的分支却只有几层。这样就会导致搜索效率变慢了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-10-19-43-image-20240110194317309.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-10-19-43-image-20240110194317309.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-10-19-43-image-20240110194317309.png" alt="image-20240110194317309" style="zoom:33%;" loading="lazy"/>
  </picture>



#### AVL树

##### 介绍

AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试保持自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。



##### 一些概念

节点的高度：指从节点到其任意子节点的边的最大值。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-14-image-20240115121453602.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-14-image-20240115121453602.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-14-image-20240115121453602.png" alt="image-20240115121453602" style="zoom:33%;" loading="lazy"/>
  </picture>

平衡因子：对每个节点计算右子树高度（hr）和左子树高度（hl）之间的差值，该值（hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-18-image-20240115121833727.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-18-image-20240115121833727.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-18-image-20240115121833727.png" alt="image-20240115121833727" style="zoom:50%;" loading="lazy"/>
  </picture>



##### 平衡操作——AVL旋转

###### ❑ 左-左（LL）

向右的单旋转。这种情况出现于节点的左侧子节点的高度大于右侧子节点的高度时，并且左侧子节点也是平衡或左侧较重的。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-23-image-20240115122334396.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-23-image-20240115122334396.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-23-image-20240115122334396.png" alt="image-20240115122334396" style="zoom:33%;" loading="lazy"/>
  </picture>



假设向AVL树插入节点5，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作：❑ 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）；❑ 节点X的左子树保持不变；❑ 将节点Y的左子节点置为节点X的右子节点Z（行{2}）；❑ 将节点X的右子节点置为节点Y（行{3}）。

```js
    rotationLL(node) {
      const tmp = node.left; // {1}
      node.left = tmp.right; // {2}
      tmp.right = node; // {3}
      return tmp;
    }
```



###### ❑ 右-右（RR）：向左的单旋转

右-右的情况和左-左的情况相反。它出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点也是平衡或右侧较重的。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-36-image-20240115123628022.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-36-image-20240115123628022.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-15-12-36-image-20240115123628022.png" alt="image-20240115123628022" style="zoom:33%;" loading="lazy"/>
  </picture>

假设向AVL树插入节点90，这会造成树失衡（节点50-Y高度为-2），因此需要恢复树的平衡。下面是我们执行的操作：❑ 与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）；❑ 节点X的右子树保持不变；❑ 将节点Y的右子节点置为节点X的左子节点Z（行{2}）；❑ 将节点X的左子节点置为节点Y（行{3}）。

```js
    rotationRR(node) {
      const tmp = node.right; // {1}
      node.right = tmp.left; // {2}
      tmp.left = node; // {3}
      return tmp;
    }
```







###### ❑ 左-右（LR）：向右的双旋转（先LL旋转，再RR旋转）

这种情况出现于左侧子节点的高度大于右侧子节点的高度，并且左侧子节点右侧较重。在这种情况下，我们可以对左侧子节点进行左旋转来修复，这样会形成左-左的情况，然后再对不平衡的节点进行一个右旋转来修复。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-16-17-17-image-20240116171712911.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-16-17-17-image-20240116171712911.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-16-17-17-image-20240116171712911.png" alt="image-20240116171712911" style="zoom:33%;" loading="lazy"/>
  </picture>

假设向AVL树插入节点75，这会造成树失衡（节点70-Y高度为-2），需要恢复树的平衡。下面是我们执行的操作：❑ 将节点X置于节点Y（平衡因子为-2）所在的位置；❑ 将节点Z的左子节点置为节点X的右子节点；❑ 将节点Y的右子节点置为节点X的左子节点；❑ 将节点X的右子节点置为节点Y；❑ 将节点X的左子节点置为节点Z。基本上，就是先做一次LL旋转，再做一次RR旋转。

```js
    rotationLR(node) {
      node.left = this.rotationRR(node.left);
      return this.rotationLL(node);
    }
```





###### ❑ 右-左（RL）：向左的双旋转（先RR旋转，再LL旋转）

右-左的情况和左-右的情况相反。这种情况出现于右侧子节点的高度大于左侧子节点的高度，并且右侧子节点左侧较重。在这种情况下我们可以对右侧子节点进行右旋转来修复，这样会形成右-右的情况，然后我们再对不平衡的节点进行一个左旋转来修复。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-16-17-18-image-20240116171818766.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-16-17-18-image-20240116171818766.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-16-17-18-image-20240116171818766.png" alt="image-20240116171818766" style="zoom:33%;" loading="lazy"/>
  </picture>

假设向AVL树插入节点35，这会造成树失衡（节点50-Y高度为+2），需要恢复树的平衡。下面是我们执行的操作：❑ 将节点X置于节点Y（平衡因子为+2）所在的位置；❑ 将节点Y的左子节点置为节点X的右子节点；❑ 将节点Z的右子节点置为节点X的左子节点；❑ 将节点X的左子节点置为节点Y；❑ 将节点X的右子节点置为节点Z。基本上，就是先做一次RR旋转，再做一次LL旋转。

```js
    rotationRL(node) {
      node.right = this.rotationLL(node.right);
      return this.rotationRR(node);
    }
```









##### 完整代码

```js
// AVL树是一个BST，我们可以扩展我们写的BST类，只需要覆盖用来维持AVL树平衡的方法，也就是insert、insertNode和removeNode方法。所有其他的BST方法将会被AVLTree类继承。
class AVLTree extends BinarySearchTree {
      constructor(compareFn = defaultCompare) {
        super(compareFn);
        this.compareFn = compareFn;
        this.root = null;
      }
  
    getNodeHeight(node) { // 计算一个节点高度
      if (node == null) {
        return -1;
      }
      return Math.max(
        this.getNodeHeight(node.left), this.getNodeHeight(node.right)
        ) + 1;
    }
  
    getBalanceFactor(node) { // 计算 平衡因子
      const heightDifference = this.getNodeHeight(node.left) -
    this.getNodeHeight(node.right);
      switch (heightDifference) {
        case -2:
          return BalanceFactor.UNBALANCED_RIGHT;
        case -1:
          return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;
        case 1:
          return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;
        case 2:
          return BalanceFactor.UNBALANCED_LEFT;
        default:
          return BalanceFactor.BALANCED;
      }
    }
  
  /* 插入*/
      insert(key) {
      this.root = this.insertNode(this.root, key);
    }
    insertNode(node, key) {
      // 像在BST树中一样插入节点
      if (node == null) {
        return new Node(key);
      } else if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
        node.left = this.insertNode(node.left, key);
      } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {
        node.right = this.insertNode(node.right, key);
      } else {
        return node; // 重复的键
      }
      // 如果需要，将树进行平衡操作
      const balanceFactor = this.getBalanceFactor(node); // {1}
      if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) { // {2} 如果在向左侧子树插入节点后树不平衡了（行{2}），我们需要比较是否插入的键小于左侧子节点的键（行{3}）。如果是，我们要进行LL旋转（行{4}）。否则，要进行LR旋转（行{5}）。
        if (this.compareFn(key, node.left.key) === Compare.LESS_THAN) { // {3}
          node = this.rotationLL(node); // {4}
        } else {
          return this.rotationLR(node); // {5}
        }
      }
      if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) { // {6} 如果在向右侧子树插入节点后树不平衡了（行{6}），我们需要比较是否插入的键小于右侧子节点的键（行{7}）。如果是，我们要进行RR旋转（行{8}）。否则，要进行RL旋转（行{9}）。
        if (
            this.compareFn(key, node.right.key) === Compare.BIGGER_THAN
        ) { // {7}
          node = this.rotationRR(node); // {8}
        } else {
          return this.rotationRL(node); // {9}
        }
      }
      return node;
    }
  
  /*移除*/
      removeNode(node, key) {
      node = super.removeNode(node, key); // {1}
      if (node == null) {
        return node; // null，不需要进行平衡
      }
      // 检测树是否平衡
      const balanceFactor = this.getBalanceFactor(node); // {2}
      if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) { // {3} 如果在从左侧子树移除节点后树不平衡了（行{3}），我们要计算左侧子树的平衡因子（行{4}）。如果左侧子树向左不平衡（行{5}），要进行LL旋转（行{6}）；如果左侧子树向右不平衡（行{7}），要进行LR旋转（行{8}）。
        const balanceFactorLeft = this.getBalanceFactor(node.left); // {4}
        if (
          balanceFactorLeft === BalanceFactor.BALANCED ||
          balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
        ) { // {5}
          return this.rotationLL(node); // {6}
        }
        if (
            balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
            ) { // {7}
          return this.rotationLR(node.left); // {8}
        }
      }
      if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) { // {9} 如果在从右侧子树移除节点后树不平衡了（行{9}），我们要计算右侧子树的平衡因子（行{10}）。如果右侧子树向右不平衡（行{11}），要进行RR旋转（行{12}）；如果右侧子树向左不平衡（行{13}），要进行LR旋转（行{14}）。
        const balanceFactorRight = this.getBalanceFactor(node.right); // {10}
        if (
          balanceFactorRight === BalanceFactor.BALANCED ||
          balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
        ) { // {11}
          return this.rotationRR(node); // {12}
        }
        if (
            balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
            ) { // {13}
          return this.rotationRL(node.right); // {14}
        }
      }
      return node;
    }
}
```









#### 红黑树

##### 与AVL树的区别

红黑树和 AVL 树都是自平衡二叉搜索树，它们在平衡性要求和平衡调整操作上有所不同。红黑树在平衡性方面较为宽松，插入和删除操作较快，适用于需要平衡性和性能的场景。而 AVL 树在平衡性方面要求严格，插入和删除操作相对较慢，适用于需要更严格的平衡性的场景，即搜索更快。

##### 介绍

和AVL树一样，红黑树也是一个自平衡二叉搜索树。AVL树插入和移除节点可能会造成旋转。如果插入和删除频率较低（我们更需要多次进行搜索操作），那么AVL树比红黑树更好。否则，红黑树better。



在红黑树中，每个节点都遵循以下规则：

(1) 顾名思义，每个节点不是红的就是黑的；

(2) 树的根节点是黑的；

(3) 所有叶节点都是黑的（用NULL引用表示的节点）；

(4) 如果一个节点是红的，那么它的两个子节点都是黑的；

(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；

(6) 从给定的节点到它的后代节点（NULL叶节点）的所有路径包含相同数量的黑色节点。





##### 完整代码

```js
    class RedBlackTree extends BinarySearchTree {
      constructor(compareFn = defaultCompare) {
        super(compareFn);
        this.compareFn = compareFn;
        this.root = null;
      }
      。。。。。。
    }
```







# 多叉树

一般的多叉树的结点是这样的：

```c++
struct TreeNode {
    VALUETYPE value;    //结点值
    TreeNode* children[NUM];    //指向孩子结点
};
```



## Trie树

### 介绍

Trie [traɪ] 读音和 try 相同，它的另一些名字有：字典树，前缀树，单词查找树等。

特点：根节点不包含字符，除根节点外的每一个子节点都包含一个字符；从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；每个节点的所有子节点包含的字符都不相同。

### 应用场景

Trie树，也叫前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。总的来说，Trie树在处理字符串相关的问题上有很大的优势，特别是在查找和匹配方面。




Trie树的主要应用场景包括：


字符串检索：Trie树最基本的应用就是字符串的快速检索。通过构建Trie树，<mark>可以在O(m)的时间复杂度内查找到一个长度为m的字符串，这在文本检索中非常有用。</mark>(因为在插入的时候牺牲了一些时间，所以很快)


字典：Trie树可以用来实现字典功能，比如英语单词的拼写检查等。


前缀匹配：Trie树可以用来做前缀匹配，比如搜索引擎的自动补全功能。


IP路由匹配：在计算机网络中，IP路由匹配通常使用Trie树来实现。


数据压缩：Trie树也可以用于数据压缩，比如在T9输入法中，Trie树被用来存储词库，实现快速的单词匹配。


敏感词过滤：在社区论坛或者聊天工具中，Trie树可以用来过滤敏感词汇。








### 算法实现

Trie 的结点是这样的：

```js
class TrieNode {
    constructor() {
        this.end = false; //该结点是否是一个串的结束
        this.children = {};//字母映射表
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word) {
        let node = this.root;
        for(let char of word) {
            if(!node.children[char]) {
                node.children[char] = new TrieNode();
            }
            node = node.children[char];
        }
        node.end = true;
    }

    search(word) {
        let node = this.root;
        for(let char of word) {
            if(!node.children[char]) {
                return false;
            }
            node = node.children[char];
        }
        return node.end;
    }

    startsWith(prefix) {
        let node = this.root;
        for(let char of prefix) {
            if(!node.children[char]) {
                return false;
            }
            node = node.children[char];
        }
        return true;
    }
}

// 使用
let trie = new Trie();
trie.insert("hello");
console.log(trie.search("hello")); // true
console.log(trie.search("hell")); // false
console.log(trie.startsWith("hell")); // true
console.log(trie.startsWith("helloo")); // false
```



### 例题

##### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)、[211. 添加与搜索单词 - 数据结构设计](https://leetcode.cn/problems/design-add-and-search-words-data-structure/)、[648. 单词替换](https://leetcode.cn/problems/replace-words/)这三题其实是一样的，都是实现trie树。



##### [LCR 066. 键值映射](https://leetcode.cn/problems/z1R5dt/)

```js
class TrieNode{
    constructor(){
        this.sum = 0
        this.children = {}
    }
}

/**
 * Initialize your data structure here.
 */
var MapSum = function() {
    this.root = new TrieNode()
    this.map = new Map()
};

/** 
 * @param {string} key 
 * @param {number} val
 * @return {void}
 */
MapSum.prototype.insert = function(key, val) {
    const delta = val - (this.map.get(key) || 0); // 原来可能有值
    this.map.set(key, val);// 更新值
    let node = this.root
    for(const char of key){
        if(!node.children[char]){
            node.children[char] = new TrieNode()
        }
        node = node.children[char] // 往下走
        node.sum +=delta // 每个节点都记录本前缀的和
    }
};

/** 
 * @param {string} prefix
 * @return {number}
 */
MapSum.prototype.sum = function(prefix) {
    let node = this.root
    for(const char of prefix){
        if(!node.children[char]){
            return 0
        }
        node = node.children[char]// 往下走
    }
    return node.sum
};

/**
 * Your MapSum object will be instantiated and called as such:
 * var obj = new MapSum()
 * obj.insert(key,val)
 * var param_2 = obj.sum(prefix)
 */
```







# 回溯（DFS）

## 思维模式

<mark>核心就两件事： 尝试与回退、剪枝。找到结果之后就返回算是纵向剪枝了(即减少了层数)，所以核心在于如何能横向剪枝（即减少每一层的列数）。可以把纵向理解成curArr(当前存的结果)里的元素个数不断增加即index继续加，横向就是找到合适的放入curArr的当前index里。(可见 分割回文串)</mark>。 典型题：[47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-27-21-04-image-20231127210451013.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-27-21-04-image-20231127210451013.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-27-21-04-image-20231127210451013.png" alt="image-20231127210451013" style="zoom:50%;" loading="lazy"/>
  </picture>

站在回溯树的一个节点上，你只需要思考 3 个问题：

1、路径：也就是已经做出的选择（现在的状态）。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。



## 回溯算法的框架

> 组合和子集问题的for循环从startIndex开始；排列问题的for循环从0开始，排列的used其实跟startIndex一样的作用。（因为排列是有序的，{1, 2} 和{2, 1}是两个不同的可行方案）

```java
path=[]   /*path=已选择列表。*/
def backtrack(可选择列表):    /*可选择列表（有很多种形式视不同的题目而定）*/
    if 满足结束条件:/*base case*/ /*子集问题一般不需要这个，直接加入就好*/
        result.add(path.slice()) /*这里注意塞进result里的是个引用类型的话要拷贝一份出来再塞进去*/
        return
          
/*每个在函数调用栈中的backtrack就是一个节点，for循环确定横坐标，递归确定纵坐标，每个backtrack会保留for循环里的i和递归里的index，先沿着一条枝遍历到最深那个节点，再遍历这一层，然后返上去接着上次父节点的位置遍历每一层*/
    				/*for循环掌管每个同一父节点下的那一层，递归掌管每个父节点往下生一个节点（通过参数来往下走）*/
    for 选择 in 可选择列表:  ---/*一个节点有多少个孩子，这个for循环就执行多少次*/
				检查该选择是否可行---/*这一步就是剪枝，这里的剪枝控制广度，有的题需要，有的题不需要*/
        做选择
        backtrack(可选择列表)
        撤销选择
```





## 解决的问题

回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等







## 时空复杂度

代码随想录说的：

子集问题分析：

- 时间复杂度：$O(n × 2^n)$，因为每一个元素的状态无外乎取与不取，所以时间复杂度为$O(2^n)$，构造每一组子集都需要填进数组，又有需要$O(n)$，最终时间复杂度：$O(n × 2^n)$。
- 空间复杂度：$O(n)$，递归深度为n，所以系统栈所用空间为$O(n)$，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为$O(n)$。

排列问题分析：

- 时间复杂度：$O(n!)$，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * ..... 1 = n!。
- 空间复杂度：$O(n)$，和子集问题同理。

组合问题分析：

- 时间复杂度：$O(n × 2^n)$，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。
- 空间复杂度：$O(n)$，和子集问题同理。

**一般说道回溯算法的复杂度，都说是指数级别的时间复杂度，这也算是一个概括吧！**









## 组合/子集

> **组合和子集是一样的：大小为 `k` 的组合其实就是大小为 `k` 的子集**

<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/1.jpeg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/1.jpeg?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/1.jpeg" alt="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/1.jpeg" loading="lazy"/>
  </picture>



### 例题

#### 元素无重不可复选

##### [78. 子集](https://leetcode-cn.com/problems/subsets/)

```javascript
var subsets = function(nums) {
    let res=[],path=[],len=nums.length
    const backtrack=function (path,startIndex){
        res.push(Array.from(path))
        for(let i=startIndex;i<len;i++){//这个 i 从 start 开始，那么下一层回溯树就是从 i + 1 开始，从而保证已经选过的这个元素不会被重复使用
            path.push(nums[i])
            backtrack(path,i+1)
            path.pop()
        }
        return
    }
    backtrack(path,0)
    return res
};
```

##### [77. 组合](https://leetcode-cn.com/problems/combinations/)

```javascript
var combine = function(n, k) {
    let res=[],path=[]
    const backtrack=function(path,start){
        if(path.length===k){
            res.push([...path])
            return
        }
        for(let i=start;i<=n;i++){
            path.push(i)
            backtrack(path,i+1)
            path.pop()
        }
        return
    }
    backtrack(path,1)
    return res
};


/*再剪一下枝版本*/
var combine = function(n, k) {
    let res=[],path=[]
    const backtrack=function(path,start){
        if(path.length===k){
            res.push([...path])
            return
        }
        for(let i=start;n-i+1>=k-path.length;i++){//如果可选的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了
            path.push(i)
            backtrack(path,i+1)
            path.pop()
        }
        return
    }
    backtrack(path,1)
    return res
};
```



##### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

```javascript
var combinationSum3 = function(k, n) {
    let curSum = 0,curArr = [],res = []
    function backtrack(start){
        if(curSum===n&&curArr.length===k){
            res.push([...curArr])
            return 
        }
        for(let i=start;i<=9&&k-curArr.length<=9-i+1&&curSum<n;i++){ //加一是因为要包括i自己
            curSum+=i
            curArr.push(i)
            backtrack(i+1)
            curArr.pop()
            curSum-=i
        }
        return
    }
    backtrack(1)
    return res
};
```



##### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```javascript
var letterCombinations = function(digits) {
    const map = {
        2:['a','b','c'],
        3:['d','e','f'],
        4:['g','h','i'],
        5:['j','k','l'],
        6:['m','n','o'],
        7:['p','q','r','s'],
        8:['t','u','v'],
        9:['w','x','y','z'],
    }
    const cur = [],res = []
    const len = digits.length
    function backtrack(index){
        if(cur.length===len){
            res.push(cur.join(''))
            return 
        }
        const str = digits[index]
        const arr = map[str]
        for(const s of arr){
            cur.push(s)
            backtrack(index+1)
            cur.pop()
        }
        return 
    }
    if(len===0) return []
    backtrack(0)
    return res
};
```

##### [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

> 有点难想的，但是个好题呀。可以看代码随想录题解
>
> 分割问题本质也是组合问题，就多了一步切割s.substring()

```javascript
/**
 * @param {string} s
 * @return {string[][]}
 */
var partition = function(s) {
    let res=[],path=[],len=s.length
    const isPalindrome= str =>{
        let left=0,right=str.length-1
        while(left<=right){
            if(str[left]!==str[right]) return false
            left++
            right--
        }
        return true
    }

    const backtrack = startIndex=>{
        if(startIndex>=len) {
            res.push([...path])
            return
        }
        for(let i=startIndex;i<len;i++){
            const str = s.substring(startIndex,i+1)
            if(!isPalindrome(str)) continue
            path.push(str)
            backtrack(i+1)
            path.pop()
        }
        return
    }
    backtrack(0)
    return res
};
```



##### [140. 单词拆分 II](https://leetcode.cn/problems/word-break-ii/)

思路跟 分割回文串 一致

```js
var wordBreak = function(s, wordDict) {
    const res=[],path=[],len = s.length
    function backtrack(startIndex){
        if(startIndex>=len){
            res.push(path.join(' '))
            return
        }
        for(let i=startIndex;i<len;i++){
            const subStr = s.substring(startIndex,i+1)
            if(!wordDict.includes(subStr)) continue
            path.push(subStr)
            backtrack(i+1)
            path.pop()
        }
    }
    backtrack(0)
    return res
};
```







##### [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```javascript
var restoreIpAddresses = function(s) {
    let res=[],path=[],len=s.length
    const backtrack= startIndex=>{
        if(path.length>4) return  //剪树的深度，return后树就不会再往下生长了
        if(path.length===4&&startIndex===len){
            res.push(path.join("."))
            return
        }
        for(let i=startIndex;i<len;i++){
            const str=s.substring(startIndex,i+1)
            if(str>255||str.length>3) return //return掉就是说这一层的从这个开始往右走都不要了；continue就是跳过这一个，但这一层的这个的右边还是要的
            if(str.length > 1 && str[0] === "0") return
            path.push(str)
            backtrack(i+1)
            path.pop()
        }
        return
    }
    backtrack(0)
    return res
};
```



##### [842. 将数组拆分成斐波那契序列](https://leetcode.cn/problems/split-array-into-fibonacci-sequence/)

思路跟 分割回文串 一致

```js
var splitIntoFibonacci = function(num) {
    const path=[],len=num.length
    let res=[]
    function backtrack(startIndex){
        if(path.length>=3&&startIndex>=len){
            res = path
            return true
        }


        for(let i=startIndex;i<len;i++){
            const subStr = num.substring(startIndex,i+1)
            if(subStr.length>1&&subStr.startsWith('0')) break
            const curNum = subStr*1
            if(curNum >= 2 ** 31) break

            const pLen = path.length
            if(pLen>=2){
                if(curNum!=path[pLen-2]+path[pLen-1]){
                    continue
                }
            }

            path.push(curNum)
            if(backtrack(i+1)) return true
            path.pop()
        }
        return false
    }
    backtrack(0)
    return res
};
```











##### [1255. 得分最高的单词集合](https://leetcode.cn/problems/maximum-score-words-formed-by-letters/)

```js

 //枚举所有的 words 组合，然后判断是否可以满足单词拼写的游戏规则，最后找出所有满足条件的最大分数
var maxScoreWords = function(words, letters, score) {
    const scores=[0]
    const lettersMap = new Map()
    let eachMaxScore=0
    for(const char of letters){
        if(lettersMap.has(char)){
            let num = lettersMap.get(char)
            num++
            lettersMap.set(char,num)
        }else{
            lettersMap.set(char,1)
        }
    }

    function backtrack(startIndex){
        for(let i=startIndex;i<words.length;i++){
            const score = getScore(words[i])
            if(score==0)  continue
            eachMaxScore += score
            scores.push(eachMaxScore)
            backtrack(i+1)
            eachMaxScore -= score
            restoreLetterMap(words[i])
        }
    }
    function getScore(word) { //返回分数，如果组合不出这个单词则返回0
        const len= word.length
        let res = 0
        let i = 0
        for (; i < len;i++) {
            const char = word[i]
            if(lettersMap.has(char)){ //判断是否有
                let num = lettersMap.get(char)
                if (num == 0) { 
                    res = 0
                    break
                }
                num--
                lettersMap.set(char,num)

                const index = char.charCodeAt(0)-'a'.charCodeAt(0) //计算得分
                res += score[index]
            }else{
                res = 0
                break
            }
        }
        if (res == 0) {
            restoreLetterMap(word.substring(0,i))
        }
        return res
    }
    function restoreLetterMap(word) {
        for (const char of word) {
            let num = lettersMap.get(char)
            num++
            lettersMap.set(char,num)
        }
    }

    backtrack(0)
    return Math.max(...scores)
};
```







##### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```javascript
var generateParenthesis = function(n) {
  let res = [], path = [],left=new Array(n).fill('('),right=new Array(n).fill(')')
  const backtrack = (leftIndex,rightIndex) => {
    if (leftIndex === n&&rightIndex===n) { /*base case*/
      res.push(path.join(""))
      return
    }
    if (leftIndex>n||rightIndex>n||rightIndex > leftIndex) return /*这个剪枝 前面两个是约束不越界，最后面这一个是看你对形成合法括号是否了解了*/
    
    /*这道题是个二叉树，即每个父节点下的每一层都只有两个节点，即如果是for循环也循环两次就好了，这里左右两个不同的数组用循环你不鸡肋吗所以不用循环了，但本质还是那个框架*/
      path.push(left[leftIndex])
      backtrack(leftIndex + 1, rightIndex)
      path.pop()

      path.push(right[rightIndex])
      backtrack(leftIndex, rightIndex + 1)
      path.pop()
  }
  backtrack(0, 0)
  return res
};
```

##### [473. 火柴拼正方形](https://leetcode-cn.com/problems/matchsticks-to-square/)

```javascript
var makesquare = function (matchsticks) {
  matchsticks.sort((a,b)=>b-a)//从大值开始，可以优化时间
  let sum = matchsticks.reduce((pre, cur) => pre + cur, 0)
  if (sum % 4) return false //边长除于4除不尽则说明不可能成为正方形
  let edge = sum / 4 //每条边的边长
  let bucket = new Array(4).fill(0) //准备四个桶来放四条边的边长
  let len = matchsticks.length
  const backtrack= index => {
    if (index === len) {
      return true
    }
    for (let i = 0; i < 4; i++){// matchsticks里的每个数过来都看看四个桶哪个桶能放
      if (bucket[i] + matchsticks[index] > edge) continue
      bucket[i] += matchsticks[index]
      if(backtrack(index + 1)) return true  //递归遍历matchsticks里的所有值
      bucket[i] -= matchsticks[index]
    }
    return false
  }
  return backtrack(0)
};
```







#### 元素可重不可复选

> **强调一下，树层去重的话，需要对数组排序！！**
>
> startIndex是指每个方案里的第一个数

##### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

```javascript
var subsetsWithDup = function(nums) {
    const res = [],path = []
    const len = nums.length
    function backtrack(startIndex){
        res.push(path.slice())
        for(let i= startIndex;i<len;i++){
            if(i>startIndex&&nums[i]==nums[i-1]) continue
            path.push(nums[i])
            backtrack(i+1)
            path.pop()
        }
    }
    nums.sort((a,b)=>a-b)
    backtrack(0)
    return res
};
```

##### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

> **本题我们要去重的是同一树层上的“使用过”**

```javascript
var combinationSum2 = function(candidates, target) {
    candidates.sort((a,b)=>a-b) //给定的数组可能有重复的元素，先排序，使得重复的数字相邻，方便去重
    let res=[],path=[],sum=0,len=candidates.length
    const backtrack=function(startIndex){
        if(sum===target) {
            res.push([...path])
            return
        }
        for(let i=startIndex;i<len;i++){
            if(i-1>=startIndex&&candidates[i]===candidates[i-1]) continue  // 当前元素跟上一个元素相同且上一个元素在索引选择范围内则当前元素就不需要加入
            if(sum>target) return
            path.push(candidates[i])
            sum+=candidates[i]
            backtrack(i+1)
            path.pop()
            sum-=candidates[i]
        }
        return
    }
    backtrack(0)
    return res
};
```



##### [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

```javascript
var findSubsequences = function(nums) {
    let res=[],path=[],len=nums.length
    const backtrack= startIndex=>{
        if(path.length>=2){
            res.push([...path])
        }

        let used=new Set()//记录在本层中某个元素是否使用过
        for(let i=startIndex;i<len;i++){
            if(used.has(nums[i])||(path.length>0&&nums[i]<path[path.length-1])) continue 
            used.add(nums[i])
            path.push(nums[i])
            backtrack(i+1)
            path.pop()
        }
        return
    }
    backtrack(0)
    return res
};
```







#### 元素无重可复选

##### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```javascript
var combinationSum = function(candidates, target) {
    let res=[],path=[],len=candidates.length,sum=0
    const backtrack= startIndex=>{
        if(sum===target){
            res.push([...path])
            return 
        }
        if(sum>target)return //停止树再往下生长了
        for(let i=startIndex;i<len;i++){
            path.push(candidates[i])
            sum+=candidates[i]
            backtrack(i) //还可以选自己
            path.pop()
            sum-=candidates[i]
        }
        return
    }
    backtrack(0)
    return res
};
```



## 排列

<picture>
    <source type="image/avif" srcset="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/2.jpeg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/2.jpeg?imageMogr2/format/webp">
    <img src="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/2.jpeg" alt="https://labuladong.gitee.io/algo/images/%e6%8e%92%e5%88%97%e7%bb%84%e5%90%88/2.jpeg" loading="lazy"/>
  </picture>



### 例题

#### 元素无重不可复选

##### [46. 全排列](https://leetcode-cn.com/problems/permutations/) 

```javascript
var permute = function(nums) {
    let res = [],path=new Set()
    const len=nums.length
    function backtrack(path){
        if(path.size == len){
            res.push([...path])
        }
        for(let i = 0;i<len;i++){
            if(path.has(nums[i])) continue
            path.add(nums[i])
            backtrack(path)
            path.delete(nums[i])
        }
    }
    backtrack(path)
    return res
};
```



##### [剑指 Offer 38. 字符串的排列](https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/)

```javascript
var permutation = function(s) {
    const result= new Set()
    function backtrack(path,used){
        if(path.length===s.length) {
            result.add(path.join(''))
        }

        for (let i = 0; i < s.length; i++){
            if(used.get(i)) continue
            used.set(i,true)
            path.push(s[i])
            backtrack(path,used)
            path.pop()
            used.set(i,false)
        }
    }
    const used = new Map()
    backtrack([],used)
    return [...result]
};
```





#### 元素可重不可复选

##### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```javascript
var permuteUnique = function(nums) {
    nums.sort((a,b)=>a-b)
    const res = [],curArr = [],len = nums.length
    const selectedIndex = new Set()// 用于每一列中不能选自己前面行选过的值
    function backtrack(){
        if(curArr.length === nums.length){
            res.push(curArr.slice())
            return
        }
         
        let preSelfLevelNum  // 用于在本层去重，如果当前值等于本层的上一个用到的值，则这个值不选；用这种相邻的方式来去重必须保证数组是有序的。
        for(let i=0;i<len;i++){
            if(preSelfLevelNum===nums[i]||selectedIndex.has(i)){
                continue
            }else{
                preSelfLevelNum = nums[i]
                curArr.push(nums[i])
                selectedIndex.add(i)
                backtrack()
                curArr.pop()
                selectedIndex.delete(i)
            }
        }
    }
    backtrack()
    return res
};
```



## 其他例题

### [LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/)

```javascript
var numWays = function(n, relation, k) {
    const neighbors = new Array(n).fill(0).map(item=>new Array())
    let result=0
    for(const [src,neighbor] of relation){
        neighbors[src].push(neighbor) //记录每个节点的邻居节点
    }

    const dfs = (index,step)=>{
        if(step===k){
            index===n-1&&result++
            return
        }
        for(const next of neighbors[index]){
            step++
            dfs(next,step)
            step--
        }
    }
    dfs(0,0)
    return result
};
```









# BFS

## 应用场景

最短路径。**广搜只要搜到了终点，那么一定是最短的路径**。因为广搜就是以起点中心向四周扩散的搜索。

## 思维模式

BFS 相对 DFS 的最主要的区别是：**BFS 找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多**，而且找最短的话DFS也能找但是要穷举完才找的到，BFS就快多了，每次都把这一层给找了，而DFS是一个一个来。

BFS 问题的本质就是让你在一幅「图」中找到从起点 `start` 到终点 `target` 的最近距离

框架

> 怎么套到 BFS 的框架里呢？首先明确一下起点 `start` 和终点 `target` 是什么，怎么判断到达了终点？

```java
var jump = function(nums) {
    const n = nums.length;
    let ans = 0; //跳跃次数就是每一层，跳一次到下一层
    const visited = new Array(n).fill(false);
    const queue = [];

    visited[0] = true;
    queue.push(0);

    while (queue.length > 0) { // 控制层级
        const size = queue.length;

        for (let i = 0; i < size; i++) { // 取出该层的每一个数
            const idx = queue.shift();

            if (idx === n - 1) { // 是否到达终点
                return ans;
            }

            for (let j = idx + 1; j <= idx + nums[idx] && j < n; j++) { // 逐个加入下一层的数
                if (!visited[j]) { // 防止重复
                    visited[j] = true;
                    queue.push(j);
                }
            }
        }

        ans++;
    }

    return ans;
};

```



## BFS优化---双向BFS	

**传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时扩散，当两边有交集的时候停止。**



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-04-17-28-image-20240104172847177.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-04-17-28-image-20240104172847177.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-04-17-28-image-20240104172847177.png" alt="image-20240104172847177" style="zoom:33%;" loading="lazy"/>
  </picture>

在最坏的情况下，如果图中的节点数为N，那么普通的BFS需要搜索O(N)个节点，而双向BFS只需要搜索O(N^(1/2))个节点。

**无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的**。由图可知由于少遍历一些节点能缓解一定的空间和时间问题。

应用场景：**要想用双向 BFS，则必须知道终点在哪里**。

```java
//双向 BFS 还有一个优化是在 while 循环开始时做一个判断：因为按照 BFS 的逻辑，队列（集合）中的元素越多，扩散之后新的队列（集合）中的元素就越多；在双向 BFS 算法中，如果我们每次都选择一个较小的集合进行扩散，那么占用的空间增长速度就会慢一些，效率就会高一些。
// ...
while (!q1.isEmpty() && !q2.isEmpty()) {
  	if (q1.size > q2.size) [q1, q2] = [q2, q1]//哪个少就扩散哪个 （感觉没啥意义，可以两边同时扩散而不是取小的）
    for (const cur of q1)  {
      	// 。。。。。。
      	if(q2.has(cur)) return // 找到答案了
    }
}
 // ...
```





## 例题

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

```javascript
var minDepth = function(root) { 
  let queue = [], step = 1//因为root本身就算一层，所以step初始值为1
  if (root) queue.push(root)
  else {
    return 0
  }
  while (queue.length) {
    let size = queue.length
    for (let i = 0; i < size; i++){
      let cur = queue.shift()
      if (cur.left === null && cur.right === null) return step
      if (cur.left) queue.push(cur.left)
      if(cur.right) queue.push(cur.right)
    }
    step++
  }
};
```



### [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

```javascript
var openLock = function(deadends, target) {
  let visited = new Set(deadends)
  if (visited.has('0000')) return -1
  let queue = [],step=0
  queue.push('0000')
  visited.add('0000')
  while (queue.length) {
    let size = queue.length
    for (let i = 0; i < size; i++){
      let cur = queue.shift()
      if (cur === target) return step
      
      for (let j = 0; j < 4; j++){
        let handleNum = cur[j] * 1
        const upNum=(handleNum+1)%10
        const downNum = (handleNum + 9) % 10//取余就可以把某个数限制在某个范围内，比如这里就可以把数限制在10以内
        const upStr = cur.substring(0, j) + upNum + cur.substring(j + 1)
        const downStr = cur.substring(0, j) + downNum + cur.substring(j + 1)
        if (!visited.has(upStr)) { 
          visited.add(upStr)
          queue.push(upStr)
        } 
        if (!visited.has(downStr)) { 
          visited.add(downStr)
          queue.push(downStr)
        } 
      }
    }
    step++
  }
  return -1
};
```

双向BFS优化

```javascript
var openLock = function(deadends, target) {
  let visited = new Set(deadends)
  if (visited.has('0000')) return -1
  let q1=new Set(),q2=new Set(),step=0
  q1.add('0000')
  q2.add(target)
  while (q1.size && q2.size) {
    if (q1.size > q2.size) [q1, q2] = [q2, q1]//哪个少就扩散哪个
    let temp = new Set() //q1扩散后的节点存在temp里，如果存回q1里的话那下面这个循环就会一直下去知道扩散完整个图最后return 0
    for (const cur of q1) {
      if(visited.has(cur))continue
      if(q2.has(cur)) return step
       visited.add(cur)//跟单向BFS的位置不一样
      for (let j = 0; j < 4; j++){
        let handleNum = cur[j] * 1
        const upNum=(handleNum+1)%10
        const downNum = (handleNum + 9) % 10//取余就可以把某个数限制在某个范围内，比如这里就可以把数限制在10以内
        const upStr = cur.substring(0, j) + upNum + cur.substring(j + 1)
        const downStr = cur.substring(0, j) + downNum + cur.substring(j + 1)
        if (!visited.has(upStr)) { 
          temp.add(upStr)
        } 
        if (!visited.has(downStr)) { 
          temp.add(downStr)
        } 
      }
    }
    step++
    q1=temp
  }
  return -1
};
```



### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

```js
var jump = function(nums) {
    const n = nums.length;
    let ans = 0; //跳跃次数就是每一层，跳一次到下一层
    const visited = new Array(n).fill(false);
    const queue = [];

    visited[0] = true;
    queue.push(0);

    while (queue.length > 0) { // 控制层级
        const size = queue.length;

        for (let i = 0; i < size; i++) { // 取出该层的每一个数
            const idx = queue.shift();

            if (idx === n - 1) { // 是否到达终点
                return ans;
            }

            for (let j = idx + 1; j <= idx + nums[idx] && j < n; j++) { // 逐个加入下一层的数
                if (!visited[j]) { // 防止重复
                    visited[j] = true;
                    queue.push(j);
                }
            }
        }

        ans++;
    }

    return ans;
};
```







# 图

## 应用场景

图论解决的都是诸如社交网络这样数据规模巨大的问题

图这种数据结构有一些比较特殊的算法，比如二分图判断，有环图无环图的判断，拓扑排序，以及最经典的最小生成树，单源最短路径问题，更难的就是类似网络流这样的问题。

不过以我的经验呢，像网络流这种问题，你又不是打竞赛的，没时间的话就没必要学了；像 [最小生成树](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/prim-zui-x-0ef51/) 和 [最短路径问题](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/dijkstra-s-6d0b2/)，虽然从刷题的角度用到的不多，但它们属于经典算法，学有余力可以掌握一下；像 [二分图判定](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/er-fen-tu--73400/)、拓扑排序这一类，属于比较基本且有用的算法，应该比较熟练地掌握。

## 图的逻辑结构

图一般用邻接表和邻接矩阵来表示：邻接表看图就行。邻接矩阵则是一个二维布尔数组，我们权且称为 `matrix`，如果节点 `x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。

无论什么花里胡哨的图，都可以用这两种方式存储。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-27-13-46-image-20230827134625590.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-27-13-46-image-20230827134625590.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-27-13-46-image-20230827134625590.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-27-13-46-image-20230827134625590.png" loading="lazy"/>
  </picture>

对于邻接表，好处是占用的空间少。

你看邻接矩阵里面空着那么多位置，肯定需要更多的存储空间。

但是，邻接表无法快速判断两个节点是否相邻。

比如说我想判断节点 `1` 是否和节点 `3` 相邻，我要去邻接表里 `1` 对应的邻居列表里查找 `3` 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。







## 一些概念

### 有向无权、有向加权、无向无权、无向加权

上述这个图是**有向无权图**。还有什么加权图，无向图，等等……这些更复杂的模型都是基于这个最简单的图衍生出来的。



**有向加权图怎么实现**？很简单呀：

如果是邻接表，我们不仅仅存储某个节点 `x` 的所有邻居节点，还存储 `x` 到每个邻居的权重

如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重





**无向图怎么实现**？也很简单，所谓的「无向」，是不是等同于「双向」？

如果连接无向图中的节点 `x` 和 `y`，那么把 `matrix[x][y]` 和 `matrix[y][x]` 都变成 `true` 不就行了；邻接表也是类似的操作，在 `x` 的邻居列表里添加 `y`，同时在 `y` 的邻居列表里添加 `x`。



把上面的技巧合起来，就变成了**无向加权图**





### 度

在无向图中，「度」就是每个节点相连的边的条数。由于有向图的边有方向，所以有向图中每个节点「度」被细分为**入度**（indegree）和**出度**（outdegree）



### 图的crud

具体实现看这：https://www.hello-algo.com/chapter_graph/graph_operations/

设图中共有 \(n\) 个顶点和 \(m\) 条边，表 9-2 对比了邻接矩阵和邻接表的时间效率和空间效率。

表 9-2  邻接矩阵与邻接表对比

|              | 邻接矩阵   | 邻接表（链表） | 邻接表（哈希表） |
| :----------- | :--------- | :------------- | :--------------- |
| 判断是否邻接 | \(O(1)\)   | \(O(m)\)       | \(O(1)\)         |
| 添加边       | \(O(1)\)   | \(O(1)\)       | \(O(1)\)         |
| 删除边       | \(O(1)\)   | \(O(m)\)       | \(O(1)\)         |
| 添加顶点     | \(O(n)\)   | \(O(1)\)       | \(O(1)\)         |
| 删除顶点     | \(O(n^2)\) | \(O(n + m)\)   | \(O(n)\)         |
| 内存空间占用 | \(O(n^2)\) | \(O(n + m)\)   | \(O(n + m)\)     |

观察表 9-2 ，似乎邻接表（哈希表）的时间效率与空间效率最优。但实际上，在邻接矩阵中操作边的效率更高，只需一次数组访问或赋值操作即可。综合来看，邻接矩阵体现了“以空间换时间”的原则，而邻接表体现了“以时间换空间”的原则。







## 图的遍历

### 多叉树的 DFS 遍历框架

```javascript
/* 多叉树遍历框架 */
var traverse = function(root) {
    if (root == null) return;
    // 前序位置
    for (var i = 0; i < root.children.length; i++) {
        traverse(root.children[i]);
    }
    // 后序位置
};
```

### 图遍历框架

图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点，而树不会出现这种情况，从某个节点出发必然走到叶子节点，绝不可能回到它自身。如果图包含环，遍历框架就要一个 `onPath` 数组进行辅助。



#### dfs

DFS 最显著的特征在于其 **递归调用自身**。遇到一个邻居就先进去遍历他邻居，遇到一个邻居又先进去遍历他邻居。

```js
/* 邻接表 dfs遍历框架 */
function traverse(graph,cur){ 
  if(cur===终点) return
  for(let i=0;i<graph.neighbors(cur).length;i++){ //遍历当前元素可以访问的所有节点
    traverse(graph,graph.neighbors(cur).[i])
  }
}
```





#### bfs

bfs利用队列进行双重循环。很专一，把自己的邻居先遍历完再去遍历别人的邻居。

```js
	function traverse(cur){
        const queue = []
        queue.push(cur)
        while(queue.length){
            const curNode = queue.shift()
            for(const neighborNode of curNode.neighbors){
                queue.push(neighborNode)
            }
        }
    }
```





```js
/* 图遍历框架 */ onPath 就是 用来 判断有无环； visited顾名思义，某些题不一定有用，感觉更多还是用来剪枝
var visited = [];
var onPath = [];

function traverse(graph, s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (var i = 0; i < graph.neighbors(s).length; i++) {
        var neighbor = graph.neighbors(s)[i];
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

注意 `visited` 数组和 `onPath` 数组的区别，因为二叉树算是特殊的图，所以用遍历二叉树的过程来理解下这两个数组的区别：

**在 `visited` 中被标记为 true 的节点用灰色表示，在 `onPath` 中被标记为 true 的节点用绿色表示**，在图的遍历过程中，`onPath` 用于判断是否成环。类比贪吃蛇游戏，`visited` 记录蛇经过过的格子，而 `onPath` 仅仅记录蛇身。`onPath` 用于判断是否成环，类比当贪吃蛇自己咬到自己（成环）的场景。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-ZLsGOl.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-ZLsGOl.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-ZLsGOl.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-ZLsGOl.gif" loading="lazy"/>
  </picture>





## 例题





#### [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)

```js
var allPathsSourceTarget = function(graph) {
    const res = [],curPath = [],len = graph.length
    function dfs(curIndex){
        curPath.push(curIndex)
        if(curIndex===len-1){
            res.push(curPath.slice())
        }
        const neighbors = graph[curIndex]
        for(const i of neighbors){
            dfs(i)
        }
        curPath.pop()
    }
    dfs(0)
    return res
};
```







#### [133. 克隆图](https://leetcode.cn/problems/clone-graph/)

```js
//bfs
var cloneGraph = function(node) {
    if(node === null) return null
    const visited = new WeakMap()
        const queue = []
        queue.push(node)
        const startNodeClone = new Node(node.val,[])
        visited.set(node,startNodeClone)
        while(queue.length){
            const curNode = queue.shift()

            for(const neighborNode of curNode.neighbors){
                if(!visited.has(neighborNode)){
                    queue.push(neighborNode)
                    const clonedNeighborNode = new Node(neighborNode.val,[])
                    visited.set(neighborNode,clonedNeighborNode)
                }
                const clonedNeighborNode =  visited.get(neighborNode)
                const clonedCurNode = visited.get(curNode)
                clonedCurNode.neighbors.push(clonedNeighborNode)
            }
        }
    return startNodeClone
};


//dfs
const cloneGraph = (startNode) => {
  const visited = new Map();

  const clone = (node) => {
    if (node == null) return null;
    if (visited.has(node.val)) return visited.get(node.val);

    const clonedNode = new Node(node.val, []);
    visited.set(node.val, clonedNode);

    for (const neighborNode of node.neighbors) {
      const clonedNeighborNode = clone(neighborNode);
      clonedNode.neighbors.push(clonedNeighborNode);
    }
    return clonedNode;
  };

  return clone(startNode);
};
```



#### [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)

```js
var canVisitAllRooms = function(rooms) {
    const doorsNum = rooms.length
    const visited = new Array(doorsNum).fill(false)
    function bfs(queue){
        while(queue.length){
            const len = queue.length
            for(let i = 0;i<len;i++){
                const cur = queue.shift()
                if(visited[cur]) continue
                visited[cur] = true
                const neighbors = rooms[cur]
                queue.push(...neighbors)
            }
        }
    }

    bfs([0])
    return visited.every(item=>item===true)
};
```





#### [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

```js
/**
 * @param {string} beginWord
 * @param {string} endWord
 * @param {string[]} wordList
 * @return {number}
 */

function isOnlyOneDiff(a,b){
    const len = a.length
    let diff = 0
    for(let i=0;i<len;i++){
        if(a[i]!==b[i]){
            diff++
        }
        if(diff>1){
            return false
        }
    }
    return true
}

var ladderLength = function (beginWord, endWord, wordList) {
    if(!wordList.includes(endWord)) return 0
    wordList.unshift(beginWord)
    const wordSet = new Set(wordList)
    wordList = Array.from(wordSet)
    const len = wordSet.size
    /**建图 */
    const graph = {}
    for (let i = 0; i <len;i++) {
        for(let j = i+1;j<len;j++){
            if(isOnlyOneDiff(wordList[i],wordList[j])){
                if(!graph[wordList[i]]){
                    graph[wordList[i]] = new Set()
                }
                if(!graph[wordList[j]]){
                    graph[wordList[j]] = new Set()
                }
                graph[wordList[i]].add(wordList[j])
                graph[wordList[j]].add(wordList[i])
            }
        }
    }

    if(!Object.keys(graph).includes(beginWord)) return 0

    // bfs
    let depth = 0
    const queue = [beginWord],visited = new Set()
    while(queue.length){
        depth++
        const len = queue.length
        for(let i = 0;i<len;i++){
            const cur = queue.shift()
            if(visited.has(cur)) continue
            visited.add(cur)
            const neighbors = graph[cur]
            if(neighbors.has(endWord)){
                return depth+1
            }else{
                queue.push(...neighbors)
            }
        }
    }
  
      // 双向bfs
    let depth = 0
    let q1 = [beginWord],q2 = [endWord],visited = new Set()
    while(q1.length&&q2.length){
        depth++
        if (q1.length > q2.length) [q1, q2] = [q2, q1]
        const len = q1.length
        for(let i = 0;i<len;i++){
            const cur = q1.shift()
            if(visited.has(cur)) continue
            if(q2.includes(cur)) return depth
            visited.add(cur)
            const neighbors = graph[cur]
            q1.push(...neighbors)
        }
    }
    return 0
};
```









### 环检测

dfs通过onPath记录。

bfs：

1、构建一个 `indegree` 数组记录每个节点的入度，即 `indegree[i]` 记录节点 `i` 的入度。

2、对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列。

**3、开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列**。

**4、如果最终所有节点都被遍历过（`count` 等于节点数），则说明不存在环，反之则说明存在环**。

具体为什么可以看https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/#%E7%8E%AF%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95-bfs-%E7%89%88%E6%9C%AC 这里的图解



[207. 课程表](https://leetcode.cn/problems/course-schedule/)

labuladong有题解

就是判断有无环就行

```js
/**dfs*/
var canFinish = function (numCourses, prerequisites) {
      /**建图 */
  const graph = new Array(numCourses).fill(0).map(() => []);
  for (let i = 0; i < prerequisites.length; i++) {
    const edge = prerequisites[i];
    const from = edge[1];
    const to = edge[0];
    graph[from].push(to);
  }

    const visited = new Set()
    let isCycle = false
  const onPath = new Set();
  function dfs(curIndex) {
    if (onPath.has(curIndex)) {
      // 有环
      isCycle =  true;
    }
    if(visited.has(curIndex)||isCycle){
        return 
    }
    visited.add(curIndex)
    onPath.add(curIndex);
    const neighbors = graph[curIndex];
    for (const i of neighbors) {
      dfs(i)
    }
    onPath.delete(curIndex);
  }

  for(let i=0;i<graph.length;i++){ // 从任意一个点开始都要尝试
      dfs(i)
  }
  return !isCycle
};



/*bfs*/
var canFinish = function(numCourses, prerequisites) {
    /**建图 */
    const graph = new Array(numCourses).fill(1).map(()=>[])
    for(let i =0;i<prerequisites.length;i++){
        const edge = prerequisites[i]
        const from = edge[1]
        const to = edge[0]
        graph[from].push(to)
    }

    /**建立 入度 数组 */
    const indegree = new Array(numCourses).fill(0)
        for(let i =0;i<prerequisites.length;i++){
        const edge = prerequisites[i]
        const to = edge[0]
        indegree[to]++
    }

    /**初始化 bfs 的队列 */
    const queue = []
    for (let i = 0; i < numCourses; i++) {
        if (indegree[i] == 0) {
            queue.push(i);
        }
    }

    /**开始 bfs */
    while(queue.length){
        const len = queue.length
        for(let i=0;i<len;i++){
            const curIndex = queue.shift()
            const neighbors = graph[curIndex]
            neighbors.forEach((item)=>{
                indegree[item]--
                if(indegree[item]===0){
                    queue.push(item);
                }
            })
        }
    }
    
    return indegree.every(item=>item===0)
};
```





### 拓扑排序

#### 解法

**直观地说就是，让你把一幅图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的**，比如上图所有箭头都是朝右的。此时节点的顺序就是满足了拓扑排序。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-22-17-image-20231213221711273.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-22-17-image-20231213221711273.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-22-17-image-20231213221711273.png" alt="image-20231213221711273" style="zoom:33%;" loading="lazy"/>
  </picture>

很显然，如果一幅有向图中存在环，是无法进行拓扑排序的，因为肯定做不到所有箭头方向一致；反过来，如果一幅图是「有向无环图」，那么一定可以进行拓扑排序。



dfs：**后序遍历的反转结果就是拓扑排序**。**之所以拓扑排序的基础是后序遍历，是因为一个任务必须等到它依赖的所有任务都完成之后才能开始开始执行**。但由于后序遍历中父节点是在子节点后面才进队列的，而拓扑排序要求父节点在子节点前面，所以要进行反转。

bfs：**节点的遍历顺序就是拓扑排序的结果**。[labuladong讲解](https://labuladong.github.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-bfs-%E7%89%88%E6%9C%AC)



#### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)

就是拓扑排序

```js
/*dfs*/
var findOrder = function (numCourses, prerequisites) {
  const graph = new Array(numCourses).fill(1).map(() => []);
  for (let i = 0; i < prerequisites.length; i++) {
    const edge = prerequisites[i];
    const from = edge[1];
    const to = edge[0];
    graph[from].push(to);
  }

    const postOrder = [];
  const curPath = [];
  const visited = new Set();
  let hasCycle = false;
  function dfs(curIndex) {
    if (curPath.includes(curIndex)) {
      hasCycle = true;
    }
    if (hasCycle || visited.has(curIndex)) {
      return;
    }

    curPath.push(curIndex);
    visited.add(curIndex);
    const neighbors = graph[curIndex];
    for (const i of neighbors) {
      dfs(i);
    }
    postOrder.push(curIndex);
    curPath.pop();
  }

  for (let i = 0; i < numCourses; i++) {
    dfs(i);
  }
      if(hasCycle){
        return []
    }else{
    return  postOrder.reverse()
    }
};

/*bfs*/
var findOrder = function(numCourses, prerequisites) {
    /**建图 */
    const graph = new Array(numCourses).fill(1).map(()=>new Array())
    for(const edge of prerequisites){
        const from = edge[1]
        const to = edge[0]
        graph[from].push(to)
    }

    /**建立 入度 数组 */
    const ig = new Array(numCourses).fill(0)
    for(const edge of prerequisites){
        const to = edge[0]
        ig[to]++
    }

    /**初始化 queue */
    const queue = []
     ig.forEach((item,index)=>{
        if(item===0){
            queue.push(index)
        }
    })

    /**开始bfs */
    const res= []
    while(queue.length){
        const len = queue.length
        for(let i=0;i<len;i++){
            const curIndex = queue.shift()
            res.push(curIndex)
            const neighbors = graph[curIndex]
            neighbors.forEach(item=>{
                ig[item]--
                if(ig[item]===0){
                    queue.push(item)
                }
            })
        }
    }
    return ig.every(item=>item===0)?res:[]
};
```



#### [310. 最小高度树](https://leetcode.cn/problems/minimum-height-trees/)

```js
 /**
 拓扑排序法：
 从叶子节点开始，一层一层地删除叶子节点（每删除一层叶子节点，就会产生新的叶子节点），直到剩下的节点数小于等于 2 个为止。之所以是 2 个而不是 1 个，是因为如果输入的这幅图两边完全对称，可能出现两个节点都可以作为根节点的情况。最后剩下的这些节点，就是我们要找的最小高度树的根节点。
  */
var findMinHeightTrees = function(n, edges) {
    /**建图 和 算度*/
    const graph = new Array(n).fill(0).map(()=>[])
    const indegree = new Array(n).fill(0)
    for(const edge of edges){
        const one = edge[0]
        const two = edge[1]
        graph[one].push(two)
        graph[two].push(one)
        indegree[one]++
        indegree[two]++
    }

    /** bfs*/
    const queue = []
    indegree.forEach((item,index)=>{
        if(item === 1){
            queue.push(index)
        }
    })

    let remainNodes = n
    while(remainNodes>2){
        const len = queue.length
        remainNodes -= len
        for(let i = 0;i<len;i++){
            const curIndex = queue.shift()
            const neighbors = graph[curIndex]
            neighbors.forEach(item=>{
                indegree[item]--
                if(indegree[item]===1){
                    queue.push(item)
                }
            })
        }
    }
    return queue.length===0?[0]:queue
};
```







### 二分图

#### 定义

一幅「图」，能用两种颜色将图中的所有顶点着色，且任意一条边的两个端点的颜色都不相同。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-18-21-51-image-20231218215113307.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-18-21-51-image-20231218215113307.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-18-21-51-image-20231218215113307.png" alt="image-20231218215113307" style="zoom:50%;" loading="lazy"/>
  </picture>



#### 应用场景

二分图作为一种特殊的图模型，会被很多高级图算法（比如最大流算法）用到，不过这些高级算法我们不是特别有必要去掌握。

从简单实用的角度来看，二分图结构在某些场景可以更高效地存储数据。：比如说我们需要一种数据结构来储存电影和演员之间的关系：某一部电影肯定是由多位演员出演的，且某一位演员可能会出演多部电影。并且如果给出一个演员的名字，我们想快速得到该演员演出的所有电影，这就需要「反向索引」。如果用哈希表存储，需要两个哈希表分别存储「每个演员到电影列表」的映射和「每部电影到演员列表」的映射。但如果用「图」结构存储，将电影和参演的演员连接，很自然地就成为了一幅二分图：，每个电影节点的相邻节点就是参演该电影的所有演员，每个演员的相邻节点就是该演员参演过的所有电影，非常方便直观。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-18-21-54-image-20231218215423955.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-18-21-54-image-20231218215423955.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-18-21-54-image-20231218215423955.png" alt="image-20231218215423955" style="zoom:25%;" loading="lazy"/>
  </picture>



####  二分图判定思路

判定二分图的算法就是用代码解决「双色问题」。

**即遍历一遍图，一边遍历一边染色，看看能不能用两种颜色给所有节点染色，且相邻节点的颜色都不相同**。





#### 题目

##### [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)

```js
/**bfs*/
var isBipartite = function (graph) {
    const len = graph.length
    const color = new Array(len).fill(false)
    const visited = new Set()

    function bfs(start) {
        const queue = [start]
        visited.add(start)
        while (queue.length) {
            const l = queue.length
            for (let i = 0; i < l; i++) {
                const curIndex = queue.shift()
                const neighbors = graph[curIndex]
                for (const item of neighbors) {
                    if (visited.has(item)) {
                        if (color[item] === color[curIndex]) {
                            return false
                        }
                    } else {
                        color[item] = !color[curIndex]
                        visited.add(item)
                        queue.push(item)
                    }
                }
            }
        }
        return true
    }

    for (let i = 0; i < len; i++) {
        if(visited.has(i)) continue
        if (bfs(i)) {
            continue
        } else {
            return false
        }
    }
    return true
};


/**dfs*/
var isBipartite = function(graph) {
    const len = graph.length
    const color = new Array(len).fill(false)
    const visited = new Set()
    let res = true
    function dfs(curIndex){
        visited.add(curIndex)
        const neighbors = graph[curIndex]
        for(const n of neighbors){
            if(visited.has(n)){
                if(color[curIndex]===color[n]){
                    res =false
                    return
                }
                continue
            }else{
                color[n] = !color[curIndex]
                dfs(n)
                if(res===false){
                    return res
                }
            }
        }
    }
    // 因为图不一定是联通的，可能存在多个子图,所以要把每个节点都作为起点进行一次遍历,如果发现任何一个子图不是二分图，整幅图都不算二分图
    for (let v = 0; v < len; v++) {
        if (!visited.has[v]) {
            dfs(v);
            if(res===false){
                return res
            }
        }
    }
    return true
};
```



##### [886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)

```js
// bfs
var possibleBipartition = function (n, dislikes) {
  const graph = new Array(n + 1).fill(1).map(() => []);
  for (const [a, b] of dislikes) {
    graph[a].push(b);
    graph[b].push(a);
  }

  const color = new Array(n + 1).fill(false);
  const colored = new Set();
  const queue = [];
  function bfs(start) {
    queue.push(start);
    colored.add(start);
    while (queue.length) {
      const len = queue.length;
      for (let i = 0; i < len; i++) {
        const cur = queue.shift();
        const neighbors = graph[cur];
        for (const item of neighbors) {
          if (colored.has(item)) {
            if (color[item] === color[cur]) {
              return false;
            }
          } else {
            color[item] = !color[cur];
            colored.add(item);
            queue.push(item);
          }
        }
      }
    }
    return true;
  }
  for (let i = 1; i <= n; i++) {
    if (colored.has(i)) continue;
    if (!bfs(i)) return false;
  }
  return true;
};
```



### 并查集

#### 应用场景

并查集（Union-Find）算法是一个专门针对「动态连通性」的算法（某与某之间有关系，某与某之间没有关系）。本质是为了归类（注意是归类，同一类之间并有等级之分，所以树的结构不重要。）

并查集常用来解决连通性问题。

大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。

并查集主要有两个功能：

- 将两个元素添加到一个集合中。
- 判断两个元素在不在同一个集合



#### 介绍

Union-Find 算法主要需要实现这两个 API：

```java
class UF {
    /* 将 p 和 q 连接 */
    public void union(int p, int q);
    /* 判断 p 和 q 是否连通 */
    public boolean connected(int p, int q);
}
```

这里所说的「连通」是一种等价关系，也就是说具有如下三个性质：

1、自反性：节点 `p` 和 `p` 是连通的。

2、对称性：如果节点 `p` 和 `q` 连通，那么 `q` 和 `p` 也连通。

3、传递性：如果节点 `p` 和 `q` 连通，`q` 和 `r` 连通，那么 `p` 和 `r` 也连通。

比如说0～9 中任意两个**不同**的点都不连通，调用 `connected` 都会返回 false，连通分量为 10 个。

如果现在调用 `union(0, 1)`，那么 0 和 1 被连通，连通分量降为 9 个。

再调用 `union(1, 2)`，这时 0,1,2 都被连通，调用 `connected(0, 2)` 也会返回 true，连通分量变为 8 个。

判断这种「等价关系」非常实用，比如说编译器判断同一个变量的不同引用，比如社交网络中的朋友圈计算等等。





#### 算法实现

我们目标是：对节点进行归类，把属于同一类的节点，合并到一个树中。
约定：让 x 的根节点 指向 y 的根节点，那么 x 和 y 节点就同处一棵树了。（谁指向谁并不重要，只是为了归类）

维护一个 roots 数组（或者叫 parent），这个 roots 数组，就是一个存放每个节点的 “父亲” 的数组。一个数组其实可以映射成树，用【索引值】指向【元素值】描述指向关系。所以roots 数组可以映射出若干颗树，树描述了节点的连接关系，一棵树是一个集合。

如下图，节点 0 ~ 5 是 roots 数组的索引，它们各自对应的元素值是父节点的值。这里的-1表示自己就是自己的父节点。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-28-14-45-image-20231228144539942.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-28-14-45-image-20231228144539942.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-28-14-45-image-20231228144539942.png" alt="image-20231228144539942" style="zoom:50%;" loading="lazy"/>
  </picture>



注意我的算法跟上描述有一些不一致，比如不是用-1来表示自己就是自己的父节点，而是【索引值】==【元素值】来表示 自己就是自己的父节点。  且每个节点都直接指向根节点。

```js
class UnionFind {
  constructor(n) {
    this.count = n;
    this.roots = new Array(n).fill(-1).map((item, index) => index);
  }

  findRoot(x) {
    if (this.roots[x] !== x) {
      // 还不是根节点则继续往下找
      this.roots[x] = this.findRoot(this.roots[x]); // 每次找完都会将自己指向根节点
    }
    return this.roots[x];
  }

  union(x, y) {
    const rootX = this.findRoot(x);
    const rootY = this.findRoot(y);
    this.roots[rootX] = rootY;
    this.count--;
  }

  isConnected(x, y) {
    const rootX = this.findRoot(x);
    const rootY = this.findRoot(y);
    return rootX === rootY;
  }
}
```







#### 例题

##### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)

```js
//并查集
class unionF{
    constructor(n){
        this.count = n
        this.roots = new Array(n).fill(0).map((item,index)=>index)
    }

    findRoot(x){
        if(this.roots[x]!==x){
            this.roots[x] = this.findRoot(this.roots[x])
        }
        return this.roots[x]
    }
    
    union(x,y){
        const rx = this.findRoot(x)
        const ry = this.findRoot(y)
        this.roots[rx] = ry
        this.count--
    }

    isConnected(x,y){
        return this.findRoot(x)===this.findRoot(y)
    }
}

var validPath = function(n, edges, source, destination) {
    const UF = new unionF(n)
    for(const [s,t] of edges){
        UF.union(s,t)
    }
    return UF.isConnected(source,destination)
};


// 双向bfs
var validPath = function(n, edges, source, destination) {
    const graph = new Array(n).fill(0).map(()=>[])
    for(const [s,t] of edges){
        graph[s].push(t)
        graph[t].push(s)
    }

    const visited = new Array(n).fill(false)
    function bfs(start,end,graph){
        const startq = [start]
        const endq = [end]
        while(startq.length&&endq.length){
            const slen = startq.length
            for(let i = 0;i<slen;i++){
                const scur = startq.shift()
                if(visited[scur]) continue
                if(endq.includes(scur)) return true
                visited[scur] = true
                const neighbors = graph[scur]
                startq.push(...neighbors)
            }

            const elen = endq.length
            for(let i = 0;i<elen;i++){
                const ecur = endq.shift()
                if(visited[ecur]) continue
                if(startq.includes(ecur)) return true
                visited[ecur] = true
                const neighbors = graph[ecur]
                endq.push(...neighbors)
            }
        }
        return false
    }
    return bfs(source,destination,graph)
};
```





##### [990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)

```js
var equationsPossible = function (equations) {
  const baseCode = "a".charCodeAt(0);
  const UF = new UnionFind(26); // 26 个英文字母

  // 先让相等的字母形成连通分量
  for (const eq of equations) {
    if (eq.charAt(1) === "=") {
      const first = eq.charAt(0).charCodeAt(0) - baseCode;
      const second = eq.charAt(3).charCodeAt(0) - baseCode;
      UF.union(first, second);
    }
  }

// 检查不等关系是否打破相等关系的连通性
  for (const eq of equations) {
    if (eq.charAt(1) === "!") {
      const first = eq.charAt(0).charCodeAt(0) - baseCode;
      const second = eq.charAt(3).charCodeAt(0) - baseCode;
      if (UF.isConnected(first, second)) {
        return false;
      }
    }
  }
  return true;
};
```



##### [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)

如果边的两个节点已经出现在同一个集合里，说明边的两个节点已经连在一起了，再加入这条边一定就出现环了。

```js
/**
 * @param {number[][]} edges
 * @return {number[]}
 */

class UnionF{
    constructor(n){
        this.roots = new Array(n).fill(0).map((item,index)=>index)
        this.count = n
    }

    findRoot(x){
        if(this.roots[x]!==x){
            this.roots[x]=this.findRoot(this.roots[x])
        }
        return this.roots[x]
    }

    union(x,y){
        const rx = this.findRoot(x)
        const ry = this.findRoot(y)
        this.roots[rx] = ry
        this.count--
    }

    isConnected(x,y){
        return this.findRoot(x)===this.findRoot(y)
    }
}

var findRedundantConnection = function(edges) {
    const UF = new UnionF(edges.length)
    for(const [s,t] of edges){
        if(UF.isConnected(s,t)){
            return [s,t]
        }
        UF.union(s,t)
    }
    return []
};
```







##### [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)

```js
// 解读题目：题目说的冗余一定是要么有入度为二的点，要么有环。如果有入度为2的点则删掉跟他相关的一条边后看还有没有环，无环则删掉边，仍有环则删掉另一条边；如果没有入度为2的点则删掉成环的那条边即可。
class UnionF {
    constructor(n) {
        this.count = n
        this.roots = new Array(n).fill(0).map((item, index) => index)
    }

    findRoot(x) {
        if (this.roots[x] !== x) {
            this.roots[x] = this.findRoot(this.roots[x])
        }
        return this.roots[x]
    }

    union(x, y) {
        this.roots[this.findRoot(x)] = this.findRoot(y)
        this.count--
    }

    isConnected(x, y) {
        return this.findRoot(x) === this.findRoot(y)
    }
}

var findRedundantDirectedConnection = function (edges) {
    const len = edges.length
    const inDegree = new Array(len + 1).fill(0)
    for (const [s, t] of edges) {
        inDegree[t]++
    }

    const twoDegreeTarget = inDegree.findIndex(item => item === 2)
    const twoDegreeEdgeIndexs = []

    for (let i = 0; i < len; i++) {
        const item = edges[i]
        if (item[1] === twoDegreeTarget) {
            twoDegreeEdgeIndexs.push(i)
        }
    }
    if (twoDegreeTarget !== -1) { // 存在入度为2的点
        if (hasCycle(edges, twoDegreeEdgeIndexs[1])) { // 构成有向环了，一定不是树。 
            return edges[twoDegreeEdgeIndexs[0]]
        } else {
            return edges[twoDegreeEdgeIndexs[1]]
        }
    } else {
        // 如果没有入度为2的点则一定是有环，删掉成环的那条边即可
        const UF = new UnionF(len)
        for (const [s, t] of edges) {
            if (UF.isConnected(s, t)) {
                return [s, t]
            }
            UF.union(s, t)
        }
    }
};

function hasCycle(edges, deletedEdgeIndex) { // 假删除
    const len = edges.length
    const UF = new UnionF(len)
    for (let i = 0; i < len; i++) {
        if (i === deletedEdgeIndex) continue
        const [s, t] = edges[i]
        if (UF.isConnected(s, t)) {
            return true
        }
        UF.union(s, t)
    }
    return false
}
```







### 二维矩阵

二维矩阵本质上是一幅「图」

#### 框架

```java
int[][] grid
int rows = grid.length, cols = grid[0].length;
boolean[][] visited//因为二维矩阵本质上是一幅「图」，所以遍历的过程中需要一个 visited 布尔数组防止走回头路。也可以在grid上做手脚，那就不用维护visited了。
void dfs(int i, int j) {
    if (i < 0 || j < 0 || i >= m || j >= n) {
        return;// 超出索引边界
    }
    if (visited[i][j]) {
        return;// 已遍历过 (i, j)
    }
    // 进入节点 (i, j)
    visited[i][j] = true;
    dfs(i - 1, j); // 上
    dfs(i + 1, j); // 下
    dfs(i, j - 1); // 左
    dfs(i, j + 1); // 右
}
```



#### 例题

##### [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

```javascript
var floodFill = function(image, sr, sc, newColor) {
    const rows=image.length,cols=image[0].length,oldColor=image[sr][sc]
    if(oldColor==newColor)return image
    const dfs= (x,y)=>{
        if(x<0||x>=rows||y<0||y>=cols||image[x][y]!=oldColor) return
        image[x][y]=newColor
        dfs(x+1,y)
        dfs(x,y+1)
        dfs(x-1,y)
        dfs(x,y-1)
    }
    dfs(sr,sc)
    return image
};
```





##### 沉岛算法

【淹掉】有 防重复的作用。

###### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```javascript
// dfs
var numIslands = function(grid) {    
    let rows=grid.length,cols=grid[0].length
    const dfs=function(x,y){ //淹没岛屿 --- 这个函数也叫Flood Fill 算法
        if(x<0||x>=rows||y<0||y>=cols||grid[x][y]==='0') return
        grid[x][y]='0' //能过上面那个if判断就说明是陆地，是陆地就把它淹掉
        dfs(x+1,y)
        dfs(x,y+1)
        dfs(x-1,y)
        dfs(x,y-1)
    }

    let num=0
    for(let i=0;i<rows;i++){
        for(let j=0;j<cols;j++){
            if(grid[i][j]==='1'){ //由于边矩形的边界都是水所以找到一个陆地就算找到一个岛屿，并且进去把它淹了
                num++ 
                dfs(i,j)
            }
        }
    }
    return num
};


//bfs
var numIslands = function (grid) {
    let res = 0
    const m = grid.length, n = grid[0].length
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (grid[i][j] === '1') {
                res++
                bfs(i, j)
            }
        }
    }

    function bfs(i, j) {
        const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 四个方向
        const queue = [[i, j]]
        while (queue.length) {
            const len = queue.length
            for (let i = 0; i < len; i++) {
                const [curI, curJ] = queue.shift()
                if (grid[curI][curJ] === '0') {
                    continue
                } else {
                    grid[curI][curJ] = '0'
                    dirs.forEach(([diff1, diff2]) => {
                        if (curI + diff1 >= m || curJ + diff2 >= n || curI + diff1 < 0 || curJ + diff2 < 0) { }
                        else { queue.push([curI + diff1, curJ + diff2]) }
                    })
                }
            }
        }
    }
    return res
};
```







###### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

```javascript
// dfs
var maxAreaOfIsland = function(grid) {
    let maxArea = 0
    const row = grid.length,col = grid[0].length
    const direction = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]
    function flood(i,j){
        if(i<0||i>=row||j<0||j>=col||grid[i][j]===0)return 0
        let curArea = 1
        grid[i][j]=0
        for(const dir of direction){
            const {x,y} = dir
            curArea+=flood(i+x,j+y)
        }
        return curArea
    }

    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(grid[i][j]===1){
                maxArea = Math.max(maxArea,flood(i,j))
            }
        }
    }
    return maxArea
};

// bfs
var maxAreaOfIsland = function(grid) {
    let maxArea = 0
    const row = grid.length,col = grid[0].length
    const direction = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}]

    function flood(queue){
        let curArea = 0
        while(queue.length){
            const len = queue.length
            for(let k = 0;k<len;k++){
                const {i,j} = queue.shift()
                if(i<0||i>=row||j<0||j>=col||grid[i][j]===0) continue
                curArea++
                grid[i][j]=0
                for(const dir of direction){
                    const {x,y} = dir
                    queue.push({i:i+x,j:j+y})
                }
            }
        }
        return curArea
    }
    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(grid[i][j]===1){
                maxArea = Math.max(maxArea,flood([{i,j}]))
            }
        }
    }
    return maxArea
};
```





###### [1254. 统计封闭岛屿的数目](https://leetcode-cn.com/problems/number-of-closed-islands/)

```javascript
//提前把靠边的陆地都淹掉，然后算出来的就是封闭岛屿了。
var closedIsland = function(grid) {
    let rows=grid.length,cols=grid[0].length
    const dfs= (x,y)=>{ //淹没岛屿 
        if(x<0||x>=rows||y<0||y>=cols||grid[x][y]===1)return
        grid[x][y]=1 //进来把你淹掉
        dfs(x+1,y)
        dfs(x,y+1)
        dfs(x-1,y)
        dfs(x,y-1)
    }

  for (let i = 0; i < rows; i++) {//提前把靠边的陆地都淹掉，然后算出来的就是封闭岛屿了。
    for (let j = 0; j < cols; j++) {
      if (
        (i == 0 || i == rows - 1 || j == 0 || j == cols - 1) &&grid[i][j] == 0
      )
        dfs(i, j);
    }
  }
    let num=0
    for(let i=0;i<rows;i++){
        for(let j=0;j<cols;j++){
            if(grid[i][j]===0){
                num++
                dfs(i,j)
            }
        }
    }
    return num
};
```



###### [1905. 统计子岛屿](https://leetcode.cn/problems/count-sub-islands/)

```js
//bfs
var countSubIslands = function (grid1, grid2) {
  const row = grid2.length;
  const col = grid2[0].length;
  const directions = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0],
  ];

  function flood(queue){
      let curRes = true
      while(queue.length){
          const len = queue.length
          for(let i =0;i<len;i++){
              const [x,y] = queue.shift()
                if (x < 0 || x >= row || y < 0 || y >= col || grid2[x][y] === 0) continue;
                if (grid1[x][y] === 0) curRes = false;
                grid2[x][y] = 0;
                for (const [offsetX, offectY] of directions) {
                    queue.push([x + offsetX, y + offectY]);
                }
          }
      }
      return curRes
  }

  let res = 0
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (grid2[i][j] === 1) {
        if (flood([[i,j]])) {
          res++;
        } 
      }
    }
  }
  return res;
};

// dfs
/**
 * @param {number[][]} grid1
 * @param {number[][]} grid2
 * @return {number}
 */
var countSubIslands = function (grid1, grid2) {
  const row = grid2.length;
  const col = grid2[0].length;
  const directions = [
    [0, -1],
    [1, 0],
    [0, 1],
    [-1, 0],
  ];
  let res = 0,
    curRes = true;
  function flood(x, y) {
    if (x < 0 || x >= row || y < 0 || y >= col || grid2[x][y] === 0) return;
    if (grid1[x][y] === 0) curRes = false;
    grid2[x][y] = 0;
    for (const [offsetX, offectY] of directions) {
      flood(x + offsetX, y + offectY);
    }
  }
  for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (grid2[i][j] === 1) {
        flood(i, j);
        if (curRes) {
          res++;
        } else {
          curRes = true;
        }
      }
    }
  }
  return res;
};
```







###### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)

```javascript
/*先把靠边的陆地淹掉，然后去数剩下的陆地数量就行了*/
var numEnclaves = function(grid) {
    const rows=grid.length,cols=grid[0].length
    let num=0
    const dfs= (x,y)=>{ //floodfill
        if(x<0||x>=rows||y<0||y>=cols||grid[x][y]==0)return
        grid[x][y]=0
        dfs(x+1,y)
        dfs(x,y+1)
        dfs(x-1,y)
        dfs(x,y-1)
    }

    for(let i=0;i<cols;i++){
        dfs(0,i)
    }
    for(let i=0;i<cols;i++){
        dfs(rows-1,i)
    }
    for(let i=0;i<rows;i++){
        dfs(i,0)
    }
    for(let i=0;i<rows;i++){
        dfs(i,cols-1)
    }

    for(let i=0;i<rows;i++){
        for(let j=0;j<cols;j++){
            if(grid[i][j]==1) {
                num++
            }
        }
    }
    return num
};
```



###### [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

```js
/**
 * @param {character[][]} board
 * @return {void} Do not return anything, modify board in-place instead.
 */
var solve = function(board) {
    const directions = [[-1,0],[0,1],[1,0],[0,-1]]
    const row = board.length,col = board[0].length
    function flood(x,y){
        if(x<0||x>=row||y<0||y>=col||board[x][y]==='X'||board[x][y]==='F'){
            return
        }
        board[x][y]='F'
        for(const [i,j] of directions){
            flood(x+i,y+j)
        }
    }

    // 沿上下边缘轮一遍
    for(let j = 0;j<col;j++){
        if(board[0][j]==='O'){
            flood(0,j)
        }
        if(board[row-1][j]==='O'){
            flood(row-1,j)
        }
    }

    for(let i=0;i<row;i++){
        if(board[i][0]==='O'){
            flood(i,0)
        }
        if(board[i][col-1]==='O'){
            flood(i,col-1)
        }
    }

    // 整体轮一遍
    for(let i = 0;i<row;i++){
        for(let j=0;j<col;j++){
            if(board[i][j]==='O'){
                board[i][j]='X'
            }else if(board[i][j]==='F'){
                board[i][j]='O'
            }
        }
    }
};
```





##### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

```js
var pacificAtlantic = function(heights) {
    const row = heights.length,col = heights[0].length
    const directions = [[0,-1],[1,0],[0,1],[-1,0]]
    const pacific = new Array(row).fill(0).map(item => new Array(col).fill(false))
    const atlantic = new Array(row).fill(0).map(item => new Array(col).fill(false))
    function dfs(x,y,ocean){
        ocean[x][y] = true
        for(const [i,j] of directions){
            const willX = x+i
            const willY = y+j
            if(willX<0||willX>=row||willY<0||willY>=col||ocean[willX][willY]) continue
            if(heights[willX][willY]<heights[x][y]) continue
            dfs(willX,willY,ocean)
        }
    }

    for(let i = 0;i<row;i++){
        dfs(i,0,pacific)
        dfs(i,col-1,atlantic)
    }
    for(let j = 0;j<col;j++){
        dfs(0,j,pacific)
        dfs(row-1,j,atlantic)
    }
    
    const res = []
    for(let i = 0;i<row;i++){
        for(let j=0;j<col;j++){
            if(pacific[i][j]&&atlantic[i][j]){
                res.push([i,j])
            }
        }
    }
    return res
};
```







##### [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

我用的他方法：https://leetcode.cn/problems/making-a-large-island/solutions/1830957/by-muse-77-37hi

```js
var largestIsland = function(grid) {
    const directions = [[-1,0],[0,1],[1,0],[0,-1]]
    const row = grid.length,col = grid[0].length
    const islands = {0:0}
    let filter = 2
    function flood(x,y){
        if(x<0||x>=row||y<0||y>=col||grid[x][y]!==1){
            return
        }
        grid[x][y]=filter
        if(islands[filter]){
            islands[filter]++
        }else{
            islands[filter]=1
        }
        for(const [i,j] of directions){
            flood(x+i,y+j)
        }
    }

    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(grid[i][j]===1){
                flood(i,j)
                filter++
            }
        }
    }

    let res = Math.max(...Object.values(islands))
    for(let i=0;i<row;i++){
        for(let j=0;j<col;j++){
            if(grid[i][j]===0){
                const since = new Set()
                let curSum = 0
                for(const [x,y] of directions){
                    if(i+x<0||i+x>=row||j+y<0||j+y>=col||since.has(grid[i+x][j+y])){
                        continue
                    }
                    since.add(grid[i+x][j+y])
                    curSum+=islands[grid[i+x][j+y]]
                }
                res = Math.max(res,curSum+1)
            }
        }
    }
    return res
};
```









##### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

```javascript
var exist = function(board, word) {
    let cols=board.length,raws=board[0].length,wordLen=word.length

    const backtrack= (boardY,boardX,wordIndex)=>{
        if(boardY<0||boardY>=cols||boardX<0||boardX>=raws||board[boardY][boardX] != word[wordIndex]) return false
        if(wordIndex===wordLen-1) return true
        
      /*下面这段就是框架里的for循环，只不过是res那里替代了for循环*/
        let temp=board[boardY][boardX]
        board[boardY][boardX]='0'
        let res = backtrack(boardY+1,boardX,wordIndex+1) || backtrack(boardY,boardX+1,wordIndex+1) || backtrack(boardY-1,boardX,wordIndex+1) || backtrack(boardY,boardX-1,wordIndex+1)
        board[boardY][boardX]=temp
        return res
    }
    
    for(let y=0;y<cols;y++){
        for(let x=0;x<raws;x++){
            if(board[y][x]===word[0]){
                if(backtrack(y,x,0)) return true
            }
        }
    }
    return false
};
```





##### 迷宫

---从左上角走到右下角

```javascript
var maze = function (raws, cols, grid) {
  let path=[]
  const backtrack = (x, y) => {
    if (y < 0 || y >= cols || x < 0 || x >= raws || grid[x][y] === 1 ||grid[x][y]===2) return false
    if (y === cols - 1 && x === raws - 1) {
      path.push([x,y])
      return true
    }
    
    path.push([x, y])
    grid[x][y]=2
    let res = backtrack(x+1,y)||
    backtrack(x,y+1)||
    backtrack(x-1,y)||
      backtrack(x, y - 1)
    if(res) return true
    path.pop()
    grid[x][y] = 0
    return false
  }
  
  backtrack(0, 0)
  return path
};
```



##### [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function (grid) {
  const row = grid.length,
    col = grid[0].length;
  let res = 0;
  const directions = [
    [-1, 0],
    [0, 1],
    [1, 0],
    [0, -1],
  ];
  const visited = new Array(row)
    .fill(1)
    .map((item) => new Array(col).fill(false));
  outer: for (let i = 0; i < row; i++) {
    for (let j = 0; j < col; j++) {
      if (grid[i][j] === 1) {
        dfs(i, j);
        break outer;
      }
    }
  }

  function dfs(x, y) {
    if (x < 0 || x >= row || y < 0 || y >= col) {
      res++;
      return;
    }
    if (visited[x][y]) {
      return;
    }
    if (grid[x][y] === 0) {
      res++;
      return;
    }
    visited[x][y] = true;
    for (const [i, j] of directions) {
      dfs(x + i, y + j);
    }
  }
  return res;
};
```



# 动态规划

## 思维模式

### 简介

#### 主要思想

就是每一次的结果都跟前面的相关，然后从前往后算，并把前面的保存下来。

它的大概意思先将一件事情分成**若干阶段**，然后通过阶段之间的**转移**达到目标。由于转移的方向通常是多个，因此这个时候就需要**决策**选择具体哪一个转移方向。

1. 阶段之间可以进行转移，这叫做动态。

2. 达到一个**可行解(目标阶段)** 需要不断地转移，那如何转移才能达到**最优解**？这叫规划。

那我们应该做出如何的**决策序列**才能使得结果最优？换句话说就是每一个状态应该如何选择到下一个具体状态，并最终到达目标状态。这就是动态规划研究的问题。

每次决策实际上**不会考虑之后的决策，而只会考虑之前的状态。** 形象点来说，其实是走一步看一步这种短视思维

#### 一般形式

**动态规划问题的一般形式就是==求最值==**。动态规划刚开始就是来求最优解的。只不过有的时候顺便可以求总的方案数等其他东西，这其实是**动态规划的副产物**。

##### 核心思路

**求解动态规划的核心问题是穷举**。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值。如果是直接找到最值那就是贪心算法了。

动态规划一般都脱离了递归，而是由循环==迭代==完成计算



#### 什么时候使用动态规划

存在重叠子问题那就是用动态规划。

递归中**如果**存在重复计算（我们称重叠子问题，下文会讲到），那就是使用记忆化递归（或动态规划）解题的强有力信号之一。可以看出动态规划的核心就是使用记忆化的手段消除重复子问题的计算，如果这种重复子问题的规模是指数或者更高规模，那么记忆化递归（或动态规划）带来的收益会非常大。

为了消除这种重复计算，我们可使用查表的方式。即一边递归一边使用“记录表”（比如哈希表或者数组）记录我们已经计算过的情况，当下次再次碰到的时候，如果之前已经计算了，那么直接返回即可，这样就避免了重复计算。下文要讲的**动态规划中 DP 数组其实和这里“记录表”的作用是一样的**。



### 动态规划的两个基本概念

#### 最优子结构：决定了具体如何解决

只有两个子问题都是**最优的**时候整体才是最优的，这是因为子问题之间不会相互影响。

举个例子：如果考试中的分数定义为 f，那么这个问题就可以被分解为语文，数学，英语等子问题。显然子问题最优的时候，总分这个大的问题的解也是最优的。









#### 无后效性：决定了是否可使用动态规划来解决

即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

举个例子来说：数学考得高不能影响英语（现实其实可能影响，比如时间一定，投入英语多，其他科目就少了）。





### **动态规划三要素**

- 重叠子问题

  1. 动态规划的穷举有点特别，因为这类问题**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下，所以需要「备忘录」（自顶向下的时候用）或者「DP table」（自底向上的时候用）来优化穷举过程，避免不必要的计算。
  2. 备忘录或dp 就是个数组或者哈希表，本质都是用于记录
  3. 动态规划问题的最后一步优化，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试缩小 DP table 的大小，只记录必要的数据，从而降低空间复杂度。

  > 但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。（比如发现重叠子问题）

- 最优子结构

  动态规划问题一定会**具备「最优子结构」**，才能通过子问题的最值得到原问题的最值。

- 状态转移方程（递推公式）

  为啥叫「状态转移方程」？其实就是为了听起来高端。`f(n)` 的函数参数会不断变化，所以你把参数 `n` 想做一个状态，这个状态 `n` 是由状态 `n - 1` 和状态 `n - 2` 转移（相加）而来，这就叫状态转移，仅此而已。其实状态转移方程直接代表着暴力解法。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。





#### 状态定义

动态规划解题的第一步就是定义状态。定义好了状态，就可以画出递归树，聚焦最优子结构写转移方程就好了，因此我才说状态定义是动态规划的核心。比如爬楼梯的问题，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么 f(1), f(2), ... 就是各个**独立的状态**。

枚举状态：

- 如果是一维状态，那么我们使用一层循环可以搞定。

- 如果是两维状态，那么我们使用两层循环可以搞定。

- 如果你没有使用滚动数组的技巧，那么遍历顺序取决于状态转移方程。比如:

  ```py
  for i in range(1, n + 1):
    dp[i] = dp[i - 1] + 1
  #我们就需要从左到右遍历，原因很简单，因为 dp[i] 依赖于 dp[i - 1]，因此计算 dp[i] 的时候， dp[i - 1] 需要已经计算好了
  ```

- 如果你使用了滚动数组的技巧，则怎么遍历都可以，但是不同的遍历意义通常不不同的。实际中采用怎么样的遍历手段取决于题目。



#### 临界条件

在上面讲解的爬楼梯问题中，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么：

f(1) 与 f(2) 就是【边界】

f(n) = f(n-1) + f(n-2) 就是【状态转移公式】

我用动态规划的形式表示一下：

dp[0] 与 dp[1] 就是【边界】

dp[n] = dp[n - 1] + dp[n - 2] 就是【状态转移方程】

实际上临界条件相对简单，大家只有多刷几道题，里面就有感觉。





#### 状态转移方程

动态规划中当前阶段的状态往往是上一阶段状态和上一阶段决策的结果。这里有两个关键字，分别是 ：

- 上一阶段状态
- 上一阶段决策

也就是说，如果给定了第 k 阶段的状态 s[k] 以及决策 choice(s[k])，则第 k+1 阶段的状态 s[k+1] 也就完全确定，用公式表示就是：s[k] + choice(s[k]) -> s[k+1]， 这就是状态转移方程。需要注意的是 choice 可能有多个，因此每个阶段的状态 s[k+1]也会有多个。

继续以上面的爬楼梯问题来说，爬楼梯问题由于上第 n 级台阶一定是从 n - 1 或者 n - 2 来的，因此 上第 n 级台阶的数目就是 `上 n - 1 级台阶的数目加上 n - 2 级台阶的数目`。

上面的这个理解是核心， 它就是我们的状态转移方程，用代码表示就是 `f(n) = f(n - 1) + f(n - 2)`。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-6aneY8.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-6aneY8.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-6aneY8.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-6aneY8.jpg" loading="lazy"/>
  </picture>

### 如何debug

**动态规划问题找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的**

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。



### 解题步骤

1. 确定dp数组（dp table）以及下标的含义

   有两种思路：

   - 一维

   - 二维

2. 确定递推公式

3. dp数组如何初始化

4. 确定遍历顺序

   只要把住两点就行了：

   **1、遍历的过程中，所需的状态必须是已经计算出来的**。

   **2、遍历结束后，存储结果的那个位置必须已经被计算出来**。

5. 举例推导dp数组

   确定base case ，然后再举个base case 的下一个值为例去推导即可

### **如何列出状态转移方程**？

1、**确定 base case**

2、**确定「状态」，也就是原问题和子问题中会变化的变量**。

3、**确定「选择」，也就是导致「状态」产生变化的行为**。比如说[322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)这题所有硬币的面值，就是你的「选择」。

4、**明确 `dp` 函数/数组的定义**。用递归自顶向下时dp是个函数，用迭代自底向上时dp是个数组

按上面的套路走，再套这个框架：

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```





## 时间与空间复杂度

动态规划的空间和时间复杂度**打底就是状态的个数**，而状态的个数通常是参数的笛卡尔积，这是由动态规划的无后向性决定的。



## 滚动数组优化

核心：每一轮开始的时候这个数组里的值是上一轮的值。

爬楼梯我们并没有必要使用一维数组，而是借助两个变量来实现的，空间复杂度是 O(1)。代码：

```js
function climbStairs(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  let a = 1;
  let b = 2;
  let temp;
  for (let i = 3; i <= n; i++) {
​    temp = a + b;
​    a = b;
​    b = temp;
  }
  return temp;
}
```

之所以能这么做，是因为爬楼梯问题的状态转移方程中**当前状态只和前两个状态有关**，因此只需要存储这两个即可。 动态规划问题有很多这种讨巧的方式，这个技巧叫做滚动数组。

对于单个因素的，我们最多只需要一个一维数组即可，对于如背包问题我们需要二维数组等更高维度。



## 动态规划 VS 记忆化递归

上面我们用记忆化递归的问题巧妙地解决了爬楼梯问题。 那么动态规划是怎么解决这个问题呢？

答案也是“查表”，我们平常写的 dp table 就是表，其实这个 dp table 和上面的 memo 没啥差别。

而一般我们写的 dp table，**数组的索引通常对应记忆化递归的函数参数，值对应递归函数的返回值。**

看起来两者似乎**没任何思想上的差异，区别的仅仅是写法**？？ 没错。不过这种写法上的差异还会带来一些别的相关差异，这点我们之后再讲。

如果上面的爬楼梯问题，使用动态规划，代码是怎么样的呢？我们来看下：

```js
function climbStairs(n) {
  if (n == 1) return 1;
  const dp = new Array(n);
  dp[0] = 1;
  dp[1] = 2;
  for (let i = 2; i < n; i++) {
​    dp[i] = dp[i - 1] + dp[i - 2];
  }
  return dp[dp.length - 1];
}
```

大家现在不会也没关系，我们将**前文的递归的代码稍微改造一下**。其实就是将函数的名字改一下：

```js
function dp(n) {
  if (n === 1) return 1;
  if (n === 2) return 2;
  return dp(n - 1) + dp(n - 2);
}
```

经过这样的变化。我们将 dp[n] 和 dp(n) 对比看，这样是不是有点理解了呢? 其实他们的区别只不过是**递归用调用栈枚举状态， 而动态规划使用迭代枚举状态。**

> 如果需要多个维度枚举，那么记忆化递归内部也可以使用迭代进行枚举，比如最长上升子序列问题。

动态规划的查表过程如果画成图，就是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-MgaV8B.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-MgaV8B.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-MgaV8B.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-MgaV8B.jpg" loading="lazy"/>
  </picture>



记忆化递归和动态规划除了一个用递归一个用迭代，其他没差别。那两者有啥区别呢？我觉得最大的区别就是记忆化递归无法使用滚动数组优化。

不信你用上面的爬楼梯试一下，下面代码如何使用滚动数组优化？

```js
const memo = {};

function dp(n) {

  if (n === 1) return 1;

  if (n === 2) return 2;

  if (n in memo) return memo[n];

  const ans = dp(n - 1) + dp(n - 2);

  memo[n] = ans;

  return ans;

}
```

本质上来说， 记忆化递归采用的方式是 DFS，因此会一条路走到黑，然后返回来继续其他可行的路一口气再次走到黑。而迭代使用的是类似 BFS 的方式，这样一层层访问，  太远的层可能用不到了，就可以直接抹去，这就是滚动数组的本质。

记忆化调用栈的开销比较大（复杂度不变，你可以认为空间复杂度常数项更大），不过几乎不至于 TLE 或者 MLE。**因此我的建议就是没空间优化需求直接就记忆化，否则用迭代 dp**。

再次强调一下：

- 如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。 那么动态规划就是从寻常入手， 逐步扩大规模到最优子结构。
- 记忆化递归和动态规划没有本质不同。都是枚举状态，并根据状态直接的联系逐步推导求解。
- 动态规划性能通常更好。 一方面是递归的栈开销，一方面是滚动数组的技巧。





## Hello算法版本

### 介绍

#### 子问题分解

子问题分解是一种通用的算法思路，在分治、动态规划、回溯中的侧重点不同。

- 分治算法递归地将原问题划分为多个相互独立的子问题，直至最小子问题，并在回溯中合并子问题的解，最终得到原问题的解。
- 动态规划也对问题进行递归分解，但与分治算法的主要区别是，动态规划中的子问题是相互依赖的，在分解过程中会出现许多重叠子问题。
- 回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作为一个子问题。

#### 概念

「动态规划 dynamic programming」是一个重要的算法范式，<mark>它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。**动态规划是一种“从底至顶”的方法**：从最小子问题的解开始，迭代地构建更大子问题的解，直至得到原问题的解。由于动态规划不包含回溯过程，因此只需使用循环迭代实现，无须递归。</mark>本质就是空间换时间。



#### 动态规划的常用术语

- 将数组 `dp` 称为「dp 表」，dp[i] 表示状态 i 对应子问题的解。
- 将最小子问题对应的状态（即第 1 和 2 阶楼梯）称为「初始状态」。
- 将递推公式 dp[i]=dp[i−1]+dp[i−2] 称为「状态转移方程」。



#### 空间优化

**由于 dp[i] 只与 dp[i−1] 和 dp[i−2] 有关，因此我们无须使用一个数组 `dp` 来存储所有子问题的解**，而只需两个变量滚动前进即可。

```
/* 爬楼梯：空间优化后的动态规划 */
function climbingStairsDPComp(n) {
    if (n === 1 || n === 2) return n;
    let a = 1,
        b = 2;
    for (let i = 3; i <= n; i++) {
        const tmp = b;
        b = a + b;
        a = tmp;
    }
    return b;
}
```

由于省去了数组 `dp` 占用的空间，因此空间复杂度从 O(n) 降低至 O(1) 。

在动态规划问题中，当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**。



#### 动态规划的特性

- 解决重叠子问题：通过dp表存储前面的结果。

- <mark>最优子结构</mark>的含义：**原问题的最优解是从子问题的最优解构建得来的**。

- <mark>无后效性</mark>是动态规划能够有效解决问题的重要特性之一，定义为：**给定一个确定的状态，它的未来发展只与当前状态有关，而与当前状态过去所经历过的所有状态无关**。

  - 如果我们向爬楼梯问题添加一个约束，就不满足无后效性了：

    给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶，**但不能连续两轮跳 1 阶**。

    在该问题中，如果上一轮是跳 1 阶上来的，那么下一轮就必须跳 2 阶。这意味着，**下一步选择不能由当前状态（当前楼梯阶数）独立决定，还和前一个状态（上轮楼梯阶数）有关**。

    <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-04-15-19-image-20231004151915545.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-04-15-19-image-20231004151915545.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-04-15-19-image-20231004151915545.png" alt="image-20231004151915545" style="zoom:50%;" loading="lazy"/>
  </picture>

    ```
    /* 带约束爬楼梯：动态规划 */
    function climbingStairsConstraintDP(n) {
        if (n === 1 || n === 2) {
            return 1;
        }
        // 初始化 dp 表，用于存储子问题的解
        const dp = Array.from(new Array(n + 1), () => new Array(3));
        // 初始状态：预设最小子问题的解
        dp[1][1] = 1;
        dp[1][2] = 0;
        dp[2][1] = 0;
        dp[2][2] = 1;
        // 状态转移：从较小子问题逐步求解较大子问题
        for (let i = 3; i <= n; i++) {
            dp[i][1] = dp[i - 1][2];
            dp[i][2] = dp[i - 2][1] + dp[i - 2][2];
        }
        return dp[n][1] + dp[n][2];
    }
    ```

    在上面的案例中，由于仅需多考虑前面一个状态，我们仍然可以通过扩展状态定义，使得问题重新满足无后效性。然而，某些问题具有非常严重的“有后效性”。

    

  - 给定一个共有 n 阶的楼梯，你每步可以上 1 阶或者 2 阶。**规定当爬到第 n 阶时，之后所有轮都不允许跳到第 2n 阶上**。例如，前两轮分别跳到了第 2、3 阶上，则之后就不能跳到第 4、6 阶上。

    在这个问题中，下次跳跃依赖于过去所有的状态，对于这类问题，动态规划往往难以解决。



### 是否适合用动态规划

**先观察问题是否适合使用回溯（穷举）解决**。

**适合用回溯解决的问题通常满足“决策树模型”**，这种问题可以使用树形结构来描述，其中每一个节点代表一个决策，每一条路径代表一个决策序列。动态规划可以通过重复子问题优化这个决策过程，相当于剪枝。按理说记忆化递归跟动规的时间复杂度差不多，且往往此时的递归代码也能体现出递推的关系。「动态规划」是由「记忆化递归」改进而来(即能 记忆化递归 就能 动态规划)。

在此基础上，动态规划问题还有一些判断的“加分项”。

- 问题包含最大（小）或最多（少）等最优化描述。
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。

相应地，也存在一些“减分项”。

- 问题的目标是找出所有可能的解决方案，而不是找出最优解。
- 问题描述中有明显的排列组合的特征，需要返回具体的多个方案。

### 求解步骤

**第一步：思考每轮的决策，定义状态，从而得到 dp 表** 。 画出决策树然后画出dp表。

**第二步：找出最优子结构，进而推导出状态转移方程**：找状态转移方程的方法是，思考每个状态有哪些「选择」，只要我们能用正确的逻辑做出正确的选择，算法就能够正确运行。

**第三步：确定边界条件和状态转移顺序。**边界条件在动态规划中用于初始化 dp 表，在搜索中用于剪枝。

降维：二维变一维时：其实滚动数组的本质就是在该数组未重新赋值前存的是上一行的值，重新赋值后就是本行的值。    dp[j-1]没重新赋值前 就是上一行且前一列的值，dp[j-1]重新赋值后就是同一行且前一列的值，dp[j]没重新赋值前就是上一行同一列的值。



### 代码随想录求解步骤(更靠谱)

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化(`dp[0][0]`是多少)
4. 确定遍历顺序
5. 打印dp数组

二维变一维时：其实滚动数组的本质就是在该数组未重新赋值前存的是上一行的值，重新赋值后就是本行的值。    dp[j-1]没重新赋值前 就是上一行且前一列的值，dp[j-1]重新赋值后就是同一行且前一列的值，dp[j]没重新赋值前就是上一行同一列的值。



### dyc说

递归是自顶向下，动态规划是自底向上。



滚动数组只是优化了dp的维度，但是该多少维循环还得是多少维循环。二维变一维时：<mark>其实滚动数组的本质就是在该数组未重新赋值前存的是上一行的值，重新赋值后就是本行的值。</mark>    dp[j-1]没重新赋值前 就是上一行且前一列的值，dp[j-1]重新赋值后 就是同一行且前一列的值，dp[j]没重新赋值前就是上一行同一列的值。（我们一般将数组优化成列的大小，当然其实都可以，只是优化成列之后循环的顺序基本不用动）



### 例题

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

严格来说不是动态规划，因为没有求最值。

```javascript
var fib = function(n) {
    /*暴力解法
    if(n==0||n==1) return n //base case
    return fib(n-1)+fib(n-2)
    */ 

    /**动态规划
    let dp=new Array(n+1).fill(0)
    dp[0]=0 //base case
    dp[1]=1 //base case

    for(let i=2;i<=n;i++){
        dp[i]=dp[i-1]+dp[i-2]
    }
    return dp[n]
    */

    /**动态规划优化dp的所用空间版
    根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了
    if(n==0||n==1) return n //base case
    let cur,dp_prepre=0,dp_pre=1
    for(let i=2;i<=n;i++){
        cur = dp_prepre+dp_pre
        dp_prepre=dp_pre
        dp_pre=cur
    }
    return cur
    */

};
```







#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

严格来说不是动态规划，因为没有求最值。

```javascript
var climbStairs = function(n) {
    if(n==1) return 1
    if(n==2) return 2
    let dp_prepre=1,dp_pre=2,cur
    for(let i=3;i<=n;i++){
        cur=dp_pre+dp_prepre
        dp_prepre=dp_pre
        dp_pre=cur
    }
    return cur
};
```







#### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

```js
var minCostClimbingStairs = function(cost) {
    const len = cost.length
    const dp = new Array(len+1).fill(0) // dp[i]表示爬上第i层所需的最小费用
    for(let i= 2;i<len+1;i++){
        dp[i] = Math.min(cost[i-1]+dp[i-1],cost[i-2]+dp[i-2])
    }
    return dp[len]
};

// 滚动优化后：
var minCostClimbingStairs = function(cost) {
    const len = cost.length
    let a = 0,b=0
    for(let i= 2;i<len+1;i++){
        const temp = Math.min(a+cost[i-2],b+cost[i-1])
        a = b
        b = temp
    }
    return b
};
```









#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

跟爬楼梯一样的，只是变成了二维。

```js
// dp[i][j]表示到i,j有多少条路线
// dp[i][j] = dp[i-1][j]+dp[i][j-1]
var uniquePaths = function(m, n) {
    const dp = new Array(m).fill(1).map(item=>new Array(n).fill(1))
    for(let i=1;i<m;i++){
        dp[i][0] = 1
    }
    for(let j=1;j<n;j++){
        dp[0][j] = 1
    }
    for(let i = 1;i<m;i++){
        for(let j = 1;j<n;j++){
            dp[i][j] = dp[i-1][j]+dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
};


//滚动数据降维：
var uniquePaths = function(m, n) {
    const dp = new Array(m).fill(1) // 记录这一列的所有数据
    //j 表示列，i表示行
    for(let j = 1;j<n;j++){ // 对于每一列来说有用的数据就是本列的上一行和上一列的本行。一列一列去进行操作，每次内层循环完都dp里全是本列的数据
        for(let i = 1;i<m;i++){
            dp[i] =dp[i]+ dp[i-1] //等号右边的dp[i]是上一列的数据，dp[i-1]是本列的数据(因为dp[i-1]已经被操作过了)
        }
    }
    return dp[m-1]
};

// or：
var uniquePaths = function(m, n) {
    const dp = new Array(n).fill(1)
    for(let i = 1;i<m;i++){
        for(let j = 1;j<n;j++){
            dp[j] += dp[j-1]
        }
    }
    return dp[n-1]
};

```

#### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

```js
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const dp = new Array(m).fill(0).map(item=>new Array(n).fill(0))
    dp[0][0] = obstacleGrid[0][0]===1?0:1
    for(let i=1;i<m;i++){
       dp[i][0] = obstacleGrid[i][0] === 1? 0:dp[i-1][0]
        
    }
    for(let j=1;j<n;j++){
        dp[0][j] = obstacleGrid[0][j] === 1? 0:dp[0][j-1]
    }
    for(let i = 1;i<m;i++){
        for(let j = 1;j<n;j++){
            dp[i][j] =obstacleGrid[i][j] === 1?0: dp[i-1][j]+dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
};

// 滚动数组优化：
var uniquePathsWithObstacles = function(obstacleGrid) {
    const m = obstacleGrid.length
    const n = obstacleGrid[0].length
    const dp = new Array(n).fill(0)
    dp[0] = obstacleGrid[0][0]===1?0:1
    for(let i = 0;i<m;i++){
        for(let j = 0;j<n;j++){
                if (obstacleGrid[i][j] == 1) {
                    dp[j] = 0;
                } else if (j != 0) {
                    dp[j] += dp[j - 1];
                }
        }
    }
    return dp[n-1]
};
```



#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

```js
// dp[i]表示拆i得到的乘积最大值
// dp[i] = max(j*(i-j),j*dp[i-j]) 因为有可能两个数本身相乘就已经是最大，也可能要继续往下拆才有最大
var integerBreak = function(n) {
    const dp = new Array(n+1).fill(0)
    dp[2] = 1
    for(let i=3;i<=n;i++){
        for(let j = 1;j<=i/2;j++){
            dp[i] = Math.max(dp[i],j*(i-j),j*dp[i-j])
        }
    }
    return dp[n]
};
```



#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

```js
/**
 * dp[i] 表示 i个节点能组成多少种树
 * dp[3] = G[3]+G[2]+G[1] // G表示以什么值为根结点时能组成多少树
 * G[3] = dp[3-1]*dp[i-3] // 左子树*右子树
 * G[2] = dp[2-1]*dp[i-2]
 * G[1] = dp[1-1]*dp[i-1]
 * 上述推导得：dp[3] = dp[3-1]*dp[i-3]+dp[2-1]*dp[i-2]+dp[1-1]*dp[i-1]
 *           dp[2] = dp[2-1]*dp[i-2]+dp[1-1]*dp[i-1]
 *           dp[1] = dp[1-1]*dp[i-1]
 * 即：dp[i] += dp[j-1]*dp[i-j] // j表示以什么值为根结点
 */
var numTrees = function(n) {
    const dp = new Array(n+1).fill(0)
    dp[0]=1
    dp[1]=1
    for(let i = 2;i<=n;i++){
        for(let j=1;j<=i;j++){
            dp[i]+= dp[j-1]*dp[i-j]
        }
    }
    return dp[n]
};
```



// 记忆化递归：

```js
/**
 * dp[i] 表示 i个节点能组成多少种树
 * dp[3] = G[3]+G[2]+G[1] // G表示以什么值为根结点时能组成多少树
 * G[3] = dp[3-1]*dp[i-3] // 左子树*右子树
 * G[2] = dp[2-1]*dp[i-2]
 * G[1] = dp[1-1]*dp[i-1]
 * 上述推导得：dp[3] = dp[3-1]*dp[i-3]+dp[2-1]*dp[i-2]+dp[1-1]*dp[i-1]
 *           dp[2] = dp[2-1]*dp[i-2]+dp[1-1]*dp[i-1]
 *           dp[1] = dp[1-1]*dp[i-1]
 * 即：dp[i] += dp[j-1]*dp[i-j] // j表示以什么值为根结点
 */
var numTrees = function(n) {
    const memo  = new Array(n+1).fill(false)
    function backtrack(n){
        if(n===0||n===1){
            return 1
        } 
        if(memo[n]){
            return memo[n]
        }
        let cur = 0
        for(let i=1;i<=n;i++){
             cur += backtrack(i-1)*backtrack(n-i)
        }
        memo[n]  = cur
        return cur
    }
    return backtrack(n)
};
```







#### 背包问题

01背包和完全背包就够用了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-13-22-40-image-20231013224051867.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-13-22-40-image-20231013224051867.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-13-22-40-image-20231013224051867.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-13-22-40-image-20231013224051867.png" loading="lazy"/>
  </picture>

##### 01背包问题

###### 解题模版

物品一个一个尝试，容量一点一点尝试，每个物品分类讨论的标准是：<mark>选与不选。</mark>

可看此视频解释：https://www.bilibili.com/video/BV1qy4y1F7MR/?spm_id_from=333.337.search-card.all.click&vd_source=0b12706181dace1502b9c644984e8c2c

`dp[i][j]`表示价值

| 货物范围\背包重量             | 1    | 2    |
| ----------------------------- | ---- | ---- |
| 0                             | 0    | 5    |
| 0-1 本质就是要不要选1这个物品 | 0    | 5    |
| 0-2 本质就是要不要选2这个物品 | 3    | 5    |



###### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

这道题可以换一种表述：给定一个只包含正整数的非空数组 nums，判断是否可以从数组中选出一些数字，使得这些数字的和等于整个数组的元素和的一半。因此这个问题可以转换成「0−1 背包问题」。

```js
var canPartition = function (nums) {
    const len = nums.length
    if (len < 2) {
        return false;
    }
    const sum = nums.reduce((pre, cur) => pre + cur, 0)
    if (sum & 1) { // 是奇数
        return false;
    }
    const semiSum = sum >> 1
    const dp = new Array(len).fill(0).map(() => new Array(semiSum + 1).fill(false))// dp[i][j]表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j

    //如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有 0≤i<n，都有 dp[i][0]=true
    for (let i = 0; i < len; i++) {
        dp[i][0] = true
    }
    dp[0][nums[0]] = true // 只有一个数时，且这个数就等于target时为true
    for (let i = 1; i < len; i++) {
        for (let j = 1; j <= semiSum; j++) {
            if (j >= nums[i]) {
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]
            } else {// 这种情况只能不选当前值
                dp[i][j] = dp[i - 1][j]
            }
        }
    }
    return dp[len - 1][semiSum]
};
```

优化空间：

计算 dp的过程中，每一行的 dp 值都只与上一行的 dp 值有关。此时的转移方程为：`dp[j]=dp[j] ∣ dp[j−nums[i]]`
第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 dp 值，那么在计算 dp[j] 值的时候，dp[j−nums[i]] 已经是被更新过的状态，不再是上一行的 dp 值。

```js
var canPartition = function (nums) {
    const len = nums.length
    if (len < 2) {
        return false;
    }
    const sum = nums.reduce((pre, cur) => pre + cur, 0)
    if (sum & 1) { // 是奇数
        return false;
    }
    const semiSum = sum >> 1
    const dp = new Array(semiSum+1).fill(false)
    //如果不选取任何正整数，则被选取的正整数等于 0。因此对于所有 0≤i<n，都为true
    dp[0]=true
    for (let i = 1; i < len; i++) {
        for (let j = semiSum; j >0; j--) {
            if (j >= nums[i]) {
                dp[j] = dp[j] || dp[j - nums[i]]
            } 
        }
    }
    return dp[semiSum]
};
```





###### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**。

法一：

```js
 // dp[j]表示容量为j的背包最多能装石头的重量
 // dp[j] = max(dp[j],dp[j-stores[i]]+stores[i])
var lastStoneWeightII = function (stones) {
  const len = stones.length;
  const sum = stones.reduce((pre, cur) => pre + cur, 0);
  const weight1 = sum >> 1;
  const dp = new Array(weight1 + 1).fill(0);
  for (let i = 0; i < len; i++) {
    for (let j = weight1; j >= stones[i]; j--) {
      dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
    }
  }
  return sum - dp[weight1] - dp[weight1]; //分成两堆石头，一堆石头的总重量是dp[target]，另一堆就是sum - dp[target]。**在计算target的时候，target = sum / 2 因为是向下取整，所以sum - dp[target] 一定是大于等于dp[target]的**。
};
```



法二：跟上一题一样思路

```js
// 要使最后一块石头的重量尽可能地小，则其中一堆石头 需要在不超过 ⌊sum/2⌋ 的前提下尽可能地大。
var lastStoneWeightII = function(stones) {
    const len = stones.length
    const sum = stones.reduce((pre,cur)=>pre+cur,0)
    const semiSum = sum>>1
    const dp  = new Array(len).fill(0).map(()=>new Array(semiSum+1).fill(false)) // dp[i][j]表示[0,i]时是否能选取到等于j
    for(let i =0;i<len;i++){
        dp[i][0] = true
    }
    dp[0][stones[0]]=true
    for(let i = 1;i<len;i++){
        for(let j = 1;j<=semiSum;j++){
            if(stones[i]<=j){
                dp[i][j] = dp[i-1][j] || dp[i-1][j-stones[i]]
            }else{
                dp[i][j]= dp[i-1][j]
            }
        }
    }
    for(let j=semiSum;j>=0;j--){ // 找到最接近semiSum的值
        if(dp[len-1][j]){
            return sum-j-j
        }
    }
};

// 滚动优化
var lastStoneWeightII = function(stones) {
    const len = stones.length
    const sum = stones.reduce((pre,cur)=>pre+cur,0)
    const semiSum = sum>>1
    const dp  = new Array(semiSum+1).fill(false) // dp[i]表示是否能选取到等于i
    dp[0]=true
    for(let i = 0;i<len;i++){
        for(let j = semiSum;j>0;j--){
            if(stones[i]<=j){
                dp[j] = dp[j] || dp[j-stones[i]]
            }
        }
    }
    for(let j=semiSum;j>=0;j--){
        if(dp[j]){
            return sum-j-j
        }
    }
};
```







###### [494. 目标和](https://leetcode.cn/problems/target-sum/)

一定有 left组合 - right组合 = target。

left + right = sum，而sum是固定的。right = sum - left

公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。

target是固定的，sum是固定的，left就可以求出来。

此时问题就是在nums中找出和为left的组合的数量。

```js
var findTargetSumWays = function (nums, target) {
    const len = nums.length
    const sum = nums.reduce((a, b) => a + b);
    if (Math.abs(target) > sum) {
        return 0;
    }
    if ((target + sum) % 2) {
        return 0;
    }
    const halfSum = (target + sum) / 2;
    const dp = new Array(len+1).fill(0).map(() => new Array(halfSum + 1).fill(0)) // dp[i][j]表示从前i个数中选出j的方案有几种。为什么是len+1？主要是为了更容易定初始值。因为所有数都不选也是一种情况，如果len不加一，那么初始情况就是选不选第一个数，若此时j为0且第一个数也为0，那选与不选都行，即初始情况有可能是两种方案也可能是一种方案，即初始值不好确定。而len加一，把所有数都不选单独领出来为初始情况，则很好定初始值，不就是j也为0时才有一种方案，j为其它任何数方案都为0。
    dp[0][0]=1
    for (let i = 1; i <= len; i++) {
        for (let j = 0; j <= halfSum; j++) {
            if (j < nums[i-1]) { // 不能选nums[i-1]
                dp[i][j] = dp[i - 1][j]
            } else {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i-1]]
            }
        }
    }
    return dp[len][halfSum]
};

// 滚动优化
var findTargetSumWays = function (nums, target) {
    const len = nums.length
    const sum = nums.reduce((a, b) => a + b);
    if (Math.abs(target) > sum) {
        return 0;
    }
    if ((target + sum) % 2) {
        return 0;
    }
    const halfSum = (target + sum) / 2;
    const dp = new Array(halfSum+1).fill(0) // dp[j]表示从前i个数中选出j的方案有几种。
    dp[0]=1 // 此时其实是i=0的时候
    for (let i = 1; i <= len; i++) {
        for (let j = halfSum; j >=0; j--) {
            if(nums[i-1]<=j) {
                dp[j] = dp[j] + dp[j - nums[i-1]]
            }
        }
    }
    return dp[halfSum]
};
```





###### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

```js
function getZeroOne(str){
    let zero = 0,one = 0
    for(const char of str){
        if(char==='1'){
            one++
        }else if(char==='0'){
            zero++
        }
    }
    return {
        zero,
        one
    }
}
var findMaxForm = function(strs, m, n) {
 const len = strs.length
 const dp = new Array(len+1).fill(0).map(()=>new Array(m+1).fill(0).map(()=>new Array(n+1).fill(0))) // dp[i][j][k] 表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量。
    for(let i = 1;i<=len;i++){
        for(let j=0;j<=m;j++){
            for(let k=0;k<=n;k++){
                const {zero,one} = getZeroOne(strs[i-1])
                if(zero>j||one>k){ // 那这个字符串不能选
                    dp[i][j][k] = dp[i-1][j][k]
                }else{
                    dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-zero][k-one]+1)
                }
            }
        }
    }
    return dp[len][m][n]
};

// 滚动优化
var findMaxForm = function(strs, m, n) {
 const len = strs.length
 const dp = new Array(m+1).fill(0).map(()=>new Array(n+1).fill(0)) // dp[i][j][k] 表示在前 i 个字符串中，使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量。
    for(let i = 1;i<=len;i++){
        for(let j=m;j>=0;j--){
            for(let k=n;k>=0;k--){
                const {zero,one} = getZeroOne(strs[i-1])
                if(zero<=j&&one<=k){// 那这个字符串可以选
                    dp[j][k] = Math.max(dp[j][k],dp[j-zero][k-one]+1)
                }
            }
        }
    }
    return dp[m][n]
};
```





###### [879. 盈利计划](https://leetcode.cn/problems/profitable-schemes/)

```js
var profitableSchemes = function(n, minProfit, group, profit) {
    const MOD = 1e9 + 7;
    const work = group.length
    const dp = new Array(work+1).fill(0).map(()=>new Array(n+1).fill(0).map(()=>new Array(minProfit+1).fill(0)))// dp[i][j][k]表示在前 i 个工作中选择 j 个员工，并且满足工作利润至少为 k 的情况下的盈利计划的总数目
    dp[0][0][0] = 1
    for(let i = 1;i<=work;i++){
        for(let j =0;j<=n;j++){
            for(let k=0;k<=minProfit;k++){
                if(group[i-1]<=j){
                    dp[i][j][k] = (dp[i-1][j][k]+dp[i-1][j-group[i-1]][Math.max(0,k-profit[i-1])])% MOD
                }else{
                    dp[i][j][k] = dp[i-1][j][k]
                }
            }

        }
    }
    let sum = 0
    for(let j = 0;j<=n;j++){ // 题目要求是从n个员工中选，即不选满这n个员工也行
        sum=(sum+dp[work][j][minProfit])% MOD
    }
    return sum
};

// 滚动优化
var profitableSchemes = function(n, minProfit, group, profit) {
    const MOD = 1e9 + 7;
    const work = group.length
    const dp = new Array(n+1).fill(0).map(()=>new Array(minProfit+1).fill(0))// dp[i][j][k]表示在前 i 个工作中选择 j 个员工，并且满足工作利润至少为 k 的情况下的盈利计划的总数目
    dp[0][0] = 1
    for(let i = 1;i<=work;i++){
        for(let j =n;j>=0;j--){
            for(let k=minProfit;k>=0;k--){
                if(group[i-1]<=j){
                    dp[j][k] = (dp[j][k]+dp[j-group[i-1]][Math.max(0,k-profit[i-1])])% MOD
                }else{
                    dp[j][k] = dp[j][k]
                }
            }

        }
    }
    let sum = 0
    for(let j = 0;j<=n;j++){
        sum=(sum+dp[j][minProfit])% MOD
    }
    return sum
};
```







##### 完全背包问题

###### 解题模版

因为都要二维dp，所以可以先写记忆化递归，再直接根据记忆化递归的代码写出一维dp的代码。

###### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)

方法一：更符合完全背包的思路：

```js
var change = function(amount, coins) {
    const len = coins.length
    const dp = new Array(len + 1).fill(0).map(()=>new Array(amount+1).fill(0)); // dp[i][j] 表示从前i个硬币里选凑出j的方案数
    for(let i = 0;i<=len;i++){
        dp[i][0]=1
    }
    for (let i =1;i<=len;i++) {
        const coin = coins[i-1]
        for (let j = 1; j <= amount; j++) {
            if(j>=coin){
                dp[i][j] = dp[i][j - coin]+dp[i-1][j]; // dp[i][j]=有自己的时候但还缺一个自己才能凑齐j+没自己的时候就能凑齐j
            }else{
                dp[i][j] =dp[i-1][j]
            }
        }
    }
    return dp[len][amount];
};

// 滚动优化
var change = function(amount, coins) {
    const len = coins.length
    const dp = new Array(amount+1).fill(0); // dp[i][j] 表示从前i个硬币里选凑出j的方案数
    dp[0]=1
    for (let i =1;i<=len;i++) {
        const coin = coins[i-1]
        for (let j = 1; j <= amount; j++) {
            if(j>=coin){
                dp[j] += dp[j - coin]; // dp[i][j]=有自己的时候但还缺一个自己才能凑齐j+没自己的时候就能凑齐j
            }
        }
    }
    return dp[amount];
};
```



方法二：01背包的思路进化而来：

```js
//dp[i][j]表示从0-i个物品里选值为j时的方案总和
var change = function(amount, coins) {
    const dp = new Array(coins.length).fill(0).map(item=>new Array(amount+1).fill(0))
    for(let i=0;i<coins.length;i++){ 
        dp[i][0] = 1
    }
    for(let j=1;j<=amount;j++){
        if(j%coins[0]===0){
            dp[0][j] = 1
        }
    }

    for(let i = 1;i<coins.length;i++){ // 遍历硬币
        for(let j=1;j<=amount;j++){ // 遍历价值
            if(coins[i]>j){ // 这个硬币的价值大于所需的价值那就不选这个硬币了
                dp[i][j] = dp[i-1][j]
            }else{ // 要选这个硬币，那么要选几个呢,一个一个遍历呗
                for(let k = 1;k*coins[i]<=j;k++){
                    dp[i][j] += dp[i-1][j-k*coins[i]] 
                }
                dp[i][j]+=dp[i-1][j] // 还要加上不选这个的时候的个数才是0-i中的总方案数
            }
        }
    }
    return dp[coins.length-1][amount]
};


// 滚动数组降维
var change = function (amount, coins) {
    const len = coins.length;
    const dp = new Array(amount + 1).fill(0); // dp[j]表示从前i枚硬币中选凑够j的方式数
    dp[0] = 1
    for (let i = 1; i <= len; i++) {
        for (let j = amount; j >= 0; j--) {
            if (coins[i - 1] <= j) {
                for (let k = 1; ; k++) {
                    if (k * coins[i - 1] <= j) {
                        dp[j] += dp[j - k * coins[i - 1]];
                    } else {
                        break;
                    }
                }
            }
        }
    }
    return dp[amount];
};
```



###### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

```js
var coinChange = function(coins, amount) {
    const len = coins.length
    const dp = new Array(len+1).fill(0).map(()=>new Array(amount+1).fill(Number.MAX_SAFE_INTEGER))
    for(let i = 0;i <= len;i++){
        dp[i][0]=0
    }
    for(let i =1;i<=len;i++){
        const num = coins[i-1]
        for(let j= 1;j<=amount;j++){
            if(num<=j){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-num]+1)
            }else{
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[len][amount] === Number.MAX_SAFE_INTEGER?-1:dp[len][amount]
};

// 滚动优化
var coinChange = function(coins, amount) {
    const len = coins.length
    const dp = new Array(amount+1).fill(Number.MAX_SAFE_INTEGER)
    dp[0]=0
    for(let i =1;i<=len;i++){
        const num = coins[i-1]
        for(let j= 1;j<=amount;j++){
            if(num<=j){
                dp[j] = Math.min(dp[j],dp[j-num]+1)
            }
        }
    }
    return dp[amount] === Number.MAX_SAFE_INTEGER?-1:dp[amount]
}; 



// 记忆化递归
var coinChange = function(coins, amount) {
    const memo = new Array(amount+1).fill(-2) // 要区分初始值和凑不到这个值的情况，如果不区分的话，剪枝就不会剪掉凑不到这个值的情况。
    function backtrack(target){
        if(target===0){
            return 0
        }
        if(target<0){
            return -1
        }
        if(memo[target]!==-2) return memo[target]
        let res = Infinity
        for(const coin of coins){
            const subProblem = backtrack(target-coin)
            if(subProblem===-1) continue
            res = Math.min(res,subProblem+1)
        }
        return memo[target] = Number.isFinite(res) ? res : -1;
    }
    const res = backtrack(amount)
    return  res
};
```





###### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

方法一：把问题转换成跟前面一样的。

```js
var numSquares = function(n) {
    const nums = new Array()
    for(let j = 1;j<=Math.ceil(n);j++){ // 把可选的物品算出来
        nums.push(j*j)
    }
    const len = nums.length
    const dp = new Array(len+1).fill(0).map(()=>new Array(n+1).fill(Number.MAX_SAFE_INTEGER))
    for(let i=0;i<=len;i++){
        dp[i][0] = 0
    }
    for(let i = 1;i<=len;i++){
        const num = nums[i-1]
        for(let j = 1;j<=n;j++){
            if(num<=j){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-num]+1) // dp[i][j-num]+1表示选一个新数进来
            }else{
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[len][n]
};

//滚动优化
var numSquares = function(n) {
    const nums = new Array()
    for(let j = 1;j<=Math.ceil(n);j++){ // 把可选的物品算出来
        nums.push(j*j)
    }
    const len = nums.length
    const dp = new Array(n+1).fill(Number.MAX_SAFE_INTEGER)
    dp[0]=0
    for(let i = 1;i<=len;i++){
        const num = nums[i-1]
        for(let j = 1;j<=n;j++){
            if(num<=j){
                dp[j] = Math.min(dp[j],dp[j-num]+1) // dp[i][j-num]+1表示选一个新数进来
            }
        }
    }
    return dp[n]
}; 
```



方法二：看不懂啊

```js
// 动态规划
var numSquares = function(n) {
    const dp = new Array(n+1).fill(Number.MAX_SAFE_INTEGER)
    dp[0] = 0
    for(let i = 1;i<=n;i++){
        for(let j = 1;j<=Math.sqrt(i);j++){
            dp[i] = Math.min(dp[i],dp[i-j*j]+1) // dp[i-j*j]+1表示选一个新数进来
        }
    }
    return dp[n]
};

// 记忆化递归
var numSquares = function(n) {
    const memo = new Array(n+1).fill(Number.MAX_SAFE_INTEGER)
    function backtrack(target){
        if(target===0){
            return 0
        }
        if(memo[target]!==Number.MAX_SAFE_INTEGER){
            return memo[target]
        }
        for(let i=1;i<=Math.floor(Math.sqrt(target));i++){
            if(i*i>target)break
            memo[target] = Math.min(memo[target],backtrack(target-i*i)+1)
        }
        return memo[target]
    }
    return backtrack(n)
};
```







###### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

```js
 // 递归 --- 写出递归基本就能看出递推关系，就能写出一维的动态规划了。
var combinationSum4 = function(nums, target) {
    function backtrack(target){
        if(target===0) return 1 // 使target为0了说明找到一种方案了
        let res = 0
        for(const num of nums){
            if(num>target) continue
            res += backtrack(target-num)
        }
       return res
    }
    return backtrack(target)
};

// 记忆化递归
var combinationSum4 = function(nums, target) {
    const targetMemo = new Map() // target是多少时 有几种方案
    function backtrack(target){
        if(target===0) return 1 // 使target为0了说明找到一种方案了
        if(targetMemo.has(target)) return targetMemo.get(target)
        let res = 0
        for(const num of nums){
            if(num>target) continue
            res += backtrack(target-num)
        }
       targetMemo.set(target,res)
       return res
    }
    return backtrack(target)
};



 // 二维动态规划
// dp[i][j]：i表示target，j表示物品
var combinationSum4 = function(nums, target) {
    const dp = new Array(target+1).fill(0).map(item=>new Array(nums.length+1).fill(0))
    for(let j=1;j<=nums.length;j++){
        dp[0][j] = 1
    }
    for(let i=1;i<=target;i++){
        for(let j=1;j<=nums.length;j++){
            if(nums[j-1]<=i){ //这个数能选进来
                for(let k=0;k<j;k++){ // 可以理解成末尾分别是不同的nums[k]时各有几种方式
                    if(i-nums[k]>-1)dp[i][j]+=dp[i-nums[k]][j] 
                }
            }else{
                dp[i][j]= dp[i][j-1]
            }
        }
    }
    return dp[target][nums.length]
};

// 一维动态规划
var combinationSum4 = function(nums, target) {
    const dp = new Array(target+1).fill(0)
    dp[0] = 1
    for(let i=1;i<=target;i++){
        for(let j=0;j<nums.length;j++){
            if(nums[j]<=i){ //这个数能选进来
                dp[i]+=dp[i-nums[j]]
            }
        }
    }
    return dp[target]
};

// 回溯
var combinationSum4 = function(nums, target) {
    let res = 0,curSum = 0
    function backtrack(){
        if(curSum===target){
            return res+=1
        }
        else if(curSum>target){
            return
        }
        for(const num of nums){
            if(curSum+num>target) continue
            curSum+=num
            backtrack()
            curSum-=num
        }
    }
    backtrack()
    return res
};
```









###### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

```js
// 第一种记忆化递归，会超时，但我感觉是因为题目给的例子的问题。
var wordBreak = function (s, wordDict) {
  const memo = new Map()
  function countChar(str, char) {
    return str.split(char).length - 1;
  }
  function backtrack(target) {
    if(memo.has(target)) return memo.get(target)
    if (countChar(target, '1') === target.length) {
      return true;
    }
    let res = false;

    for (const word of wordDict) {
      if (target.indexOf(word) === -1) continue
      const subString = target.replace(word, '1')
      res = backtrack(subString);
      if (res) return res;
    }
    memo.set(target,res)
    return false;
  }
  return backtrack(s);
};

// 第二种记忆化递归，通关。
var wordBreak = function (s, wordDict) {
  const memo = new Map()
  const wordSet = new Set(wordDict)

  function backtrack(sub) {
    if(memo.has(sub)) return memo.get(sub)
    if (sub==='') {
      return true;
    }
    let res = false;
    for (let i = 1;i<=sub.length;i++) {
      let prefix = sub.slice(0,i)
      if(wordSet.has(prefix)){
        res = backtrack(sub.slice(i))
        if(res) return res
      }
    }
    memo.set(sub,res)
    return false;
  }
  return backtrack(s);
};
// 根据第二种记忆化递归实现的动态规划
var wordBreak = function(s, wordDict) {
    const dp = new Array(s.length+1).fill(false) // dp[i]表示s[0...i]能否
    const wordSet = new Set(wordDict)
    dp[0] = true
    for(let end =1;end<=s.length;end++ ){
        for(let i = 0;i<end;i++){ // i表示分割点，看s[0...i]和s[i...end]是否都合法
            if(dp[end]) break;
            dp[end] = dp[i]&&wordSet.has(s.slice(i,end))
        }
    }
    return dp[s.length]
}; // 还可以再进行剪枝，枚举分割点的时候倒着枚举，如果分割点 i 到 end 的长度已经大于字典列表里最长的单词的长度，那么就结束枚举，
```



###### [1449. 数位成本和为目标值的最大数字](https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/)

```js

 // 记忆化递归
var largestNumber = function(cost, target) {
    function getMax(a,b){
        if(a.length>b.length)return a
        else if(b.length>a.length) return b
        else return a>b?a:b
    }

    const memo = new Array(target+1).fill('')
    function backtrack(t){
        if(memo[t]!==''){
            return memo[t]
        }
        if(t===0){
            return ''
        }
        let maxNum = '0'
        for(let i = 0;i<cost.length;i++){
            const shuwei = i+1
            const chengben = cost[i]
            if(chengben>t) continue
            const nextNum = backtrack(t-chengben)
            if(nextNum!=='0'){
                const curNum= shuwei+nextNum
                maxNum=getMax(curNum,maxNum)
            }
        }
        memo[t] = getMax(maxNum,memo[t])
        return maxNum
    }
    return backtrack(target)
};
// 动态规划
var largestNumber = function(cost, target) {
    function getMax(a,b){
        if(a.length>b.length)return a
        else if(b.length>a.length) return b
        else return a>b?a:b
    }

    const dp = new Array(target+1).fill('0')
    dp[0]=''
        for(let t = 1;t<=target;t++){
            for(let i = 0;i<cost.length;i++){
                const shuwei = i+1
                const chengben = cost[i]
                if(chengben>t) continue
                if(dp[t-chengben]!=='0'){
                    dp[t] = getMax(shuwei+dp[t-chengben],dp[t])
                }
            }
        }
    return dp[target]
};


//我的方案：
function getMax(a, b) {
  if (b === "fuck") return a;
  else if (a.length > b.length) return a;
  else if (b.length > a.length) return b;
  else return a > b ? a : b;
}

// 二维动规
var largestNumber = function (cost, target) {
  const len = cost.length;
  const dp = new Array(len + 1)
    .fill(0)
    .map(() => new Array(target + 1).fill(""));
  for (let i = 0; i <= len; i++) {
    dp[i][0] = "0"; // 0表示不选。
  }
  for (let j = 1; j <= target; j++) {
    dp[0][j] = "fuck"; // fuck表示无论如何也凑不到该成本。
  }
  for (let i = 1; i <= len; i++) {
    const chengben = cost[i - 1];
    for (let j = 1; j <= target; j++) {// 因为上一个成本里可能选过该数，所以这里处理选与不选即可，不用处理重复选多少个的问题。
      const curDp = dp[i][j - chengben];
      if (chengben > j || curDp === "fuck") {
        //不能选
        dp[i][j] = dp[i - 1][j];
      } else {
        const curNum = curDp === "0" ? i + "" : i + curDp;
        dp[i][j] = getMax(curNum, dp[i - 1][j]); 
      }
    }
  }
  return dp[len][target]==='fuck'?'0':dp[len][target];
};

// 一维动规
var largestNumber = function (cost, target) {// 0表示不选。fuck表示无论如何也凑不到该成本。
  const len = cost.length;
  const dp =  new Array(target + 1).fill("fuck")
  dp[0]='0'
  for (let i = 1; i <= len; i++) {
    const chengben = cost[i - 1];
    for (let j = 1; j <= target; j++) {
      const curDp = dp[j - chengben];
      if (chengben > j || curDp === "fuck") {
        //不能选
      } else {
        const curNum = curDp === "0" ? i + "" : i + curDp;
        dp[j] = getMax(curNum, dp[j]);
      }
    }
  }
  return dp[target]==='fuck'?'0':dp[target];
};
```



#### 打家劫舍

##### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

```js
 // dp[i] 表示 一共有i间房时偷到的最大金额
 // dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])
var rob = function(nums) {
    nums.unshift(0)
    const dp = new Array(nums.length).fill(0)
    dp[1] = nums[1]
    for(let i=2;i<nums.length;i++){
        dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i])
    }
    return dp[nums.length-1]
};

//滚动降维
var rob = function(nums) {
    nums.unshift(0)
    let a=0,b=nums[1]
    for(let i=2;i<nums.length;i++){
        const cur = Math.max(b,a+nums[i])
        a=b
        b=cur
    }
    return b
};
```



##### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

环状排列 意味着第一个房子和最后一个房子中 只能选择一个偷窃，因此可以把此 环状排列房间 问题约化为两个 单排排列房间 子问题：

把不偷窃第一个房子和不偷窃最后一个房子这两种情况分别用上一题的方法解出答案后再比较即可。

```js
  // dp[i] 表示 一共有i间房时偷到的最大金额
var rob = function(nums) {
    function fuck(n){
        n.unshift(0)
        let a=0,b=n[1]
        for(let i=2;i<n.length;i++){
            const cur = Math.max(b,a+n[i])
            a=b
            b=cur
        }
        return b
    }
    const len = nums.length
    if(len===1) return nums[0]
    return Math.max(fuck(nums.slice(0,len-1)),fuck(nums.slice(1)))
};
```



#### 树形dp

对于树的话，首先就要想到遍历方式，前中后序（深度优先搜索）还是层序遍历（广度优先搜索）。

从树形dp你就可以看出动态规划的核心是从自底向上由子问题一步步推出主问题的过程。dp数组和for循环都只是其形式，其核心是自底向上。你看树形dp就不需要dp数组和for循环，树遍历就替代了for循环。



##### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

**本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算**。

如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子

```js
var rob = function(root) {
  function traverse(root){
    if(root === null) return [0,0]
    const [robLeft,notRobLeft] = traverse(root.left)
    const [robRight,notRobRight] = traverse(root.right)
    const robRoot = notRobLeft+notRobRight+root.val
    const notRobRoot = Math.max(robLeft,notRobLeft)+Math.max(robRight,notRobRight)
    return [robRoot,notRobRoot]
  }
  return Math.max(...traverse(root))
};
```







#### 股票买卖

##### 通用思路

###### 定义状态

这类问题的「状态」有三个，第一个是天数，第二个是交易数的上限（这里交易是指你的一次买和卖），第三个是当前的持有状态（用 1 表示持有，0 表示没有持有）。用一个三维数组就可以装下这几种状态的全部组合：

```
dp[i][k][0 or 1]
n 为天数，K 为当前交易的次数，0 和 1 代表是否持有股票。
for 0 <= i < n:
​    for 1 <= k <= K:
​        for s in {0, 1}:
​            dp[i][k][s] = max(buy, sell, rest)
```



###### 状态转移方程：

有两种情况：

第一种情况

```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max( 今天选择 rest,        今天选择 sell       )
```

解释：今天我没有持有股票，有两种可能，我从这两种可能中求最大利润：

1、我昨天就没有持有，且截至昨天最大交易次数限制为 `k`；然后我今天选择 `rest`，所以我今天还是没有持有，最大交易次数限制依然为 `k`。

2、我昨天持有股票，且截至昨天最大交易次数限制为 `k`；但是今天我 `sell` 了，所以我今天没有持有股票了，最大交易次数限制依然为 `k`。



第二种情况

```python
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max( 今天选择 rest,         今天选择 buy         )
```

解释：今天我持有着股票，最大交易次数限制为 `k`，那么对于昨天来说，有两种可能，我从这两种可能中求最大利润：

1、我昨天就持有着股票，且截至昨天最大交易次数限制为 `k`；然后今天选择 `rest`，所以我今天还持有着股票，最大交易次数限制依然为 `k`。

2、我昨天本没有持有，且昨天交易次数为 `k - 1`；但今天我选择 `buy`，所以今天我就持有股票了，交易次数变为为 `k`。

###### 定义 base case：

```python
dp[-1][...][0] = 0
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0。

dp[-1][...][1] = -infinity
解释：还没开始的时候，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。

dp[...][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0。

dp[...][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的。
因为我们的算法要求一个最大值，所以初始值设为一个最小值，方便取最大值。
```

```
总结base case：
dp[-1][...][0] = dp[...][0][0] = 0
dp[-1][...][1] = dp[...][0][1] = -infinity

总结状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```



##### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

直接套状态转移方程，根据 base case，可以做一些化简：

```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])
解释：根据k = 0 时的 base case， dp[i-1][0][0] = 0。

本题 k 就一直是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
```

```js
var maxProfit = function(prices) {
    const dp = new Array(prices.length+1).fill(0).map(()=>new Array(2).fill(0))
    dp[0][0]=0
    dp[0][1]=-prices[0]
    for(let i =1;i<prices.length;i++){
        dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i])
        dp[i][1] = Math.max(dp[i-1][1],-prices[i])
    }
    return dp[prices.length-1][0]
};

// 降维
var maxProfit = function(prices) {
    let a=0
    let b=-prices[0]
    for(let i =1;i<prices.length;i++){
        let cur1= Math.max(a,b+prices[i])
        let cur2 = Math.max(b,-prices[i])
        a = cur1
        b = cur2
    }
    return a
};
```





##### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

这道题的特点在于没有给出交易总数 `k` 的限制，也就相当于 `k` 为正无穷。

如果 `k` 为正无穷，那么就可以认为 `k` 和 `k - 1` 是一样的。可以这样改写框架：

```python
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
```

```js
var maxProfit = function(prices) {
    const dp = new Array(prices.length).fill(0).map(()=>new Array(2).fill(0))
    dp[0][0]=0
    dp[0][1]=-prices[0]
    for(let i = 1;i<prices.length;i++){
        dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i])
        dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]-prices[i])
    }
    return dp[prices.length-1][0]
};
```







##### [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

```
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
```

```js
var maxProfit = function(prices) {
    if(prices.length<2) return 0
    const dp = new Array(prices.length).fill(0).map(()=>new Array(2).fill(0))
    dp[0][0]=0
    dp[0][1]=-prices[0]
    dp[1][0] = Math.max(dp[0][0],dp[0][1]+prices[1])
    dp[1][1] = Math.max(dp[0][1],-prices[1])
    for(let i=2;i<prices.length;i++){
        dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i])
        dp[i][1] = Math.max(dp[i-1][1],dp[i-2][0]-prices[i])
    }
    return dp[prices.length-1][0]
};

// 降维
var maxProfit = function(prices) {
    if(prices.length<2) return 0
    let a=0
    let b=-prices[0]
    dp[1][0] = Math.max(a,b+prices[1])
    dp[1][1] = Math.max(b,-prices[1])
    let c= a
    a= dp[1][0]
    b=dp[1][1]
    for(let i=2;i<prices.length;i++){
        let cur1 = Math.max(a,b+prices[i])
        let cur2 = Math.max(b,c-prices[i])
        c=a
        a=cur1
        b=cur2
    }
    return a
};
```



##### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

```js
var maxProfit = function(prices, fee) {
    const dp = new Array(pricjses.length).fill(0).map(()=>new Array(2).fill(0))
    dp[0][0]=0
    dp[0][1]=-prices[0]
    for(let i=1;i<prices.length;i++){
        dp[i][0]=Math.max(dp[i-1][0],dp[i-1][1]+prices[i]-fee)
        dp[i][1]=Math.max(dp[i-1][1],dp[i-1][0]-prices[i])
    }
    return dp[prices.length-1][0]
};
```





##### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

```js
var maxProfit = function(prices) {
    const dp = new Array(prices.length).fill(0).map(()=>new Array(3).fill(0).map(()=>new Array(2).fill(0)))
    for(let i= 0;i<prices.length;i++){
        for(let k=1;k<=2;k++){
            if(i-1==-1){
                dp[i][k][0] = 0
                dp[i][k][1]=-prices[i]
                continue
            }
            dp[i][k][0]=Math.max(dp[i-1][k][0],dp[i-1][k][1]+prices[i])
            dp[i][k][1]=Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-prices[i])
        }
    }
    return dp[prices.length-1][2][0]
}

  
  
  
  /**
 * 状态转移方程：
 * dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
 * dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
 * dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
 * dp[i][1][1] = max(dp[i-1][1][1], -prices[i])
 * 
 * 空间复杂度优化版本
 */
var maxProfit_k_2 = function(prices) {
    let dp_i10 = 0, dp_i11 = -Infinity;
    let dp_i20 = 0, dp_i21 = -Infinity;
    for (let price of prices) {
        dp_i20 = Math.max(dp_i20, dp_i21 + price);
        dp_i21 = Math.max(dp_i21, dp_i10 - price);
        dp_i10 = Math.max(dp_i10, dp_i11 + price);
        dp_i11 = Math.max(dp_i11, -price);
    }
    return dp_i20;
}

```





#### 子序列问题

##### dp定义的套路

**`dp[i]` 定义为以 `nums[i-1]` 这个数结尾的子序列的长度，即nums[i-1]一定是被选进去了**。题目只有一个数组那dp就是一维数组，题目有两个数组那dp就是二维数组。

用记忆化递归去理解估计更好理解：**解决两个字符串的动态规划问题，一般都是用两个指针 `i, j` 分别指向两个字符串的最后，然后一步步往前移动，缩小问题的规模**。

子序列和最值，肯定**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。



二维变一维时：其实滚动数组的本质就是在该数组未重新赋值前存的是上一行的值，重新赋值后就是本行的值。    dp[j-1]没重新赋值前 就是上一行且前一列的值，dp[j-1]重新赋值后就是同一行且前一列的值，dp[j]没重新赋值前就是上一行同一列的值。

##### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

```js
/**
 * @param {string} word1
 * @param {string} word2
 * @return {number}
 */
 // dp[i][j] 表示 s以i-1结尾，t以j-1结尾时所使用的最少操作数
var minDistance = function(word1, word2) {
    const dp = new Array(word1.length+1).fill(0).map(()=>new Array(word2.length+1).fill(0))
    for(let i=0;i<word1.length+1;i++){
        dp[i][0] = i
    }
    for(let j=0;j<word2.length+1;j++){
        dp[0][j]=j
    }
    for(let i=1;i<word1.length+1;i++){
        for(let j=1;j<word2.length+1;j++){
            if(word1[i-1]===word2[j-1]){
                dp[i][j] = dp[i-1][j-1]
            }else{
                dp[i][j] = Math.min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1)
            }
        }
    }
    return dp[word1.length][word2.length]
};

// 降维: dp[j-1]没重新赋值前 就是上一行且前一列的值，dp[j-1]重新赋值后就是同一行且前一列的值，dp[j]没重新赋值前就是上一行同一列的值。
var minDistance = function(word1, word2) {
    const dp = new Array(word2.length+1).fill(0)
    for(let j=0;j<word2.length+1;j++){
        dp[j]=j
    }
    for(let i=1;i<word1.length+1;i++){
        const initialDuiJiaoXian = dp[0] // 此时dp[j-1]还没被更新为本行的值
        dp[0] = i // dp[0]是指word2为空的时候
        let duiJiaoXian = initialDuiJiaoXian
        for(let j=1;j<word2.length+1;j++){
            const nextNumDuiJiaoXian = dp[j]  // 由于下次循环开始j会++，而且此时dp[j]还没被重新赋值所以记录的是上一行的值，所以dp[j]就是下一次循环的对角线的值。
            if(word1[i-1]===word2[j-1]){
                dp[j] = duiJiaoXian
            }else{
                dp[j] = Math.min(duiJiaoXian+1,dp[j-1]+1,dp[j]+1) // 此时dp[j-1]已是本行的值
            }
            duiJiaoXian = nextNumDuiJiaoXian
        }
    }
    return dp[word2.length]
};
```







##### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

```js
 // dp[i][j]表示以i-1结尾的s和以j-1结尾的t时的方案数
 /**
 举例，s 为babgbag，t 为bag，末尾字符相同，于是 s 有两种选择：
用s[s.length-1]去匹配掉t[t.length-1]，问题规模缩小：继续考察babgba和ba。
不这么做，但t[t.length-1]仍需被匹配，于是在babgba中继续挑，考察babgba和bag。

s[i]!=t[j]的情况呢？s[i]不匹配t[j]，唯有拿s[i]之前的子串去匹配
  */
var numDistinct = function(s, t) {
    const dp = new Array(s.length+1).fill(0).map(()=>new Array(t.length+1).fill(0))
    for(let j=0;j<s.length+1;j++){ // t为空的时候肯定是s的子序列
        dp[j][0] = 1 
    }
    for(let i=1;i<s.length+1;i++){
        for(let j=1;j<t.length+1;j++){
            if(s[i-1]===t[j-1]){
                dp[i][j] = dp[i-1][j-1]+dp[i-1][j]
            }else{
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    return dp[s.length][t.length]
};

// 降维
var numDistinct = function(s, t) {
    const dp = new Array(t.length+1).fill(0)
    dp[0]=1
    for(let i=1;i<s.length+1;i++){
        for(let j=t.length;j>0;j--){
            if(s[i-1]===t[j-1]){
                dp[j] = dp[j-1]+dp[j]
            }
        }
    }
    return dp[t.length]
};
```







##### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```js
 // dp[i]表示以num[i]结尾的子数组的最大和
var maxSubArray = function(nums) {
    const dp = new Array(nums.length).fill(0)
    dp[0]=nums[0]
    let res = dp[0]

    for(let i=1;i<nums.length;i++){
        dp[i] = Math.max(nums[i],dp[i-1]+nums[i])
        res = Math.max(dp[i],res)
    }
    return res
};

// 降维
var maxSubArray = function(nums) {
    let a=nums[0]
    let res =a

    for(let i=1;i<nums.length;i++){
        let cur = Math.max(nums[i],a+nums[i])
        res = Math.max(cur,res)
        a = cur
    }
    return res
};
```





##### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

```js
 // 将状态定义为「以 nums[i] 结尾 的「上升子序列」的长度」。
var lengthOfLIS = function(nums) {
    let res = 1
    const dp = new Array(nums.length).fill(1)
    for(let i= 1;i<nums.length;i++){
        for(let j = 0;j<i;j++){
            if(nums[j]<nums[i]){
            dp[i] = Math.max(dp[i],dp[j]+1)
            res = Math.max(res,dp[i])
            }

        }
    }
    return res
};
```

类似的题还有：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/solutions/297889/chuan-shang-yi-fu-wo-jiu-bu-ren-shi-ni-liao-lai-3/







##### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

```js
var findLengthOfLCIS = function(nums) {
    let res = 1
    const dp = new Array(nums.length).fill(1)
    for(let i= 1;i<nums.length;i++){
        if(nums[i-1]<nums[i]){
            dp[i]=dp[i-1]+1
            res = Math.max(dp[i],res)
        }
    }
    return res
};
```

##### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

```js
 // dp[i][j] 表示以 i结尾的A数组，j结尾的B数组,i和j都从1开始，对应nums的0，因为i和j为0的时候用以表示A数组和B数组为空。
var findLength = function(nums1, nums2) {
    const len1 = nums1.length
    const len2 = nums2.length
    const dp = new Array(len1+1).fill(0).map(()=>new Array(len2+1).fill(0))
    let res = 0
    for(let i=1;i<len1+1;i++){
        for(let j=1;j<len2+1;j++){
            if(nums1[i-1]===nums2[j-1]){
                dp[i][j] = dp[i-1][j-1]+1
                res = Math.max(res,dp[i][j])
            }
        }
    }
    return res
};

// 优化成一维数组为什么必须从右往左计算：因为 计算当前值 依赖的是 其左上角的值，如果从左向右计算会在计算到元素左边值时，把左上角的值 覆盖掉
// 滚动数组：每一轮都要更新这个数组里的每一个元素
var findLength = function(nums1, nums2) {
    const len1 = nums1.length
    const len2 = nums2.length
    const dp = new Array(len2+1).fill(0)
    let res =0
    for(let i=1;i<len1+1;i++){
        for(let j=len2;j>=0;j--){
            if(nums1[i-1]===nums2[j-1]){
                dp[j] = dp[j-1]+1
                res=Math.max(res,dp[j])
            }else{
                dp[j]=0
            }
        }
    }
    return res
};
```



##### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

```js
 // dp[i][j]表示A以i-1结尾时，B以j-1结尾时的最长公共子序列
 /**如果某个字符应该在 lcs 中，那么这个字符肯定同时存在于 s1 和 s2 中，因为 lcs 是最长公共子序列嘛。所以本题的思路是这样：
用两个指针 i 和 j 从后往前遍历 s1 和 s2，如果 s1[i]==s2[j]，那么这个字符一定在 lcs 中；否则的话，s1[i] 和 s2[j] 这两个字符至少有一个不在 lcs 中，需要丢弃一个。
 */
var longestCommonSubsequence = function(text1, text2) {
    const len1 = text1.length,len2 = text2.length
    const dp = new Array(len1+1).fill(0).map(()=>new Array(len2+1).fill(0))
    for(let i=1;i<=len1;i++){
        for(let j=1;j<=len2;j++){
            if(text1[i-1]===text2[j-1]){
                dp[i][j] = dp[i-1][j-1]+1
            }else{
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
            }
        }
    }
    return dp[len1][len2]
};
```



##### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

```js
 // dp[i][j] 表示 s以i-1结尾，t以j-1结尾时是否是子序列
var isSubsequence = function(s, t) {
    const dp = new Array(s.length+1).fill(false).map(()=>new Array(t.length+1).fill(false))
    for(let j=0;j<t.length+1;j++){ // s为空的时候看到是t的子序列
        dp[0][j] = true 
    }
    for(let i=1;i<s.length+1;i++){
        for(let j=i;j<t.length+1;j++){
            if(s[i-1]===t[j-1]){
                dp[i][j] = dp[i-1][j-1]
            }else{
                dp[i][j] = dp[i][j-1]
            }
        }
    }
    return dp[s.length][t.length]
};
```



##### [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

```js
 // 其实就是求最长公共子序列
var minDistance = function(word1, word2) {
    const dp = new Array(word1.length+1).fill(0).map(()=>new Array(word2.length+1).fill(0))
    for(let i=1;i<word1.length+1;i++){
        for(let j=1;j<word2.length+1;j++){
            if(word1[i-1]===word2[j-1]){
                dp[i][j]=dp[i-1][j-1]+1
            }else{
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])
            }
        }
    }
    return word1.length-dp[word1.length][word2.length]+word2.length-dp[word1.length][word2.length]
};
```





##### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

```js
 //dp[i][j]表示在i和j区间的字符串是否回文子串
var countSubstrings = function(s) {
    let res = 0
    const dp = new Array(s.length).fill(false).map(()=>new Array(s.length).fill(false))
    for(let j=0;j<s.length;j++){ // 根据画出二维表或者根据递推公式可知需要 先遍历 列
        for(let i=0;i<=j;i++){
            if(i===j){
                dp[i][j]=true
            }
            else if(s[i]===s[j]){
                if(j-i===1){
                    dp[i][j]=true
                }else{
                    dp[i][j]=dp[i+1][j-1]
                }
            }
            if(dp[i][j]){
                res++
            }
        }
    }
    return res
};
```



##### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

```js

  //dp[i][j]表示从i到j区间的字符串的最长回文子序列
var longestPalindromeSubseq = function(s) {
    const dp = new Array(s.length).fill(0).map(()=>new Array(s.length).fill(0))
    for(let i=s.length-1;i>=0;i--){ // 根据画出二维表或者根据递推公式可知需要 先遍历 列
        for(let j=i;j<s.length;j++){
            if(i===j){
                dp[i][j]=1
                continue
            }
            if(s[i]===s[j]){
                dp[i][j]=dp[i+1][j-1]+2
            }else{
                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1])
            }
        }
    }
    return dp[0][s.length-1]
};

// 降维
var longestPalindromeSubseq = function(s) {
    const dp = new Array(s.length).fill(0)
    for(let i=s.length-1;i>=0;i--){ // 根据画出二维表或者根据递推公式可知需要 先遍历 列
        let duijiaoxian = dp[i]
        for(let j=i;j<s.length;j++){
            let nextduijiaoxian=dp[j] // dp[j]是下面一行的，拿到下个循环用就相当于是下面一行且上一列的
            if(i===j){
                dp[j]=1
            }
            else if(s[i]===s[j]){
                dp[j]=duijiaoxian+2
            }else{
                dp[j]=Math.max(dp[j],dp[j-1]) //dp[j]是下面一行的，dp[j-1]是本行的
            }
            duijiaoxian=nextduijiaoxian
        }
    }
    return dp[s.length-1]
};


```



##### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

解法跟常规子序列问题不一样，套路不能直接套。

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
 // 某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且<mark>最后一个元素呈上升趋势</mark>。如序列 [1,3,2,4]即为「上升摆动序列」。
// 某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且<mark>最后一个元素呈下降趋势</mark>。如序列 [4,2,3,1] 即为「下降摆动序列」

/**
up[i]表示以前 i 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。
down[i]表示以前 i 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。
状态转移方程可见leetcode官方解释
 */
var wiggleMaxLength = function(nums) {
    const len = nums.length
    const up = new Array(len).fill(0)
    const down = new Array(len).fill(0)
    up[0] =1
    down[0]=1
    for(let i=1;i<len;i++){
        if(nums[i]===nums[i-1]){
            up[i] = up[i-1]
            down[i]=down[i-1]
        }
        else if(nums[i-1]>nums[i]){
            up[i] = up[i-1]
            down[i] = Math.max(up[i-1]+1,down[i-1])
        }else{
            up[i]=Math.max(up[i-1],down[i-1]+1)
            down[i]=down[i-1]
        }
    }
    return Math.max(up[len-1],down[len-1])
};

// 降维
var wiggleMaxLength = function(nums) {
    const len = nums.length
    let up =1
    let down=1
    for(let i=1;i<len;i++){
        if(nums[i-1]===nums[i]){
            continue
        }
        else if(nums[i-1]>nums[i]){
            down = Math.max(up+1,down)
        }else{
            up=Math.max(up,down+1)
        }
    }
    return Math.max(up,down)
};

// 这居然是贪心？ 这个解法就是遍历一遍然后计算变化。
var wiggleMaxLength = function(nums) {
    const len = nums.length
    if(len<2){
        return len
    }
    let preDiff = nums[1]-nums[0]
    let res = preDiff===0?1:2
    for(let i=2;i<len;i++){
        const diff =nums[i]-nums[i-1]
        if((diff<0&&preDiff>=0)||(diff>0&&preDiff<=0)){
            res++
            preDiff=diff
        }
    }
    return res
};

```



# 贪心算法

## 概述

最重要的是思路，看了思路后代码都能写出来，不像动态规划和递归啥的，看了思路都不一定会写代码。



「贪心算法」 和 「动态规划」、「回溯搜索」 算法一样，完成一件事情，是 分步决策 的；
「贪心算法」 在每一步总是做出在当前看来最好的选择
贪心算法和动态规划相比，它既不看前面（也就是说它不需要从前面的状态转移过来），也不看后面（无后效性，后面的选择不会对前面的选择有影响），因此贪心算法时间复杂度一般是线性的，空间复杂度是常数级别的；

**感觉局部最优是可以推出全局最优，并想不出反例，那么就试一试贪心**

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-10-21-50-image-20231110215035018.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-10-21-50-image-20231110215035018.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-10-21-50-image-20231110215035018.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-10-21-50-image-20231110215035018.png" loading="lazy"/>
  </picture>



## 应用场景

典型的贪心算法问题：

- **硬币找零问题**：在某些硬币组合下，贪心算法总是可以得到最优解。
- <mark>**区间调度问题**：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。</mark>
- **分数背包问题**：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。
- **股票买卖问题**：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。
- **霍夫曼编码**：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最小的两个节点合并，最后得到的霍夫曼树的带权路径长度（即编码长度）最小。
- **Dijkstra 算法**：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。





## [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

贪心的思路，局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。

局部最优可以推出全局最优。

那么如果将负数都转变为正数了，K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。

那么又是一个贪心：局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大（例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。

```js
var largestSumAfterKNegations = function(nums, k) {
    const len = nums.length
    nums.sort((a,b)=>Math.abs(b)-Math.abs(a))
    for(let i=0;i<len;i++){
        if(nums[i]<0){
        nums[i] = -nums[i]
            k--
        }
        if(k<=0) break
    }
    while(k>0){
        nums[len-1] = -nums[len-1]
        k--
    }
    return nums.reduce((preRes,curParam)=>preRes+curParam,0)
};
```





## [134. 加油站](https://leetcode.cn/problems/gas-station/)

```js
var canCompleteCircuit = function(gas, cost) {
    const len = gas.length
    let cur=0,startIndex = 0,sum=0
    for(let i=0;i<len;i++){
        const profit = gas[i]-cost[i]
        cur+= profit
        sum+=profit
        if(cur<0){
            startIndex = i+1
            cur=0
        }
    }
    if(sum<0) return -1
    return startIndex>=len?-1:startIndex
};
```







## [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

```javascript
var lemonadeChange = function(bills) {
    let five=0,ten=0
    for(const item of bills){
        switch(item){
            case 5:{
                five++
                break
            }
            case 10:{
                if(!five) return false
                five--
                ten++
                break
            }
            case 20:{
                if(ten&&five){
                    ten--
                    five--
                }else if(five>2){
                    five-=3
                }else{
                    return false
                }
                break
            }
        }
    }
    return true
};
```





## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

```javascript
var findContentChildren = function(g, s) {
    let res = 0
   g.sort((a,b)=>a-b)
   s.sort((a,b)=>a-b)
   for(let i = 0,j=0 ;i<g.length,j<s.length;){
           if(g[i]<=s[j]){
               res++
               i++
               j++
           }else{
               j++
           }
   }
   return res
};
```



## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。

```javascript
 /*不用拘泥于每次究竟跳跳几步，而是看每个元素的覆盖范围，覆盖范围内一定是可以跳过来的*/
var canJump = function(nums) {
    let cover=0
    for(let i=0;i<=cover;i++){//覆盖到才能去呀
        cover=Math.max(cover,nums[i]+i)
        if(cover>=nums.length-1) return true
    }
    return false
};
```





## [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

```js
 // 遍历一个可抵达的区间，从中选出能跳最远的点，就有了新的可抵达的区间，然后跳跃一次，进入新的区间继续遍历寻求最优解
var jump = function(nums) {
    let maxDistance = 0
    let lastMaxDistance = 0
    let step = 0
    for(let i=0;i<nums.length;i++){
        maxDistance = Math.max(maxDistance,nums[i]+i)
        if(lastMaxDistance===nums.length-1){
            return step
        }
        if(i===lastMaxDistance){
            lastMaxDistance = maxDistance
            step++
        }
    }
    return step
};
```







## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

```js
var maxSubArray = function(nums) {
    let res = nums[0]
    let count = 0 // 表示连续子数组的和
    for(let i=0;i<nums.length;i++){
        count +=nums[i]
        if(count>res){
            res=count
        }
        if(count<0){ // 贪心就体现在这里：子数组的起点一定是正数，因为负数只会拉低总和，所以是负数的时候就置为0
            count=0
        }
    }
    return res
};
```







## [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

这道题 「贪心」 的地方在于，对于 「今天的股价 - 昨天的股价」，得到的结果有 3 种可能：① 正数，② 000，③负数。贪心算法的决策是： **只加正数** 。也可以理解成贪心的地方在于 赚了就卖 能赚就卖。

```js
var maxProfit = function(prices) {
    let res = 0
    for(let i=1;i<prices.length;i++){
        const diff =prices[i]-prices[i-1]
        if(diff>0){
            res+=diff
        }
    }
    return res
};
```





## [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)





## [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

代码随想录 解释的挺好

```js
 /**
0：该节点无覆盖
1：本节点有摄像头
2：本节点有覆盖
  */
var minCameraCover = function(root) {
    let res = 0
    function traverse(node){
        if(node === null){
            return 2
        }

        const left = traverse(node.left)
        const right = traverse(node.right)
        if(left === 2 && right === 2){
            return 0
        }
        else if(left===0||right===0){
            res++
            return 1
        }
        else if(left===1||right===1){
            return 2
        }
    }
    const head = traverse(root) // 这里返回的是头节点的情况
    return head===0 ? res+1:res
};
```





## 需要考虑两个维度

遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。**如果两个维度一起考虑一定会顾此失彼**



### [135. 分发糖果](https://leetcode.cn/problems/candy/)



### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

```js
// 身高按降序排列，同一高度按k升序排列，然后再遍历people，把这个人插入到k索引的对应位置
var reconstructQueue = function(people) {
    let queue = []
    people.sort((a, b ) => {
        if(b[0] !== a[0]) {
            return b[0] - a[0]
        } else {
            return a[1] - b[1]
        }
        
    })

    for(let i = 0; i < people.length; i++) {
        queue.splice(people[i][1], 0, people[i])
    }
    return queue
};
```





## 区间调度问题(会议室分配)

**区间问题肯定按照区间的起点或者终点进行排序**





### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

```js
var findMinArrowShots = function(points) {
    let shot = 1
    points.sort((a,b)=>a[0]-b[0])
    for(let i=1;i<points.length;i++){
        if(points[i-1][1]<points[i][0]){ // 如果没有重叠 则 肯定要射掉
            shot++
        }else{ // 有重叠则不一定是本次就射，把最小的右边界传递下去看是否还有跟后面的继续重叠
            points[i][1] = Math.min(points[i-1][1],points[i][1])
        }
    }
    return shot
};
```





### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)(实际场景：会议室分配)

**类似本题的实际场景**：假设现在只有一个会议室，还有若干会议，你如何将尽可能多的会议安排到这个会议室里？

这个问题需要将这些会议（区间）按结束时间（右端点）排序。

1、先按每个区间的`end`数值升序排列。

2、记录区间集合 中还没有交集的`end` 最小的那一个区间（记为x）。

3、区间start比x的end大的就是跟x有交集的区间。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-2RkMiT.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-2RkMiT.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-2RkMiT.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-2RkMiT.gif" loading="lazy"/>
  </picture>

```javascript
var eraseOverlapIntervals = function(intervals) {
    let res = 0
    intervals.sort((a,b)=>a[0]-b[0])
    for(let i=1;i<intervals.length;i++){
        if(intervals[i-1][1]>intervals[i][0]){ // 如果有重叠那必须移除，且移除的是右边界更大的那个，所以是把最小的右边界传递下去看跟后面的还会不会重叠
            res++
            intervals[i][1] = Math.min(intervals[i-1][1],intervals[i][1])
        }
    }
    return res
};
```





### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

```js
var merge = function(intervals) {
    const res = []
    intervals.sort((a,b)=>a[0]-b[0])
    for(let i=0;i<intervals.length;i++){
        if(i===intervals.length-1){
            res.push(intervals[i])
            break
        }
        if(intervals[i][1]<intervals[i+1][0]){
            res.push(intervals[i])
        }else{
            intervals[i+1][0]=intervals[i][0]
            intervals[i+1][1]=Math.max(intervals[i][1],intervals[i+1][1])
        }
    }
    return res
};
```





### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

我自己写的更上面几道题差不多的思路：

```js
var partitionLabels = function(s) {
    const store = {}
    for(let i=0;i<s.length;i++){ // 统计每个字符出现的起始位置和结束位置。
        const cur = s[i]
        if(store[cur]){
            store[cur][1] = i
        }else{
            store[cur] = [i,i]
        }
    }
    const arr = Object.values(store) // 取出每个字符的区间
    arr.sort((a,b)=>a[0]-b[0]) // 对区间进行排序
    let res=[]
    for(let i=1;i<arr.length;i++){
        if(arr[i-1][1]<arr[i][0]){ // 贪心：如果没有重叠则直接分割
            res.push(arr[i-1][1]-arr[i-1][0]+1)
        }else{ // 如果有重叠则 把最大的右边界传递下去
            arr[i][1] = Math.max(arr[i][1],arr[i-1][1])
            arr[i][0] = Math.min(arr[i][0],arr[i-1][0])
        }
        if(i===arr.length-1){ // 算到最后一个了必须得切一下
            res.push(arr[i][1]-arr[i][0]+1)
        }
    }
    return res
};
```





更巧妙的方法：

在遍历的过程中相当于是要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了**。此时前面出现过所有字母，最远也就到这个边界了。

可以分为如下两步：

- 统计每一个字符最后出现的位置
- 从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-16-10-17-image-20231116101711201.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-16-10-17-image-20231116101711201.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-16-10-17-image-20231116101711201.png" alt="image-20231116101711201" style="zoom:50%;" loading="lazy"/>
  </picture>

```javascript
var partitionLabels = function(s) {
    const hash={}
    for(let i=0;i<s.length;i++){
        hash[s[i]]=i
    }
    let start=0,end=0
    const result=[]
    for(let i=0;i<s.length;i++){
        end = Math.max(end,hash[s[i]])
        if(i===end){
            result.push(end-start+1)
            start=end+1
        }
    }
    return result
};
```







### [1024. 视频拼接](https://leetcode.cn/problems/video-stitching/)

先按照起点升序排序，如果起点相同的话按照终点降序排序（因为这样clips[0]就是必选的）。**比较所有起点小于 `clips[0][1]` 的区间，它们中终点最大的那个区间就是第二个会被选中的视频**，这一条就是贪心的策略。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4E4rRY.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4E4rRY.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4E4rRY.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4E4rRY.gif" loading="lazy"/>
  </picture>





# 排序

## 使数组乱序

纯乱序的方案是数组中每个元素都对其余位置进行比较， 这个比较有50%的交换位置概率。这样一来，总共比较次数一定为n(n-1)。 而在所有排序算法中都不会满足这样的条件（排序算法最差也就是n(n-1)/2）。

### 利用sort()和Math.random()

```js
function shuffle(arr) {
  return arr.sort(() => Math.random() - 0.5);
}
```

这个方法不够随机的根本原因在于：

v8在处理sort方法时，使用了插入排序和快排两种方案。 当目标数组长度小于10时，使用插入排序；反之，使用快速排序。

大多数排序算法的时间复杂度介于O(n)到O(n²)之间， 元素之间的比较次数通常情况下要远小于n(n-1)/2， 也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能）， 这些 sort 随机排序的算法自然也不能真正随机。





### 改进sort()和Math.random()

（不管了不知道为啥这样就改进了---https://juejin.cn/post/6844903863812620296）

我们将数组中原来的值保存在对象的 val 属性中，同时为对象增加一个属性 ram ，值为一个随机数。接下来我们只需要对数组中每个对象的随机数进行排序，即可得到一个乱序数组。

```js
function shuffle(arr) {
    let newArr = arr.map(item=>({val:item,ram:Math.random()}));
    newArr.sort((a,b)=>a.ram-b.ram);
    arr.splice(0,arr.length,...newArr.map(i=>i.val));
    return arr;
}
```



### 最优法：Fisher–Yates也称为Knuth洗牌算法

将数组从后向前遍历，然后将当前元素与随机位置的元素进行交换。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-14-30-image-20230820143049467.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-14-30-image-20230820143049467.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-14-30-image-20230820143049467.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-14-30-image-20230820143049467.png" loading="lazy"/>
  </picture>

```js
function shuffle(arr) {
    let m = arr.length;
    while (m > 1){
        let index = Math.floor(Math.random() * m--);
        [arr[m] , arr[index]] = [arr[index] , arr[m]]
    }
    return arr;
}
```









## 总览

- 稳定

  指的是相同的元素在排序之后的相对位置对比排序之前是否是一样的,如果没有发生变化的,那么就称这个算法是稳定的。稳不稳定的关键在于是不是跟相邻的元素比较。

- in-place/out-place：

1. 就地算法在不使用任何额外内存的情况下转换输入。就地算法可能需要少量额外内存用于其操作。但是，所需的内存量不依赖于输入大小，并且应该是恒定的。（不考虑函数调用堆栈使用的空间）
2. 异地算法使用的额外空间取决于输入大小。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-43-image-20230801094311112.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-43-image-20230801094311112.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-43-image-20230801094311112.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-43-image-20230801094311112.png" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-19S5Iw.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-19S5Iw.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-19S5Iw.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-19S5Iw.webp" loading="lazy"/>
  </picture>



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-57-image-20230801095746576.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-57-image-20230801095746576.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-57-image-20230801095746576.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-09-57-image-20230801095746576.png" loading="lazy"/>
  </picture>



## 冒泡排序

### 一句话总结

两两交换使剩余序列中的最小值到剩余序列中的最前面。（保证左侧有序---这个有序是指元素已经在正确的位置上了，因为每次找到的都是最值。）



### 代码思路

外层循环确定这一轮要确保是正确元素的位置，内层循环从尾部开始通过两两交换相邻元素的方式每次把小的或者大的换到前面去，这样一轮循环下来就能保证i的位置上放的元素是对的。 

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-bVIa3a.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-bVIa3a.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-bVIa3a.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-bVIa3a.webp" loading="lazy"/>
  </picture>

```javascript
function bubbleSort(arr) { 
    for (let i = 0; i<arr.length; i++){ 
      	let doSwap = false //用于处理数组本身就是有序的情况，这样就能确保冒泡排序在数组本来就有序的情况下的时间复杂度为O(n)。
        for (let j=arr.length-1; j > i; j--){ 
            if (arr[j - 1] > arr[j]) {
                [arr[j-1],arr[j]]=[arr[j],arr[j-1]]
              	doSwap = true 
            }
        }
      	if(!doSwap) return arr //没有交换就说明从结尾到开头的每个元素都大于它之前的元素
    }
  	return arr
}
```





### 时间复杂度

- 最好情况：本来就是顺序的，内层循环没有发生交换操作。  
- 最坏情况： 本来就是逆序的，内层循环每次都要交换。





### 稳定的

「只有当元素的大小不一样时，<font color="red">相邻</font>元素之间才会交换位置」

### 优化

<font color="red">核心：没有导致交换操作就说明是有序的</font> 

#### 优化一：处理数组数组部分有序的情况（有序是指元素在正确的位置上）

优化的点在于：循环的时候是直接跳跃式跃进，减少了一些不必要的循环趟数

```ts
function bubbleSort(arr: Array<number>) {
  const len = arr.length;
  let lastSwapIndex = 0; //用于记录上一轮循环中最后发生了交换的位置。（由于内层循环是从后往前，所以初始值设为0）
  for (let i = 0; i < arr.length; i = lastSwapIndex) {
    //i是指这一轮遍历的结束位置，而且i就是这一次要确保是正确元素的位置
    //lastSwapIndex前面的元素都是已经排好序的（因为如果是无序的就会导致交换了）。
    let j = len - 1;
    for (; j > i; j--) {
      //每一轮都是从尾部开始遍历
      if (arr[j] < arr[j - 1]) {
        [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
        lastSwapIndex = j;
      }
    }
    if (lastSwapIndex === j) return arr; // 这一次的结束位置跟上一次的结束位置相同说明这一次没有做交换，如果内层循环没有做交换操作说明数组已经有序了。
  }
  return arr;
}
```



#### 优化二：双向冒泡

内层循环里保证剩余元素里最小数和最大数的位置，所以内层循环需要有两个循环：把最小的数冒到剩余元素的最前面，最大的数冒到剩余元素的最后面。（有点像双指针）

```ts
function bubbleSort(a: Array<number>) {
  let start = 0,
    end = a.length - 1; // 用于缩减剩余的队列，start就是放目前剩余队列里最小的元素，end就是放目前剩余队列里最大的元素。
  while (start < end) {
    for (let i = start; i < end; i++) {
      // 从前往后遍历把最大值放到最后去
      if (a[i] > a[i + 1]) {
        [a[i], a[i + 1]] = [a[i + 1], a[i]];
      }
    }
    end--; //此时end位置的元素是正确的了，可以减减了
    for (let i = end; i > start; i--) {
      // 从后往前遍历把最小值放到最前去
      if (a[i] < a[i - 1]) {
        [a[i], a[i - 1]] = [a[i - 1], a[i]];
      }
    }
    start++; //此时start位置的元素是正确的了，可以加加了
  }
  return a;
}
```





#### 优化三：结合上述两思路

有点像双指针跳跃式递进

```ts
function bubbleSort(a: Array<number>) {
  let start = 0,
    end = a.length - 1;
  let lastForwardSwapIndex = start;
  let lastBackwardSwapIndex = end;
  while (start < end) {
    let i = start;
    for (; i < end; i++) {
      if (a[i] > a[i + 1]) {
        [a[i], a[i + 1]] = [a[i + 1], a[i]];
        lastForwardSwapIndex = i;
      }
    }

    if (end === lastForwardSwapIndex) return a; //说明上面这轮循环没有改变lastForwardSwapIndex的值，说明没有导致交换操作
    end = lastForwardSwapIndex; //刚刚那轮循环是从前往后，所以右边是好的（不用换的才是好的），所以赋值给end
    for (i = end; i > start; i--) {
      if (a[i] < a[i - 1]) {
        [a[i], a[i - 1]] = [a[i - 1], a[i]];
        lastBackwardSwapIndex = i;
      }
    }
    if (start === lastBackwardSwapIndex) return a; //说明上面这轮循环没有改变lastBackwardSwapIndex的值，说明没有导致交换操作
    start = lastBackwardSwapIndex;
  }
  return a;
}
```











## 选择排序

### 一句话总结

找到最小的元素所在的位置并一直记着，跟剩余队列最前的位置进行交换，遍历完所有剩余元素才进行交换。（冒泡排序是比较了之后就会决定要不要交换） （保证左侧有序---这个有序是指元素已经在正确的位置上了，因为每次找到的都是最值。）



### 代码思路

外层循环确定这一轮要确保是正确元素的位置，内层循环保证找到最小值。 



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-sZkbIh.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-sZkbIh.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-sZkbIh.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-sZkbIh.gif" loading="lazy"/>
  </picture>

```ts
function selectSort(arr: Array<number>) {
  const len = arr.length;
  for (let i = 0; i < len - 1; i++) {
    let minIndex = i;
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
    }
    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
  }
  return arr;
}
```



### 时间复杂度

最好情况--即数组本身就有序下也是O(n2)，因为每次都要内层循环完找最值。





### 不稳定

跟冒泡排序的区别是：选择排序是跳跃的交换，而冒泡排序是相邻交换，选择排序可能【2，1，1】第二个1直接跟2交换了。

举例：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-10-28-image-20230801102803784.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-10-28-image-20230801102803784.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-10-28-image-20230801102803784.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-01-10-28-image-20230801102803784.png" loading="lazy"/>
  </picture>





### 优化

在一趟遍历中，同时找出最大值与最小值，放到数组两端，这样就能将遍历的趟数减少一半。（类似双指针）

```ts
function selectSort(arr: Array<number>) {
  let start = 0,
    end = arr.length - 1;
  while (start < end) {
    let minIndex = start;
    let maxIndex = end;
    let j = start;
    for (; j <= end; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j;
      }
      if (arr[j] > arr[maxIndex]) {
        maxIndex = j;
      }
    }
    [arr[start], arr[minIndex]] = [arr[minIndex], arr[start]];
    [arr[end], arr[maxIndex]] = [arr[maxIndex], arr[end]];
    start++;
    end--;
  }
  return arr;
}
```











## 插入排序

### 一句话总结

从这个元素的位置往前数，如果前面那个值比他大，那这个值往后移，否则这个位置就是目标元素的位置。类似于打牌时码牌行为的排序。（保证左侧有序---这个有序并不意味着元素已经在正确的位置上了.）



### 代码思路

==外层循环表示这一次要找到正确位置的元素==，内层循环从 这个元素的原始位置往前 找到 它这个元素 相对于其前面的元素该放的位置 并且 过程中其他元素要不断往后移。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-03-11-55-image-20230803115556309.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-03-11-55-image-20230803115556309.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-03-11-55-image-20230803115556309.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-03-11-55-image-20230803115556309.png" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ko9FAr.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ko9FAr.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ko9FAr.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ko9FAr.gif" loading="lazy"/>
  </picture>

```javascript
function insertionSort(arr: Array<number>) {
  const len = arr.length;
  for (let i = 1; i < len; i++) {
    // i表示本次被操作的元素的原本位置
    const target = arr[i];
    let j = i - 1; //j表示目前被比较的位置
    for (; j >= 0; j--) {
      if (arr[j] > target) {
        // 如果目前被比较的元素比目标元素大则这个元素要往后移
        arr[j + 1] = arr[j];
      } else { //如果前面的元素比目标元素小，那就可以直接跳出了，因为插入排序是保证了前面有序的
        break;
      }
    }
    arr[j + 1] = target; // 目前被比较的位置的后一个位置才是目标的位置。
  }
  return arr;
}
```



### 时间复杂度

最好情况 --- 数组本身就有序是O(n)，因为内层循环直接就跳出了。







### 稳定的

因为这个位置的元素比目标元素大才会往后移





### 优化

因为是在左侧有序的队列里找到要插入的位置，所以可以通过二分查找的方式在左侧找到目标元素要插入的位置。

注意和二分搜索有点不一样。搜索插入的位置，应该是最近大于待插入元素的位置。

然后还需要将从该待插入的位置到目标元素的位置都往后移动一位，腾出位置插入目标值。

```tsx
function insertionSort(arr: Array<number>) {
  function binarySearch(
    arr: Array<number>,
    start: number,
    end: number,
    target: number
  ) {
    while (start < end) {
      const mid = (start + end) >> 1;
      if (arr[mid] > target) {
        end = mid;
      } else {
        start = mid + 1;
      }
    }
    return start;
  }

  function moveBack(arr: Array<number>, start: number, end: number) {
    for (let i = end; i > start; i--) {
      arr[i] = arr[i - 1];
    }
  }

  for (let i = 1; i < arr.length; i++) {
    // i表示本次被操作的元素的原本位置
    const target = arr[i];
    const insertIndex = binarySearch(arr, 0, i, target);
    if (i !== insertIndex) {
      // 相同说明不用挪动了
      moveBack(arr, insertIndex, i);
      arr[insertIndex] = target;
    }
  }
  return arr;
}
```







## 希尔排序

### 一句话总结

#### 增量序列

选一组递减的整数作为增量序列。最小的增量必须为1。

- 先用第一个增量把数组分为若干个子数组，每个子数组中的元素下标距离等于增量；
- 然后对每个子数组进行简单插入排序
- 再使用第二个增量，继续同样的操作，直到增量序列里的增量都使用过一次。
  （增量为1时，其实就是对整个数组进行简单插入排序）

一般我们选择的增量是从数组长度开始每次除以2：「希尔排序跟插入排序比较就是多加了一步`确定步长`」**.在插入排序的过程中,我们的步长是固定的为1,在希尔排序中步长**「一开始是`数组长度的一半`,之后每次分组排序之后步长就`再减半`,`直到步长到1`为止」**



#### 理解成希尔排序就是插入排序的优化

因为插入排序是从目标元素位置往前找，在找到位置的情况下内层循环就会退出，所以通过步长来分组（像归并排序一样相邻的为一组是达不到这个效果的）的方式让相对较小的元素都放到了前边去就能让插入排序更早找到插入的位置而退出循环）





### 代码思路

<font color="red">步长跟组数是一样的</font>

**「希尔排序跟插入排序比较就是多加了一步`确定步长`」**.在插入排序的过程中,我们的步长是固定的为1,在希尔排序中步长**「一开始是`数组长度的一半`,之后每次分组排序之后步长就`再减半`,`直到步长到1`为止」**

<picture>
    <source type="image/avif" srcset="https://camo.githubusercontent.com/68a3945dc668bee934f15515e942a2e5c2a6b3871933359cda5432b5cd42820d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://camo.githubusercontent.com/68a3945dc668bee934f15515e942a2e5c2a6b3871933359cda5432b5cd42820d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970?imageMogr2/format/webp">
    <img src="https://camo.githubusercontent.com/68a3945dc668bee934f15515e942a2e5c2a6b3871933359cda5432b5cd42820d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="https://camo.githubusercontent.com/68a3945dc668bee934f15515e942a2e5c2a6b3871933359cda5432b5cd42820d/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313934303331372d616363366336663136623039363739342e6769663f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" loading="lazy"/>
  </picture>

```ts
function shellSort(arr: Array<number>) {
  // 步长跟组数是一样的
  const len = arr.length;
  let buchang = len >> 1;
  while (buchang >= 1) {
          //下面就是插入排序
    for (let i = 0; i < buchang; i++) {
      for (let j = i + buchang; j < len; j = j + buchang) {
        // 本次要确定位置的元素
        const target = arr[j];
        let k = j - buchang;
        for (; k >= 0; k = k - buchang) {
          // 从目标元素的原位置开始往前遍历
          if (arr[k] > target) {
            arr[k + buchang] = arr[k];
          } else {
            break;
          }
        }
        arr[k + buchang] = target;
      }
    }
    buchang = buchang >> 1;
  }
  return arr;
}
```







### 时间复杂度

希尔排序的复杂度跟增量序列的选择有关；目前最好的平均时间复杂度为O(n^1.3);

当n较大时，比较和移动的次数约在n^1.25 到 (1.6n)^1.25 之间。所以可以这样简单记忆

- 当n较小时，希尔排序和插入排序相差不大，都为n^2左右
- 当n很大时，时间增长幅度逐渐放缓，平均复杂度大致是nlogn。



### 不稳定

因为当间隔不为1的时候，移动的时候并不和相邻的元素进行比较。比如相同的元素a和b，后面的元素b可能因为和a前面的元素进行交换，而交换到a的前面。（跟选择排序一样，稳不稳定的关键在于是不是跟相邻的比较）。 比如[5, 2-a, 4, 2-b, 3, 2-c]，当间隔为3时进行交换后变成[2-b, 2-a, 2-c, 5, 3, 4]

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-04-19-38-image-20230804193852540.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-04-19-38-image-20230804193852540.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-04-19-38-image-20230804193852540.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-04-19-38-image-20230804193852540.png" loading="lazy"/>
  </picture>







### 优化

希尔排序的优化主要是针对增量序列的优化。增量序列如果取得不好，效率比直接插入排序还要低。有些大佬们就整出了下面这些增量序列：**Hibbard增量序列**、**Knuth增量序列**、**Sedgewick增量序列**等等：

Hibbard$$增量序列的取法为 
$$
D_k = 2^k -1
$$
：{1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191...}
最坏时间复杂度为𝑂(𝑁3/2)；平均时间复杂度约为𝑂(𝑁5/4)





## 归并排序

### 一句话总结

归并排序的思想本质就是进行分冶.把 **「`整个`序列拆分成`多个`序列」**,先将每个序列排好序,这个就是**「分冶思想中`分`」**,同样也是**「归并排序中`归`」** 的思想。之后再将各个序列整合到一起这就是**「分冶中的`冶`同样也是归并排序的`并`」**.

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-05-11-19-image-20230805111950879.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-05-11-19-image-20230805111950879.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-05-11-19-image-20230805111950879.png" alt="image-20230805111950879" style="zoom:150%;" loading="lazy"/>
  </picture>



### 稳定的

因为都是相邻的元素为一组





### 代码思路

#### 迭代-自底向上

这里的自底向上还是自顶向下指的是 分（归）的时候是自顶向下还是自底向上，合（并）的时候都是自底向上。

这里就是一开始就是两个两个一组一直向上直到所有元素为一组。

```ts
function mergeSort(arr: Array<number>): number[] {//时间复杂度：0(nlogn)  空间复杂度：O(n) 
  const len = arr.length;
  let sortingNum = 1; // 正在排序的数字数量，比如为2时就说明要合并两个长度为一的数组，这里初始赋值为一是为了配合下面的循环。
  while (sortingNum <= len) {
    sortingNum *= 2; // logN
    for (let i = 0; i < len; i += sortingNum) {//i表示每个分组的第一个元素的位置。    logN 
      const mid = i + (sortingNum >> 1)
   		if (arr[mid - 1] < arr[mid]) continue; //如果左边数组的最后一个元素小于右边数组的第一个元素说明这两个数组就是有序的，不用合并了
      merge(i, mid, Math.min(i + sortingNum, len));
    }
  }
  return arr;

  function merge(left: number, mid: number, right: number) {
    // 左闭右开
    const res = []; // 空间复杂度 n
    let i = left,
      j = mid,
      resIndex = 0;
    while (i < mid && j < right) { // 时间复杂度 n
      if (arr[i] <= arr[j]) {
        res[resIndex++] = arr[i++];
      } else {
        res[resIndex++] = arr[j++];
      }
    }
    while (i < mid) {
      res[resIndex++] = arr[i++];
    }
    while (j < right) {
      res[resIndex++] = arr[j++];
    }
    for (let k = left, resIndex = 0; k < right; k++, resIndex++) {
      arr[k] = res[resIndex];
    }
  }
}
```







#### 递归-自顶向下

自顶向下：比如长度为8的数组，先把数组分成每份四个，再成每份2个，再成每份1个。因为是递归，一直往下分之后从每份一个开始合并。

> 归并思想其实就是二叉树的后序遍历
>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4Lv8OE.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4Lv8OE.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4Lv8OE.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-4Lv8OE.gif" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-L7xBWs.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-L7xBWs.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-L7xBWs.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-L7xBWs.png" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Sregnv.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Sregnv.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Sregnv.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Sregnv.png" loading="lazy"/>
  </picture>

##### 归并的过程

```js
let arr = [15, 1, 3,5, 5, 5, 4, 8, 0]
sortArr(arr)
function sortArr(arr) {
    function mergeSort(left,right) {
        if (left >= right) return [left,right]
        let mid = (left + right) >> 1
        let [left1, right1] = mergeSort(left, mid)
        console.log('左',left1,right1)
        let [left2,right2] = mergeSort(mid + 1, right)
        console.log('右',left2,right2)
        return merge(left,mid,right)
    }
    function merge(left, mid, right) {
        return [left,right]
    }
    mergeSort(0,arr.length-1)
}

//打印出：
左 0 0
右 1 1
左 0 1
右 2 2
左 0 2
左 3 3
右 4 4
右 3 4
左 0 4
左 5 5
右 6 6
左 5 6
左 7 7
右 8 8
右 7 8
右 5 8
```

##### 代码实现

```javascript
function sortArr(arr) { //时间复杂度：0(nlogn)  空间复杂度：O(n + logn) ---O(logn)是递归产生的栈空间
    function mergeSort(left, right) { 
        if (left >= right) return //时间复杂度：0(logn);
        let mid = (left + right) >> 1
      	if (arr[mid - 1] < arr[mid]) return  arr
        mergeSort(left, mid) 
        mergeSort(mid + 1, right)
        if (arr[mid] < arr[mid + 1]) return arr // 如果两个数组对比本来就是有序的就不用再重新合并了
        return merge(left,mid,right)
    }
    function merge(left,mid,right) { //左闭右闭      
        let temp = arr.slice() // 空间复杂度：O(n)
        let l = left, r = mid + 1
        let tempIndex = left
        for (; l <= mid && r <= right;tempIndex++) { //时间复杂度：0(n)
            if (arr[l] < arr[r]) {
                temp[tempIndex]=arr[l++]
            } else {
                temp[tempIndex]=arr[r++]
            }
        }
        while (l <= mid) {
            temp[tempIndex++]=arr[l++]
        }
        while (r <= right) {
            temp[tempIndex++]=arr[r++]
        }
        for (let i = left; i <= right; i++){
            arr[i]=temp[i]
        }
    }
    mergeSort(0, arr.length - 1)
    return arr
}
```





### 优化

#### 小规模数组使用插入排序

**用不同的方法处理小规模问题能改进大多数递归算法的性能**，**因为插入排序非常简单**， 因此一般来说**在小数组上比归并排序更快**。 这种优化能使归并排序的运行时间缩短10%到15%；

 

**怎么切换呢?** 只要把作为停止递归条件的

```
  if(low>=high) { return; }
```

 

改成

```
    if(low + M>=high) { // 数组长度小于10的时候
      InsertSort.sort(int a [], int low,int high) // 切换到插入排序
      return;
    }
```



#### 去除原数组序列到辅助数组的拷贝

优化方案出处：https://www.cnblogs.com/penghuwan/p/7940440.html#_label5_0

在上面介绍的基于递归的归并排序的代码中， 我们在每次调用merge方法时候，我们都把a对应的序列拷贝到辅助数组aux中来，即

```
    for(int k=low;k<=high;k++){
      aux[k] = a[k]; // 将待排序序列a[low...high]拷贝到辅助数组的相同位置
    }
```

 

为了去除原数组序列到辅助数组的拷贝，我们**要在递归调用的每个层次交换输入数组和输出数组的角色，从而不断地把输入数组排序到辅助数组，再将数据从辅助数组排序到输入数组。**

```
  public static void sort(int a []){
    aux = a.clone(); // 拷贝一个和a所有元素相同的辅助数组
    sort(a,aux,0,a.length-1);
  }
  /**
   * @description: 基于递归的归并排序算法
   */
  private static void sort (int a[], int aux[], int low,int high) {
    if(low>=high) { return; } // 终止递归的条件
    int mid =  low + (high - low)/2;  // 取得序列中间的元素
    sort(aux, a,low,mid);  // 对左半边递归
    sort(aux, a,mid+1,high);  // 对右半边递归
    merge(a, aux, low,mid,high);  // 单趟合并
  }
```

在这里我们做了两个操作：

- **在排序前拷贝一个和原数组元素完全一样的辅助数组（不再是创建一个空数组了！）**
- **在递归调用的每个层次交换输入数组和输出数组的角色**





## 快速排序

### 一句话总结

> 快速排序是对[冒泡排序](http://data.biancheng.net/view/70.html)的一种改进（冒泡是相邻交换把它换到正确的位置上，快速排序是跳着换且每次把基准元素换到正确的位置）
>
> **快速排序的过程是一个构造二叉搜索树的过程，每一轮partition能保证这个位置放的元素是对的**。
>
> 这是典型的分治思想（分治思想其实就是二叉树的前序遍历）：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据比另一部分的所有数据要小，再按这种方法对这两部分数据分别进行快速排序。

### 代码思路

每次排序一开始都**「选定一个`基准值`」**，选定完这个基准值之后,我们另外还需要两个**指针**，「这两个指针分别指向待排序序列的`队头元素`和`队尾元素`」。首先「从`队尾`元素开始`从右往左`查找出`第一个不大于`该基准值的元素」,再「从`队头`元素开始`从左往右`查找`第一个不小于`基准值的元素」,之后交换两个元素,重复上面这个步骤,**「直到队头指针与队尾指针交叉越过,越过之后就代表我们的第一次排序就已经完成了」**,**「基准值`左边`的元素全部`小于等于`该基准值,基准值`右边`的元素全部`大于等于`该基准值.」**。之后的排序就只需要对基准值左右两边的序列再进行上述的操作即可。每次需要保存排序前的左右边界（递归就可以天然做到这点），因为下一次就是从这个基准值的左边到这个基准值和基准值到基准值的右边，两个数组分别操作。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lTj5AS.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lTj5AS.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lTj5AS.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lTj5AS.gif" loading="lazy"/>
  </picture>



#### 递归

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var sortArray = function(nums) {//时间复杂度：O(nlogn) 空间复杂度：O(logn) --- 递归栈。
    //左闭右闭
    function quickSort(head,tail){ // 时间复杂度：O(logn)   空间复杂度： O(logn)
        if(head>=tail) return
        putBaseToTail(head,tail)
        const pIndex = partition(head,tail) 
        quickSort(head,pIndex-1)
        quickSort(pIndex+1,tail)
    }

    function partition(head: number, tail: number) {
      // 时间复杂度：O(n)  基准值最后排好的位置就是left最后的位置
      let left = head,
        right = tail - 1;
      while (left <= right) {
        while (arr[left] <= arr[tail] && left <= right) {
          left++;
        }
        while (arr[right] >= arr[tail] && left <= right) {
          right--;
        }
        if (left < right) {
          [arr[left], arr[right]] = [arr[right], arr[left]];
          left++;
          right--;
        }
      }
      if (left < tail) [arr[left], arr[tail]] = [arr[tail], arr[left]]; // 因为tail的位置是在基准值的右边，所以最后换去tail的也应该是一个大于基准值的值。left最后指向的值一定大于基准值或者是基准值本身，right最后指向的值一定是小于基准值或者是-1
      return left;
    }

    function putBaseToTail(head,tail){
        const mid = (head+tail)>>>1
        if(nums[head]>nums[mid]) [nums[mid],nums[head]]=[nums[head],nums[mid]]
        if(nums[tail]>nums[mid]) [nums[mid],nums[tail]]=[nums[tail],nums[mid]] //把最大的放mid那
        if(nums[head]>nums[tail]) [nums[tail],nums[head]]=[nums[head],nums[tail]]
    }
    quickSort(0,nums.length-1)
    return nums
};
```



#### 迭代

就是用迭代实现递归前序遍历

```ts
function quickSortIteration(arr: Array<number>) {
  const stack = [];
  stack.push(0); // 左
  stack.push(arr.length - 1); //右
  while (stack.length) {
    const right = stack.pop();
    const left = stack.pop();
    if (left >= right) continue;
    const p = partition(left, right);
    if (p > left) {
      stack.push(left);
      stack.push(p - 1);
    }
    if (p < right) {
      stack.push(p + 1);
      stack.push(right);
    }
  }
  return arr;

  function partition(left, right) {
    let l = left,
      r = right - 1,
      base = right;
    while (l <= r) {
      while (l <= r && arr[l] <= arr[base]) {
        l++;
      }
      while (l <= r && arr[r] >= arr[base]) {
        r--;
      }
      if (l <= r && arr[l] > arr[r]) {
        [arr[l], arr[r]] = [arr[r], arr[l]];
        l++;
        r--;
      }
    }
    [arr[l], arr[base]] = [arr[base], arr[l]];
    return l;
  }
}
```









### 不稳定

跳着换当然不稳定



### 复杂度

如果数组本身是有序的（全是重复元素也一样）则时间复杂度是O(n*n),空间复杂度是O(n)。举个例子【6，5，4，3，2，1，0】用迭代算法去看吧，直接变成冒泡排序了，<font color="red">内层</font>第一轮遍历7个元素，第二轮遍历6个元素，第三轮遍历5个元素……成一条单链了。而正常情况下是<font color="red">内层</font>第一轮遍历7个，第二轮遍3个，是二叉树的形式。

随机挑选基准值就是为了避免数组本身有序这种情况。当然还是有概率导致这种最坏情况的。









### 优化

1. 每次取三个数，将中位数当基准值。
2. 排序前将其彻底打乱非常无序（这样能避免数组本身就有序的情况）。
3. 跟归并排序一样，当数组长度小于（5～15）时插入排序会更快



## 堆排序

### 算法步骤

堆排序的算法步骤三步.

- 1.**「将数组重构成大根堆」**--- 构造二叉堆的过程就是将原数组元素一个一个尾插入后上浮的过程，只不过是只操作原数组，只操作原数组的话就应该从前往后将原数组的元素一个个取出来插，前面是堆了进行上浮才有意义（前面的元素都不是堆你搁这尾插入后再上浮有啥意义）。当然也可以通过下沉去建堆，可以看示例代码。
- 2.**「将数组的`队头`元素与`队尾`元素交换位置」**
- 3.**「在去除了队尾元素的数组中将队头下沉操作,再次重构成大根堆」**
- 重复2，3



**每轮排序都可以确定`一个`元素的`最终`位置** （因为上浮或者下沉的操作只能确定头部是最大或者是最小的，所以每轮上浮或者下沉只能确定出一个元素，然后提取出这个元素后还要再上浮或下沉一次，以此反复。）

二叉堆在逻辑上其实是一种完全二叉树，只不过是存储在数组里。

- 如果子节点的数组下标是i，那么其父节点就是（i-1）/2

- 如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2

  上浮某个节点 A，只需要 A 和其父节点比较大小即可；下沉某个节点 A，需要 A 和其**两个子节点**比较大小，如果 A 不是最大的就需要调整位置，要把较大的那个子节点和 A 交换。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kXYGnd.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kXYGnd.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kXYGnd.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kXYGnd.gif" loading="lazy"/>
  </picture>

### 代码

```javascript
var sortArray = function(nums) { //时间复杂度：(n/2-1)*log(n) + n*log(n) = n*log(n)  空间复杂度：O(1)
    //原地排序的情况下，大顶堆排出来的是升序的，小顶堆排出来的是降序的
    const heapSort=function(isBig){ 
        createHeap(isBig) // 时间复杂度：(n/2-1)*log(n) --- (n/2-1)是最后一个非叶节点
        for(let i=nums.length-1;i>0;i--){ //时间复杂度： n*log(n)
            [nums[0],nums[i]]=[nums[i],nums[0]] // 如果是大顶堆则第一个值就是这一次最大的值
            if(isBig){
                sinkMax(0,i) //每次都是整个堆重新调整，所以传入0
            }else{
                sinkMin(0,i)//忽略最后面的那个元素，将剩余的元素调整为小顶堆。如此循环就能每次都把最小的放到这些剩余元素的最后面。
            }
        }
    }

    function createHeap(isBig){
        const lastRoot=(arr.length>>1)-1 //最后一个非叶子节点
        for(let i=lastRoot;i>=0;i--){ //从下往上建堆
            if(isBig){
                sinkMax(i,arr.length)
            }else{
                sinkMin(i,arr.length)
            }
        }
    }
  
  	
    function sinkMin(targetRoot,len){ // 参数是 表示从哪里开始调整的头 和 表示调整的终点 的长度
        for(let sonIndex = targetRoot*2+1;sonIndex<len;sonIndex=sonIndex*2+1){// targetRoot*2+1就是targetRoot的左子节点
            if(sonIndex+1<len&&arr[sonIndex]>arr[sonIndex+1]) sonIndex++ ////先挑出左右子节点里较小的那个
            if(arr[sonIndex]<arr[targetRoot]){
                [arr[targetRoot], arr[sonIndex]] = [arr[sonIndex], arr[targetRoot]]
                targetRoot=sonIndex //往下调整
            }else{
                break //既然没有进行交换那么再往下的堆就都不用变咯,所以可以退出循环了
            }
        }
    }

  	
    function sinkMax(targetRoot,len){
        for(let sonIndex=targetRoot*2+1;sonIndex<len;sonIndex=sonIndex*2+1){// targetRoot*2+1就是targetRoot的左子节点
            if(sonIndex+1<len&&arr[sonIndex]<arr[sonIndex+1]) sonIndex++ //先挑出左右子节点里较大的那个
            if(arr[sonIndex]>arr[targetRoot]){
                [arr[targetRoot], arr[sonIndex]] = [arr[sonIndex], arr[targetRoot]]
                targetRoot=sonIndex //往下调整
            }else{
                break
            }
        }
    }

    heapSort(true)
    return nums
};
```





### 复杂度

- 时间复杂度

  堆排序的本质思想也是利用了二叉树的特性,堆排序的时间复杂度为`O(N*logn)`,不仅仅是平情况是这样最好与最坏的情况都是如此.

- 空间复杂度

  `O(1)`.



## 计数排序

### 特点

用于元素间最大值和最小值差值不大，且都是整数的数组进行排序。 不基于比较。



### 稳定

相同元素的相对位置不会发生调换。



### 复杂度

时间复杂度O(n+k)，空间复杂度O(k)。k为辅助数组。



### 代码思路

建立一个容量为【A数组中最大值+1】（就是默认最小值为0）的数组B，且B的所有值均为0，按照【B数组的下标对应A数组的元素值】进行统计，例如A数组中出现了两次5，则B数组中的下标5的元素值应为2。最后根据数组B输出最后排好序的结果（B元素的值是多少就输出对应的下标多少次）。



改进--按照这个写代码，上面那个帮助入门理解：

辅助数组的容量：建立一个容量为【最大值与最小值的差值+1】的数组B，

统计时：A数组中元素值与最小值的差值对应数组B的下标；

输出结果时：输出B数组中的下标加上最小值后的值，输出该下标对应的元素值次。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-gWYFnD.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-gWYFnD.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-gWYFnD.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-gWYFnD.gif" loading="lazy"/>
  </picture>



```ts
function countingSort(arr: Array<number>) { //时间复杂度O(n+k)，空间复杂度O(k)
  const len = arr.length;
  let min = arr[0],
    max = arr[0];
  for (let i = 1; i < len; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  const tempLen = max - min + 1;
  const timesArr = new Array(tempLen).fill(0);
  for (let i = 0; i < len; i++) {
    timesArr[arr[i] - min]++;
  }
  for (let i = 0, arrIndex = 0; i < tempLen; i++) {
    let times = timesArr[i];
    while (times--) {
      arr[arrIndex++] = min + i;
    }
  }
  return arr;
}
```







## 桶排序

### 代码思路

`(MAX-MIN+1)/桶的数量`,得到的结果就是桶的长度，这样可以让元素平均的分散到每一个桶里。往桶里面添加元素的时候,就需要在每个桶里面将元素排好序。最后遍历桶即可。

**「如果`桶的数量`设置的`合理`,既能降低时间复杂度,也能降低空间复杂度.」**



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-IX40gk.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-IX40gk.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-IX40gk.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-IX40gk.gif" loading="lazy"/>
  </picture>



### 稳定

取决于每个桶里面的排序算法吧。





### 复杂度

- 时间复杂度

  `O(n+k)`。最坏情况下就变成了所有元素都装到了一个桶里面，那就跟桶里面的时间复杂度一样了。

- 空间复杂度

  假设有k个桶，且由于所有的桶其实就是装满了原数组的所有元素，所以空间复杂度就为`O(n+k)`（辅助数组是个二维数组）







## 基数排序

### 代码思路

可以理解成多关键字排序，一个一个关键字的排。原理就是逐位排序，遍历的次数取决于最大元素的位数。排序数字只能用低位优先，高位优先排出来是无序的。也需要类似桶排序那样的二维数组（但这里的桶里面不需要进行排序）。

- 第一次遍历：出序列中的最大值MAX,找到MAX之后我们可以确定我们需要比较多少数位了.
- 第二次遍历：按照元素该位数上对应的数字将元素存入到相应的容器之中。（先新建一个0-9的数组容器）
- 第三次遍历：按照容器的顺序将元素重新弹出构成我们接下来需要排序的序列，注意弹出的时候是先进先出，即桶是一个队列。
- `重复2,3步骤`,直到最高位也比较完毕

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-J2toeO.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-J2toeO.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-J2toeO.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-J2toeO.gif" loading="lazy"/>
  </picture>









### 使用场景

多关键字排序的时候，不同的关键字当成是一个数位即可。比如扑克牌排序需要根据花色和数值两个关键字，可以选择先根据花色排序或者先根据数值进行排序





### 稳定

桶里面是按先进先出顺序弹出。





### 复杂度

- 最大元素的位数K（即关键字个数=k）,时间复杂度应该是`O((n+m)*k)`，m为桶的个数，n为元素个数，因为放进桶的时候遍历n，从桶里拿出来的时候遍历m。最好情况是O(n+m)，即关键字只有一个的时候，比如都是个位数。
- 空间复杂度为`O(n+k)`，跟桶排序类似：有k（如果是排数字k就是10）个桶，且所有的桶其实就是装满了原数组的所有元素



## 题目

### [14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)

```javascript
var longestCommonPrefix = function(strs) {
    const len = strs.length
    if(!len) return ''
    if(len==1) return strs[0]
    strs.sort((a,b)=>a.length-b.length)
    const shortest = strs[0]
    const shortestLength=shortest.length
    const result = shortest
    for(let i = 0;i<shortestLength;i++){ //按列来
        for(let j=1;j<len;j++){
            if(strs[j][i]!==result[i]) {
                return result.slice(0,i)
            }
        }
    }
    return result
};
```





# 一些算法思想

## 分治

分治通常基于递归实现，包括“分”和“治”两个步骤。

1. **分（划分阶段）**：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。

2. **治（合并阶段）**：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。

   <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-08-21-08-image-20240108210803028.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-08-21-08-image-20240108210803028.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-08-21-08-image-20240108210803028.png" alt="image-20240108210803028" style="zoom:33%;" loading="lazy"/>
  </picture>





一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。

1. **问题可以分解**：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。
2. **子问题是独立的**：子问题之间没有重叠，互不依赖，可以独立解决。
3. **子问题的解可以合并**：原问题的解通过合并子问题的解得来。



分治在算法和数据结构的设计中应用得非常广泛。

- **二分查找**：二分查找是将有序数组从中点索引处分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，并在剩余区间执行相同的二分操作。
- **归并排序**：本节开头已介绍，不再赘述。
- **快速排序**：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，再对这两部分进行相同的划分操作，直至子数组只剩下一个元素。
- **桶排序**：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组。
- **树**：例如二叉搜索树、AVL 树、红黑树、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治策略的应用。
- **堆**：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。
- **哈希表**：虽然哈希表并不直接应用分治，但某些哈希冲突解决方案间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。

可以看出，**分治是一种“润物细无声”的算法思想**，隐含在各种算法与数据结构之中。





# 面试题

### 对象转换（字节跳动）

```js
/**题目：
*将 obj = {
    x: 1,
    y: {
        a: 2,
        b: {
            c: 3,
            d: 4
        }
    }
}
转换成 
{x: 1, y.a: 2, y.b.c: 3, y.b.d: 4}
*/
const result = {}
function getKeys(obj, char) {
    const ownKeys = Object.getOwnPropertyNames(obj)
    for (const key of ownKeys) {
        const newKey = char===''?key:char+'.'+key
        if (Object.prototype.toString.call(obj[key]) === '[object Object]') { 
            getKeys(obj[key],newKey)
        } else {
            result[newKey]=obj[key] //递归到最里面后塞到结果里
        }
    }
}

//调试
var obj = {
    x: 1,
    y: {
        a: 2,
        b: {
            c: 3,
            d: 4
        }
    }
}
getKeys(obj,'')
console.log(result)
```

### 命名方式中划线改小驼峰

方案一：

```js
function transName(arr) {
    let res = arr.map(e => {
        let items = e.split('-').map((item, index) => {
            if (index) {
                let first = item.substring(0,1)
                let rest = item.substring(1)
                return first.toUpperCase()+rest
            }else{
                return item.toLowerCase()
            }
        })
        return items.join('')
    })
    return res
}
console.log(transName(['A-b-cee', 'ca-de-ea', 'e-fe-eaa','f-g','mn']))
```

方案二：

```js
function turnName(str){
    return str.replace(/-[a-zA-Z]/g,match=>match.replace('-','').toUpperCase())
}
```

### 命名方式小驼峰改中划线

```js
let s1 = 'aBBcdE';

let t = s1.replace( /[A-Z]/g, match=>'-'+match.toLowerCase());
console.log(t);
```

