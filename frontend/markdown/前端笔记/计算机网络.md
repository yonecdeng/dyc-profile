# 大纲

## 整条链路

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-04-22-19-image-20231204221915732.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-04-22-19-image-20231204221915732.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-04-22-19-image-20231204221915732.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-04-22-19-image-20231204221915732.png" loading="lazy"/>
  </picture>



## 网络基础

网络主要组成：主机、路由器（负责联通）、网络协议（负责规定如何装包拆包）。

网络的结构：类似于道路的拓扑结构。广域网、局域网、城域网、区域网

信息交换方式：利用分组交换，大报文拆成小报文一起传等齐人了就合并，这样就避免了等一整个传完再传下一个（电路交换）。

网络分层：每一层只关注自己层的事情。每一层都有自己关注的标头，上一层的标头也算是这一层的载荷（因为我根本不关心呀，快递员只关心快递从哪发到哪就行了，具体是啥无所谓呀，哪怕需要知道里面是啥，那你标头里写明是啥就好了）。报文 = 链路层头+IP协议头+TCP协议头+HTTP协议头+HTTP正文

网络协议：负责规定如何装包拆包，区分标头与载荷。比如TCP 报文通过固定的data offset（位于第96bit - 100bit）来区分标头和载荷，HTTP通过把报文中的二进制转为ASCII码后发现连续的换行符和回车符来确定标头与载荷。





## 端到端通信和点对点

点对点：机器到另一台机器。物理层、数据链路层、网络层。

端到端：应用程序之间的通信，“端”表示端口号。传输层。





## 性能指标

### 带宽

带宽用来表示网络的通信线路传送数据的能力，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。带宽的单位是“比特每秒”，记为b/s。

带宽跟各层都有关。同时发起多个请求，如果一个请求很大 会影响另一个请求的响应时间。





# HTTP

## HTTP请求方法

### 常见方法

<font color="red">大写</font>

GET: 通常用来获取资源

HEAD: 获取资源的元信息

POST: 提交数据，即上传数据

PUT: 修改数据

DELETE: 删除资源(几乎用不到)

CONNECT: 建立连接隧道，用于代理服务器

TRACE: 追踪请求-响应的传输路径

OPTIONS: 获取服务器支持的所有HTTP请求方法；用来跨域请求



### Get和Post的区别

1.get请求一般是去取获取数据（其实也可以提交，但常见的是获取数据）；post请求一般是去提交数据。

2.get因为参数会放在url中，请求的数据长度是有限制的，不同的浏览器和服务器不同，一般限制在 2~8K 之间，更加常见的是 1k 以内；post请求是没有的长度限制，请求数据是放在body中；get请求只能进行url编码（appliacation-x-www-form-urlencoded）,post请求支持多种（multipart/form-data等）。

3.get请求刷新服务器或者回退没有影响，post请求回退时会重新提交数据请求。（没看懂）

4.get请求可以被缓存，post请求不会被缓存。

5.get请求会被保存在浏览器历史记录当中，post不会。get请求可以被收藏为书签，因为参数就是url中，但post不能，它的参数不在url中。



深入理解
1…GET 和 POST都是http请求方式， 底层都是 TCP/IP协议；通常GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包（但firefox是发送一个数据包）

2.对于 GET 方式的请求，没有请求体和响应体，浏览器会把 http header 发送出去，服务器响应 200
（返回数据）表示成功；而对于 POST，浏览器先发送 header，服务器响应 100， 浏览器再继续发送 请求体，服
务器响应 200 （返回数据）。





### HTTP 方法的幂等性特点

1. **GET：** GET 方法是幂等的，因为它只是从服务器获取资源，不对服务器上的资源状态做出任何修改。
2. **HEAD：** HEAD 方法与 GET 方法类似，也是幂等的，但它不返回实际的响应体，只返回响应头。
3. **PUT：** PUT 方法是幂等的，因为它用于更新或创建资源。如果资源已经存在，它将被更新；如果资源不存在，将会创建一个新的资源。
4. **DELETE：** DELETE 方法是幂等的，因为多次调用删除同一资源的请求不会改变删除的结果。
5. **OPTIONS：** OPTIONS 方法是幂等的，因为它只是询问服务器支持哪些方法，并不会改变资源的状态。
6. **TRACE：** TRACE 方法是幂等的，因为它仅用于诊断，不会改变资源的状态。
7. **POST 和 PATCH：** 这两个方法通常不是幂等的，因为它们用于修改资源的状态，多次调用可能会导致不同的结果。不过，可以通过一些约定来设计具有幂等性的 POST 和 PATCH 请求。





##  HTTP报文

### 请求报⽂

- 请求⾏（起始行）
- 请求头部
- 空⾏
- 请求体

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-HRIB42.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-HRIB42.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-HRIB42.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-HRIB42.webp" loading="lazy"/>
  </picture>



### 响应报文

- 响应⾏
- 响应头
- 空⾏
- 响应体

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-fUVmyE.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-fUVmyE.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-fUVmyE.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-fUVmyE.webp" loading="lazy"/>
  </picture>





### 字段

#### HTTP请求头中各字段

https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers#%E9%AA%8C%E8%AF%81%EF%BC%88authentication%EF%BC%89

**Accept** : 浏览器（或者其他基于HTTP的客户端程序）可以接收的内容类型（Content-types）,例如 Accept: text/plain

**Accept-Charset**：浏览器能识别的字符集，例如 Accept-Charset: utf-8

**Accept-Encoding**：浏览器可以处理的编码方式，注意这里的编码方式有别于字符集，这里的编码方式通常指gzip,deflate等。例如 Accept-Encoding: gzip, deflate
**Accept-Language**：浏览器接收的语言，其实也就是用户在什么语言地区，例如简体中文的就是 Accept-Language: zh-CN

**Accept-Datetime**：设置接受的版本时间，例如Accept-[Datetime](https://so.csdn.net/so/search?q=Datetime&spm=1001.2101.3001.7020): Thu, 31 May 2007 20:35:00 GMT
**Authorization**：在HTTP中，服务器可以对一些资源进行认证保护，如果你要访问这些资源，就要提供用户名和密码，这个用户名和密码就是在Authorization头中附带的，格式是“username:password”字符串的base64编码，例如：Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ中，basic指使用basic认证方式，　QWxhZGRpbjpvcGVuIHNlc2FtZQ使用base64解码就是Aladdin:open sesame

**Cache-Control**：这个指令在request和response中都有，用来指示缓存系统（服务器上的，或者浏览器上的）应该怎样处理缓存，因为这个头域比较重要，特别是希望使用缓存改善性能的时候，内容也较多，设置请求响应链上所有的缓存机制必须遵守的指令，eg：Cache-Control: no-cache

**Connection**：告诉服务器这个user agent（通常就是浏览器）想要使用怎样的连接方式。值有keep-alive和close。http1.1默认是keep-alive。keep-alive就是浏览器和服务器　的通信连接会被持续保存，不会马上关闭，而close就会在response后马上关闭。但这里要注意一点，我们说HTTP是无状态的，跟这个是否keep-alive没有关系，不要认为keep-alive是对HTTP无状态的特性的改进。
设置当前连接和hop-by-hop协议请求字段列表的控制选项

Connection: keep-alive
Connection: Upgrade

**Cookie**：浏览器向服务器发送请求时发送cookie，或者服务器向浏览器附加cookie，就是将cookie附近在这里的。例如：Cookie:user=admin
设置服务器使用Set-Cookie发送的http cookie
Cookie: $Version=1; Skin=new;

**Content-Length：**一个请求的请求体的内存长度，单位为字节(byte)。请求体是指在HTTP头结束后，两个CR-LF字符组之后的内容，常见的有POST提交的表单数据，这个Content-Length并不包含请求行和HTTP头的数据长度。
设置请求体的字节长度
Content-Length: 348

**Content-MD5**：使用base64进行了编码的请求体的MD5校验和。例如：Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==
基于MD5算法对请求体内容进行Base64二进制编码

**Content-Type**：请求体中的内容的mime类型。通常只会用在POST和PUT方法的请求中。设置请求体的MIME类型（适用POST和PUT请求）。Content-Type的值中还可以包含一些参数，如字符集。示例如下：`Content-Type: text/javascript; charset=utf-8`

**Content-Encoding**：gzip

**Content-Disposition**：客户端会根据它的值判断是应该将报文数据当做即时浏览的内容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名。示例如下：`Content-Disposition: attachent; filename="filename.ext"`

**Date：**发送请求时的GMT时间。例如：Date: Tue, 15 Nov 1994 08:12:31 GMT
设置消息发送的日期和时间

Expect：标识客户端需要的特殊浏览器行为
Expect: 100-continue

**From**：发送这个请求的用户的email地址。例如：From: [user@example.com](mailto:user@example.com)
设置发送请求的用户的email地址

**Host**：被服务器的域名或IP地址，如果不是通用端口，还包含该端口号，例如：Host: [www.some.com:182](http://www.some.com:182/)
设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略
Host: [en.wikipedia.org:8080](http://en.wikipedia.org:8080/)
Host: [en.wikipedia.org](http://en.wikipedia.org/)

**If-Match** :通常用在使用PUT方法对服务器资源进行更新的请求中，意思就是，询问服务器，现在正在请求的资源的tag和这个If-Match的tag相不相同，如果相同，则证明服务器上的这个资源还是旧的，现在可以被更新，如果不相同，则证明该资源被更新过，现在就不用再更新了（否则有可能覆盖掉其他人所做的更改）。
设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源

**If-Modified-Since**：询问服务器现在正在请求的资源在某个时间以来有没有被修改过，如果没有，服务器则返回304状态来告诉浏览器使用浏览器自己本地的缓存，如果有修改过，则返回200，并发送新的资源（当然如果资源不存在，则返回404。）
设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified

**If-None-Match**：和If-Modified-Since用意差不多，不过不是根据时间来确定，而是根据一个叫ETag的东西来确定。关于etag我想在下一篇博客介绍一下。
设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified

**If-Range**：告诉服务器如果这个资源没有更改过(根据If-Range后面给出的Etag判断)，就发送这个资源中在浏览器缺少了的某些部分给浏览器，如果该资源以及被修改过，则将整个资源重新发送一份给浏览器。

**If-Unmodified-Since**：询问服务器现在正在请求的资源在某个时刻以来是否没有被修改过。

**Max-Forwards**：限制请求信息在代理服务器或网关中向前传递的次数。
Pragma：好像只有一个值，就是:no-cache。Pragma:no-cache 与cache-control:no-cache相同，只不过cache-control:no-cache是http1.1专门指定的，而Pragma:no-cache可以在http1.0和1.1中使用

**Proxy-Authorization**：连接到某个代理时使用的身份认证信息，跟Authorization头差不多。例如：Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
为连接代理授权认证信息

**Range**：在HTTP头中，”Range”字眼都表示“资源的byte形式数据的顺序排列，并且取其某一段数据”的意思。Range头就是表示请求资源的从某个数值到某个数值间的数据，例如：Range: bytes=500-999 就是表示请求资源从500到999byte的数据。数据的分段下载和多线程下载就是利用这个实现的。

**Referer**：指当前请求的URL是在什么地址引用的。[例如在www.a.com/index.html页面中点击一个指向www.b.com的超链接，那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。](http://xn--www-uc0e316agqd.a.com/index.html页面中点击一个指向www.b.com的超链接，那么，这个www.b.com的请求中的Referer就是www.a.com/index.html。通常我们见到的图片防盗链就是用这个实现的。)

**Upgrade**：请求服务器更新至另外一个协议，例如：Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

**User-Agent**：通常就是用户的浏览器相关信息。例如：User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/12.0

**Via**：用来记录一个请求经过了哪些代理或网关才被送到目标服务器上。例如一个请求从浏览器出发(假设使用http/1.0)，发送给名为 SomeProxy的内部代理，然后被转发至www.somenet.com的公共代理（使用http/1.1），[最后被转发至目标服务器www.someweb.com](http://xn--www-4w2e97cpkq4l415boda96i829dgw1a2isvtv.someweb.com/)，那么在someweb.com中收到的via 头应该是：via:1.0 someProxy 1.1 [www.someweb.com](http://www.someweb.com/)(apache 1.1)

**Warning**：记录一些警告信息。
通用但非标准的HTTP头（通常，非标准的头域都是用“X-”开头，例如”x-powered-by”）：

**X-Requested-With**：主要是用来识别ajax请求，很多javascript框架会发送这个头域（值为XMLHttpRequest）

**DNT** : DO NOT TRACK的缩写，要求服务器程序不要跟踪记录用户信息。DNT: 1 (开启DNT) DNT: 0 (关闭DNT)火狐，safari,IE9都支持这个头域，并且于2011年3月7日被提交至IETF组织实现标准化

**X-Forwarded-For** : 记录一个请求从客户端出发到目标服务器过程中经历的代理，或者负载平衡设备的IP。

**X-Forwarded-Proto**：记录一个请求一个请求最初从浏览器发出时候，是使用什么协议。因为有可能当一个请求最初和反向代理通信时，是使用https，但反向代理和服务器通信时改变成http协议，这个时候，X-Forwarded-Proto的值应该是https

**Front-End-Https**：微软使用与其负载平衡的一个头域。

**[`Location`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Location)**：指示要将页面重定向到的 URL。



#### Content-type

##### 浏览器自动识别content-type

###### 识别请求

浏览器通常会根据请求的内容自动识别并填充适当的 `Content-Type` 头部，以便服务器正确解析请求。以下是一些浏览器通常会自动填充 `Content-Type` 头部的情况：

1. **Form 表单：** 当提交一个 HTML 表单时，浏览器会自动设置 `Content-Type` 为 `application/x-www-form-urlencoded` 或者 `multipart/form-data`，具体取决于表单的 `enctype` 属性。
2. **URLSearchParams数据：** 当发送**URLSearchParams**数据时，浏览器会自动设置 `Content-Type` 为 `application/x-www-form-urlencoded`。
3. **XML 数据：** 如果你发送 XML 数据，浏览器会自动设置 `Content-Type` 为 `application/xml`。
4. **纯文本数据：** 当发送纯文本数据时，浏览器通常会自动设置 `Content-Type` 为 `text/plain`。
5. **其它类型：** 浏览器可能还会根据请求的内容类型自动设置相应的 `Content-Type`，如发送图片、音频、视频等。

如果你使用 JavaScript 通过 `XMLHttpRequest` 或 `fetch` 发送请求，你也可以手动设置 `Content-Type` 头部，以确保服务器正确处理请求。不过，在大多数情况下，浏览器会根据请求的内容自动填充适当的 `Content-Type`，无需手动设置。



###### 识别响应

浏览器会根据响应的 `Content-Type` 头部来解析响应体（即服务器返回的数据）。

以下是一些常见的 `Content-Type` 类型及其对应的处理方式：

1. **text/html：** 如果服务器返回的 `Content-Type` 是 `text/html`，浏览器会将响应体视为 HTML 文本，并在页面中渲染。
2. **application/json：** 如果服务器返回的 `Content-Type` 是 `application/json`，浏览器会将响应体解析为 JSON 格式的数据，你可以在 JavaScript 中使用 `JSON.parse()` 来将 JSON 数据转换为对象或数组。
3. **application/xml：** 如果服务器返回的 `Content-Type` 是 `application/xml`，浏览器会将响应体解析为 XML 数据，你可以使用浏览器提供的 XML 解析库来处理。
4. **text/plain：** 如果服务器返回的 `Content-Type` 是 `text/plain`，浏览器会将响应体视为纯文本数据，你可以直接获取文本内容。
5. **image/\*：** 如果服务器返回的 `Content-Type` 是以 `image/` 开头的类型（如 `image/jpeg`、`image/png` 等），浏览器会将响应体解析为图片数据，并在页面中显示。
6. **audio/\* 和 video/*：** 类似地，如果服务器返回的 `Content-Type` 是以 `audio/` 或 `video/` 开头的类型，浏览器会将响应体解析为音频或视频数据。









##### MIME 类型

MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。它最早用于电子邮件，后来也应用到浏览器中。

MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。

浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。

###### 语法

MIME 类型通用结构：

```
type/subtype
```

MIME 由类型与子类型两个字符串中间用 **/** 分隔而组成，不允许有空格。type 表示可以被分多个子类的独立类别，subtype 表示细分后的每个类型。

MIME类型对大小写不敏感，但是传统写法都是小写。

两种主要的 MIME 类型在默认类型中扮演了重要的角色：

- **text/plain** 表示文本文件的默认值。
- **application/octet-stream** 表示所有其他情况的默认值。







##### HTTP content-type

Content-Type（告诉服务器内容的类型），决定以什么形式、什么编码读取这个文件

语法格式：

```
Content-Type: text/html; charset=utf-8
Content-Type: multipart/form-data; boundary=something
```



##### 常见的媒体格式类型如下

- text/html ： HTML格式
- text/plain ：纯文本格式
- text/xml ： XML格式
- image/gif ：gif图片格式
- image/jpeg ：jpg图片格式
- image/png：png图片格式

以application开头的媒体格式类型：

- application/xhtml+xml ：XHTML格式
- application/xml： XML数据格式
- application/atom+xml ：Atom XML聚合格式
- application/json： JSON数据格式
- application/pdf：pdf格式
- application/msword ： Word文档格式
- application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ： `<form encType="">`中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

另外一种常见的媒体格式是上传文件之时使用的：

- multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式



#### 大文件传输

##### “**Accept-Encoding**”压缩

通常浏览器在发送请求时都会带着“**Accept-Encoding**”头字段，里面是浏览器支持的压缩格式列表，例如 gzip、deflate、br （br算法专为压缩HTML设计）等，这样服务器就可以从中选择一种压缩算法，放进“**Content-Encoding**”响应头里，再把原数据压缩后发给浏览器。gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，再用 gzip 处理也不会变小（甚至还有可能会增大一点），所以它就失效了。



##### “**Transfer-Encoding: chunked**”分块

###### 定长包体

会有字段“**Content-Length**”表示包体的字节个数



###### 不定长包体

字段“**Transfer-Encoding: chunked**”来表示，意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。分块传输也可以用于“流式数据”，例如由数据库动态生成的表单页面，这种情况下 body 数据的长度是未知的，无法在头字段“**Content-Length**”（表示包体的字节个数）里给出确切的长度，所以也只能用 chunked 方式分块发送。此时“Content-Length”字段不生效。

Transfer-Encoding也可以用gzip、deflate等值，Transfer-Encoding传输后会自动解码还原出原始数据，而Content-Encoding则必须由应用自行解码。

分块的格式是==16 进制==长度头 + 数据块：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708161448527.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708161448527.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708161448527.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708161448527.png" loading="lazy"/>
  </picture>



##### **Range**分段

请求头不能使用该字段

比如你在看当下正热播的某穿越剧，想跳过片头，直接看正片，或者有段剧情很无聊，想拖动进度条快进几分钟，这实际上是想获取一个大文件其中的片段数据，而分块传输并没有这个能力。HTTP 协议为了满足这样的需求，提出了“**范围请求**”（range requests）的概念，允许客户端在请求头里使用专用字段来表示只获取文件的一部分。

范围请求不是 Web 服务器必备的功能，所以服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”。如果不支持的话服务器可以发送“Accept-Ranges: none”，或者干脆不发送“Accept-Ranges”字段。

请求头**Range**是 HTTP 范围请求的专用字段，格式是“**bytes=x-y**”，其中的 x 和 y 是以字节为单位的数据范围。

 x、y 表示的是“偏移量”，范围必须从 0 计数，例如前 10 个字节表示为“0-9”，第二个 10 字节表示为“10-19”，而“0-10”实际上是前 11 个字节。Range 的起点 x 和终点 y 可以省略，能够很方便地表示正数或者倒数的范围。假设文件是 100 个字节，那么：

- “0-”表示从文档起点到文档终点，相当于“0-99”，即整个文件；
- “10-”是从第 10 个字节开始到文档末尾，相当于“10-99”；
- “-1”是文档的最后一个字节，相当于“99-99”；
- “-10”是从文档末尾倒数 10 个字节，相当于“90-99”。

服务器收到 Range 字段后，需要做四件事。

第一，它必须检查范围是否合法，比如文件只有 100 个字节，但请求“200-300”，这就是范围越界了。服务器就会返回状态码**416**，意思是“你的范围请求有误，我无法处理，请再检查一下”。

第二，如果范围正确，服务器就可以根据 Range 头计算偏移量，读取文件的片段了，返回状态码“**206 Partial Content**”，和 200 的意思差不多，但表示 body 只是原数据的一部分。

第三，服务器要添加一个响应头字段**Content-Range**，告诉片段的实际偏移量和资源的总大小，格式是“**bytes x-y/length**”。例如，对于“0-10”的范围请求，值就是“bytes 0-10/100”。

第四，把片段用 TCP 发给客户端，一个范围请求就算是处理完了。



不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：

- 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；
- 开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；
- 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。



##### 多段数据

刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。

这种情况需要使用一种特殊的 MIME 类型：“**multipart/byteranges**”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“**boundary=xxx**”给出段之间的分隔标记。

多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段。每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708162555617.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708162555617.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708162555617.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220708162555617.png" loading="lazy"/>
  </picture>

这四种方法不是互斥的，而是可以混合起来使用，例如压缩后再分块传输，或者分段后再分块



#### 缓存

##### 请求头：

`If-Modified-Since`（在请求头里的，携带Last-Modified值，http 1.0）

`If-None-Match`（在请求头里的，携带Etag值， http 1.1）

`Cache-Control` （http 1.1） 可设置的字段：

- `no-cache`：==每次都要协商缓存==，设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- `no-store`：设置了该字段表示==禁止任何缓存==，每次都会向服务端发起新的请求，拉取最新的资源；
- `max-age=`：设置==客户端的缓存的最大有效期==，单位为秒；
- `min-fresh=`: 表示客户端希望在指定的时间内 ( 比如到期前5秒 ) 获取最新的响应
- `no-transform`: 不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改
- `only-if-cached`:表示客户端只会接受代理缓存，而==不会接受源服务器的响应==。如果代理缓存无效，则直接返回`504（Gateway Timeout）`。

##### 响应头：

`Expires` ： 缺点这个时间是是服务器的时间，客户端的时间和服务器端的时间可能不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。

`Cache-Control`可设置的字段（ HTTP 1.1 中提出，可代替`Expires`，优先级高于`Expires` ）：

- `public`：设置了该字段值的资源表示可以==被任何对象==（包括：发送请求的客户端、代理服务器等等）缓存。
- `private`：设置了该字段值的资源==只能被用户浏览器缓存==，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；
- `no-cache`：==每次都要协商缓存==，设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；
- `no-store`：设置了该字段表示==禁止任何缓存==，每次都会向服务端发起新的请求，拉取最新的资源；比如接口的响应肯定都会设置成这个。
- `max-age=`：设置==客户端的缓存的最大有效期==，单位为秒；进行类似倒计时的方式计算过期时间
- `s-maxage=`：`s`是`share`的意思，限定了缓存在==代理服务器==中可以存放多久
- `max-stale[=]`：设置了该字段表明==客户端愿意接收已经过期的资源，但是不能超过给定的这个时间限制==。
- `stale-while-revalidate=<seconds>`: 表明客户端愿意接受陈旧的响应，同时在==后台异步检查新的响应==。秒值指示客户愿意接受陈旧响应的时间长度。
  `stale-if-error=<seconds>`: 表示==如果新的检查失败==，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。
- `no-transform`: 不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改
- `must-revalidate`：是**客户端**缓存==过期就去源服务器==获取，
- `proxy-revalidate`：**代理服务器**的缓存==过期后到源服务器==获取
- `immutable`: 表示==响应正文是不会随时间而改变的==。所以即使用户显式地刷新页面，客户端也不应发送重新验证请求头（例如If-None-Match或If-Modified-Since）来检查更新，

`Last-Modified` ：（http 1.0 ） 这种方法有两个缺点：

- - Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内被修改多次的话，Last-Modified 的值不会改变。
  - 文件的时间戳改动但内容并不一定改动。

`Etag` ：（http 1.1） 服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符。ETag的全称是Entity Tag，由服务器端生成，服务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳改动造成的带宽浪费。下面是根据内容生成散列值的方法：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-16-19-image-20230820161904161.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-16-19-image-20230820161904161.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-16-19-image-20230820161904161.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-16-19-image-20230820161904161.png" loading="lazy"/>
  </picture>

（缺点是算hash值比较耗时。 使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。）



#### Cookie 

##### 设置cookie

如果要设置cookie成功，必须ajax请求得设置with-credentials:true，同时后端也要设置对应的Access-Control-Allow-Origin和Access-Control-Allow-Credentials头部。

1. ajax请求设置with-credentials:true，后端即使不设置CORS头也可set-cookie成功
2. ajax请求不设置with-credentials或者false，set-cookie响应头会被直接忽略



##### Set-Cookie

格式：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-15-22-image-20230819152211066.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-15-22-image-20230819152211066.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-15-22-image-20230819152211066.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-15-22-image-20230819152211066.png" loading="lazy"/>
  </picture>

1. 在响应头里面可以添加多个 Set-Cookie 字段，一般一个Set-Cookie 字段只设置一个name=value
2. 之后客户端对该服务器每一次请求中都通过 Cookie 字段将 Cookie 信息发送给服务器。

<picture>
    <source type="image/avif" srcset="https://camo.githubusercontent.com/8abbb6e15a6c836042cbfd3230a44408c510a0596e85304f9952c869507f06b3/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423133364e45794b4c32674b306a535a506858586168765858612d313932382d3631362e6a7067?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://camo.githubusercontent.com/8abbb6e15a6c836042cbfd3230a44408c510a0596e85304f9952c869507f06b3/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423133364e45794b4c32674b306a535a506858586168765858612d313932382d3631362e6a7067?imageMogr2/format/webp">
    <img src="https://camo.githubusercontent.com/8abbb6e15a6c836042cbfd3230a44408c510a0596e85304f9952c869507f06b3/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423133364e45794b4c32674b306a535a506858586168765858612d313932382d3631362e6a7067" alt="https://camo.githubusercontent.com/8abbb6e15a6c836042cbfd3230a44408c510a0596e85304f9952c869507f06b3/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423133364e45794b4c32674b306a535a506858586168765858612d313932382d3631362e6a7067" loading="lazy"/>
  </picture>

##### Set-Cookie的字段

###### 基本

1.Name=Value

用 JavaScript 操作 Cookie 的时候注意对 Value 进行编码处理。

###### [生命周期](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#定义_cookie_的生命周期)

1.Expires

Expires 用于设置 Cookie 的过期时间。比如：

```
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
```

当 Expires 属性缺省时，表示是会话性 Cookie，像上图 Expires 的值为 Session，表示的就是会话性 Cookie。当为会话性 Cookie 的时候，值保存在客户端内存中，并在用户关闭浏览器时失效。需要注意的是，有些浏览器提供了会话恢复功能，这种情况下即使关闭了浏览器，会话期 Cookie 也会被保留下来，就好像浏览器从来没有关闭一样。

与会话性 Cookie 相对的是持久性 Cookie，持久性 Cookies 会保存在用户的硬盘中，直至过期或者清除 Cookie。这里值得注意的是，设定的日期和时间只与客户端相关，而不是服务端。



2.Max-Age

Max-Age 用于设置在 Cookie 失效之前需要经过的秒数。比如：

```
Set-Cookie: id=a3fWa; Max-Age=604800;
```

Max-Age 可以为正数、负数、甚至是 0。

如果 max-Age 属性为正数时，浏览器会将其持久化，即写到对应的 Cookie 文件中。

当 max-Age 属性为负数，则表示该 Cookie 只是一个会话性 Cookie。

当 max-Age 为 0 时，则会立即删除这个 Cookie。

假如 Expires 和 Max-Age 都存在，Max-Age 优先级更高。

>  如果您的站点对用户进行身份验证，则每当用户进行身份验证时，它都应重新生成并重新发送会话 Cookie，甚至是已经存在的会话 Cookie。此技术有助于防止[会话固定攻击（session fixation attacks） (en-US)](https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks)。



###### [限制访问 Cookie](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#限制访问_cookie)

1.Secure属性

标记为 Secure 的 Cookie 只应通过被HTTPS协议加密过的请求发送给服务端。使用 HTTPS 安全协议，可以保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改。

2.HTTPOnly

设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。



3.SameSite

- 作用

SameSite 属性可以让 Cookie 在==跨站==请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）

- 属性值

1. **Strict** 仅允许同站请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie。
2. **Lax** 允许部分跨站请求携带 Cookie。
3. **None** 无论是否跨站都会发送 Cookie。

之前默认是 None 的，Chrome80 后默认是 Lax。

<picture>
    <source type="image/avif" srcset="https://camo.githubusercontent.com/feff36574753ce4c04ddfe9769e623ad671a539ac8792a40f8aff34909ee8114/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423172473448794b4832674b306a535a4645585863714d7058612d313430302d3532382e706e67?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://camo.githubusercontent.com/feff36574753ce4c04ddfe9769e623ad671a539ac8792a40f8aff34909ee8114/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423172473448794b4832674b306a535a4645585863714d7058612d313430302d3532382e706e67?imageMogr2/format/webp">
    <img src="https://camo.githubusercontent.com/feff36574753ce4c04ddfe9769e623ad671a539ac8792a40f8aff34909ee8114/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423172473448794b4832674b306a535a4645585863714d7058612d313430302d3532382e706e67" alt="https://camo.githubusercontent.com/feff36574753ce4c04ddfe9769e623ad671a539ac8792a40f8aff34909ee8114/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f54423172473448794b4832674b306a535a4645585863714d7058612d313430302d3532382e706e67" loading="lazy"/>
  </picture>





- 注意

1. HTTP 接口不支持 SameSite=none

如果你想加 SameSite=none 属性，那么该 Cookie 就必须同时加上 Secure 属性，表示只有在 HTTPS 协议下该 Cookie 才会被发送。

2. 需要 UA 检测，部分浏览器不能加 SameSite=none

IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性。`Samesite=None`的UA列表可以看这里得知：https://www.chromium.org/updates/same-site/incompatible-clients





###### [作用域](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies#cookie_的作用域)

1.Domain

Domain 指定了 Cookie 可以送达的主机名。详情见 浏览器 这篇笔记的 同源策略部分









2.Path

Path 指定了一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部。比如设置 `Path=/docs`，`/docs/Web/` 下的资源会带 Cookie 首部，`/test` 则不会携带 Cookie 首部。`/` 表示域名下的任意路径都允许使用 Cookie。





#### 代理

##### Via

举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:

```
客户端 -> 代理1 -> 代理2 -> 源服务器
```

在源服务器收到请求后，会在`请求头`拿到这个字段:

```
Via: proxy_server1, proxy_server2
```

而源服务器响应时，最终在客户端会拿到这样的`响应头`:

```
Via: proxy_server2, proxy_server1
```

可以看到，`Via`中代理的顺序即为在 HTTP 传输中报文传达的顺序。

##### X-Forwarded-For

字面意思就是`为谁转发`, 它记录的是**请求方**的`IP`地址(注意，和`Via`区分开，`X-Forwarded-For`记录的是请求方这一个IP)。

`X-Forwarded-For`这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从`客户端`到`代理1`，这个字段是客户端的 IP，从`代理1`到`代理2`，这个字段就变为了代理1的 IP。

这会产生两个问题:

1. 意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。
2. 在 HTTPS 通信加密的过程中，原始报文是不允许修改的。

由此产生了`代理协议`，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:

```
// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口
PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222
GET / HTTP/1.1
...
```

##### X-Real-IP

是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。

相应的，还有`X-Forwarded-Host`和`X-Forwarded-Proto`，分别记录**客户端**(不包括代理)的`域名`和`协议名`。





#### HTTP 处理表单数据提交

在 http 中，有两种主要的表单提交的方式，体现在两种不同的`Content-Type`取值:

- application/x-www-form-urlencoded
- multipart/form-data

由于表单提交一般是`POST`请求，很少考虑`GET`，因此这里我们将默认提交的数据放在请求体中。

##### application/x-www-form-urlencoded

对于`application/x-www-form-urlencoded`格式的表单内容，有以下特点:

- 其中的数据会被编码成以`&`分隔的键值对
- 字符以**URL编码方式**编码。

如：

```
// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
"a%3D1%26b%3D2"
```

##### multipart/form-data

对于`multipart/form-data`而言:

- 请求头中的`Content-Type`字段会包含`boundary`，且`boundary`的值有浏览器默认指定。例: `Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe`。
- 数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如`Content-Type`，在最后的分隔符会加上`--`表示结束。

相应的`请求体`是下面这样:

```
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```



#### 大文件下载

HTTP 针对这一场景，采取了`范围请求`的解决方案，允许客户端仅仅请求一个资源的一部分。

服务器要支持**范围请求**，就必须加上这样一个响应头:

```
Accept-Ranges: none
```

用来告知客户端这边是支持范围请求的。

##### Range 字段

`客户端`通过`Range`这个请求头字段确定请求哪一部分。接下来就来讨论一下这个 Range 的书写格式:

- **0-499**表示从开始到第 499 个字节。
- **500**- 表示从第 500 字节到文件终点。
- **-100**表示文件的最后100个字节。

服务器收到请求之后，首先验证范围**是否合法**，如果越界了那么返回==`416`错误码==，否则读取相应片段，返回==`206`状态==码。

同时，`服务器`需要添加`Content-Range`字段，这个字段的格式根据请求头中`Range`字段的不同而有所差异。

具体来说，请求`单段数据`和请求`多段数据`，响应头是不一样的。

举个例子:

```
// 单段数据
Range: bytes=0-9
// 多段数据
Range: bytes=0-9, 30-39
```

##### 单段数据响应

对于`单段数据`的请求，返回的响应如下:

```
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

i am xxxxx
```

值得注意的是`Content-Range`字段，`0-9`表示请求的返回，`100`表示资源的总大小。

##### 多段数据响应

接下来我们看看多段请求的情况。得到的响应会是下面这个形式:

```
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--
```

在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上`--`表示结束。



## HTTP1.0

keep-connect 参数默认为false，每次http请求都要重新建立tcp连接。



## HTTP1.1协议的特点

建立在TCP的连接基础上。HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。

**特点**：

- **无连接**：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。
- **无状态**：HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。

- **明文传输：** 协议中的报文使用的是文本形式，这就直接暴露给外界
- **队头阻塞**：同一个 TCP 管道中同一时刻只能处理一个 HTTP 请求，也就是说如果当前请求没有处理完，其它的请求都处于阻塞状态。任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理 --- 解决方法：并发多个链接（chrome限制最多并发6个，缺点在于第一网络带宽是固定的，所以分成了六个之后每一个tcp分下来的带宽就会相应减少，导致一个完成的http请求时间就会变长。第二如果是https请求，每一个tcp都要进行tls协商。第三当请求数量大于tcp数量时仍然需要排队），域名分片（一个域名下分出多个二级域名都指向同一台服务器。）
- 不安全：（1）通信使用明文（不加密），内容可能会被窃听； （2）不验证通信方的身份，因此有可能遭遇伪装； （3）无法证明报文的完整性，所以有可能已遭篡改





## HTTP 2.0

### 图解

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-7GexiP.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-7GexiP.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-7GexiP.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-7GexiP.webp" loading="lazy"/>
  </picture>

### 二进制帧

#### 帧结构

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-50-image-20230419205030158.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-50-image-20230419205030158.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-50-image-20230419205030158.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-50-image-20230419205030158.png" loading="lazy"/>
  </picture>



每个帧分为`帧头`和`帧体`。先是三个字节的帧长度，这个长度表示的是`帧体`的长度。

然后是帧类型，大概可以分为**数据帧**和**控制帧**两种。数据帧用来存放 HTTP 报文，控制帧用来管理`流`的传输。

接下来的一个字节是**帧标志**，里面一共有 8 个标志位，常用的有 **END_HEADERS**表示头数据结束，**END_STREAM**表示单方向数据发送结束。

后 4 个字节是`Stream ID`, 也就是`流标识符`，有了它，接收方就能从乱序的二进制帧中选择出 ID 相同的帧，按顺序组装成请求/响应报文。

具体可以理解成这样：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-49-image-20230419204918373.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-49-image-20230419204918373.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-19-20-49-image-20230419204918373.png" alt="image-20230419204918373" style="zoom:50%;" loading="lazy"/>
  </picture>



#### 流的状态变化

在 HTTP/2 中，所谓的`流`，其实就是二进制帧的==双向传输的序列==

HTTP/2 其实也是借鉴了 TCP 状态变化的思想，根据帧的标志位来实现具体的状态改变。这里我们以一个普通的`请求-响应`过程为例来说明：



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-MhB8Yx.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-MhB8Yx.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-MhB8Yx.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-MhB8Yx.webp" loading="lazy"/>
  </picture>



最开始两者都是空闲状态，当客户端发送`Headers帧`后，开始分配`Stream ID`, 此时客户端的`流`打开, 服务端接收之后服务端的`流`也打开，两端的`流`都打开之后，就可以互相传递数据帧和控制帧了。

当客户端要关闭时，向服务端发送`END_STREAM`帧，进入`半关闭状态`, 这个时候客户端只能接收数据，而不能发送数据。

服务端收到这个`END_STREAM`帧后也进入`半关闭状态`，不过此时服务端的情况是只能发送数据，而不能接收数据。随后服务端也向客户端发送`END_STREAM`帧，表示数据发送完毕，双方进入`关闭状态`。

如果下次要开启新的`流`，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个。

### 流的特性

- 并发性。一个 HTTP/2 连接上可以同时发多个帧，这一点和 HTTP/1 不同。这也是实现**多路**复用的基础。
- 自增性。流 ID 是不可重用的，而是会按顺序递增，达到上限之后又新开 TCP 连接从头开始。
- 双向性。客户端和服务端都可以创建流，互不干扰，双方都可以作为`发送方`或者`接收方`。
- 可设置优先级。可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。



### 二进制帧带来的好处

#### 头部压缩

HTTP/2 当中==废除了起始行==，将起始行中的请求方法、URI、状态码转换成了头字段，不过这些字段都有一个==":"前缀==，用来和其它请求头区分开。

HTTP/2 针对头部字段，采用了——HPACK算法对请求头进行压缩。

它主要的亮点有两个：

- 在服务器和客户端之间建立哈希表，将用到的字段存放在这张表中，传输的时候对于之前出现过的值，只需要把**索引**(比如0，1，2，...)传给对方即可，对方拿到索引查表就行了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-2d1kjt.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-2d1kjt.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-2d1kjt.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-2d1kjt.webp" loading="lazy"/>
  </picture>

- 其次是对于整数和字符串进行**哈夫曼编码**，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短。




#### 多路复用(解决HTTP层的队头阻塞)

 HTTP/2 干脆把报文全部换成二进制格式，全部传输`01`串，方便了机器的解析。

用**Headers帧**存放头部字段，**Data帧**存放请求体数据。分帧之后，服务器看到的不再是一个个完整的 HTTP 请求报文，而是一堆乱序的二进制帧。这些二进制帧不存在先后关系，因此也就不会排队等待。通信双方都可以给对方发送二进制帧，这种二进制帧的**双向传输的序列**，也叫做`流`(Stream)。乱序指的是不同 ID 的 Stream 是乱序的，但同一个 Stream ID 的帧一定是按顺序传输的。二进制帧到达后对方会将 Stream ID 相同的二进制帧组装成完整的**请求报文**和**响应报文**。

#### 服务器推送

在 HTTP/2 当中，服务器也能新建 stream 来给客户端发送消息，当 TCP 连接建立之后，比如浏览器请求一个 HTML 文件，服务器就可以在返回 HTML 的基础上，将 HTML 中引用到的其他资源文件一起返回给客户端，减少客户端的等待。







### HTTP 1.1 和 HTTP 2.0 的区别

- **二进制协议**：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
- **多路复用：** HTTP/2 同一域名下只需一个TCP连接，但是在一个连接里客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，避免了"队头堵塞"的问题（同一个 TCP 管道中同一时刻只能处理一个 HTTP 请求，也就是说如果当前请求没有处理完，其它的请求都处于阻塞状态）。
- **数据流：** HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
- **头信息压缩：** HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
- **服务器推送：** HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。比如对于一个 html 的请求，通过 HTTP 2 我们可以同时将相应的 js 和 css 资源推送到浏览器，省去了后续请求的开销。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。



### 缺陷

#### 建立连接时间长

目前是用 RTT（Round-Trip Time）来定义建立时间，RTT 指的是往返时间，表示从发送端发送数据开始，到发送端收到来自接受端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间）总共经历的时间，即通信一来一回的时间。

##### **TCP 建立连接时间**

TCP 建立连接有三次握手：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-91uUjc.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-91uUjc.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-91uUjc.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-91uUjc.png" loading="lazy"/>
  </picture>

- 一去 （SYN）：客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态
- 二回 （SYN+ACK）：服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态
- 三去 （ACK）：当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功

==TCP 建立连接时间 = 1.5 RTT==

##### **HTTP 交易时间**

客户端在请求数据的时候，首先花费 1.5 RTT 建立 TCP 连接，然后 TCP 才开始传输 HTTP 请求，浏览器收到服务器的响应，又要等待的时间为：

- 一去（HTTP Request）
- 二回 （HTTP Responses）

==HTTP 交易时间 = 1 RTT==

由于 TCP 在第三次握手的时候，不需要等待服务器端的响应，所以第三次去的那个可以不算即节省 0.5 RTT，那么基于 TCP 传输的 HTTP 通信，一共花费的时间总和：

==HTTP 通信时间总和 = TCP 建立连接时间 + HTTP 交易时间 = 1 RTT + 1 RTT = 2 RTT==

##### **HTTPS 通信时间**

HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，但真实应用中的 HTTP/2 都是加密的，HTTPS 通信时间 = TCP 建立连接时间 + TLS 连接时间 + HTTP 交易时间。

TLS1.2 建立连接的时候，有四次握手，需要 2 个 RTT。在 TLS1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接就不需要 RTT 了。

<strong style="color:red">HTTPS 通信时间总和（基于TLS1.2） = TCP 建立连接时间 + TLS1.2 连接时间 + HTTP交易时间 = 1 RTT + 2 RTT + 1 RTT = 4 RTT</strong>

<strong style="color:red">HTTPS 通信时间总和（基于TLS1.3） = TCP 建立连接时间 + TLS1.3 连接时间 + HTTP交易时间 = 1 RTT + 1 RTT + 1 RTT = 3 RTT</strong>

#### 仍然存在TCP的队头阻塞问题

因为 HTTP/2 使用了多路复用，所以一般来说同一域名下<font color="red">只有一个 TCP 连接</font>。当这个连接中出现了丢包时，整个 TCP 都要开始等待重传（因为TCP的机制是如果前一个包没有抵达就会等这个包抵达了才会把下一个数据包给下一层），也就导致了后面的所有数据都被阻塞了。但是<font style="color:red;">HTTP/1 有多个 TCP 连接</font>，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据。





## HTTP3

### QUIC 协议介绍

Google 另起炉灶写了一个基于 UDP 协议的 QUIC 协议（Quick UDP Internet Connection），并把这个协议用在了 HTTP/3 上，HTTP/3 之前的命名为 HTTP-over-QUIC。（该协议属于运输层）

基本上都解决了http层面影响web性能的问题。



### HTTP/3 新特性

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-vQpavX.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-vQpavX.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-vQpavX.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-vQpavX.png" loading="lazy"/>
  </picture>

QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。

#### 1. 多路复用，解决队头阻塞问题

虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能。

QUIC 协议是基于 UDP 协议实现的，同一个 QUIC 连接上可以创建多个 stream（数据流） 来发送多个 HTTP 请求，并且，多个 stream 之间没有依赖，传输的单个 stream可以保证有序交付且不会影响其他的数据流。

例如下图，stream2 丢了一个 UDP 包，不会影响后面跟着 Stream3 和 Stream4。这样的技术就解决了之前 TCP 存在的队头阻塞问题。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VzI7Eh.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VzI7Eh.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VzI7Eh.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VzI7Eh.jpg" loading="lazy"/>
  </picture>

并且 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。

#### 2. 0RTT

通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。

0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？

- 传输层 0RTT 就能建立连接。
- 加密层 0RTT 就能建立加密连接。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-KJouJy.gif?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-KJouJy.gif?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-KJouJy.gif" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-KJouJy.gif" loading="lazy"/>
  </picture>

上图左边是 HTTPS 的一次完全握手的建连过程，需要 2-3 个 RTT才开始传输数据，右边 QUIC 协议在第一个包就可以包含有效的应用数据

当然，QUIC 协议可以实现 0RTT ，但这也是有条件的，实际上是首次连接 1RTT，非首次连接 0RTT。

#### 3. 向前纠错机制

QUIC 协议有一个非常独特的特性，称为向前纠错 (Forward Error Correction，FEC)，每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。

向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间（包括确认数据包丢失、请求重传、等待新数据包等步骤的时间消耗）。

假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。

当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。

当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。

#### 4. 加密认证的报文

TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。

但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。

这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。





## HTTP状态码

### 状态码的类别

| **类别** | **原因**                        | **描述**                   |
| -------- | ------------------------------- | -------------------------- |
| 1xx      | Informational(信息性状态码)     | 接受的请求正在处理         |
| 2xx      | Success(成功状态码)             | 请求正常处理完毕           |
| 3xx      | Redirection(重定向状态码)       | 需要进行附加操作一完成请求 |
| 4xx      | Client Error (客户端错误状态码) | 服务器无法处理请求         |
| 5xx      | Server Error(服务器错误状态码)  | 服务器处理请求出错         |



### HTTP状态码列表

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
|        |                                 |                                                              |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
|        |                                 |                                                              |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
|        |                                 |                                                              |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
|        |                                 |                                                              |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |



### **307**，**303**，**302**的区别

首先**301 Moved Permanently**即永久重定向，对应着**302 Found**，即临时重定向。

比如你的网站以前的站点再也不用了，应当返回`301`，这个时候浏览器默认会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。而如果只是暂时不可用，那么直接返回`302`即可，和`301`不同的是，浏览器并不会做缓存优化。

302是http1.0的协议状态码，实际操作中，不管第一次是什么谓词，重定向后都变成Get，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。






## 浏览器中输入url

（1）**解析URL：** 首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）**缓存判断：** 浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）**DNS解析：** 下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。

（4）**获取MAC地址：** 当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。

（5）**TCP三次握手：** 下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

（6）**HTTPS握手：** 如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。

（7）**返回数据：** 当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（8）**页面渲染：** 浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。（更详细可见浏览器渲染原理）

（9）**TCP四次挥手：** 最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。





## URI

### URI 结构

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-26cXy1.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-26cXy1.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-26cXy1.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-26cXy1.webp" loading="lazy"/>
  </picture>

### URI 编码

URI 只能使用`ASCII`, 因此，URI 引入了`编码`机制，将所有**非 ASCII 码字符**和**界定符**转为十六进制字节值，然后在前面加个`%`。如，空格被转义成了`%20`，**三元**被转义成了`%E4%B8%89%E5%85%83`。





# HTTPS

## 什么是HTTPS协议？

超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。

HTTP协议采用**明文传输**信息，存在**信息窃听**、**信息篡改**和**信息劫持**的风险，而协议TLS/SSL具有**身份验证**、**信息加密**和**完整性校验**的功能，可以避免此类问题发生。

安全层的主要职责就是**对发起的HTTP请求的数据进行加密操作** 和 **对接收到的HTTP的内容进行解密操作**。


<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-PUBB5x.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-PUBB5x.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-PUBB5x.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-PUBB5x.webp" loading="lazy"/>
  </picture>





## TLS/SSL的工作原理

### 介绍

**TLS/SSL**全称**安全传输层协议**（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议。（**TLS 实际上只是SSL的更新版本**）

密钥TLS/SSL是一个公钥/私钥的结构，每个服务器端和客户端都有自己的公私钥。建立安全传输之前，客户端和服务器端之间需要互换公钥。：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-24-image-20230819142434035.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-24-image-20230819142434035.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-24-image-20230819142434035.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-24-image-20230819142434035.png" loading="lazy"/>
  </picture>

客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要客户端的公钥进行加密，公钥和私钥是配对的，通过公钥加密的数据，只有通过私钥才能解密。

为了中间人攻击（见web安全），数据传输过程中还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器。



### TLS/SSL的功能实现主要依赖三类算法

**散列函数hash**、**对称加密**、**非对称加密**。这三类算法的作用如下：

- 基于散列函数验证信息的完整性
- 对称加密算法采用协商的秘钥对数据加密
- 非对称加密实现身份认证和秘钥协商

#### 数字签名hash

常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于==防止信息篡改并验证数据的完整性==。

#### 对称加密

对称加密的方法是，==双方使用同一个秘钥==对数据进行加解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了

#### 非对称加密

非对称加密的方法是，公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。任何想和我们通信的客户， 都可以使用我们提供的==公钥对数据进行加密==，这样我们就可以使用==私钥进行解密==。非对称加密有一个缺点就是加密的过程很慢。

### 数字证书

#### 为了避免中间人攻击

为了避免中间人攻击（见web安全）。因为<font color="red">没有办法确定得到的公钥就一定是安全的公钥</font>。为了解决这样的问题，可以使用数字证书。数字证书中包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。`CA的公钥`是以CA给自己颁发的证书的形式内置在操作系统中的。

#### Certificate Authority，数字证书认证中心

CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现的签名。

为了得到签名证书，服务器端需要通过自己的私钥生成CSR（Certificate Signing Request，证书签名请求）文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构就能验证证书是否合法。

如果是知名的CA机构，它们的证书一般预装在浏览器中。如果是自己扮演CA机构，颁发自有签名证书则不能享受这个福利，客户端需要获取到CA的证书才能进行验证。

签名证书是一环一环地颁发的，但是在CA那里的证书是不需要上级证书参与签名的，这个证书我们通常称为根证书。

CA的公钥内置在系统 + CA的私钥不泄露 → CA的证书无法伪造 → 网站的公钥等信息无法伪造 + 网站的私钥不泄露→ 使用网站的公钥加密后的对称加密密钥无法解密 → 所有通过对称加密后的数据无法解密  → 中间人无法窃听或篡改信息。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-nxQdpo.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-nxQdpo.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-nxQdpo.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-nxQdpo.webp" loading="lazy"/>
  </picture>

#### 自签名证书

对于中小型企业而言多半是采用自签名证书来构建安全网络的。就是自己扮演CA机构，给自己的服务器端颁发签名证书。以下为生成私钥、生成CSR文件、通过私钥自签名生成证书的过程：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-38-image-20230819143840712.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-38-image-20230819143840712.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-38-image-20230819143840712.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-38-image-20230819143840712.png" loading="lazy"/>
  </picture>

上述步骤完成了扮演CA角色需要的文件。接下来回到服务器端，服务器端需要向CA机构申请签名证书。在申请签名证书之前依然是要创建自己的CSR文件。值得注意的是，这个过程中的Common Name要匹配服务器域名，否则在后续的认证过程中会出错。如下是生成CSR文件所用的命令：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-41-image-20230819144159383.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-41-image-20230819144159383.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-41-image-20230819144159383.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-41-image-20230819144159383.png" loading="lazy"/>
  </picture>。得到CSR文件后，向我们自己的CA机构申请签名吧。签名过程需要CA的证书和私钥参与，最终颁发一个带有CA签名的证书，如下所示：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-42-image-20230819144230942.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-42-image-20230819144230942.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-42-image-20230819144230942.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-19-14-42-image-20230819144230942.png" loading="lazy"/>
  </picture>

客户端在发起安全连接前会去获取服务器端的证书，并通过CA的证书验证服务器端证书的真伪。除了验证真伪外，通常还含有对服务器名称、IP地址等进行验证的过程。



### TLS1.2握手

TLS 的握手过程可以简单分为两个过程：客户端拿到服务端的 CA 证书，验证其有效性得到了服务端的公钥；客户端和服务端分别生成同样的密钥，之后用生成的密钥加密通信。耗时2-RTT

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-TSY2eC.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-TSY2eC.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-TSY2eC.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-TSY2eC.png" loading="lazy"/>
  </picture>





### TLS1.3

#### 握手过程

耗时1-RTT

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-uESKSS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-uESKSS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-uESKSS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-uESKSS.webp" loading="lazy"/>
  </picture>



#### Session Ticket

1.2使用**Seesion ID**，客户端和服务器首次连接后各自保存会话的 ID，并存储会话密钥，当再次连接时，客户端发送`ID`过来，服务器查找这个 ID 是否存在，如果找到了就直接复用之前的会话状态，会话密钥不用重新生成，直接用原来的那份。但这种方式也存在一个弊端，就是当客户端数量庞大的时候，对服务端的==存储压力非常大==。1.3用**Session Ticket**。双方连接成功后，服务器加密会话信息，用**Session Ticket**消息发给客户端，让客户端保存下来。下次重连的时候，就把这个 Ticket 进行解密，验证它过没过期，如果没过期那就直接恢复之前的会话状态。这种方式虽然减小了服务端的存储压力，但与带来了安全问题，即每次用一个固定的密钥来解密 Ticket 数据，一旦黑客拿到这个密钥。

#### PSK

发送**Session Ticket**的同时带上应用数据，不用等到服务端确认，这种方式被称为`Pre-Shared Key`。若中间人截获`PSK`的数据，不断向服务器重复发，类似于 TCP 第一次握手携带数据，洪水攻击



## HTTPS 保障了三个方面的安全

数据安全可能遇到**窃听、篡改、发送者身份不可靠**三个问题。所以 TLS层( 传输安全协议）提供**加密、数字签名、和数字证书**来解决这三个问题

### **数字签名-防篡改**

数字签名类似于校验码，会附加在要传输的原信息的尾部，原信息+数字签名任何一者的修改过都会导致无法通过校验。

接收方接收到原文件和数字签名时，会做两件事。

- 将原文件计算，得到摘要 m
- 用 A 的公钥解密数字签名，得到摘要 n

如果 m、n 两份摘要相同，说明原文件没有被篡改过。



### 加密-防窃听

非对称加密和对称加密

### 数字证书-身份认证





# 长连接

## websocket

WebSocket是HTML5提供的一种浏览器与服务器进行**全双工通讯**的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ampg6P.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ampg6P.jpg?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ampg6P.jpg" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Ampg6P.jpg" loading="lazy"/>
  </picture>

有状态的持久连接

发送消息的延迟比HTTP低



WebSocket 的通信过程是这样的：首先通过 http 切换协议，服务端返回 101 的状态码后，就代表协议切换成功。

之后就是 WebSocket 格式数据的通信了，一方可以随时向另一方推送消息。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-47-image-20231103214704266.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-47-image-20231103214704266.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-47-image-20231103214704266.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-47-image-20231103214704266.png" loading="lazy"/>
  </picture>







## HTTP 的 Server Send Event

HTTP 的 Server Send Event 流程是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-50-image-20231103215019440.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-50-image-20231103215019440.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-03-21-50-image-20231103215019440.png" alt="image-20231103215019440" style="zoom:50%;" loading="lazy"/>
  </picture>

服务端返回的 Content-Type 是 text/event-stream，这是一个流，可以多次返回内容。连接断了浏览器会自动重连，WebSocket 如果断开之后是需要手动重连的。

比如后端处理一个逻辑可能比较久需要返回进度(其实这种可能假进度就行了)，比如你用的 CICD 平台，它的日志是实时打印的。再比如说 ChatGPT，它回答一个问题不是一次性给你全部的，而是一部分一部分的加载回答。

客户端这样写：

EventSource 是浏览器原生 api，就是用来获取 sse 接口的响应的，它会把每次消息传入 onmessage 的回调函数。

```js
    const eventSource = new EventSource('http://localhost:3000/stream');
    eventSource.onmessage = ({ data }) => {
      console.log('New message', JSON.parse(data));
    };
```





# CDN

## 简介

CDN的全称是Content Delivery Network，即内容分发网络。

**实现方法：** 通过在网络各处放置**节点服务器**所构成的在现有的互联网基础之上的一层**智能虚拟网络**，CDN系统能够实时地根据网络流量和各节点的**连接和负载**状况以及到用户的**距离**和**响应时间**等综合信息将用户的请求重新**导向离用户最近的服务节点**上，加快访问速度。

**目的：** 使用户可`就近`取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的`响应速度`。



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-58-image-20240204165849231.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-58-image-20240204165849231.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-58-image-20240204165849231.png" alt="image-20240204165849231" style="zoom:75%;" loading="lazy"/>
  </picture>









## CDN基本工作流程

### 不使用CDN时

1. 用户在自己的浏览器中输入要访问的网站域名。
2. 浏览器向 本地DNS服务器 请求对该域名的解析。
3. 本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。
4. 本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。
5. 浏览器得到域名解析结果，就是该域名相应的服务设备的 IP地址 。
6. 浏览器向服务器请求内容。
7. 服务器将用户请求内容传送给浏览器。

### 使用了CDN时

DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。

1. 当用户点击网站页面上的内容URL，经过**本地**DNS系统解析，DNS 系统会最终将域名的解析权交给 `CNAME` 指向的 CDN 专用 DNS 服务器。
2. CDN 的 DNS 服务器将 CDN 的**全局负载均衡设备** `IP` 地址返回用户。
3. 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。
4. CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
5. 基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：
   - 根据用户 IP 地址，判断哪一台服务器距用户最近；
   - 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；
   - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。
6. 全局负载均衡设备把服务器的 IP 地址返回给用户。
7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。
8. CDN边缘节点会检测用户请求数据的缓存是否过期，如果cdn数据没有过期，则直接响应用户请求，此时一个完成http请求结束；如果cdn数据已经过期，那么CDN还需要向源站发出回源请求，来拉取最新的数据。

   **缓存优点：** CDN的分流作用不仅减少了用户的访问延时，也减少的源站的负载。

   **缺点：** 当网站更新时，如果CDN节点上数据没有及时更新，会因为CDN边缘节点没有同步最新数据而导致用户访问异常。









## CDN容灾

CDN容灾是指在使用内容分发网络（CDN）时，为了保证网站或应用的可用性和稳定性，采取一些措施来应对可能发生的故障或异常情况。

在CDN容灾中，通常会采取以下措施：

1. 多节点部署：通过在全球各地的多个节点部署服务器，将内容复制到各个节点上，可以提高用户访问的速度和质量。当某个节点出现故障或网络中断时，其他节点可以接替服务，确保用户的访问不受影响。

2. 负载均衡：通过负载均衡技术将用户请求分发到不同的服务器上，避免某个服务器负载过高而导致性能下降或故障。当某个服务器不可用时，负载均衡机制可以将请求转发到其他可用的服务器上，保证服务的连续性。

3. 异地容灾：在不同的地理位置建立备份服务器，确保即使某个地区出现故障或灾害，其他地区的服务器仍然能够提供服务。通过实时数据同步和故障切换机制，保证用户可以无缝地切换到备用服务器上。

4. 自动故障检测与恢复：通过监控系统实时监测服务器的状态和性能指标，一旦发现异常或故障，能够及时地通知管理员并采取相应的措施。自动故障检测与恢复机制可以快速地将故障节点从服务池中移除，并尽快恢复正常运行。







## CDN的作用

### 1. 加速访问

CDN可以使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。

还提供服务器端加速，解决由于用户访问量大造成的服务器过载问题；

### 2. 实现跨运营商、跨地域的全网覆盖

互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。

CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。

### 3. 保障你的网站安全

CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。

### 4. 异地备援

当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。

### 5. 节约成本

能克服**网站分布不均**的问题，投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，并且能降低网站自身建设和维护成本。

### 6. 让你更专注业务本身

CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。

## CDN工作原理

CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。

### 1. 用户访问cdn资源的过程

1. 用户向浏览器输入www.web.com这个域名，浏览器第一次发现本地没有DNS缓存，则向网站的DNS服务器请求；
2. 网站的DNS域名解析器设置了CNAME，指向了www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；
3. 智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点（CDN服务器）返回给用户；
4. 用户向该IP节点（CDN服务器）发出请求；
5. 由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；
6. 请求结果发给用户。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-58-image-20240204165849231.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-58-image-20240204165849231.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-58-image-20240204165849231.png" alt="image-20240204165849231" style="zoom:75%;" loading="lazy"/>
  </picture>







### 2. cdn主要特点

1. **本地Cache加速** 提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性
2. **镜像服务** 消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。
3. **远程加速** 远程访问用户根据DNS负载均衡技术智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度
4. **带宽优化** 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。
5. **集群抗攻击** 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。

## CDN对网络的优化

1. 解决服务器端的“第一公里”问题
2. 缓解甚至消除了不同运营商之间互联的瓶颈造成的影响
3. 减轻了各省的出口带宽压力
4. 缓解了骨干网的压力
5. 优化了网上热点内容的分布

**第一公里** 是指万维网流量向用户传送的第一个出口，是网站服务器接入互联网的链路所能提供的带宽。 这个带宽决定了一个 网站能为用户提供的访问速度和并发访问量。如果业务繁忙，用户的访问数越多，拥塞越严重，网站会在最需要向用户提供服务时失去用户。

**中间一公里** 代表互联网中节点与节点之间的传输网络。

**最后一公里** 万维网流量向用户传送的最后一段接入链路。

## CDN的应用场景

### 1. 网站站点/应用加速

站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，建议结合 对象存储OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发

### 2. 视音频点播/大文件下载分发加速

支持各类文件的下载、分发，支持在线点播加速业务，如mp4、flv视频文件或者平均单个文件大小在20M以上，主要的业务场景是视音频点播、大文件下载（如安装包下载）等，建议搭配对象存储OSS使用，可提升回源速度，节约近2/3回源带宽成本。

### 3. 视频直播加速（内测中）

视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。目前CDN直播加速已服务内部用户测试并优化，即将上线

### 4. 移动应用加速

移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。

## CDN缓存

### 介绍

缓存是`空间换时间`的思路，通过使用多余的空间，换来更快的访问速度。

- 不使用cdn缓存时

所有的用户都直接访问源服务器

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-0dxJPT.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-0dxJPT.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-0dxJPT.webp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>

- 使用cdn缓存时

客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果cdn数据没有过期，则直接响应用户请求，此时一个完成http请求结束；如果cdn数据已经过期，那么CDN还需要向源站发出回源请求，来拉取最新的数据。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-pT5oNi.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-pT5oNi.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-pT5oNi.webp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-17-00-image-20240204170059466.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-17-00-image-20240204170059466.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-17-00-image-20240204170059466.png" alt="image-20240204170059466" style="zoom:75%;" loading="lazy"/>
  </picture>



**缓存优点：** CDN的分流作用不仅减少了用户的访问延时，也减少的源站的负载。

**缺点：** 当网站更新时，如果CDN节点上数据没有及时更新，即便用户再浏览器使用Ctrl+F5的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。



### CDN缓存的策略

拉 策略：

用户请求了什么就缓存什么，方便下次请求。



推 策略：

服务器认为哪个访问的概率高就缓存哪个，服务器主动让CDN进行缓存。



一般可以两个策略一起用。然后一定时间段用LRU算法清除一些缓存。







### 解决CDN缓存更新的办法

1. 资源url参数加时间戳

url的参数加上时间戳，每次更新时时间戳也跟随更新，重新使cdn边缘节点同步源服务器最新数据。

```sh
http://www.cdn.com/static/images/test.png # 没加时间戳
http://www.cdn.com/static/images/test.png?_t=202012290910 # 加了时间戳
复制代码
```

1. 调用cdn服务商提供的**刷新缓存**接口

CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。

这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。

## cdn的组成

### 1. 部署架构

CDN 系统设计的首要目标是尽量**减少用户的访问响应时间**，为达到这一目标，CDN 系统应该尽量将用户所需要的内容**存放在距离用户最近的位置**。也就是说，负责为用户提供内容服务的 Cache 设备应部署在物理上的网络边缘位置，我们称这一层为`CDN边缘层`。CDN 系统中负责全局性管理和控制的设备组成`中心层`，中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。

不同CDN系统设计之间存在差异，中心层可能具备用户服务能力，也可能不直接提供服务，只向下级节点提供内容。如果CDN网络规模较大，边缘层设备直接向中心层请求内容或服务会造成中心层设备压力过大，就要考虑在边缘层和中心层之间部署一个`区域层`，负责一个区域的管理和控制，也保存部分内容副本供边缘层访问。

如图是一个典型的CDN系统三级部署示意图:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Vk7OgA.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Vk7OgA.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Vk7OgA.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Vk7OgA.webp" loading="lazy"/>
  </picture>

### 2. 设备组成

CDN网络中包含的功能实体主要由以下几个部分组成：

- 内容缓存设备
- 内容交换机
- 内容路由器
- CDN内容管理系统

### 1. 内容缓存设备

内容缓存为**CDN网络节**点，位于用户接入点，是面向最终用户的内容提供设备，可缓存静态Web内容和流媒体内容，实现内容的边缘传播和存储，以便用户的就近访问。

### 2. 内容交换机

内容交换机处于**用户接入集中点**，可以均衡单点多个内容缓存设备的负载，并对内容进行缓存负载平衡及访问控制。

### 3. 内容路由器

内容路由器负责将用户的请求**调度到适当的设备**上。

内容路由通常通过负载均衡系统来实现，动态均衡各个内容缓存站点的载荷分配，为用户的请求选择最佳的访问站点，同时提高网站的可用性。

内容路由器可根据多种因素制定路由，包括站点与用户的临近度、内容的可用性、网络负载、设备状况等。

**负载均衡系统是整个CDN的核心。负载均衡的准确性和效率直接决定了整个CDN的效率和性能。**

### 4. 内容管理系统

内容管理系统负责整个CDN的**管理**，是**可选部件**，作用是进行内容管理，如内容的注入和发布、内容的分发、内容的审核、内容的服务等。





# DNS

### DNS 协议是什么

将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。对于 Web 浏览器而言，除了初始请求外，不需要从用户的计算机进行任何交互。

IP地址的长度为32比特，也就是4字节；域名最短也要几十个字节，最长甚至可以达到255字节。换句话说，使用IP地址只需要处理4字节的数字，而域名则需要处理几十个到255个字节的字符，这增加了路由器的负担，传送数据也会花费更长的时间。

### DNS同时使用TCP和UDP协议？

**DNS占用53号端口，同时使用TCP和UDP协议。** 

（1）在区域传输的时候使用TCP协议

- 辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。

  

（2）在域名解析的时候使用UDP协议

- 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。



### 加载网页涉及 4 个 DNS 服务器

- **[DNS 解析器](https://www.cloudflare.com/learning/dns/dns-server-types/)** - 该解析器可被视为被要求去图书馆的某个地方查找特定图书的图书馆员。解析器一般负责发出其他请求，以便满足客户端的 DNS 查询。 调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息。响应消息中包含查询到的IP地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。接下来，浏览器在向Web服务器发送消息时，只要从该内存地址取出IP地址，并将它与HTTP请求消息一起交给操作系统就可以了。 

  

  <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-06-13-09-image-20231206130950645.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-06-13-09-image-20231206130950645.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-06-13-09-image-20231206130950645.png" alt="image-20231206130950645" style="zoom:50%;" loading="lazy"/>
  </picture>

  一层一层来

  发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过网卡将消息发送给DNS服务器（图1.12④⑤）。

- **根域名服务器** - [根域名服务器](https://www.cloudflare.com/learning/dns/glossary/dns-root-server/)是将人类可读的主机名转换（解析）为 IP 地址的第一步。可将其视为指向不同书架的图书馆中的索引 - 一般其作为对其他更具体位置的引用。

- **[TLD 名称服务器](https://www.cloudflare.com/learning/dns/dns-server-types/)** —— 顶级域名服务器（[TLD](https://www.cloudflare.com/learning/dns/top-level-domain/)）可看做是图书馆中一个特殊的书架。这个域名服务器是搜索特定 IP 地址的下一步，其上托管了主机名的最后一部分（例如，在 example.com 中，TLD 服务器为 “com”）。

- **[权威性域名服务器](https://www.cloudflare.com/learning/dns/dns-server-types/)** - 可将这个最终域名服务器视为书架上的字典，其中特定名称可被转换成其定义。权威性域名服务器是域名服务器查询中的最后一站。如果权威性域名服务器能够访问请求的记录，则其会将已请求主机名的 IP 地址返回到发出初始请求的 DNS 解析器（图书管理员）。

  - 在查询对象为子域（例如 foo.example.com 或 [blog.cloudflare.com](https://blog.cloudflare.com/)）的情况下，将向权威性域名服务器之后的序列添加一个附加域名服务器，其负责存储该子域的 [CNAME 记录](https://www.cloudflare.com/learning/dns/dns-records/dns-cname-record/)。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-21-image-20230730002104037.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-21-image-20230730002104037.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-21-image-20230730002104037.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-21-image-20230730002104037.png" loading="lazy"/>
  </picture>



###  DNS完整的查询过程

DNS服务器解析域名的过程：

- 首先会在<font color="red">浏览器的缓存</font>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步
- 将请求发送给**本地DNS服务器**，在本地域名<font color="red">服务器缓存</font>中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步
- 本地DNS服务器向**根域名服务器**发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址。向DNS服务器发送消息时需要知道DNS服务器的IP地址。只不过这个IP地址是作为TCP/IP的一个设置项目事先设置好的，不需要再去查询了。不同的操作系统中TCP/IP的设置方法也有差异。
- 本地DNS服务器向**顶级域名服务器**发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址
- 本地DNS服务器向**权威域名服务器**发送请求，域名服务器返回对应的结果
- 本地DNS服务器将返回结果保存在缓存中，便于下次使用
- 本地DNS服务器将返回结果返回给浏览器

比如要查询 [www.baidu.com](https://link.juejin.cn?target=http%3A%2F%2Fwww.baidu.com%2F) 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-17-image-20230730001724137.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-17-image-20230730001724137.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-17-image-20230730001724137.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-00-17-image-20230730001724137.png" loading="lazy"/>
  </picture>

###  迭代查询与递归查询

实际上，DNS解析是一个包含迭代查询和递归查询的过程。

- **递归查询**指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。
- **迭代查询**指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。

<font color="red">我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</font>

## 127.0.0.1和0.0.0.0和localhost的区别

127.0.0.1和localhost是指向本地计算机的回送地址，即“本地主机”或“环回地址”。这意味着它们是指向你自己的IP地址。以下是它们之间的区别：

1. 127.0.0.1是一个IP地址，指向本地计算机上的网络接口。它通常被称为“本地回环地址”或“环回地址”，用于测试网络设备或本地网络连接。
2. localhost是一个主机名，它在系统的本地主机名解析中被映射到IP地址127.0.0.1。当你在浏览器中输入“[http://localhost”时，它实际上指向127.0.0.1。](http://xn--localhost%2C127-qr6gh591dnfuaz32a5naw67i9imkk1w.0.0.1./)
3. 0.0.0.0是指任何可用的网络接口。当一个应用程序侦听这个地址时，它将绑定到系统上所有可用的网络接口，而不是特定的接口。在某些情况下，这可能是有用的，例如当你想要让一个应用程序在所有网络接口上运行。

总之，127.0.0.1和localhost是指向本地计算机上的网络接口的回送地址，而0.0.0.0是指向所有可用网络接口的地址。





# 网络模型（目录上面是应用层，下面是其它层）

https://blog.csdn.net/weixin_40475396/article/details/105607907 各层对应的各种详细协议

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kMLy8B.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kMLy8B.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kMLy8B.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-kMLy8B.webp" loading="lazy"/>
  </picture>



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-qmb1Iv.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-qmb1Iv.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-qmb1Iv.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-qmb1Iv.webp" loading="lazy"/>
  </picture>





# TCP&UDP

## 传输层

**传输层定义了主机应用程序之间端到端的连通性**





## 套接字

套接字（Socket）是计算机网络中进行网络通信的一种编程接口（API）。它提供了一种用于在网络上发送和接收数据的方法，使不同计算机之间能够进行数据交换和通信。

套接字可以看作是网络通信的端点，类似于电话通信中的电话插孔。它通过网络协议（如TCP/IP）与网络进行连接，并通过网络传输层提供的协议（如TCP或UDP）来发送和接收数据。

套接字通常由IP地址和端口号组成。IP地址用于标识网络中的设备，而端口号用于标识设备上的应用程序。在进行网络通信时，通过套接字可以指定要连接的目标IP地址和端口号，从而与目标设备上的应用程序进行通信。

套接字提供了一组函数或方法，用于创建、连接、发送和接收数据等操作。在编程中，可以使用套接字API来实现网络通信的各种功能，例如建立客户端和服务器之间的连接、发送HTTP请求、接收和处理网络数据等。

总之，套接字是计算机网络中进行网络通信的一种编程接口，它提供了一种方便的方式来进行数据交换和通信，使得计算机之间能够进行网络连接和数据传输。







## TCP 和 UDP的概念

IP负责把数据报发送到目的主机，tcp/udp负责把报文段送达给具体应用

### **UDP（User Datagram Protocol）**

**1）无连接**

UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。

**2）有单播，多播，广播的功能**

UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式

**3）面向报文**

- 在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了
- 在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作

**4）没有拥塞控制**， UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，



**5）头部开销小** 

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-E3DLcz.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-E3DLcz.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-E3DLcz.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-E3DLcz.webp" loading="lazy"/>
  </picture>

UDP 头部包含了以下几个数据：

- 两个十六位的端口号，分别为==源端口（可选字段）和目标端口==
- 整个数据报文的长度
- 整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误

UDP 的头部只有==8字节==，相比 TCP 的至少20字节要少得多

6）尽最大努力交付，不保证可靠交付



### TCP（Transmission Control Protocol）

TCP的全称是传输控制协议,是一种面向连接的、可靠的、基于字节流的传输层通信协议。同一个端口可以出现在多个不同的TCP连接中。

它有以下几个特点：

**1）面向连接**

面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。

**2）仅支持单播传输**

每条TCP传输连接只能有两个端点，只能进行点对点的数据传输。TCP连接的端点叫做套接字（socket）或插口。套接字socket = （IP地址：端口号）

**3）面向字节流**

把应用程序交下来的数据看成是一连串字节流（例如应用程序交给TCP十个数据块，但TCP可能把这些字节流转换成4个数据块发出去）

**4）可靠传输**

- 保证数据包按顺序到达
- 出现差错时重传
- 根据网络情况控制发送速度

**5）提供全双工通信**

TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）





## TCP和UDP的区别

|              | UDP                                                | TCP                                                          |
| ------------ | -------------------------------------------------- | ------------------------------------------------------------ |
| 是否连接     | 无连接                                             | 面向连接                                                     |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制，不管丢不丢包 | 可靠传输（数据顺序和正确性），使用流量控制和拥塞控制，丢包重传 |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信         | 只能是一对一通信                                             |
| 传输方式     | 面向报文                                           | 面向字节流                                                   |
| 首部开销     | 首部开销小，仅8字节                                | 首部最小20字节，最大60字节                                   |
| 适用场景     | 适用于即时通讯和广播通信，例如视频会议、直播       | 适用于要求可靠传输的应用，文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。 |







## TCP报文

### 首部的结构图

单位为字节

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-krUXHv.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-krUXHv.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-krUXHv.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-krUXHv.webp" loading="lazy"/>
  </picture>



### 源端口、目标端口

如何标识唯一标识一个连接？答案是 TCP 连接的`四元组`——源 IP、源端口、目标 IP 和目标端口。

那 TCP 报文怎么没有源 IP 和目标 IP 呢？这是因为在 IP 报文头保存了 IP 。TCP 只需要记录两者的端口即可。



### 序列号

从图中可以看出，序列号是一个长为 4 个字节，也就是 32 位的无符号整数，表示范围为 0 ~ 2^32 - 1。如果到达最大值了后就循环到0。

初始序列号每 4 ms 加一，溢出则回到 0，这个算法使得猜测 ISN 变得很困难。





### 确认号

即`ACK(Acknowledgment number)`。用来告知对方下一个期望接收的序列号

### 标记位

常见的标记位有`SYN`,`ACK`,`FIN`,`RST`,`PSH`。

`FIN`： 即 Finish，表示发送方准备断开连接。

`RST`：即 Reset，用来强制断开连接。

`PSH`： 即 Push, 告知对方这些数据包收到后应该马上交给上层的应用，不能缓存。



### 窗口大小

占用两个字节，也就是 16 位，允许对方发送的最大数据量

### 校验和

占用两个字节，防止传输过程中数据包有损坏，如果遇到校验和有差错的报文，TCP 直接丢弃之，等待重传。

### 可选项

可选项的格式如下:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-57cGwL.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-57cGwL.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-57cGwL.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-57cGwL.webp" loading="lazy"/>
  </picture>

常用的可选项有以下几个:

- TimeStamp: TCP 时间戳，后面详细介绍。
- MSS: 指的是 TCP 允许的从对方接收的最大报文段。
- SACK: 选择确认选项。
- Window Scale： 窗口缩放选项。

#### 时间戳

`timestamp`是 TCP 报文首部的一个可选项，一共占 10 个字节，格式如下:

```
kind(1 字节) + length(1 字节) + info(8 个字节)
```

其中 kind = 8， length = 10， info 有两部分构成: **timestamp**和**timestamp echo**，各占 4 个字节。

接下来我们就来一一梳理，TCP 的时间戳主要解决两大问题:

- 计算往返时延 RTT(Round-Trip Time)
- 防止序列号的回绕问题

### 计算往返时延 RTT

比如现在 a 向 b 发送一个报文 s1，b 向 a 回复一个含 ACK 的报文 s2 那么：

- **step 1:** a 向 b 发送的时候，`timestamp` 中存放的内容就是 a 主机发送时的内核时刻 `ta1`。
- **step 2:** b 向 a 回复 s2 报文的时候，`timestamp` 中存放的是 b 主机的时刻 `tb`, `timestamp echo`字段为从 s1 报文中解析出来的 ta1。
- **step 3:** a 收到 b 的 s2 报文之后，此时 a 主机的内核时刻是 ta2, 而在 s2 报文中的 timestamp echo 选项中可以得到 `ta1`, 也就是 s2 对应的报文最初的发送时刻。然后直接采用 ta2 - ta1 就得到了 RTT 的值。




### 防止序列号回绕问题

因为每次发包的时候都是将发包机器当时的内核时间记录在报文中，那么两次发包序列号即使相同，时间戳也不可能相同，这样就能够区分开两个数据包了。





## TCP的三次握手和四次挥手

### （1）三次握手

>  通过三次握手来确定双方都有发送和接收的能力

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态

**第一次握手：** 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。

**第二次握手：** 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。

**第三次握手：** 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-rTUXPD.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-rTUXPD.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-rTUXPD.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-rTUXPD.webp" loading="lazy"/>
  </picture>





### 双方同时发 `SYN`报文

这是一个可能会发生的情况。

状态变迁如下:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-LX9pJG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-LX9pJG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-LX9pJG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-LX9pJG.webp" loading="lazy"/>
  </picture>

在发送方给接收方发`SYN`报文的同时，接收方也给发送方发`SYN`报文，两个人刚上了!

发完`SYN`，两者的状态都变为`SYN-SENT`。

在各自收到对方的`SYN`后，两者状态都变为`SYN-REVD`。

接着会回复对应的`ACK + SYN`，这个报文在对方接收之后，两者状态一起变为`ESTABLISHED`。





### （2）四次挥手

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

第一次：客户端要断开了，向服务器发送 `FIN` 报文，发送后客户端变成了`FIN-WAIT-1`状态。注意, 这时候客户端同时也变成了`half-close(半关闭)`状态，即无法向服务端发送报文，只能接收。

第二次：服务端接收后向客户端确认，变成了`CLOSED-WAIT`状态。客户端接收到了服务端的确认，变成了`FIN-WAIT2`状态。

第三次：服务端向客户端发送`FIN`，自己进入`LAST-ACK`状态，

第四次：客户端收到服务端发来的`FIN`后，自己变成了`TIME-WAIT`状态，然后发送 ACK 给服务端。客户端需要等待 2 个 `MSL`(`Maximum Segment Lifetime，报文最大生存时间`)（一个MSL大概是2分钟）, 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-YZc84w.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-YZc84w.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-YZc84w.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-YZc84w.webp" loading="lazy"/>
  </picture>

TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。





### 保活计时器（keepalive timer）

接收端每收到一次发送端的数据就重新设置保活计时器（时间的设置一般是两小时）。若两小时内没收到发送端的数据，接收端就发送一个探测报文段，每隔75秒发送一次，若发了10个后都无响应则认为出故障关闭连接。





## 半连接队列和 SYN Flood 攻击

三次握手前，服务端的状态从`CLOSED`变为`LISTEN`, 同时在内部创建了两个队列：**半连接队列**和**全连接队列**，即**SYN队列**和**ACCEPT队列**。

### 半连接队列

当客户端发送`SYN`到服务端，服务端收到以后回复`ACK`和`SYN`，状态由`LISTEN`变为`SYN_RCVD`，此时这个连接就被推入了**SYN队列**，也就是**半连接队列**。

### 全连接队列

当客户端返回`ACK`, 服务端接收后，三次握手完成。这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是**全连接队列(Accept Queue)**。

### SYN Flood 攻击原理

SYN Flood 属于典型的 DoS/DDoS 攻击。其攻击的原理很简单，就是用客户端在短时间内伪造大量不存在的 IP 地址，并向服务端疯狂发送`SYN`。对于服务端而言，会产生两个危险的后果:

1. 处理大量的`SYN`包并返回对应`ACK`, 势必有大量连接处于`SYN_RCVD`状态，从而占满整个**半连接队列**，无法处理正常的请求。
2. 由于是不存在的 IP，服务端长时间收不到客户端的`ACK`，会导致服务端不断重发数据，直到耗尽服务端的资源。

### 如何应对 SYN Flood 攻击？

1. 增加 SYN 连接，也就是增加半连接队列的容量。
2. 减少 SYN + ACK 重试次数，避免大量的超时重发。
3. 利用 SYN Cookie 技术，在服务端接收到`SYN`后不立即分配连接资源，而是根据这个`SYN`计算出一个Cookie，连同第二次握手回复给客户端，在客户端回复`ACK`的时候带上这个`Cookie`值，服务端验证 Cookie 合法之后才分配连接资源。







## TFO (TCP Fast Open）

### 首轮三次握手

首先客户端发送`SYN`给服务端，服务端接收到。

注意哦！现在服务端不是立刻回复 SYN + ACK，而是通过计算得到一个`SYN Cookie`, 将这个`Cookie`放到 TCP 报文的 `Fast Open`选项中，然后才给客户端返回。

客户端拿到这个 Cookie 的值缓存下来。后面正常完成三次握手。

### 后面的三次握手

在后面的三次握手中，客户端会将之前缓存的 `Cookie`、`SYN` 和`HTTP请求`(是的，你没看错)发送给服务端，服务端验证了 Cookie 的合法性，如果不合法直接丢弃；如果是合法的，那么就正常返回`SYN + ACK`。

重点来了，现在服务端能向客户端发 HTTP 响应了！这是最显著的改变，三次握手还没建立，仅仅验证了 Cookie 的合法性，就可以返回 HTTP 响应了。

当然，客户端的`ACK`还得正常传过来，不然怎么叫三次握手嘛。

流程如下:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-1I0nVE.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-1I0nVE.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-1I0nVE.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-1I0nVE.webp" loading="lazy"/>
  </picture>

注意: 客户端最后握手的 ACK 不一定要等到服务端的 HTTP 响应到达才发送，两个过程没有任何关系。










## 可靠传输的原理

### 超时重传

（Retransmission TimeOut, 简称RTO）

#### 停止等待协议（不用这个了）

每发送完一个报文段就停止发送，等待对方确认，收到确认后再发下一个报文段。每发完一个报文段设置一个超时计时器。



#### 连续ARQ协议&滑动窗口

##### 连续ARQ协议 

ARQ（Automatic Repeat reQuest）

TCP给每个数据包都分配了一个序列号用于顺序化，发送方维持一个发送窗口，位于发送窗口内的报文段可以连续发送出去，不需要等待对方确认。

接收方采用==累积确认==，收到几个报文段后，对按序到达对最后一个报文段发送确认，即这个序号前的报文段都已收到。但也可能会导致**Go-back-N** 

##### 以字节为单位的滑动窗口

发送窗口

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lFqJGD.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lFqJGD.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lFqJGD.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-lFqJGD.webp" loading="lazy"/>
  </picture>

接收窗口

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Qo3Mfo.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Qo3Mfo.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Qo3Mfo.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-Qo3Mfo.webp" loading="lazy"/>
  </picture>





##### 选择性重传（没有用上这个）

(SACK，Selective Acknowledgment)

为了解决Go-back-N

在收到发送端的报文后，接收端回复一个 ACK 报文，在这个报文首部的可选项中，加上`SACK`属性，通过`left edge`和`right edge`告知发送端已经收到了哪些区间的数据报。因此，即使第 5 个包丢包了，当收到第 6、7 个包之后，接收端依然会告诉发送端，这两个包到了。剩下第 5 个包没到，就重传这个包。然而SACK文档没有指明发送方应怎样响应SACK，因此大多数的实现还是重传所有未被确认的数据块。





#### 如何确定超时重传的时间

##### 经典方法

SRTT =  (α * SRTT) + ((1 - α) * RTT)

α 是**平滑因子**，建议值是`0.8`，范围是`0.8 ~ 0.9`。

拿到 SRTT，我们就可以计算 RTO 的值了:

```js
RTO = min(ubound, max(lbound, β * SRTT))
```

β 是加权因子，一般为`1.3 ~ 2.0`， **lbound** 是下界，**ubound** 是上界。

##### 标准方法

为了解决经典方法对于 RTT 变化不敏感的问题，后面又引出了标准方法，也叫`Jacobson / Karels 算法`。

一共有三步。

**第一步**: 计算`SRTT`，公式如下:

```js
SRTT = (1 - α) * SRTT + α * RTT
```

注意这个时候的 `α`跟经典方法中的`α`取值不一样了，建议值是`1/8`，也就是`0.125`。

**第二步**: 计算`RTTVAR`(round-trip time variation)这个中间变量。

```js
RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|)
```

β 建议值为 0.25。这个值是这个算法中出彩的地方，也就是说，它记录了最新的 RTT 与当前 SRTT 之间的差值，给我们在后续感知到 RTT 的变化提供了抓手。

**第三步**: 计算最终的`RTO`:

```js
RTO = µ * SRTT + ∂ * RTTVAR 
```

`µ`建议值取`1`, `∂`建议值取`4`。



### 流量控制

#### 利用滑动窗口

发送方的发送窗口不能超过接收方的接收窗口的数值。双方三次握手时初始化各自的窗口大小。如果接收端的接收窗口需要变小，则接收端会在 ACK 的报文首部带上缩小后的滑动窗口 140 字节，发送端对应地调整发送窗口的大小为 140 个字节。

TCP为每一个连接设有一个持续计时器，只要收到零窗口通知就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），对方给出回应，如果仍然为零则重新设置持续计时器。这样就可以避免一直等待非零窗口通知（因为非零窗口通知可能在传输时丢失了）。



#### Nagle 算法（针对发送方）

使发送方不发送很小的报文段。

试想一个场景，发送端不停地给接收端发很小的包，一次只发 1 个字节，那么发 1 千个字节需要发 1000 次。这种频繁的发送是存在问题的，不光是传输的时延消耗，发送和确认本身也是需要耗时的，频繁的发送接收带来了巨大的时延。

避免小包的频繁发送，这就是 Nagle 算法要做的事情。

具体来说，Nagle 算法的规则如下:

- 当第一次发送数据时不用等待，就算是 1byte 的小包也立即发送
- 后面发送满足下面条件之一就可以发了:
  - 数据包大小达到最大段大小(Max Segment Size, 即 MSS)或已达到发送窗口大小的一半
  - 之前所有包的 ACK 都已接收到

#### 延迟确认（针对接收方）

使接收方不把很小的窗口大小信息通知给对方。

糊涂窗口综合征（silly window syndrome）：比如TCP接收方的接收窗口只有一个字节，但向发送方发送确认，使得发送方一直发一个字节的报文段。

**延迟确认**(delayed ack)所做的事情就是 延迟等到接收缓存已有足够空间容纳一个最长的报文段或者等到接收缓存已有一半空闲的空间，然后合并 ACK再回复给发送端。TCP 要求这个延迟的时延必须小于500ms，一般操作系统实现都不会超过200ms。

不过需要主要的是，有一些场景是不能延迟确认的，收到了就要马上回复:

- 接收到了大于一个 frame 的报文，且需要调整窗口大小
- TCP 处于 quickack 模式（通过`tcp_in_quickack_mode`设置）
- 发现了乱序包





### 拥塞控制

**流量控制**发生在发送端跟接收端之间，并没有考虑到整个网络环境的影响，如果说当前网络特别差，特别容易丢包。而这，也正是`拥塞控制`需要处理的问题

#### 拥塞窗口

拥塞窗口（Congestion Window，cwnd）是指目前自己还能传输的数据量大小。

```
发送窗口大小 = min(rwnd, cwnd)
```

取两者的较小值。而拥塞控制，就是来控制`cwnd`的变化。



#### 四种拥塞控制的算法

##### 慢启动

刚开始进入传输数据的时候，你是不知道现在的网路到底是稳定还是拥堵的，如果做的太激进，发包太急，那么疯狂丢包，造成雪崩式的网络灾难。

因此，拥塞控制首先就是要采用一种保守的算法来慢慢地适应整个网路，这种算法叫`慢启动`。运作过程如下:

- 首先，三次握手，双方宣告自己的接收窗口大小
- 双方初始化自己的**拥塞窗口**(cwnd)大小
- 在开始传输的一段时间，发送端每收到一个 ACK，拥塞窗口大小加 1，也就是说，每经过一个 RTT，cwnd 翻倍。如果说初始窗口为 10，那么第一轮 10 个报文传完且发送端收到 ACK 后，cwnd 变为 20，第二轮变为 40，第三轮变为 80，依次类推。

它的阈值叫做**慢启动阈值**，当 cwnd 到达这个阈值之后，就开始拥塞避免



##### 拥塞避免

在到达阈值后，如何来控制 cwnd 的大小呢？这就是拥塞避免做的事情了。

原来每收到一个 ACK，cwnd 加1，现在到达阈值了，cwnd 只能加这么一点: **1 / cwnd**。，一轮 RTT 下来，收到 cwnd 个 ACK, 那最后拥塞窗口的大小 cwnd 总共才增加 1。

也就是说，以前一个 RTT 下来，`cwnd`翻倍，现在`cwnd`只是增加 1 而已。





##### 快速重传

在 TCP 传输的过程中，如果发生了丢包，即接收端发现数据段不是按序到达的时候，接收端的处理是重复发送之前的 ACK。比如第 5 个包丢了，即使第 6、7 个包到达的接收端，接收端也一律返回第 4 个包的 ACK。快重传算法规定，当发送端收到 3 个重复的 ACK 时，意识到丢包了，于是马上进行这个包的重传，不用等到一个 RTO 的时间到了才重传。





##### 快速恢复

发送端收到三次重复 ACK 之后，发现丢包，觉得现在的网络已经有些拥塞了，自己会进入**快速恢复**阶段。

在这个阶段，发送端如下改变：

- 拥塞阈值（即慢开始阈值）降低为 cwnd 的一半

- cwnd 的大小变为拥塞阈值（即慢开始阈值）

  





# 网络层





## IP协议 

（看书）

主要就是IP协议，性能至上：无连接、非可靠、无确认。路由器---连接不同网络的设备。网络层地址IP（Internet Protocol address）--- 实现大型网络间的传输。

IP寻址

选路

封装打包

分片



## 子网掩码

子网掩码表示网络号与主机号之间的边界。



## ipv4与ipv6的区别

1. 地址空间不同：IPv4使用32位地址，IPv6使用128位地址。IPv4的地址空间是有限的，只能支持大约42亿个地址，而IPv6的地址空间非常庞大，可以支持340,282,366,920,938,000,000,000,000,000,000,000,000个地址。这种区别的实际例子就是，由于IPv4地址空间的限制，互联网上的IP地址在不断枯竭，这就是为什么IPv6得到了广泛应用的原因之一。
2. 地址表示不同：IPv4的地址是以点分十进制的形式表示的，例如 192.168.1.1；IPv6地址是以冒号分隔的16进制组表示的，例如 2001:0db8:85a3:0000:0000:8a2e:0370:7334。IPv6的地址表示更加简洁和灵活，使得地址的识别和验证更加容易。
3. 前缀长度不同：IPv4使用子网掩码来确定网络中可用的IP地址数量，IPv6使用前缀长度。通常，IPv6前缀长度为64位。例如，一个IPv6地址可能为2001:db8:85a3::8a2e:370/64。这个地址中的前64位是网络前缀，剩余的64位是主机标识。这种方式使得IPv6更加灵活，可以更好地适应不同的网络拓扑结构。
4. 安全性不同：IPv6比IPv4更加安全。IPv6支持IPsec协议，这是一种用于保护数据传输的协议。IPsec可以提供点对点的安全性，它还可以在数据包通过多个路由器时保护数据包。
5. 业界支持不同：IPv4已经被广泛使用，并被广泛支持。IPv6的支持取决于不同地区和网络服务提供商的不同。虽然IPv6已经被广泛部署，但某些地区和网络运营商可能不支持IPv6。
6. 兼容性不同：IPv4和IPv6之间并不兼容。因此，在升级过程中需要大量的工作，以保证两个网络之间的互通性。例如，在IPv6部署期间，网络管理员可能需要使用各种技术来使IPv4和IPv6之间兼容，例如双栈（dual stack）技术、隧道技术等。



## 路由表

路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的最短距离。这种更新算法又称为距离向量算法。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717104002493.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717104002493.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717104002493.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717104002493.png" loading="lazy"/>
  </picture>



## 内部网关协议

### RIP协议

RIP协议的特点：

（1）仅和相邻路由器交换信息。

（2）通过UDP协议向相邻路由器交换信息。路由器交换的信息是当前本路由器所知道的全部信息，即自己现在的路由表（距离和下一跳路由）。

（3）按固定的时间间隔交换路由信息，例如，每隔30秒。



### OSPF协议

开放最短路径优先（Open Shortest Path First）。

#### 特点

（1）向本自治系统中所有路由器发送信息。这里使用的方法是洪泛法（flooding），这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。

（2）发送的信息就是与本路由器相邻的所有路由器的链路状态。所谓“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量” （metric）。OSPF将这个“度量”用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员来决定，因此较为灵活。而且规定只有路由器到达网络有开销，网络到达路由器没有开销。

（3）只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。

所有的路由器最终都能建立一个全网的拓扑结构图。



#### 划分区域

为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域（area）。图4-34就表示一个自治系统划分为四个区域。每一个区域都有一个32位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路由器最好不超过200个。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717112610826.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717112610826.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717112610826.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717112610826.png" loading="lazy"/>
  </picture>

划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑。为了使每一个区域能够和本区域以外的区域进行通信，OSPF使用层次结构的区域划分。在上层的区域叫做主于区域（backbonearea）。主干区域的标识符规定为0.0.0.0。从其他区域来的信息都由区域边界路由器（areaborderrouter）进行概括。在图4-34中，路由器R3，R4和R7都是区域边界路由器。在主干区域内的路由器叫做主干路由器（backbonerouter），如R3，R4，R5，R6和R7。一个主干路由器可以同时是区域边界路由器，如R3，R4和R7。在主区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做 自治系统边界路由器（如图中的R6）。
     OSPF不用UDP而是直接用IP数据报传送（其IP数据报首部的协议字段值为89）。OSPF构成的数据报很短。这样做可减少路由信息的通信量。





## 外部网关协议 -- BGP

通过TCP协议来 传输RIB（Routing Information Base）信息

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717114011345.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717114011345.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717114011345.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220717114011345.png" loading="lazy"/>
  </picture>





# ARP协议

## 介绍

ARP（Address Resolution Protocol）：在同一个局域网上根据IP地址找MAC地址。在主机ARP高速缓存中放一个IP地址到硬件地址的映射表，且这个映射表经常动态更新。每一台主机都有一个ARP高速缓存（ARP cache），里面是本局域网上的各主机和路由器的IP地址到硬件地址到映射表。

当主机A要向本局域网上的某台主机B发送IP数据报时，就先在其ARP高速缓存中查看有无主机B的IP地址。如有，就在ARP高速缓存中查出其对应的硬件地址，再把这个硬件地址写入MAC帧，然后通过局域网把该MAC帧发往此硬件地址。如查不到，主机A就自动运行ARP按以下步骤找出主机B的硬件地址。

（1） ARP 进程在本局域网上广播发送一个ARP请求分组。

（2）在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组。

（3）主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机A发送ARP响应分组，同时把主机A的这一地址映射写入主机B自己的ARP 高速缓存中。其余的主机都不理睬这个ARP请求分组。ARP响应分组是普通的单播。

（4）主机A收到主机B的ARP响应分组后，就在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射。



## 四种典型情形

（1）发送方是主机（如H1），要把IP 数据报发送到同一个网络上的另一台主机（如H2）。这时H1发送ARP请求分组（在网1上广播），找到目的主机H2的硬件地址。

（2）发送方是主机（如H1），要把IP数据报发送到另一个网络上的一台主机（如H3或H4）。这时H1发送ARP请求分组（在网1上广播），找到网1上的一个路由器R1的硬件地址。剩下的工作由路由器R1来完成。R1要做的事情是下面的（3）或（4）。

（3）发送方是路由器（如R1），要把IP数据报转发到与R1连接在同一个网络（网2）上的主机（如H3）。这时R1发送ARP请求分组（在网2上广播），找到目的主机H3的硬件地址。

（4）发送方是路由器（如R1），要把IP数据报转发到网3上的一台主机（如H4）。H4与R1不是连接在同一个网络上。这时R1发送 ARP请求分组（在网2上广播），找到连接在网2上的一个路由器R2的硬件地址。剩下的工作由这个路由器R2来完成。





# 数据链路层

交换机---在同一网络下连接不同主机的设备。 链路层地址MAC（Media Access Control Address），一个设备对应一个固定的MAC地址。---- 实现本地网络设备间的直接传输。

linux系统中直接输入`ifconfig`查看

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220716172816406.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220716172816406.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220716172816406.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220716172816406.png" loading="lazy"/>
  </picture>



数据链路层如何传输数据：接收来自网络层的数据报，根据IP地址确定目标mac地址，对内容进行透明传输处理和差错检测生成，如果长度过大进行分割操作，然后加上帧首部和尾部下发给物理层传输。



逻辑链路控制

媒体访问控制

封装链路层帧

MAC寻址

差错检测与处理

定义物理层标准

 

