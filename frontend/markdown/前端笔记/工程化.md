# 前端工程

## 定义

在规模化前端项目开发的场景下，利用标准化的，可衡量的工具、流程和系统，提升效率、质量，降低前端研发成本，服务好企业与前端开发者的需求。

![image-20230729194948647](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-29-19-49-image-20230729194948647.png)

![image-20230729194833788](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-29-19-48-image-20230729194833788.png)





![image-20220823171629523](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20220823171629523.png)



## CI/CD

<mark>前端只需要关注持续集成和持续部署。</mark>

CI/CD 是持续集成（Continuous Integration）和持续交付/持续部署（Continuous Delivery/Continuous Deployment）的缩写。它是一种软件开发流程和方法论，旨在加快软件交付的速度、提高质量和降低风险。以下是对 CI/CD 的简要介绍：

1. 持续集成（Continuous Integration，CI）： 持续集成是指开发团队频繁地将代码提交到共享代码库（如版本控制系统）中，然后自动构建、测试和验证这些代码。CI 的目标是尽早发现代码集成问题，确保团队成员的工作能够顺利地合并到主干分支，并减少冲突。
2. 持续交付（Continuous Delivery，CD）： 持续交付是在持续集成的基础上，进一步将代码构建、测试和打包成可发布的产物。这些产物可以随时准备好发布到生产环境，但还需要手动触发。持续交付确保代码始终处于可发布状态，从而缩短交付周期。
3. 持续部署（Continuous Deployment，CD）： 持续部署是在持续交付的基础上，自动地将经过测试的代码部署到生产环境中，而无需人工干预。持续部署实现了自动化的端到端交付流程，使软件能够更快地到达用户手中，同时降低发布时的风险。

CI/CD 的核心目标是自动化和加速软件交付流程，以及确保代码的质量和稳定性。通过自动化构建、测试、部署等过程，团队可以更频繁地发布新功能、修复问题和改进产品，从而提供更好的用户体验，并在竞争激烈的市场中保持敏捷性和创新力。



## 工程化的意义

定位问题、发现问题、解决问题是问题处理的常见步骤，工程化的意义便是将解决同一类问题的手段进行沉淀，将解决方案规范化、系统化，避免同一类问题重复出现。当同一类问题再次发生时，开发人员也能基于现有的方案进行快速处理



# 规范

## 编码规范

在Node中，异步使用非常广泛并且在实践过程中形成了一些约定。

1．异步回调函数的第一个参数应该是错误指示该部分内容在第4章中有所提及。

2．执行传入的回调函数在异步方法中一旦有回调函数传入，就一定要执行它，且不能多次执行。如果不执行，可能造成调用一直等待不结束，多次执行也可能会造成未期望的结果。



## 命名规范

### case

camelCase 还是 PascalCase 还是 kebab-case 还是 snake_case

### js命名规范

1．变量命名变量名都采用小驼峰式命名，即除了第一个单词的首字母不大写外，每个单词的首字母都大写，词与词之间没有任何符号

2．方法命名方法命名与变量命名一样，采用小驼峰式命名。与变量不同的是，方法名尽量采用动词或判断性词汇

3．类命名类名采用大驼峰式命名，即所有单词的首字母都大写

4．常量命名作为常量时，单词的所有字母都大写，并用下划线分割





### 版本命名规范-SemVar语义化

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。





### npm包命名规范

只能用 “数字、小写字母、_“命名。



### node文件命名

命名文件时，请尽量采用下划线分割单词，比如child_process.js和string_decode.js。如果你不想将文件暴露给其他用户，可以约定以下划线开头，如_linklist.js。



### 目录结构和命名规范

#### 图示

├── api-docs/                  # 接口文档
├── dist/                      # 构建输出目录
├── node_modules/              # 依赖文件
├── plugins/                   # 插件相关
├── src/                        # 源代码
│  	├── @pet                   # pet 组件市场
│   ├── assets/                # 静态资源
│   ├── types/                  # 公共类型
│   ├── gen/                  # 自动生成的文件
│   │   └── swagger/           # 接口文档（git ignore
│   ├── common/                # 公共文件
│   ├── styles/                # 样式
│   ├── utils/                 # 工具函数
│   ├── models/                # 状态管理
│   ├── hooks/                 # 可复用的逻辑
│   ├── components/            # 组件
│   ├── views/                 # 页面
│   ├── router/                # 路由
│   ├── App.vue                # 根组建
│   └── mian.js                # 入口文件
├── .eslintrc.cjs              # eslint 配置文件
├── index.html                 # 入口文件
├── openapi-generator-typescript.jsonc        # openai 配置文件
├── package.json                # 项目配置文件
├── pet-project.config.json     # pet 配置文件
├── postcss.config.js    # 接了preset之后再删掉postcss.config.js文件
├── README.md                   # 项目说明文档
├── tsconfig.json               # ts 配置文件
├── vite.config.mts             # vite 配置文件
└── vitest.config.ts            # vitest 配置文件



#### **目录结构说明**

##### **api-docs/**

项目的API 文档，与服务端接口保持同步。



##### **plugin/**

定义使用的一些插件，比如 vite 的 plugin。

##### **src/**

源代码目录，包含了项目的全部源代码。

- pet：pet 组件市场 

- assets/：静态资源目录，包含了项目的图片。

- types/: 公共类型，包括一些常量的定义。

- gen/: 自动生成的文件

- - swagger/：API文档，根据服务端配置自动生成，可以直接使用 schemas 中的类型。（git ignore）

- common/：无法归类为具体 utils 或者 hooks 等的文件， 如 logger

- styles/：样式，定义公共样式、变量等。

- utils/：工具函数，包括引入的第三方 lib。

- models/：状态管理，获取数据并集中处理。

- hooks/：定义可复用的逻辑。

- components/：组件目录，包含了项目的全部组件。

- pages/：页面目录，包含了项目的全部页面。

- - fragment-live：精彩片段页，没有重写完。【未使用】
  - home：兜底首页
  - live：直播页
  - long-video：中视频页
  - photo：视频及各类图片视频页
  - playback：回放页，没有重写完。【未使用】
  - tag：标签页
  - user：个人页

- router/：路由目录，包含了项目的路由配置。

- App.vue：根组件

- main.ts：项目的入口文件。

##### **index.html**

入口文件，加载根组件。





##### hooks和utils目录的区别

dyc认为 utils一般都是纯函数，hooks应该是有很多副作用的。

Hooks 目录：

Hooks 目录用于存放自定义的 Vue Composition API hooks。在 Vue 3 中，Composition API 提供了一种更灵活和强大的方式来组织组件逻辑，通过将逻辑封装成独立的函数（即 hooks），可以实现逻辑的复用和组件的解耦。

Hooks 目录适合存放一些和业务逻辑紧密相关的代码，例如：

- API 请求封装：封装与 API 请求相关的逻辑，包括发送请求、处理响应、错误处理等。
- 表单处理：封装表单的状态管理、验证逻辑和提交处理等。
- 状态管理：封装一些全局状态的逻辑，例如数据缓存、用户登录状态等。
- 动画处理：封装一些动画效果的逻辑，例如动画的触发、控制和状态管理等。

使用 Hooks 目录时，你可以将这些逻辑抽象成可复用的 hooks，并在需要的组件中通过 Composition API 的 `setup` 函数调用这些 hooks，从而实现逻辑的共享和复用。

Utils 目录：

Utils 目录用于存放通用的辅助函数、工具函数和帮助函数，它们是一些独立的、与业务逻辑无关的功能函数。

Utils 目录适合存放一些不依赖于 Vue 或特定框架的通用代码，例如：

- 辅助函数：一些通用的辅助函数，用于简化代码、提高代码的可读性和可维护性。
- 工具函数：一些常用的工具函数，例如日期处理、字符串处理、数组处理等。
- 帮助函数：一些通用的帮助函数，例如深拷贝、对象合并、错误处理等。

使用 Utils 目录时，你可以将这些通用的函数放置在 Utils 目录下，并在需要的地方导入和使用这些函数，从而实现代码的复用和维护。



#### **最佳实践**

##### **命名规范**

- 组件的文件名使用 **PascalCase** 命名方式，避免使用 index.vue 作为文件名

- 所有文件命名使用「小写+中划线分割」方式命名；

- assets/ 下面不再继续细分，不同类型的文件都放一起
- 推荐把页面、组件自己用到的 assets、components、types 放到自己的子目录下
- modules/ 是按功能模块划分（在春节项目中对应不同的分会场），pages/ 对应真实的路由页面





##### **约束**

- 路由内部组件、函数不可被其他路由引用
- utils 内部不允许从 utils/index.ts 引用 re-export 的内容

- 不允许跨modules引用模块







# 包管理



## NVM（Node Version Manager)

NVM（Node Version Manager）作用：

- 用于管理 Node.js 版本的工具。它允许您在同一台计算机上同时安装和切换不同版本的 Node.js。







## NPM

### 安装

在Node的安装过程中，实际上还会安装上NPM工具。





### 搭建局域NPM

《深入浅出Node.js》







### 简介

npm 作为 Node.js 生态系统的一部分，是 Node.js 的官方包管理工具，用于管理和分发 JavaScript 包。 npm 会随着 Node.js 的安装而一同安装。

npm 由两个主要部分组成:

- 用于发布和下载程序包的 CLI（命令行界面）工具
- 托管 JavaScript 程序包的  [在线存储库](https://www.npmjs.com/)

npm 的客户端是使用 JavaScript 编写的，它是一个基于命令行的工具，用于管理和分发 JavaScript 包。npm 的服务器端则是使用 Node.js 编写的，用于托管和维护 npm 仓库，处理包的发布、下载和管理等任务。



### npm 缓存

#### 介绍

当您在计算机上安装npm软件包时，npm会首先将软件包和依赖关系添加到您本地的npm缓存文件夹中。然后npm会将这些包安装到本地项目的node_modules文件夹中。在将来，如果你安装任何相同的包，npm会直接从你的缓存中安装，而不需要再次从npm下载。不过，有时如果安装了不同版本的依赖包，缓存可能会被破坏，并相互冲突。清除缓存可以让你从npm重新安装软件包，重新开始。

NPM 缓存具有以下特点和作用：

1. **提高安装速度：** 当您再次安装相同版本的包时，NPM 可以从缓存中读取并复用已下载的包，而无需再次下载。
2. **离线安装：** 如果之前已经下载过某个包并存储在缓存中，您可以在离线状态下安装该包，无需再次访问网络。
3. **版本管理：** 缓存按照依赖包的名称和版本进行存储。这允许在同一台计算机上同时安装多个版本的包，并且可以根据项目的需求进行版本切换。





#### 缓存机制

##### 介绍

>  npm will not remove data by itself: the cache will grow as new packages are installed.

npm install在执行的时候，首先构建依赖树，依次安装依赖树中的每个包。

如果缓存中有依赖包，就会向远程仓库确认是否过期（304检查）检查，如果过期，就使用新的返回数据刷新缓存，否则就直接使用缓存中的数据。

另外根据是否离线或失去对目标远程仓库的访问权限，npm还提供了fallback-to-offline模式。该模式使无法访问远程仓库的情况下，npm将直接使用本地缓存。 无论何时离线，npm都会尽可能地回退到缓存中-而不是坚持重试网络请求或失败。



##### 参数指定缓存使用的策略

--prefer-offline: 将使npm跳过任何条件请求（304检查）直接使用缓存数据，只有在缓存无法匹配到的时候，才去访问网络。这样我们将依赖包添加到项目的过程就会快很多。

例如，npm install express --prefer-offline将现在缓存中匹配express，只有在本地缓存没有匹配到的情况下，才去联网下载。

--prefer-online: 与它将强制npm重新验证缓存的数据（使用304检查），并使用重新验证的新鲜数据刷新缓存。

--offline 将强制npm使用缓存或退出。如果尝试安装的任何内容尚未在缓存中，则它将出现代码错误。

可以通过.npmrc或者npm config set来设置缓存使用的策略。

一个新的npm cache verify命令，它将对你的缓存进行垃圾回收，减少不需要的东西占据的磁盘使用量，并且会对索引和内容进行全面的完整性验证







#### 查看 NPM 缓存

在 macOS 上，NPM 缓存默认位于用户主目录下的 `.npm` （~/.npm/cacache）或 `.npm-cache` 目录中。（请注意，`.` 开头的文件和目录在 macOS 中是隐藏的，因此您需要使用命令行或在 Finder中 `command + shift + . `来查看 `.npm` 目录。）

如果您使用的是不同的 NPM 缓存目录或已自定义 NPM 缓存路径，可以通过运行以下命令来查看当前配置的 NPM 缓存路径：

```
npm config get cache
```

该命令将显示当前配置的 NPM 缓存路径，您可以使用终端或 Finder 打开该路径来访问缓存目录。



#### 管理缓存

- `npm cache clean --force `  ：清理整个缓存。（所有通过缓存的数据在插入和提取时都经过完整性验证。缓存的损坏要么触发错误，要么向`pacote`发出信号，数据必须被重新刷新，pacote会自动这样做。出于这个原因，除了回收磁盘空间之外，永远不需要清除缓存，这就是为什么clean现在需要--force来运行。）<strong style="color: red"> `npm cache clean --force` 清的是 `~/.npm/_cacache` 整个文件夹。</strong>

  ```js
  //找到npm中跟cache相关的代码，然后直接看clean方法的实现（具体代码可以看lib/cache.js）：(https://github.com/npm/cli/tree/latest/lib)
  function clean (args) {
        if (!args) args = []
        if (args.length) {
          return BB.reject(new Error('npm cache clear does not accept arguments'))
        }
      
        // 重点在这
        // npm.cache就是 ~/.npm
        // 所以cachePath的值应该是 ~/.npm/_cacache
        const cachePath = path.join(npm.cache, '_cacache')
        if (!npm.config.get('force')) {
          return BB.reject(new Error("As of npm@5, the npm cache self-heals from corruption issues and data extracted from the cache is guaranteed to be valid. If you want to make sure everything is consistent, use 'npm cache verify' instead. On the other hand, if you're debugging an issue with the installer, you can use `npm install --cache /tmp/empty-cache` to use a temporary cache instead of nuking the actual one.\n\nIf you're sure you want to delete the entire cache, rerun this command with --force."))
        }
        // TODO - remove specific packages or package versions
        return rm(cachePath)
      }
  ```

  

- `npm cache verify`：验证缓存的完整性。将对你的缓存进行垃圾回收，减少不需要的东西占据的磁盘使用量，并且会对索引和内容进行全面的完整性验证。

- `npm cache add <package-name>@<version>`：将特定版本的包添加到缓存中。

- `npm cache ls`：列出缓存中已安装的包。

需要注意的是，NPM 缓存只适用于全局安装的包和局部安装的包的共享模块。对于局部安装的包，它们会存储在项目的 `node_modules` 目录中，而不是 NPM 缓存中。



#### ~/.npm/cacache目录介绍

##### 简介版

`~/.npm/_cacache` 中存的是一些二进制文件，以及对应的索引。

npm install 时，有缓存的话，会通过 [pacote](https://www.npmjs.com/package/pacote) 把对应的二进制文件解压到相应的 `node_modules` 下面。

npm本身只提供清除缓存和验证缓存完整性的方法，不提供直接操作缓存的方法，可以通过 [cacache](https://www.npmjs.com/package/cacache) 来操作这些缓存数据。



##### 详尽版

~/.npm/cacache, 里面有三个文件夹。

打开 `_cacache` 文件夹，发现里面并不是像 `node_modules` 里面一样一个个的包，而是这样的：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/28/169344460af88644~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



打开可以发现 `content-v2` 里面基本都是一些二进制文件，把二进制文件的扩展名改为 `.tgz` 再解压之后，会发现就是在我们熟知的npm包。 `index-v5` 里面是一些描述性的文件，也是 `content-v2` 里文件的索引，仔细看会发现有点像HTTP的响应头，而且还有缓存相关的值：



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/28/169344460edf84ef~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)



那么这些文件是怎么生成的呢？从上面的文档中，可以得知，npm 主要是用 [pacote](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fpacote) 来安装包的，我们来看一下 npm 在代码中是怎么使用pacote的吧。npm主要有以下三个地方会用到 pacote：

- npm install xxx （通过 `pacote.extract` 把相应的包解压在对应的 `node_modules` 下面。npm 源码入口：[lib/install/action/extract-worker.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fcli%2Fblob%2Flatest%2Flib%2Finstall%2Faction%2Fextract-worker.js%23L17)，pacote 源码入口：[extract.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzkat%2Fpacote%2Fblob%2Flatest%2Fextract.js%23L19)）
- npm cache add xxx （通过 `pacote.tarball.stream` 往 `~/.npm/_cacache` 里增加缓存数据。npm 源码入口：[lib/cache.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fcli%2Fblob%2Flatest%2Flib%2Fcache.js%23L110)，pacote 源码入口：[tarball.js#tarballStream](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzkat%2Fpacote%2Fblob%2Flatest%2Ftarball.js%23L23)）
- npm pack xxx (通过 `pacote.tarball.toFile` 在当前路径生成对应的压缩文件。npm 源码入口：[lib/pack.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fcli%2Fblob%2Flatest%2Flib%2Fpack.js%23L92)，pacote 源码入口：[tarball.js#tarballToFile](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzkat%2Fpacote%2Fblob%2Flatest%2Ftarball.js%23L53))

对比上述三个 pacote 的方法可以发现，其主要依赖的方法是 [lib/withTarballStream.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fzkat%2Fpacote%2Fblob%2Flatest%2Flib%2Fwith-tarball-stream.js%23L19)，代码比较多，简化一下，主要看中文注释就好：

```dart
function withTarballStream (spec, opts, streamHandler) {
      opts = optCheck(opts)
      spec = npa(spec, opts.where)
    
      // 读本地文件
      const tryFile = (
        !opts.preferOnline &&
        opts.integrity &&
        opts.resolved &&
        opts.resolved.startsWith('file:')
      )
        ? BB.try(() => {
          const file = path.resolve(opts.where || '.', opts.resolved.substr(5))
          return statAsync(file)
            .then(() => {
              const verifier = ssri.integrityStream({ integrity: opts.integrity })
              const stream = fs.createReadStream(file)
                .on('error', err => verifier.emit('error', err))
                .pipe(verifier)
              return streamHandler(stream)
        })
        : BB.reject(Object.assign(new Error('no file!'), { code: 'ENOENT' }))
    
      // 上一步reject之后，从缓存中读
      const tryDigest = tryFile
        .catch(err => {
          if (
            opts.preferOnline ||
          !opts.cache ||
          !opts.integrity ||
          !RETRIABLE_ERRORS.has(err.code)
          ) {
            throw err
          } else {
    	    // 通过cacache来读缓存中的数据
            const stream = cacache.get.stream.byDigest(
              opts.cache, opts.integrity, opts
            )
            stream.once('error', err => stream.on('newListener', (ev, l) => {
              if (ev === 'error') { l(err) }
            }))
            return streamHandler(stream)
              .catch(err => {
                if (err.code === 'EINTEGRITY' || err.code === 'Z_DATA_ERROR') {
                  opts.log.warn('tarball', `cached data for ${spec} (${opts.integrity}) seems to be corrupted. Refreshing cache.`)
                  // 当错误码为EINTEGRITY或Z_DATA_ERROR时，清除缓存
                  return cleanUpCached(opts.cache, opts.integrity, opts)
                    .then(() => { throw err })
                } else {
                  throw err
                }
              })
          }
        })
    
      // 上一步reject之后，再下载
      const trySpec = tryDigest
        .catch(err => {
          if (!RETRIABLE_ERRORS.has(err.code)) {
          // If it's not one of our retriable errors, bail out and give up.
            throw err
          } else {
            return BB.resolve(retry((tryAgain, attemptNum) => {
    
    	      // 下载包，这边其实是通过npm-registry-fetch来下载的
              const tardata = fetch.tarball(spec, opts)
              if (!opts.resolved) {
                tardata.on('manifest', m => {
                  opts = opts.concat({ resolved: m._resolved })
                })
                tardata.on('integrity', i => {
                  opts = opts.concat({ integrity: i })
                })
              }
              return BB.try(() => streamHandler(tardata))
            }, { retries: 1 }))
          }
        })
    
      return trySpec
        .catch(err => {
          if (err.code === 'EINTEGRITY') {
            err.message = `Verification failed while extracting ${spec}:\n${err.message}`
          }
          throw err
        })
    }
```

从上述代码中，可以知道 pacote 是依赖 npm-registry-fetch 来下载包的。查看 npm-registry-fetch 的文档发现，在请求时有个 `cache` 属性可以设置：[npm-registry-fetch#opts.cache](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm-registry-fetch%23-optscache)。如果设置了 `cache` 的值(npm中是 `~/.npm/_cacache`)，便会在给定的路径下创建根据[IETF RFC 7234](https://link.juejin.cn?target=https%3A%2F%2Ftools.ietf.org%2Fhtml%2Frfc7234)生成的缓存数据。打开那个rfc的地址，发现就是描述 HTTP 缓存的文档，所以本段开头说的 `index-v5` 下面的文件也就好理解了。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/2/28/169344461679e65c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)













![image-20230713142330038](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-13-14-23-image-20230713142330038.png)

npm在安装依赖的时候，<strong style="color: red">根据package-lock中具体包的version,name和integrity信息（没有lock只能去请求registry了），用pacote:range-manifest:{url}:{integrity}生成唯一key，通过SHA256得到的hash，去_cacache/index-v5里找对应的文件</strong>，就能拿到基本的meta信息缓存了，前四位hash用来分路径 如果依赖信息改变了则生成的hash没有对应缓存信息可以命中，会重新下载再更新缓存。

![image-20230713143125607](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-13-14-31-image-20230713143125607.png)

这个shasum就是tar包的hash,用这个hash去_cacache/content-v2里找到对应的gzip（tgz)缓存，解压缩后得到对应依赖的tar包。















### .npmrc和package.json区别

1. .npmrc文件：这是npm的配置文件，用于配置npm的行为和设置。它通常位于项目的根目录下或用户的主目录下。.npmrc文件可以包含各种配置选项，如代理设置、镜像源、认证信息等。通过修改.npmrc文件，您可以自定义npm的行为，以适应您的项目需求。
2. package.json文件：这是npm项目的描述文件，它包含了项目的元数据和依赖信息。通过package.json文件，您可以管理和维护项目的依赖关系，并指定项目的入口文件、脚本命令等。<font color="red">每次执行跟包相关的命令前都会先校验package.json是否合法</font>

简而言之，.npmrc文件是用于配置npm的行为和设置，而package.json文件是用于描述npm项目的元数据和依赖信息。







## npm命令

### **npx**

#### 介绍

 `npx` 是 Node.js 提供的一种命令行工具，用于执行当前项目中安装的 npm 包的命令(即node_modules/.bin 下的本地命令)。它的主要作用是在不全局安装模块的情况下执行安装在项目中的模块。它将首先检查当前项目的 `node_modules` 目录是否有该命令可执行文件，<mark>如果没有，则会临时安装它并执行，用完就会删除。</mark>



npx 运行的时候，会到`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在。由于 npx 会检查环境变量`$PATH`，所以系统命令也可以调用。(注意，Bash 内置的命令不在`$PATH`里面，所以不能用。比如，`cd`是 Bash 命令，因此就不能用`npx cd`。)

> ```bash
> # 等同于 ls
> $ npx ls
> ```





#### 使用场景（参数介绍）



##### `--no-install` 参数和`--ignore-existing` 参数

如果想让 npx 强制使用本地模块，不下载远程模块，可以使用`--no-install`参数。如果本地不存在该模块，就会报错。

> ```bash
> $ npx --no-install http-server
> ```

反过来，如果忽略本地的同名模块，强制安装使用远程模块，可以使用`--ignore-existing`参数。比如，本地已经全局安装了`create-react-app`，但还是想使用远程模块，就用这个参数。

> ```bash
> $ npx --ignore-existing create-react-app my-react-app
> ```

##### 使用不同版本的 node

利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 [node 模块](https://www.npmjs.com/package/node)。

> ```bash
> $ npx node@0.12.8 -v
> v0.12.8
> ```

上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。

某些场景下，这个方法用来切换 Node 版本，要比 nvm 那样的版本管理器方便一些。

##### `-p` 参数

`-p`参数用于指定 npx 所要安装的模块，所以上一节的命令可以写成下面这样。

> ```bash
> $ npx -p node@0.12.8 node -v 
> v0.12.8
> ```

上面命令先指定安装`node@0.12.8`，然后再执行`node -v`命令。

`-p`参数对于需要安装多个模块的场景很有用。

> ```bash
> $ npx -p lolcatjs -p cowsay [command]
> ```

##### -c 参数

如果 npx 安装多个模块，默认情况下，所执行的命令之中，只有第一个可执行项会使用 npx 安装的模块，后面的可执行项还是会交给 Shell(壳) 解释。

> ```bash
> $ npx -p lolcatjs -p cowsay 'cowsay hello | lolcatjs'
> # 报错
> ```

上面代码中，`cowsay hello | lolcatjs`执行时会报错，原因是第一项`cowsay`由 npx 解释，而第二项命令`localcatjs`由 Shell(壳) 解释，但是`lolcatjs`并没有全局安装，所以报错。

`-c`参数可以将所有命令都用 npx 解释。有了它，下面代码就可以正常执行了。

> ```bash
> $ npx -p lolcatjs -p cowsay -c 'cowsay hello | lolcatjs'
> ```

`-c`参数的另一个作用，是将环境变量带入所要执行的命令。举例来说，npm 提供当前项目的一些环境变量，可以用下面的命令查看。

> ```bash
> $ npm run env | grep npm_
> ```

`-c`参数可以把这些 npm 的环境变量带入 npx 命令。

> ```bash
> $ npx -c 'echo "$npm_package_name"'
> ```

上面代码会输出当前项目的项目名。

##### 执行 GitHub 源码

npx 还可以执行 GitHub 上面的模块源码。

> ```bash
> # 执行 Gist 代码
> $ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32
> 
> # 执行仓库代码
> $ npx github:piuccio/cowsay hello
> ```

注意，远程代码必须是一个模块，即必须包含`package.json`和入口脚本。



##### **轻松地运行本地命令**

```sh
node_modules/.bin/vite -v
# vite/2.6.5 linux-x64 node-v14.16.0

# 等同于
# package.json script: "vite -v"
# npm run vite

npx vite -v
# vite/2.6.5 linux-x64 node-v14.16.0
```



##### **无需安装的命令执行**

```sh
# 启动本地静态服务
npx http-server

# 无需全局安装
npx @vue/cli create vue-project
```





### `npm exec` /`yarn exec`/`pnpm exec`

`npm exec` 是一个用于在项目中执行命令的命令行工具。它提供了一种在项目的上下文中执行命令的方式，可以确保命令在正确的环境中运行。

`npm exec` 命令的语法如下：

```
npm exec <command> [args]
```

其中，`<command>` 是要执行的命令，而 `[args]` 是传递给命令的参数（可选）。

使用 `npm exec` 的好处是，它会在执行命令之前自动设置正确的环境变量，以便命令能够访问项目的依赖项和其他配置。

以下是一些 `npm exec` 命令的示例：

- 执行本地安装的包：

  ```sh
  npm exec eslint -- --version
  ```

- 执行在 `scripts` 部分定义的脚本：

  ```sh
  npm exec lint
  ```

- 执行全局安装的包：

  ```sh
  npm exec -g create-react-app -- my-app
  ```

- 执行项目依赖的二进制文件：

  ```sh
  npm exec -- webpack --mode production
  ```

- 当命令与内置 pnpm 命令不冲突时， `exec` 部分实际上是可选的，因此您也可以运行：

```text
pnpm jest
```





### `npm run`命令

#### 介绍

查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的`npm run`命令。

> ```bash
> $ npm run
> ```



#### npm run 发生了什么

##### 全局命令与局部命令

我们以 `typescript` 为例，我们进行全局安装：

```
npm install typescript -g
```

执行以上命令之后，我们就获得了一个全局命令 `tsc`。我们就可以在终端输入 `tsc` 开头的命令。这是因为我们执行上面的命令代码之后会在系统变量 PATH 中设置的 node 命令所在的目录上写入了以下命令文件：

![tsc.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b619cfb2f884428a9badf37ea0a7da8d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

这样我们在终端输入 `tsc -v` 命令之后，命令解析器就可以通过系统变量 PATH 中设置目录路径找到对应的 `tsc` 命令。

如果我们进行局部安装：

```
npm install typescript -D
```

那么前面上面看到的那三个命令文件就会出现在当前目录的 `./node_modules/.bin` 文件目录下：

这个时候我们是不能直接通过终端执行 tsc 命令的，因为此时 tsc 命令文件所在的目录并没有在系统变量 PATH 中进行设置。

在上述文章中，我们知道命令还可以通过路径进行执行，所以我们可以以下方式执行：

```bash
./node_modules/.bin/tsc -v
复制代码
```

执行结果：

![tscdir.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7a945a6dcec4bac81611669d65c5402~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

还可以通过绝对路径执行：

![tscdirp.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5198eb619d8b49a2b9bad96eb67e79a4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)

这种方式相信大家都不会觉得陌生，我们通常在使用代码检测工具 ESLint 的时候，会先安装：

```css
npm install eslint --save-dev
复制代码
```

然后在根目录下执行以下命令：

```bash
./node_modules/.bin/eslint --init
复制代码
```

所以经过上面的解析，大家是不是豁然开朗了，原来是这么回事。本质就是通过指定命令路径执行命令。

这里顺便还说一个题外话。我们上述 ESLint 问题，还可以通过 npx 方式执行。

```csharp
npx eslint --init
复制代码
```

这是因为 npx 可以直接运行 `node_modules/.bin` 文件下的命令。npx 可以自动检查命令是否在 `node_modules/.bin` 目录中或者是否在系统环境变量 PATH 配置的目录路径中。npx 另外一个更实用的特点是，它在执行相关模块命令时会先进行依赖安装，但会在安装成功并执行完相关命令代码后便删除此依赖，从而避免了全局安装带来的问题。



### `npm install`

#### 介绍

别名：add, i, in, ins, inst, insta, instal, isnt, isnta, isntal, isntall

lock文件的优先级：

- `npm-shrinkwrap.json`
- `package-lock.json`
- `yarn.lock`



#### 参数

##### --production

With the `--production` flag (or when the `NODE_ENV` environment variable is set to `production`), npm will not install modules listed in `devDependencies`.





##### 默认是下载这个包的semver 范围运算符版本

可以通过`save-exact`参数使保存的依赖会被指定为一个确切的版本, 而不是使用 pnpm 的默认 semver range operator 配置.

Semantic Versioning（语义化版本）使用范围运算符来指定包的版本范围，以便在满足特定条件的情况下选择合适的包版本。这些运算符在依赖项声明中常用，以确保在升级或安装依赖项时，选择的版本符合预期的兼容性和功能需求。

以下是常见的 Semantic Versioning 范围运算符及其含义：

1. `^`（Caret）符号：允许在主版本号不变的情况下，升级次版本号和修订版本号。例如，`^1.2.3` 表示允许安装 1.2.3、1.2.4、1.3.0 等版本，但不包括 2.0.0。
2. `~`（Tilde）符号：允许在主版本号和次版本号不变的情况下，升级修订版本号。例如，`~1.2.3` 表示允许安装 1.2.3、1.2.4 等版本，但不包括 1.3.0。
3. `>`（大于号）：允许安装高于指定版本的任何版本。例如，`>1.2.3` 表示可以安装 1.2.4、1.3.0 等任何高于 1.2.3 的版本。
4. `<`（小于号）：允许安装低于指定版本的任何版本。例如，`<1.2.3` 表示可以安装 1.2.2、1.2.0 等任何低于 1.2.3 的版本。
5. `>=`（大于等于号）：允许安装高于或等于指定版本的任何版本。例如，`>=1.2.3` 表示可以安装 1.2.3、1.2.4、1.3.0 等任何高于或等于 1.2.3 的版本。
6. `<=`（小于等于号）：允许安装低于或等于指定版本的任何版本。例如，`<=1.2.3` 表示可以安装 1.2.3、1.2.2、1.2.0 等任何低于或等于 1.2.3 的版本。
7. `=`（等号）：指定精确的版本号。例如，`=1.2.3` 表示只能安装 1.2.3 版本。
8. `-`（连字符）：指定一个版本范围区间。例如，`1.2.3 - 1.2.6` 表示安装从 1.2.3 到 1.2.6 之间的版本（包括边界版本）。
9. `||`（逻辑或）：指定多个不同的版本范围，任何一个范围匹配就可以满足依赖关系。例如，`<1.0.0 || >=2.3.0` 表示可以安装小于 1.0.0 或大于等于 2.3.0 的版本。

这些运算符可以组合使用，以创建更复杂的版本范围。在定义依赖关系时，正确选择版本范围运算符非常重要，以确保包的版本满足你的需求，同时不引入不兼容或不稳定的更新。





#### 执行 install之后，包如何到达node_modules 中

执行命令后，首先会构建依赖树（相当于node_modules内部的目录结构），然后针对每个节点下的包，会经历下面四个步骤:

- 将依赖包的版本区间解析为某个具体的版本号
- 下载对应版本依赖的 tar 包到本地离线镜像
- 将依赖从离线镜像解压到本地缓存
- 将依赖从缓存拷贝到当前目录的 node_modules 目录









###  `npm init` / `npm create`

从 npm 的官方文档发现  `npm create` 就等于 `npm init`。

- `npm init / npm create`：初始化一个 package(包).json 文件

- `npm init <initializer> / npm create <initializer>`：本质上是调用 `npm exec create-<initializer>` 命令, 也就相当于`npx create-<initializer>`。 `<initializer>`可以理解为一个简称，它真正的包名为`create-<initializer>`，也只有符合这种命名方式的npm包才可以执行这样的命令。

因此，以下命令可以达到与`npm create vue@latest`同样的效果：

```bash
npm init vue@latest # @latest 表示 tag，在使用包时应该明确指定 tag。如果你省略了 tag，npm 可能会解析为这个包的缓存的过时版本。在 npm 中，@latest 是默认的 tag，它表示你将使用最新的稳定版本。
npx create-vue@latest
npm exec create-vue@lates
```

比如`npm create vue` 执行流程

首先查找本地的 `create-vue` npm包，在其中找到 `package.json` 文件 `bin` 属性指明的可执行文件，即 `outfile.cjs`。

<mark>当本地不存在 `create-vue` 包时，会从远程源下载该包。(这是npm create 自带的能力)</mark>

```json
// package.json
{
  "bin": {
    "create-vue": "outfile.cjs"
  },
}
```





### `npm dist-tag ls create-vue `

查看某个包的版本号



### npm audit

npm audit命令会扫描当前项目使用的工具包版本，检测其是否存在漏洞。它要求当前目录下必须存在package-lock.json文件，否则会报错。

执行npm audit后，npm会对当前package-lock.json里的依赖版本进行分析扫描。

报告会显示当前项目中存在缺陷的依赖名称，该依赖的版本、路径、缺陷以及相关问题的链接。开发人员可以访问链接查看缺陷的具体描述，也可以运行npm audit fix一键修复。



npm audit fix只会自动升级不存在Breaking Changes的版本。如果存在Breaking Changes，那么会在输出信息中进行提示。开发人员可以使用npm audit fix--force，但是这会存在很大的风险。在一般情况下，开发人员应该通过访问npm audit报告中的缺陷链接查看详细信息，根据官方给出的引导进行修复。npm audit还提供了其他命令帮助开发人员处理依赖版本的缺陷。当运行的audit fix中包含--package-lock-only参数时，npm只会更新package-lock.json文件，并不会更新node_modules里的依赖。

当运行的audit fix中包含--only参数时，npm会根据--only参数的值来决定更新的依赖模块：

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-29-22-25-image-20231229222522502.png" alt="image-20231229222522502" style="zoom:50%;" />



当运行的audit fix中包含--dry-run--json参数时，npm不会更新依赖，而是以JSON的格式输出需要更新的信息。

如果开发人员需要持续集成npm audit，那么可以使用--audit-level参数对依赖检测进行卡点。--audit-level用于设置报告检测中缺陷的风险等级，由低到高分别为low、moderate、high、critical。



### 展示能引用的包

为你分析出当前路径下能够通过模块路径找到的所有包，并生成依赖树，如下：

```sh
$ npm ls 
/Users/jacksontian 
├─┬ connect@2.0.3 
│ ├── crc@0.1.0 
│ ├── debug@0.6.0 
│ ├── formidable@1.0.9 
│ ├── mime@1.2.4 
│ └── qs@0.4.2 
├── hello_test_jackson@0.0.1 
└── urllib@0.2.3
```





### 管理包权限

通常，一个包只有一个人拥有权限进行发布。如果需要多人进行发布，可以使用npm owner

命令帮助你管理包的所有者： 

`$ npm owner ls eventproxy `



使用这个命令，也可以添加包的拥有者，删除一个包的拥有者：

```sh
npm owner ls <package name> 

npm owner add <user> <package name> 

npm owner rm <user> <package name> 
```





## npm scripts 使用指南

### npm scripts 的原理

每当执行`npm run`，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。

比较特别的是，`npm run`新建的这个 Shell，会将当前目录的`node_modules/.bin`子目录加入`PATH`变量，执行结束后，再将`PATH`变量恢复原样。

这意味着，当前目录的`node_modules/.bin`子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写`mocha test`就可以了。

> ```javascript
> "test": "mocha test"
> ```

而不用写成下面这样。

> ```javascript
> "test": "./node_modules/.bin/mocha test"
> ```

由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。

npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是`0`，npm 就认为这个脚本执行失败。





### 通配符

由于 npm 脚本就是 Shell 脚本，因为可以使用 Shell 通配符。

> ```javascript
> "lint": "jshint *.js"
> "lint": "jshint **/*.js"
> ```

上面代码中，`*`表示任意文件名，`**`表示任意一层子目录。

如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。

> ```javascript
> "test": "tap test/\*.js"
> ```



### 传参

向 npm 脚本传入参数，要使用`--`标明。

> ```javascript
> "lint": "jshint **.js"
> ```

向上面的`npm run lint`命令传入参数，必须写成下面这样。

> ```bash
> $ npm run lint --  --reporter checkstyle > checkstyle.xml
> ```



### 执行顺序

如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。

如果是并行执行（即同时的平行执行），可以使用`&`符号。

> ```bash
> $ npm run script1.js & npm run script2.js
> ```

如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用`&&`符号。

> ```bash
> $ npm run script1.js && npm run script2.js
> ```

这两个符号是 Bash 的功能。





### 钩子

#### `pre`和`post`两个钩子

npm 脚本有`pre`和`post`两个钩子。举例来说，`build`脚本命令的钩子就是`prebuild`和`postbuild`。自定义的脚本命令可以加上`pre`和`post`钩子。比如，`myscript`这个脚本命令，也有`premyscript`和`postmyscript`钩子。不过，双重的`pre`和`post`无效，比如`prepretest`和`postposttest`是无效的。

> ```javascript
> "prebuild": "echo I run before the build script",
> "build": "cross-env NODE_ENV=production webpack",
> "postbuild": "echo I run after the build script"
> ```

用户执行`npm run build`的时候，会自动按照下面的顺序执行。

> ```bash
> npm run prebuild && npm run build && npm run postbuild
> ```



#### npm 默认提供下面这些钩子

> - prepublish，postpublish
> - preinstall，postinstall
> - preuninstall，postuninstall
> - preversion，postversion
> - pretest，posttest
> - prestop，poststop
> - prestart，poststart
> - prerestart，postrestart
> - prepare，postpare



#### `npm_lifecycle_event`变量

npm 提供一个`npm_lifecycle_event`变量，返回当前正在运行的脚本名称，比如`pretest`、`test`、`posttest`等等。可以利用这个变量，在同一个脚本文件里面，为不同的`npm scripts`命令编写代码。请看下面的例子。

> ```javascript
> const TARGET = process.env.npm_lifecycle_event;
> 
> if (TARGET === 'test') {
>   console.log(`Running the test task!`);
> }
> 
> if (TARGET === 'pretest') {
>   console.log(`Running the pretest task!`);
> }
> 
> if (TARGET === 'posttest') {
>   console.log(`Running the posttest task!`);
> }
> ```









### 变量

npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。

#### 通过`npm_package_`前缀拿到`package.json`里面的字段

通过`npm_package_`前缀，npm 脚本可以拿到`package.json`里面的字段。比如，下面是一个`package.json`。

> ```javascript
> {
>   "name": "foo", 
>   "version": "1.2.5",
>   "scripts": {
>     "view": "node view.js"
>   }
> }
> ```

那么，变量`npm_package_name`返回`foo`，变量`npm_package_version`返回`1.2.5`。

> ```javascript
> // view.js
> console.log(process.env.npm_package_name); // foo
> console.log(process.env.npm_package_version); // 1.2.5
> ```

上面代码中，我们通过环境变量`process.env`对象，拿到`package.json`的字段值。如果是 Bash 脚本，可以用`$npm_package_name`和`$npm_package_version`取到这两个值。

`npm_package_`前缀也支持嵌套的`package.json`字段。

> ```javascript
>   "repository": {
>     "type": "git",
>     "url": "xxx"
>   },
>   scripts: {
>     "view": "echo $npm_package_repository_type"
>   }
> ```

上面代码中，`repository`字段的`type`属性，可以通过`npm_package_repository_type`取到。

下面是另外一个例子。

> ```javascript
> "scripts": {
>   "install": "foo.js"
> }
> ```

上面代码中，`npm_package_scripts_install`变量的值等于`foo.js`。



#### 通过`npm_config_`前缀拿到 npm 的配置变量

然后，npm 脚本还可以通过`npm_config_`前缀，拿到 npm 的配置变量，即`npm config get xxx`命令返回的值。比如，当前模块的发行标签，可以通过`npm_config_tag`取到。

> ```javascript
> "view": "echo $npm_config_tag",
> ```

注意，`package.json`里面的`config`对象，可以被环境变量覆盖。

> ```javascript
> { 
>   "name" : "foo",
>   "config" : { "port" : "8080" },
>   "scripts" : { "start" : "node server.js" }
> }
> ```

上面代码中，`npm_package_config_port`变量返回的是`8080`。这个值可以用下面的方法覆盖。

> ```bash
> $ npm config set foo:port 80
> ```



#### `env`命令可以列出所有环境变量。

> ```javascript
> "env": "env"
> ```





### 一些实用命令

#### 不许执行 `npm install` 或`yarn`

添加 preinstall npm钩子，这个钩子会在运行 npm install 或 yarn前触发。

#### 方法一：自己写脚本

package.json

```json
"scripts": {
  "preinstall": "node ./scripts/preinstall.js"
}
```

实现当运行 npm install 或 yarn，就会发生错误并且不会继续安装。

```javascript
if (!/pnpm/.test(process.env.npm_execpath || '')) {
  console.warn(
    `\u001b[33mThis repository requires using pnpm as the package manager ` +
      ` for scripts to work properly.\u001b[39m\n`
  )
  process.exit(1)
}
```

#### 方法二：用别人的包

```json
"scripts": {
    "preinstall": "npx only-allow pnpm"
}
```



## npm包

### 语义化版本（Semantic Versioning）规范

#### 介绍

语义化版本规范是一套版本变化的规范，其结构是标准的版本格式：X.Y.Z，每个字母的含义如下。

• X：主版本号。当进行了不兼容式改动或者有重大更新时，会修改此版本号进行发版。一般对于该版本号的修改极其慎重，因为这种修改对使用方造成的冲击会很大。

• Y：次版本号。当进行了小功能的更新或升级时，会修改此版本号进行发版。

• Z：补丁版本号。当进行了低版本的缺陷修复时，会修改此版本号进行发版。在大多数情况下，版本号都以0.1.0开始，并在每次发布时按照改动情况对相应版本号进行修改。当发布的模块被用于正式环境时，应该已经达到了1.0.0版本。在发布模块的正式版本之前，还存在其他测试版本：

• Alpha：希腊字母 α 的谐音，指内测版。一般是用于内部交流或者提供给专业测试人员测试用的版本，通常存在大量功能或逻辑缺陷，不适合正式使用。

• Beta：希腊字母 β 的谐音，指公测版。一般是用于抢先测试体验的版本，该版本也会存在一些缺陷，不适合正式使用。

• Gamma：希腊字母 λ 的谐音，公测版的增强版本，通常来说与即将发行的正式版相差无几。

• RC：Release Candidate的缩写，指候选版本，依然处于Gamma阶段，但该版本已经完成全部功能并修复了大部分Bug。到了这个阶段只会修复Bug，不会再对软件做任何大的更改。

 

1. `^`（Caret）符号：允许在主版本号不变的情况下，升级次版本号和修订版本号。例如，`^1.2.3` 表示允许安装 1.2.3、1.2.4、1.3.0 等版本，但不包括 2.0.0。
2. `~`（Tilde）符号：允许在主版本号和次版本号不变的情况下，升级修订版本号。例如，`~1.2.3` 表示允许安装 1.2.3、1.2.4 等版本，但不包括 1.3.0。





#### 如果某次发版破坏了语义化版本控制的规范

如果某次发版破坏了语义化版本控制的规范，就应该主动修正这个问题，并发行一个升级了次版本号的版本来更正这个问题。当遇到这种情况时，语义化版本禁止开发人员修改已发行的版本。开发人员应该将有问题的版本号记录到文件中，告诉使用者问题所在，让其能够意识到这是有问题的版本。开发人员还可以使用npm标记有问题的版本，当使用者安装有问题的版本时，控制台就会给出版本作废的警告信息。







### package.json(这本来就是用来给包配置的，对于web应用用处不大)

通过`package.json`来配置npm包的一些信息。

#### files

 files 字段是一个文件模式数组，表示 当你的软件包被作为依赖关系安装时要包含的条目。文件模式的语法与 .gitignore 类似。省略该字段则默认为["*"]，即包含所有文件。

你也可以在软件包根目录或子目录中提供 .npmignore 文件，这样就不会包含文件了。在软件包的根目录中，它不会覆盖 "files "字段，但在子目录中则会。如果 .npmignore 丢失，则将使用 .gitignore 的内容。

无论设置如何，某些文件永远不会被忽略：

- `package.json`
- `README`
- `LICENSE` / `LICENCE`
- `README` & `LICENSE` can have any case and extension.
- The file in the "main" field
- The file(s) in the "bin" field



有些文件会自动被忽略：

- `.git`
- `CVS`
- `.svn`
- `.hg`
- `.lock-wscript`
- `.wafpickle-N`
- `.*.swp`
- `.DS_Store`
- `._*`
- `npm-debug.log`
- `.npmrc`
- `node_modules`
- `config.gypi`
- `*.orig`
- `package-lock.json` (use [`npm-shrinkwrap.json`](https://docs.npmjs.com/cli/v10/configuring-npm/npm-shrinkwrap-json) if you wish it to be published)





#### dependencies

<mark>当你安装一个包时，其 dependencies 和 devDependencies 会被 npm 自动安装。 peerDependencies 则有所不同，它们不会被自动安装。</mark> 当一个依赖项 c 被列在某个包 b 的 peerDependency 中时，它就不会被自动安装。取而代之的是，包含了 b 包的代码库 a 则必须将 c 作为其依赖。



#### devDependencies

当你安装一个包时，其 dependencies 和 devDependencies 会被 npm 自动安装。 peerDependencies 则有所不同，它们不会被自动安装。 当一个依赖项 c 被列在某个包 b 的 peerDependency 中时，它就不会被自动安装。取而代之的是，包含了 b 包的代码库 a 则必须将 c 作为其依赖。

#### peerDependencies

同伴依赖，用于指定当前包（也就是你写的包）需要的宿主版本。

当你安装一个包时，其 dependencies 和 devDependencies 会被 npm 自动安装。 peerDependencies 则有所不同，它们不会被自动安装。 当一个依赖项 c 被列在某个包 b 的 peerDependency 中时，它就不会被自动安装。取而代之的是，包含了 b 包的代码库 a 则必须将 c 作为其依赖。



`peerDependencies` 在我们进行一些插件开发的时候会经常用到。用于解决插件与所依赖包不一致的问题。

插件特点：

- 插件正确运行的前提是，核心依赖库必须先下载安装，不能脱离核心依赖库而被单独依赖并引用；
- 插件入口 api 的设计必须要符合核心依赖库的规范；
- 插件的核心逻辑运行在依赖库的调用中；
- 在项目实践中，同一插件体系下，核心依赖库版本最好是相同的； 听起来可能没有那么好理解，举个例子来说明下。antd 只是提供了一套基于 react 的 ui 组件库，但它要求宿主环境需要安装指定的 react 版本，所以你可以看到 node_modules 中 antd 的 package.json 中有这么一项配置:

```json
"peerDependencies": {
    "react": ">=16.0.0",
    "react-dom": ">=16.0.0"
},
```

它要求宿主环境安装大于等于 16.0.0 版本的 react，也就是 antd 的运行依赖宿主环境提供的该范围的 react 安装包。











#### `type`

`.mjs`文件总是以 ES6 模块加载，`.cjs`文件总是以 CommonJS 模块加载，`type`字段 用于指示这个项目里的js文件以哪种模块方式被外界（别人引它的时候/node执行它的时候）解析。这个字段是给node看的，默认type=commonjs。





#### `bin`

声明这个包有哪些命令可以在终端直接执行。npm install 这个包以后，其命令的二进制文件就会放到 node_modules/.bin 目录下。

三种方式可以执行这些bin：

1. node ./node_modules/.bin/xx 
2. npx xx
3. 放在package.json的"scripts"里执行















#### 禁用npm和yarn或限制pnpm版本或限制node版本

##### 方法一`engines`

第一步：Edit .npmrc

```config
//.npmrc file

engine-strict = true
```

This option tells the package manager to use the version of the engines we have specified in the `package.json` file.

第二步：Edit package.json

Inside your `package.json` file you should add the `engines` section if you don’t currently have it.

```json
//package.json
{ 
  ...
  "engines": {
    "npm": "please-use-pnpm",
    "yarn": "please-use-pnpm",
    "pnpm": "7.4.1",
    "node": ">=16.9.0 <18"
  },
  ...
}
```

for `npm` we specify a version that doesn’t exist.This way we make sure that when someone tries to use `npm` instead of `yarn`, they will receive an error that outputs ‘`please-use-yarn`‘.







##### 方法二`packageManager`&corepack

比如`"packageManager": "yarn@1.22.15"`。但是需要有[corepack](#corepack)

使用之后的效果：

用非声明的包管理器，会拦截报错。用声明的包管理器，会自动帮你切换版本。



此方法存在的问题：

- npm 还无法拦截 也就是说 即便配置了 packageManager 使用 yarn，但是依然可以调用全局 npm 安装。
- 仅支持 pnpm 和 yarn，cnpm 也是不支持的



### .lock文件

只要任何dependences有变化就会导致.lock文件变化。注意此时必须现在本地安装了依赖保证更新了.lock文件再提交到远程仓库。



### 包格式

详细的解释看javascript模块加载部分

- cjs： 在 Node.js 环境中，资源的模块格式应该是 CommonJS。

- IIFE：即立即调用的函数表达式，为了让用户能够通过 `<script> `标签直接引用并使用。比如vue.global.js 文件就是 IIFE 形式的资源
- UMD(Universal Module Definition) 模式：这种形态会在 NPM 库启动时判断运行环境，自动选择当前适用的模块化方案。

- ESM 格式：为了让用户能够通过 `<script type="module">` 引用并使用（比如Vue.js 3 的 vue.esm-browser.js 文件）。





### 本地测试npm包

#### 首先明确

本质都是把整个目录通过`pnpm link`软链连接到node_modules里。

- 所以到`node_modules`里的是整个目录的内容，跟你直接从npm源下载下来是不一样的，毕竟你发布到npm上的肯定是过滤了一些文件的。

- 所以当在本地的依赖包发生变化时，业务项目也能实时感知到。

在代码中`import . from 'name'`通过模块名去引用时会在`node_modules`中找到该模块包后读取package.json然后找到该包的入口。如果你的name后有接一些路径，那它会根据这个路径去寻址，就不用你package.json里写的入口了。

#### 非monorepo

pnpm add 本地目录

当从目录安装时，会在当前项目目录`node_modules`中生成一个 symlink ， 效果跟执行 `pnpm link` 是一致的，但由于执行add命令，所以该包会写到package.json中，还会生成pnpm-lock.yaml。这两步是直接`pnpm link`没有的。

#### 是monorepo

执行：`pnpm add name --workspace `

当然也可以跟非monorepo的方式一样通过路径去把本地目录下载成依赖。但不能通过-F去选中子repo，要进入子repo里再通过路径去add，因为如果通过-F的话那引入到子repo中的路径是相对于根目录的，那子repo就找不到那个路径了呀。

但workspace的特别之处就在于：

可以通过包name的方式去下载本地目录为依赖，但本质也是通过link的。注意要通过 `--workspace`参数去下载，不然会先从npm源上下载。

且通过这种方式的话，当 业务项目 打包到归档（无论它是通过 `pnpm pack` ，还是 `pnpm publish` 之类的发布命令）时，我们将动态替换这些 `workspace:` 依赖：

- 目标 workspace 中的对应版本（如果使用 `workspace:*`, `workspace:~`, or `workspace:^`）
- 相关的 semver 范围（对于任何其他范围类型）

看一个例子，假设我们的 workspace 中有 `foo`、 `bar`、 `qar`、 `zoo` 并且它们的版本都是 `1.5.0`，如下：

```json
{
    "dependencies": {
        "foo": "workspace:*",
        "bar": "workspace:~",
        "qar": "workspace:^",
        "zoo": "workspace:^1.5.0"
    }
}
```

将会被转化为：

```json
{
    "dependencies": {
        "foo": "1.5.0",
        "bar": "~1.5.0",
        "qar": "^1.5.0",
        "zoo": "^1.5.0"
    }
}
```









### 发布一个npm包

#### `npm publish`

命令行中执行`npm publish`就会将dist目录上传到npm库，可以通过`.npmrc`文件里的registry配置上传到npm到地址。

如果是第一次上传需要登录，如果不是第一次上传则会应用上次的用户名。



#### 发布的包能被tree-shaking

对于包来说只要提供esmodule就行了，剩下的事就跟用户的打包工具有关



#### 发布的包能有类型提示

用了个插件rollup-plugin-dts使打包出了类型声明文件，且package.json会通过''types"配置类型声明文件入口。(“types”就是给用户的typescript看的)



#### 版本hooks

npm version提供了major、minor、patch、premajor、preminor、prepatch、prerelease等快捷命令用于修改版本号，可以在package.json中添加preversion钩子，利用其进行自动化打包。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-28-17-02-image-20231228170209863.png" alt="image-20231228170209863" style="zoom:50%;" />



 

#### .npmignore

开发人员应该合理配置“.npmignore”文件，它可以帮助npm识别哪些是无关文件，发布时不需要上传，从而减小npm包的体积。例如，components目录下未编译的代码、docs目录下的组件文档、scripts目录下的脚本。[插图]当组件发布成功后，开发人员应该使用git tag标记版本，以便在后续修复版本问题时快速切换开发分支。





#### 版本控制

单仓库：[conventional-changelog](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fconventional-changelog%2Fconventional-changelog)或者[release-it](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frelease-it%2Frelease-it)。 

release-it，自动提升版本号，自动打 `tag`，生成 `changelog` 等

[release-it 官网仓库](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frelease-it%2Frelease-it)

```bash
npm init release-it
# 选择 .release-it.json 用下面的配置，复制粘贴到 .release-it.json 中。
# 再安装 changelog 插件
npm i @release-it/conventional-changelog -D
{
 "github": {
  "release": false
 },
 "git": {
  "commitMessage": "release: v${version}"
 },
 "npm": {
  "publish": false
 },
 "hooks": {
  "after:bump": "echo 更新版本成功"
 },
 "plugins": {
  "@release-it/conventional-changelog": {
   "preset": "angular",
   "infile": "CHANGELOG.md"
  }
 }
}
```

这样配置后，可以 `npm run release` 执行 `release-it` 版本。 还支持 hooks 钩子，比如提升版本号后`"after:bump": "echo 更新版本成功"`，更多功能可以查看[release-it 官网仓库](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Frelease-it%2Frelease-it)。



多仓库： [Changesets](https://juejin.cn/post/7024827345059971080) monorepo











## pnpm



### [pnpm与npm yarn的区别](https://juejin.cn/post/6932046455733485575#heading-8)

#### 概括

**装包速度极快：** 缓存中有的依赖，直接硬链接到项目的 node_module 中；减少了 copy 的大量 IO 操作

**磁盘利用率极高：** 软/硬链接方式，同一版本的依赖共用一个磁盘空间；不同版本依赖，只额外存储 diff 内容

**解决了幽灵依赖：** node_modules 目录结构 与 package.json 依赖列表一致



#### 速度快

包安装的速度都是明显优于 npm/yarn，速度会比 npm/yarn 快 2-3 倍。即使yarn有  [PnP 安装模式](https://link.juejin.cn/?target=https%3A%2F%2Fclassic.yarnpkg.com%2Fen%2Fdocs%2Fpnp%2F)，直接去掉 node_modules，将依赖包内容写在磁盘，节省了 node 文件 I/O 的开销，提升安装速度。（具体原理见[这篇文章](https://link.juejin.cn/?target=https%3A%2F%2Floveky.github.io%2F2019%2F02%2F11%2Fyarn-pnp%2F)）。但还是没pnpm快。




#### 高效利用磁盘空间

pnpm 内部使用<font color="red">基于内容寻址</font>的文件系统来存储磁盘上所有的文件，即使某个包版本变更，也只需要存储改动的地方diff，不需要储存变更后版本的全部内容。这个文件系统出色的地方在于:

- 不会重复安装同一个包。用 npm/yarn 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。但在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用 `hardlink`(硬链接，详见[这篇文章](https://link.juejin.cn?target=https%3A%2F%2Fwww.cnblogs.com%2Fitech%2Farchive%2F2009%2F04%2F10%2F1433052.html))。
- 即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。举个例子，比如 lodash 有 100 个文件，更新版本之后多了一个文件，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的 `hardlink`，仅仅写入那`一个新增的文件`。



pnpm会默认将所有依赖包下载到**系统**某一路径（缓存）中，这部分文件可以理解成**Store**。

pnpm install时会先看Store中有没有，如果有，那么会在.pnpm下创建这个文件的**硬链接**，这就无需重新下载这个文件，这对提升下载速度以及节约磁盘空间都有利；

只有项目中真正依赖的包才会出现在node_modules根目录下且直接暴露在node_modules下的是其软链接。其他的子依赖项只会出现在.pnpm的目录下，并且文件名称会带上**@版本号**

![image-20230730142725659](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-14-27-image-20230730142725659.png)





#### 支持 monorepo

体现在各个子命令的功能上，比如在根目录下 `pnpm add A -r`, 那么所有的 package 中都会被添加 A 这个依赖，当然也支持 `--filter`字段来对 package 进行过滤。






#### 依赖管理上不同

##### 在 `npm1`、`npm2` 中嵌套结构

###### 介绍

比如下面这样:

```js
node_modules
└─ foo
   ├─ index.js
   ├─ package.json
   └─ node_modules
      └─ bar
         ├─ index.js
         └─ package.json
```

如果 `bar` 当中又有依赖，那么又会继续嵌套下去。



###### 存在的问题

1. 依赖层级太深，会导致文件路径过长的问题，尤其在 window 系统下。
2. 大量重复的包被安装，文件体积超级大。比如跟 `foo` 同级目录下有一个`baz`，两者都依赖于同一个版本的`lodash`，那么 lodash 会分别在两者的 node_modules 中被安装，也就是重复安装。
3. 模块实例不能共享。比如 React 有一些内部变量，在两个不同包引入的 React 不是同一个模块实例，因此无法共享内部变量，导致一些不可预知的 bug。



##### npm3及3+和yarn都是`扁平化`依赖管理（导致幽灵依赖）

###### 介绍

所有的依赖都被拍平到`node_modules`目录下。这样在安装新的包时，根据 node require 机制，会不停往上级的`node_modules`当中去找，如果找到相同版本的包就不会重新安装，解决了大量包重复安装的问题，而且依赖层级也不会太深。

目录结构类似下面这样:

```js
node_modules
├─ foo
|  ├─ index.js
|  └─ package.json
└─ bar
   ├─ index.js
   └─ package.json
```



###### 存在的问题

- 依赖结构的**不确定性**。
- 扁平化算法本身的**复杂性**很高，耗时较长。
- 项目中仍然可以**非法访问**没有声明过依赖的包。没有被定义在项目中的 package.json 文件中的包，也可以进行导入使用---幽灵依赖

后面两个都好理解，那第一点中的`不确定性`是什么意思？这里来详细解释一下。

假如现在项目依赖两个包 foo 和 bar，这两个包的依赖又是这样的: ![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/211c86c7838b48bead2a4ee7faee25b1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

那么 npm/yarn install 的时候，通过扁平化处理之后，究竟是这样 ![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b2368d74f8b341f0b1b545198683af59~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

还是这样：![img](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/198d6c12f0e045ce8c0867b44b3aaeb1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

答案是: 都有可能。取决于 foo 和 bar 在 `package.json`中的位置，如果 foo 声明在前面，那么就是前面的结构，否则是后面的结构。

这就是为什么会产生依赖结构的`不确定`问题，也是 `lock 文件`诞生的原因，无论是`package-lock.json`(npm 5.x才出现)还是`yarn.lock`，都是为了保证 install 之后都产生确定的`node_modules`结构。





##### pnpm 依赖管理

###### 介绍

存储中心 Store（ pnpm会默认将所有依赖包下载到**系统**某一路径中，相同的文件只存在一部分，这部分文件可以理解成**Store**。） 集中管理依赖：<mark>不同项目，相同版本依赖安装只进行硬链接；不同版本依赖，只增加Diff文件。</mark>

相同依赖安装时，将 Store 中的依赖**硬链接**到项目的 `node_modules/.pnpm` 下，而不是复制，速度快

项目`node_modules`中已有依赖重复安装时，会被**软链接**到指定目录下， 项目中依赖包和子依赖包之间通过**软链接**的方式联系起来。

项目 `package.json` 依赖列表，和`node_modules/.pnpm`目录结构一致

![image-20230816154650407](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-16-15-46-image-20230816154650407.png)



###### 举例

以安装 `express` 为例，我们新建一个目录，执行:

```csharp
pnpm init -y
```

然后执行:

```
pnpm install express
```

我们再去看看`node_modules`:

```
.pnpm
.modules.yaml
express
```

直接就看到了`express`，但这里仅仅只是一个`软链接`，里面并没有 node_modules 目录。它真正的位置在.pnpm里，在 `.pnpm/express@4.17.1/node_modules/express`

依赖都是`<package-name>@version/node_modules/<package-name>`这种目录结构。并且 express 的依赖都在`.pnpm/express@4.17.1/node_modules`下面，这些依赖也全都是**软链接**。

再看看`.pnpm`，`.pnpm`目录下虽然呈现的是扁平的目录结构，但仔细想想，顺着`软链接`慢慢展开，其实就是嵌套的结构！将`包本身`和`依赖`放在同一个`node_module`下面。

```sql
▾ node_modules
  ▾ .pnpm
    ▸ accepts@1.3.7
    ▸ array-flatten@1.1.1
    ...
    ▾ express@4.17.1
      ▾ node_modules
        ▸ accepts  -> ../accepts@1.3.7/node_modules/accepts
        ▸ array-flatten -> ../array-flatten@1.1.1/node_modules/array-flatten
        ...
        ▾ express
          ▸ lib
            History.md
            index.js
            LICENSE
            package.json
            Readme.md
```









###### 安全性高（依赖管理导致的）

（幽灵依赖）使用 npm/yarn 的时候，由于 node_module 的扁平结构，如果 A 依赖 B， B 依赖 C，那么 A 当中是可以直接使用 C 的。而pnpm 只要一个包未在 package.json 中声明依赖，那么在项目中是无法访问的。

上述依赖提升导致的bug：

第一， B 的版本是可能随时变化的，假如之前依赖的是`C@1.0.1`，现在发了新版，新版本的 B 依赖 `C@2.0.1`，那么在项目 A 当中 npm/yarn install 之后，装上的是 2.0.1 版本的 C，而 A 当中用的还是 C 当中旧版的 API，可能就直接报错了。

第二，如果 B 更新之后，可能不需要 C 了，那么安装依赖的时候，C ==都不会装==到`node_modules`里面，A 当中引用 C 的代码直接报错。

第三，在 monorepo 项目中，如果 A 依赖 X，B 依赖 X，还有一个 C，它不依赖 X，但它代码里面用到了 X。由于依赖提升的存在，npm/yarn 会把 X 放到根目录的 node_modules 中，这样 C 在本地是能够跑起来的，因为根据 node 的包加载机制，它能够加载到 monorepo 项目根目录下的 node_modules 中的 X。但试想一下，一旦 C 单独发包出去，用户单独安装 C，那么就找不到 X 了，执行到引用 X 的代码时就直接报错了。

> npm 也有想过去解决这个问题，指定`--global-style`参数即可禁止变量提升，但这样做相当于回到了当年嵌套依赖的时代。npm/yarn 本身去解决依赖提升的问题貌似很难完成，不过社区针对这个问题也已经有特定的解决方案: **dependency-check**，地址: [github.com/dependency-…](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdependency-check-team%2Fdependency-check)





### monorepo

#### 根目录下的配置

会根据最近的目录上的config文件去扫整个项目。主目录下的config会共享整个项目。

#### pnpm-workspace.yaml配置⽂件搭建monorepo环境

用于建立monorepo架构，声明有几个仓库。举例：

```yaml
packages:
	- 'packages/**' # 存放编写组件的
	- docs # 存放⽂档的
	- play # 用于测试组件的
```



#### 依赖管理Node_modules

##### 简介

mororepo下主目录里的node_modules里的是硬链接到存储位置，子目录下的node_modules是软链接到主目录里的node_modules



##### 使安装的模块放置到node_modules⽬录下

直接暴露在node_modules下的是其软链接。

如果在.npmrc⽂件里设置`shamefully-hoist =true`，让安装的模块放置到node_modules⽬录下，然后我们就可以直接使用这个模块的依赖项。（这其实就是幽灵依赖，效果跟`yarn/npm`一样强制提升了（我没有安装他，但依然能使用它）。

也可以通过参数来指定安装某个依赖时将其提升：比如需要用到vue下的vue/shared这个包（vue依赖了他）的，那么安装vue的时候就应该使用这个参数）。





#### 命令

##### pnpm i

 `pnpm i` 会安装所有的依赖（包括 `packages/*`）。

- --prod, P，安装依赖到 dependencies
- --dev, D，安装依赖到 devDependencies



##### 参数

###### -F , --filter

通过`pnpm --filter <package_selector> <command> `只对某个包进行操作



###### `-C` 

表示 "change directory"，即更改当前工作目录。因此，`pnpm -C` 可以确保在执行 `pnpm` 命令时使用正确的根目录

比如： `pnpm -C play dev`



###### -w

在[工作空间](https://pnpm.io/workspaces)的根目录中启动 pnpm ，而不是当前的工作目录。



###### -r, --recursive

Runs a command in every project of a workspace, when used with the following commands:

- `install`
- `list`
- `outdated`
- `publish`
- `rebuild`
- `remove`
- `unlink`
- `update`
- `why`

Runs a command in every project of a workspace, excluding the root project, when used with the following commands:

- `exec`
- `run`
- `test`
- `add`

If you want the root project be included even when running scripts, set the [include-workspace-root](https://www.pnpm.cn/npmrc#include-workspace-root) setting to `true`.













### 常用命令

#### pnpm run

在根目录执行`pnpm run type-check`，对所有包都执行根空间下的指令。

`pnpm run [command] --recursive --parallel`平行执行所有子包里面的`type-check`命令，如果子包没有这个指令则跳过该子包。



#### pnpm i

##### 主目录下使用 pnpm -F 子项目 i 跟进入子项目目录后执行 pnpm i

区别应该是在于子项目里没有pnpm-lock.yaml文件，可能导致安装的依赖的版本有问题，所以可能导致一些错误。



##### `pnpm i --force`强制重装依赖

The `--force` flag ensures that all packages are reinstalled, regardless of whether they are already installed or not.



#### pnpm link

##### 将已安装的软件包替换为本地版本[](https://pnpm.io/zh/cli/link#将已安装的软件包替换为本地版本)

就是通过一个软链把那个目录放到node_modules中（跟你直接从npm源下载下来是不一样的，毕竟你发布到npm上的肯定是过滤了一些文件的），不会写到package.json中，也不会生成pnpm-lock.yaml，毕竟你是link呀。

Let's say you have a project that uses `foo` package. You want to make changes to `foo` and test them in your project. In this scenario, you can use `pnpm link` to link the local version of `foo` to your project, while the `package.json` won't be modified.

```bash
cd ~/projects/foo
pnpm install # install dependencies of foo
pnpm link --global # link foo globally
cd ~/projects/my-project
pnpm link --global foo # link foo to my-project
```



You can also link a package from a directory to another directory, without using the global `node_modules` folder:

```bash
cd ~/projects/foo
pnpm install # install dependencies of foo
cd ~/projects/my-project
pnpm link ~/projects/foo # link foo to my-project
```



由于是把整个目录通过软链连接，所以当在本地的依赖包发生变化时，业务项目也能实时感知到。

在代码中`import . from 'name'`通过模块名去引用时会在`node_modules`中找到该模块包后读取package.json然后找到该包的入口。如果你的name后有接一些路径，那它会根据这个路径去寻址，就不用你package.json里写的入口了。



#### pnpm add

##### pnpm add 本地目录

当从目录安装时，会在当前项目目录`node_modules`中生成一个 symlink ， 效果跟执行 `pnpm link` 是一致的，但由于执行add命令，所以该包会写到package.json中，还会生成pnpm-lock.yaml。这两步是`pnpm link`没有的。



##### pnpm add --workspace 从workspace中安装依赖而不是npm源

通过路径去把本地目录下载成依赖时那不就跟上面是一样的。

workspace的特别之处就在于，可以通过包name的方式去下载本地目录为依赖，但其实也是通过link的，但注意要通过 `--workspace`参数去下载，不然会先从npm源上下载。





#### `pnpm dlx` 

`pnpm dlx` 是 pnpm 包管理器中的一个特殊命令，用于在项目中临时执行一个 JavaScript 或 TypeScript 脚本，而不需要全局安装依赖或污染项目的依赖关系。

`pnpm dlx` 命令的语法如下：

```sh
pnpm dlx [options] <module-name> [args...]
```

- `<module-name>`：要执行的 JavaScript 或 TypeScript 脚本的模块名称。这可以是一个已发布到 npm 或 pnpm 的包，也可以是一个 URL，或者是一个本地文件路径。
- `[args...]`：可选参数，作为脚本的参数传递给被执行的模块。

使用 `pnpm dlx` 命令时，pnpm 会在项目的 `node_modules/.bin` 目录下创建一个临时的二进制执行文件，然后使用该执行文件执行指定的模块脚本。执行结束后，临时的二进制执行文件会被清理掉，从而避免了全局安装或对项目的依赖产生影响。



#### pnpm patch 修改包源码

官网上看吧。





## <span id="corepack">Corepack「包管理器的管理器」</span>

### 介绍

Corepack 会成为 Node.js 官方的内置 CLI，用来管理【包管理工具】。目前仅支持 pnpm 和 yarn，且npm 还无法拦截。

主要作用：

- 不再需要专门全局安装 yarn pnpm 等工具。
- 可以强制团队项目中使用他特定的包管理器版本，如果不符合配置将在控制台进行错误提示



### 用法

corepack 是一个实验性工具，所以默认是没有启动的，需要显式启用，需要运行指令 corepack enable 进行启动；

```
// 当前应用激活
corepack enable
```









## monorepo

### 概念性

#### monorepo的演进

**阶段一：单仓库巨石应用monolith**： 一个 Git 仓库维护着项目代码，构建效率会降低。

**阶段二：多仓库多模块应用multi-repo**：模块间完全解耦。但增加了项目工程管理的难度：跨仓库代码难共享；要通过发包下载包的方式来管理模块之间的互现依赖。

**阶段三：单仓库多模块应用monorepo**：共享工程配置，共享模块代码。

![image-20230829111314678](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-29-11-13-image-20230829111314678.png)



#### monorepo与multi-repo横向对比

| **场景**   | **MultiRepo**                                                | **MonoRepo**                                                 |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代码可见性 | ✅ 代码隔离，研发者只需关注自己负责的仓库 ❌ 包管理按照各自owner划分，当出现问题时，需要到依赖包中进行判断并解决。 | ✅ 一个仓库中多个相关项目，很容易看到整个代码库的变化趋势，更好的团队协作。 ❌ 增加了非owner改动代码的风险 |
| 依赖管理   | ❌ 多个仓库都有自己的 node_modules，存在依赖重复安装情况，占用磁盘内存大。 | ✅ 多项目代码都在一个仓库中，相同版本依赖提升到顶层只安装一次，<font color="red">节省磁盘内存。</font>但是会蹭其它项目的依赖，比如某项目没有安装某个依赖但也能直接使用？？--- 得试试才知道了。 |
| 复用       |                                                              | ✅ <font color="red">更方便代码复用，比如A和B都用了C里的代码，如果是我们现在这种模式，把C放到packages下就好了。如果A和B分别是单个仓库，那要么就是都把C当依赖包下载进来，要么就是像通过pet那样都引进来。</font>（所以如果有pet这层抽象的话，其实确实不用monorepo或者不用那么重的monorepo（我们现在是把所有活动都放一起了）） |
| 代码权限   | ✅ 各项目单独仓库，不会出现代码被误改的情况，单个项目出现问题不会影响其他项目。 | ❌ <mark>没有项目粒度的权限管控，一个项目出问题，可能影响所有项目。（monorepo遇到的缺点: 有一个项目有问题导致master出问题，那其他也会有问题，比如一个项目没过ci合进去了（gitlab的ci，但它是kdev合进去的） 然后后面从master拉出来的分支都过不了ci了）</mark> |
| 开发迭代   | ✅ 仓库体积小，模块划分清晰，可维护性强。 ❌ 多仓库来回切换（编辑器及命令行），项目多的话效率很低。多仓库见存在依赖时，需要手动 `npm link`，操作繁琐。 ❌ 依赖管理不便，多个依赖可能在多个仓库中存在不同版本，重复安装，npm link 时不同项目的依赖会存在冲突。 | ❌ `git clone`时间较长。多项目在一个仓库中，代码体积大。led断连之后做了修改重新连接要等很久。 ✅ 依赖调试方便，<font color="red">依赖包迭代场景下，借助工具自动 npm link，直接使用本地改动的依赖，不需要发包。</font> |
| 工程配置   | ❌ 各项目构建、打包、代码校验都各自维护，不一致时会导致代码差异或构建差异。 | ✅ 多项目在一个仓库，<font color="red">工程配置一致</font>，代码质量标准及风格也很容易一致。 |
| 构建部署   | ❌ 多个项目间存在依赖，部署时需要手动到不同的仓库根据先后顺序去修改版本及进行部署，操作繁琐效率低。 | ✅  ❌<font color="red">可以一次命令完成所有项目的构建和ci。</font>既是优点也是缺点，因为同时也拖慢了ci的时间，肯定是只执行一个项目的ci更快。（其实turborepo的缓存就是干这个事，尽量只执行你改动的项目的CI，其它项目不动，就可以跟像只执行一个项目那样快了）。 |



#### monorepo场景

更适合**多模块项目**





### monorepo中方便修改changelog.md的工具

github地址：https://github.com/changesets/changesets

教程地址：https://secstep.com/2023-pnpm-changeset-turborepo-for-monorepos/



### monorepo方式相关工具横向对比

#### 关注点

| 工具     | **Turborepo** | **Rush** | **Nx** | **Lerna** | **Pnpm Workspace** |
| -------- | ------------- | -------- | ------ | --------- | ------------------ |
| 依赖管理 | ❌             | ✅        | ❌      | ❌         | ✅                  |
| 版本管理 | ❌             | ✅        | ❌      | ✅         | ❌                  |
| 增量构建 | ✅             | ✅        | ✅      | ❌         | ❌                  |
| 插件扩展 | ✅             | ✅        | ✅      | ❌         | ❌                  |
| 云端缓存 | ✅             | ✅        | ✅      | ❌         | ❌                  |
| Stars    | 20.4K         | 4.9K     | 17K    | 34.3K     | 22.7K              |





### Turborepo

#### 介绍

Turborepo 是一个为 monorepo 而生的极快的构建系统。目的是为了解决大型 monorepo 项目构建速度缓慢的一大痛点。

turbo 的核心是缓存和任务调度。<font color="red">聚焦于task的并行和项目的缓存。(所有项目同时启动一个task是pnpm run [command] --parallel干的事)</font>

智能的任务调度程序，充分利用空闲 CPU，使得整体构建速度更快。



#### **构建加速思路**

- **Multiple Running Task**：构建任务并行进行，构建顺序交给开发者配置
- **Cache、Remote Cache**：通过缓存 及 远程缓存，减少构建时间



###### Multiple Running Task

构建 repo及task的 依赖图，让每个task 尽可能并行执行。turbo的平行是根据依赖关系可以平行才会平行执行。

区别一下pnpm run [command] --recursive --parallel暴力平行。（以前团队就是用这种方式。）



比如：现在有一个 Monorepo 的项目，有以下几个 package：

- apps/web，依赖 shared
- apps/docs，依赖 shared
- package/shared，被 web 和 docs 依赖

**传统的 yarn workspace 问题**：串行执行task。

![image-20230902174306233](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-02-17-43-image-20230902174306233.png)

**Turborepo Multiple Running Task**：允许用户在 `turbo.json` 中声明 task 之间依赖关系，优化后构建如下：

![image-20230902174336552](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-02-17-43-image-20230902174336552.png)

 turbo会根据配置和遍历所有任务及repo构建依赖图（有向无环图），比如执行turbo run test --graph后得到下图：这个就是turbo构建的依赖图

![image-20231014182819918](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-10-14-18-28-image-20231014182819918.png)



###### Local Cache

 只构建被更改的 repo / 复用没有变化的 repo。（注：子repo A 和 B ，B依赖A，如果A变动，则A和B都会重新构建）。turbo 会把每次构建的产物与日志缓存起来，下次构建时只有文件发生变动的部分才会重新构建，没有变动的直接命中缓存并重现日志。

举例：第一次构建，会生成缓存存放在 `node_modules/.cache/turbo/`

![image-20230829120918311](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-29-12-09-image-20230829120918311.png)



第二次构建时：

![image-20230829120943438](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-29-12-09-image-20230829120943438.png)



###### Remote Cache

在 CI/CD 中或团队中共享打包缓存，把缓存保存到了云端，构建时被拉取。Turbo 可以在本地计算 hash 后，根据计算的结果去远端查找 / 下载缓存。

1. 缓存检查：当 Turbo 开始构建时，它会检查远程缓存服务器上是否存在先前构建的缓存。
2. 缓存下载：如果远程缓存服务器上存在匹配的缓存，Turbo 会从服务器上下载缓存，而不是重新构建项目。
3. 构建更新：如果远程缓存服务器上不存在匹配的缓存或者缓存失效，Turbo 会执行完整的构建流程，并将构建产物上传到服务器上。
4. 缓存上传：在构建完成后，Turbo 会将构建产物上传到远程缓存服务器，以便其他机器可以从服务器上下载并重复使用。

![image-20230829121057434](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-29-12-10-image-20230829121057434.png)







#### 使用

##### 常用配置`turbo.json`文件内容

默认开启了缓存

```json
{
    "$schema": "https://turborepo.org/schema.json",
    "pipeline": {
        "type-check": { // 与package.json中的`scripts`对应
            "dependsOn": [], //这个任务依赖的前前置任务列表，如果为空则说明该任务可以在任何时候被执行
            "outputs": []
        },
         "build": {
          // "A workspace's `build` command depends on its dependencies'
          // or devDependencies' `build` command being completed first"
           //前缀为^，告诉turbo这个任务取决于工作空间的拓扑依赖项是否先完成了^前缀的任务
          "dependsOn": ["^build"]
        },
         "deploy": {
          // "A workspace's `deploy` command, depends on its own `build`
          // and `test` commands first being completed"
          "dependsOn": ["build", "test"]
        },
        "check-complete-scripts": {
            "outputs": [], //缓存文件输出地址，一般像lint这类任务我们不关心其缓存文件所以设为空数组即可
            "inputs": ["apps/*/package.json", "packages/*/package.json"]
          //默认为[]，告诉turbo在确定某项任务的工作区是否有变化时要考虑的文件集。指定[]将导致任务在工作区的任何文件发生变化时被重新运行。
        }
    },
    "globalDependencies": [ // 所有会影响构建结果的文件都应放进来
        "tsconfig.json",
        ".prettierrc.json",
        ".eslintrc.js",
        ".eslintrc.common.cjs",
        ".gitlab-ci.yml"
    ]
}
```



##### **执行`turbo run`**

通过`turbo run [command]`的方式执行所有脚本，这些脚本都会根据依赖图充分并行

如：turbo run check-complete-scripts lint-check ci type-check --concurrency=100%

当你使用`--concurrency=100%`选项时，turbo会尝试使用所有可用的逻辑处理器并发执行任务。这意味着如果你的机器有多个逻辑处理器（例如，多核CPU或支持超线程的CPU），`turbo`将尝试在所有这些处理器上并发执行任务。

这里的"100%"表示的是你机器上逻辑处理器的数量。例如，如果你的机器有8个逻辑处理器，那么`--concurrency=100%`将允许最多8个任务同时执行。



##### 依赖图分析

`turbo run type-check --graph`





##### 过滤包 （Filtering Packages）

turbo中第二个核心概念filtering packages允许您将任务仅定位到你想要去操作的包。过滤器语法还有很多场景这里就不一一展示具体可见[turbo 过滤包语法](https://link.juejin.cn?target=https%3A%2F%2Fturborepo.org%2Fdocs%2Fcore-concepts%2Ffiltering)

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b95599c59a1846068e0f4b707fd5b802~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?) 



##### 远程缓存

###### 用vercel

开发人员团队和/或持续集成 (CI) 系统使用远程缓存来共享构建输出。如果您的构建是可重现的，那么一台机器的输出可以安全地在另一台机器上重复使用，这可以显着加快构建速度。

如果要将本地 turborepo 链接到远程缓存，请首先使用 Vercel 帐户对 Turborepo CLI 进行身份验证：

```
npx turbo login
```

接下来，您可以通过运行以下命令将您的 turborepo 链接到远程缓存：

```bash
npx turbo link
```

启用后，对当前缓存的包或应用程序进行一些更改，并使用`turbo run`. 您的缓存工件现在将存储在本地*和*您的远程缓存中。

要验证，请使用以下命令删除本地Turborepo 缓存：

```bash
rm -rf ./node_modules/.cache/turbo
```

然后再次运行相同的构建。如果一切正常，`turbo`则不应在本地执行任务，而是从远程缓存下载日志和工件并将它们重放给您。





###### 私有化服务器

快手内网搜：[Turborepo 中使用 remote cache]

@王文璐已经私有化部署了一个 remote cache server，

开箱即用：
team: explore-frontend
api:[ http://turborepo-remote-cache.appdev.test.gifshow.com
](http://turborepo-remote-cache.appdev.test.gifshow.com)token: xxxxxxxxxxxxxxxxxy



#### 原理

##### **hash原理**

###### **根据什么内容来hash**

首先，Turbo 会构建代码库当前全局状态的哈希值。这包括以下内容：

- 满足 globalDependencies 中 glob 模式的任何文件内容的哈希值

- globalEnv 中列出的环境变量值

- 从 turbo.json、package.json 和任何lockfile中 选择信息



然后再添加与给定工作区任务相关的更多因素：

- 工作区文件夹中所有被git追踪的文件的内容的哈希值（如果配置了inputs的话，还会加入匹配上的文件）
- 当前执行的 task的名字

- pipeline中配置的 outputs

- package.json 中，dependencies, devDependencies 和 optionalDependencies 所指定的依赖在根目录下 lockfile 中的版本。

- `pipeline.<task>.env list` 中指定的环境变量键值对的排序列表。

crates/turborepo-lib/src/hash/mod.rs



```
struct TaskHashable {
    // hashes
    global_hash: String,
    task_dependency_hashes: Vec<String>,
    hash_of_files: String,
    external_deps_hash: String,

    // task
    package_dir: turbopath::RelativeUnixPathBuf,
    task: String,
    outputs: TaskOutputs,
    pass_thru_args: Vec<String>,

    // env
    env: Vec<String>,
    resolved_env_vars: EnvVarPairs,
    pass_thru_env: Vec<String>,
    env_mode: EnvMode,
    dot_env: Vec<turbopath::RelativeUnixPathBuf>,
}
```





###### **用的hash算法**

使用了两种哈希算法：XXH3和MD4。

> crates/turbo-tasks-hash/src/lib.rs



```
//! Hashing and encoding functions for turbopack.
//!
//! An example use of this module is hashing a file's content for cache
//! invalidation, and encoding the hash to an hexadecimal string for use in a
//! file name.

mod base16;
mod deterministic_hash;
mod hex;
mod md4;
mod xxh3_hash64;

pub use crate::{
    base16::encode_base16,
    deterministic_hash::{DeterministicHash, DeterministicHasher},
    hex::{encode_hex, encode_hex_string},
    md4::hash_md4,
    xxh3_hash64::{hash_xxh3_hash64, Xxh3Hash64Hasher},
};
```



1. **XXH3**：XXH3是一种非加密的哈希函数，用于生成64位的哈希值。在crates/turbo-tasks-hash/src/xxh3_hash64.rs中，定义了一个名为Xxh3Hash64Hasher的结构体和一个名为hash_xxh3_hash64的函数，它们使用XXH3算法来生成哈希值。



1. **MD4**：MD4是一种加密的哈希函数，用于生成128位的哈希值。在crates/turbo-tasks-hash/src/md4.rs中，定义了一个名为hash_md4的函数，它使用MD4算法来生成哈希值。



依据这些信息，我们可以得出当前 repo 状态的 hash，并用这个 hash 匹配缓存的 outputs 和 stdout。若找到对应的缓存，则根据outputs 写入文件系统，并且回放 stdout。否则，执行 task，并记录 outputs 和 stdout，依据之前计算的 hash，写入缓存。



##### **本地缓存**

默认位置是在仓库根目录下的`node_modules/.cache/turbo`目录。

cli/internal/cache/cache.go  



```
func DefaultLocation(repoRoot turbopath.AbsoluteSystemPath) turbopath.AbsoluteSystemPath {
    return repoRoot.UntypedJoin("node_modules", ".cache", "turbo")
}
```





用户可以通过参数来覆盖默认的缓存目录。

 crates/turborepo-cache/src/fs.rs 



```
fn resolve_cache_dir(
    repo_root: &AbsoluteSystemPath,
    override_dir: Option<&Utf8Path>,
) -> AbsoluteSystemPathBuf {
    if let Some(override_dir) = override_dir {
        AbsoluteSystemPathBuf::from_unknown(repo_root, override_dir)
    } else {
        repo_root.join_components(&["node_modules", ".cache", "turbo"])
    }
}
```





只有当任务执行成功（即`taskExecutionSummary`不为nil）时，才会收集任务的输出和执行信息，并将其添加到缓存中。

> ```
> cli/internal/run/real_run.go
> ```



```
if taskExecutionSummary != nil {
    taskSummary.ExpandedOutputs = taskHashTracker.GetExpandedOutputs(taskSummary.TaskID)
    taskSummary.Execution = taskExecutionSummary
    taskSummary.CacheSummary = taskHashTracker.GetCacheStatus(taskSummary.TaskID)

    // lock since multiple things to be appending to this array at the same time
    taskSummaryMutex.Lock()
    taskSummaries = append(taskSummaries, taskSummary)
    // not using defer, just release the lock
    taskSummaryMutex.Unlock()

    var logBytes []byte
    if spacesLogBuffer != nil {
        logBytes = spacesLogBuffer.Bytes()
    }
    runSummary.CloseTask(taskSummary, logBytes)
}
```





##### **远程缓存原理**

turbo默认会向这些路径发请求如：/v8/artifacts/:hash 

turbo在本地算出hash值之后会向该服务器发起get请求，服务器中如果不存在以该hash值命名的文件就会告知本地turbo让它重新构建， 然后构建完的内容发到该服务器，服务器存下该内容。

```tsx
// 王文璐写的nest服务器
  @Get('/v8/artifacts/:hash')
  async getArtifact(
    @Param('hash') hash: string,
    @Query('slug') slug: string,
    @Req() req: Request,
    @Res() resp: Response,
  ) {
    tryAuth(slug, req.headers);

    const teamCacheDir = path.join(cacheDir, slug);
    if (!fs.existsSync(teamCacheDir)) {
      await fs.promises.mkdir(teamCacheDir, { recursive: true });
    }
    const file = path.join(teamCacheDir, hash);
    if (fs.existsSync(file)) {
      resp.sendFile(file);
    } else {
      resp.sendStatus(404);
    }
  }

  @Put('/v8/artifacts/:hash')
  async putArtifact(
    @Param('hash') hash: string,
    @Query('slug') slug: string,
    @Req() req: Request,
  ) {
    tryAuth(slug, req.headers);

    const teamCacheDir = path.join(cacheDir, slug);
    if (!fs.existsSync(teamCacheDir)) {
      await fs.promises.mkdir(teamCacheDir, { recursive: true });
    }

    const filePath = path.join(teamCacheDir, hash);
    await fs.promises.writeFile(filePath, req);
  }
```













### Rush

[Rush](https://link.juejin.cn?target=https%3A%2F%2Frushstack.io%2F) 是微软开发的可扩展的 Monorepo 工具及解决方案。**早期，只提供了 Rush 作为构建调取器**，其余事项交给用户灵活的选择任意构建工具链，由于过于灵活带来了很大的选型及维护成本，后来成立了 Rush Stack 来提供了**一套可复用的解决方案，涵盖多项目的构建、测试、打包和发布**，实现了更强大的工作流。有如下工具：

- [Rush](https://link.juejin.cn?target=https%3A%2F%2Frushjs.io%2F): 可扩展的 monorepo 构建编排工具
- [Heft](https://link.juejin.cn?target=https%3A%2F%2Frushstack.io%2Fzh-cn%2Fpages%2Fheft%2Foverview%2F): 可以与 Rush 交互的可扩展构建系统
- [API Extractor](https://link.juejin.cn?target=https%3A%2F%2Fapi-extractor.com%2F): 为工具库审阅 API 并生成 .d.ts 文件
- [API Documenter](https://link.juejin.cn?target=https%3A%2F%2Fapi-extractor.com%2Fpages%2Fsetup%2Fgenerating_docs): 生成你的 API 文档站
- [@rushstack/eslint-config](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F@rushstack%2Feslint-config): 专门为大型 TypeScript monorepo 仓库设计的 ESLint 规则集
- [@rushstack/eslint-plugin-packlets](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F@rushstack%2Feslint-plugin-packlets): 可用于在单个项目内来组织代码，NPM 发包的一个轻量级解决方案
- [Rundown](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F@rushstack%2Frundown): 用于优化 Node.js 启动时间的工具

**Rush 功能列举**

- **解决了幽灵依赖**：将项目所有依赖都安装到 Repo根目录的common/temp下，通过**软链接**到各项目，保证了 node_modules 下依赖与 package.json 一致
- **并行构建**：Rush 支持并行构建多个项目，提高了构建效率
- **插件系统**：Rush 提供了丰富的插件系统，可以扩展其功能，满足不同的需求，[具体参考](https://link.juejin.cn?target=https%3A%2F%2Frushstack.io%2Fzh-cn%2Fpages%2Fheft%2Fcore_plugins%2F)

- **项目发布，ChangeLog 支持友好**：自动修改项目版本号，自动生成 ChangeLog





### Nx

#### 介绍

Nx 是 [Nrwl](https://link.juejin.cn?target=https%3A%2F%2Fnx.app%2Fcompany) 团队开发的，同时在维护 Lerna，目前 Nx 可以与 Learn 5.1及以上集成使用

**构建加速思路**（比 Turborepo 更丰富）

- **缓存：** 通过缓存 及 远程缓存，减少构建时间（远程缓存：Nx 公开了一个公共 API，它允许您提供自己的远程缓存实现，Turborepo 必须使用内置的远程缓存）
- **增量构建：** 最小范围构建，非全量构建
- **并行构建：** Nx 自动分析项目的关联关系，对这些任务进行排序以最大化并行性
- **分布式构建：** 结合 Nx Cloud，您的任务将自动分布在 CI 代理中（多台远程构建机器），同时考虑构建顺序、最大化并行化和代理利用率

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8379b44c52064ffe876cc952db3f9402~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

（分布式构建示意图）

**用 Nx 强大的任务调度器加速 Lerna**：Lerna 擅长管理依赖关系和发布，但扩展基于 Lerna 的 Monorepos 很快就会变得很痛苦，因为 Lerna 很慢。这就是 Nx 的闪光点，也是它可以真正加速你的 monorepo 的地方。



#### 比turbo repo多点功能

1. Code Generators：Nx 提供了一些第三方插件来帮助生成特定类型的代码，比如 @nrwl/react， @nrwl/react:component

  @nrwl/react:lib

  当然也可以自定义。



1. Distributed Task Execution(DTE)：

通过Nx Clound分布式执行任务



1. 扩展性：Nx 中的所有内容都是可插拔的，包括任务协调。



#### 使用

Nx 将会启动一个本地服务并打开一个浏览器窗口，其中包含当前代码库项目图的交互式表示。

`nx graph`







### 轻量化 Monorepo工具

此类工具就是解决依赖管理和版本管理的事情

#### Lerna

[Lerna](https://link.juejin.cn?target=https%3A%2F%2Flerna.js.org%2F) **是什么？**

- Lerna 优化了多包工作流，解决了**多包依赖**、**发版手动维护版本**等问题
- Lerna 不提供构建、测试等任务，工程能力较弱，项目中往往需要基于它进行顶层能力的封装

**Lerna 主要做三件事**

- 为单个包或多个包运行命令 (lerna run)
- 管理依赖项 (lerna bootstrap)
- 发布依赖包，处理版本管理，并生成变更日志 (lerna publish)

**Lerna 能解决了什么问题？**

- **代码共享，调试便捷：** 一个依赖包更新，其他依赖此包的包/项目无需安装最新版本，因为 Lerna 自动 Link
- **安装依赖，减少冗余**：多个包都使用相同版本的依赖包时，Lerna 优先将依赖包安装在根目录
- **规范版本管理：** Lerna 通过 Git 检测代码变动，自动发版、更新版本号；两种模式管理多个依赖包的版本号
- **自动生成发版日志**：使用插件，根据 Git Commit 记录，自动生成 ChangeLog





#### yarn/npm + workspace

yarn 1.x 及以上版本，新增 workspace 能力，需要在根目录下 `package.json` 中，声明 `workspace`

```json
{
  "private": true, // 必须是私有项目
  "workspaces": ["project1", "project2/*"]
}
```

**yarn workspace VS Lerna**

- **yarn workspace 更突出对依赖的管理：** 依赖提升到根目录的 `node_modules` 下，安装更快，体积更小
- **Lerna 更突出工作流方面**：使用 Lerna 命令来优化多个包的管理，如：依赖发包、版本管理，批量执行脚本







#### **yarn workspace + Lerna**

**能力分工**：Lerna 将依赖管理交给 yarn workspace；Lerna 承担依赖发布能力。

**操作步骤：**

1. **配置 Lerna 使用 Yarn 管理依赖**：`learn.json` 中配置 `"npmClient": "yarn"`
2. **配置 Lerna 启用 Yarn Workspaces：**

1. 1. 配置 `lerna.json/useWorkspaces = true`
   2. 配置根目录 `package.json/workspaces = ["pacages/*"]` , 此时 lerna.json 中的 packages 配置项将不再使用
   3. 配置根目录 `package.json/private = true`

```scss
上面三个配置项需同时开启, 只开启一个 lerna 会报错
此时执行 lerna bootstrap 相当于执行yarn install，等同于执行 lerna bootstrap --npm-client yarn --use-workspaces
由于 yarn 会自动 hosit 依赖包, 无需再 lerna bootstrap 时增加参数 --hoist (加了参数 lerna 也会报错)
```

1. 不需要发包的项目，配置 `package.json/private = true`



#### Lerna + pnpm + workspace









# 打包工具

## 简介

### 什么是打包工具

> 浏览器只认识html, css, js

企业级项目里都可能会具备哪些功能：

1. typescript: 如果遇到ts文件我们需要使用tsc将typescript代码转换为js代码   
2. React/Vue: 安装react-compiler / vue-complier, 将我们写的jsx文件或者.vue文件转换为render函数
3. less/sass/postcss/component-style: 我们又需要安装less-loader, sass-loader等一系列编译工具
4. 语法降级: babel ---> 将es的新语法转换旧版浏览器可以接受的语法
5. 体积优化: uglifyjs ---> 将我们的代码进行压缩变成体积更小性能更高的文件

将App.tsx ---> tsc ---> App.jsx ---> React-complier ---> js文件

我们写的代码一变化 ---> 有人帮我们自动去tsc, react-compiler, less, babel, uglifyjs全部挨个走一遍 ---> js

这个东西就叫做**构建工具**

> 打包: 将我们写的浏览器不认识的代码 交给构建工具进行编译处理的过程就叫做打包, 打包完成以后会给我们一个浏览器可以认识的文件





### 构建工具做了什么

1. 模块化开发支持: 支持直接从node_modules里引入代码 + 多种模块化支持
2. 处理代码兼容性: 比如babel语法降级, less,ts 语法转换(**不是构建工具做的, 构建工具将这些语法对应的处理工具集成进来自动化处理**)
3. 提高项目性能: 压缩文件, **代码分割**
4. 优化开发体验: 
   - 构建工具会帮你自动监听文件的变化, 当文件变化以后自动帮你调用对应的集成工具进行重新打包, 然后再浏览器重新运行（整个过程叫做热更新, hot replacement
   - 开发服务器: 跨域的问题, 用react-cli create-react-element vue-cli  解决跨域的问题,

构建工具考虑的仅仅是如何将底层基础设施接入到构建过程的问题，自己并不需要提供底层的解决方案，正所谓`术业有专攻`，把专业的事情交给专业的工具去做。



### `module`、`chunk`、`bundle`



**同一份逻辑代码在不同转换场景下的取了三个名字**：

直接写出来的是 module，打包工具处理时是 chunk，最后生成浏览器可以直接运行的 bundle。

对应关系可能是 module(n)->chunk(1)->bundle(n)。

![image-20230927171432332](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-27-17-14-image-20230927171432332.png)

一般来说一个 chunk 对应一个 bundle，比如上图中的 utils.js -> chunks 1 -> utils.bundle.js；但也有例外，比如说上图中，我就用 MiniCssExtractPlugin 从 chunks 0 中抽离出了 index.bundle.css 文件。



### `vendor`

- `vendor`一般用于指第三方包的打包产物。





### 路径

在没有构建工具的情况下, 我们用esmodule规范去导入资源的时候, 要么是绝对路径, 要么是相对路径，并不会从node_modules里去找；但如果有构建工具的情况下就可以直接写包名，构建工具会从node_modules里去找，因为构件工具是在服务端工作的直接读本地文件，而浏览器是通过http请求去访问node_modules，如果浏览器去访问包，由于包里可能还有引用很多其他的包，这样就会导致http请求太多浪费网络资源。

比如：

```js
import _ from "lodash"; // lodash可能也import了其他的东西
```

在处理的过程中如果说看到了有非绝对路径或者相对路径的引用, 他则会尝试开启路径补全

```js
import __vite__cjsImport0_lodash from "/node_modules/.vite/deps/lodash.js?v=ebe57916";
```





### Tree-Shaking

#### 基本介绍

```js
function bar(){
	foo() //这种情况下如果bar没有被调用，则foo就会tree-shake掉
}
```





#### 必要条件

想要实现 Tree-Shaking，模块必须是 ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构。



#### 强制tree-shaking

```js
import {foo} from "./index"
/*#__PURE__*/ foo()
```

注释代码 `/*#__PURE__*/`可以作用在任何语句上，它的作用就是告诉 rollup.js、webpack以及压缩工具（如terser），对foo函数进行 Tree-Shaking，



### 主流的构建工具

- webpack
- vite
- parcel
- esbuild
- rollup
- grunt
- gulp





## 前端工程都有哪些痛点

首先是前端的**模块化需求**。我们知道，业界的模块标准非常多，包括 ESM、CommonJS、AMD 和 CMD 等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。

其次是**兼容浏览器，编译高级语法**。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、 JSX 等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。

再者是**线上代码的质量**问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的`安全性`、`兼容性`问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。

同时，`开发效率`**也不容忽视。** 我们知道，**项目的冷启动/二次启动时间**、**热更新时间**都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。

那么，前端构建工具是如何解决以上问题的呢？

- 模块化方面，提供模块加载方案，并兼容不同的模块规范。
- 语法转译方面，配合 `Sass`、`TSC`、`Babel` 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。
- 产物质量方面，在生产环境中，配合 `Terser`等压缩工具进行代码压缩和混淆，通过 `Tree Shaking` 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。
- 开发效率方面，构建工具本身通过各种方式来进行性能优化，包括`使用原生语言 Go/Rust`、`no-bundle`等等思路，提高项目的启动性能和热更新的速度。





## Code Splitting 解决的问题

在传统的单 chunk 打包模式下，当项目代码越来越庞大，最后会导致浏览器下载一个巨大的文件，从页面加载性能的角度来说，主要会导致以下问题:

- 无法做到**按需加载**，即使是当前页面不需要的代码也会进行加载。
- 页面初始代码包过大，影响首屏渲染性能；
- 线上**缓存复用率**极低，改动一行代码即可导致整个 bundle 产物缓存失效。

首先说第一个问题，一般而言，一个前端页面中的 JS 代码可以分为两个部分: `Initital Chunk`和`Async Chunk`，前者指页面首屏所需要的 JS 代码，而后者当前页面并不一定需要，一个典型的例子就是 `路由组件`，与当前路由无关的组件并不用加载。而项目被打包成单 bundle 之后，无论是`Initial Chunk`还是`Async Chunk`，都会打包进同一个产物，也就是说，浏览器加载产物代码的时候，会将两者一起加载，导致许多冗余的加载过程，从而影响页面性能。而通过`Code Splitting`我们可以将按需加载的代码拆分出单独的 chunk，这样应用在首屏加载时只需要加载`Initial Chunk` 即可，避免了冗余的加载过程，使页面性能得到提升。

其次，线上的`缓存命中率`是一个重要的性能衡量标准。对于线上站点而言，服务端一般在响应资源时加上一些 HTTP 响应头，最常见的响应头之一就是`cache-control`，它可以指定浏览器的**强缓存**，比如设置为下面这样:

```bash
cache-control: max-age=31536000
```

表示资源过期时间为一年，在过期之前，访问**相同的资源 url**，浏览器直接利用本地的缓存，并不用给服务端发请求，这就大大降低了页面加载的网络开销。不过，在单 chunk 打包模式下面，一旦有一行代码变动，整个 chunk 的 url 地址都会变化，比如下图所示的场景:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f359363de91f479894b40b35e610649b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

由于构建工具一般会根据产物的内容生成哈希值，一旦内容变化就会导致整个 chunk 产物的强缓存失效，所以单 chunk 打包模式下的缓存命中率极低，基本为零。

而进行`Code Splitting`之后，代码的改动只会影响部分的 chunk 哈希改动，如下图所示:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bdd076bb07b471a96feb0e05b0bdec5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

入口文件引用了`A`、`B`、`C`、`D`四个组件，当我们修改 A 的代码后，变动的 Chunk 就只有 `A` 以及`依赖 A 的 Chunk` 中，A 对应的 chunk 会变动，这很好理解，后者也会变动是因为相应的引入语句会变化，如这里的入口文件会发生如下内容变动:

```ts
import CompA from './A.d3e2f17a.js'
// 更新 import 语句
import CompA from './A.a5d2f82b.js'
```

也就是说，在改动 `A` 的代码后，`B`、`C`、`D`的 chunk 产物 url 并没有发生变化，从而可以让浏览器复用本地的强缓存，大大提升线上应用的加载性能。







## vite webpack区别

### 简述

<strong style="color: red">Vite 和 Webpack 这样的构建工具都支持根据import()进行代码分割。</strong>

一般的项目使用 Webpack 之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为：

- 项目冷启动时必须递归打包整个项目的依赖树。
  - 因为webpack支持多种模块化（这样就支持代码跑在浏览器端和服务端）, 他一开始必须要统一模块化代码, 所以意味着他需要将所有的依赖全部读一遍，这就导致我们的项目越大，webpack所要处理的js代码就越多，导致webpack需要很长时间才能启动开发服务器。
- JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率

这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是代码打包和文件编译。



而 Vite 很好地解决了这些问题。一方面，Vite 在开发阶段基于浏览器原生 ESM 的支持实现了`no-bundle`服务，另一方面借助 Esbuild 超快的编译速度来做第三方库构建和 TS/JSX 语法编译（不做类型检查），从而能够有效提高开发效率。

除了开发效率，在其他三个维度上， Vite 也表现不俗。

- 模块化方面，Vite 基于浏览器原生 ESM 的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物(如 CommonJS)转换为 ESM。
- 语法转译方面，Vite 内置了对 TypeScript、JSX、Sass 等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。
- 产物质量方面，Vite 基于成熟的打包工具 Rollup 实现生产环境打包，同时可以配合`Terser`、`Babel`等工具链，可以极大程度保证构建产物的质量。





### 详述vite相比于webpack的优势

[官方文档讲的很好](https://cn.vitejs.dev/guide/why.html#the-problems)

Vite 旨在利用生态系统中的新进展解决缓慢的服务器启动和缓慢的更新：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。

#### 缓慢的服务器启动[¶](https://cn.vitejs.dev/guide/why.html#slow-server-start)

当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。

Vite 通过在一开始将应用中的模块区分为 **依赖** 和 **源码** 两类，改进了开发服务器启动时间。

- **依赖** 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。

  Vite 将会使用 [esbuild](https://esbuild.github.io/) [预构建依赖](https://cn.vitejs.dev/guide/dep-pre-bundling.html)（打包）。 将其他规范的代码转换成esmodule规范, 然后放到当前目录下的node_modules/.vite/deps, 同时对esmodule规范的各个模块进行统一集成 。

  

  预构建解决了3个问题：

  1. 统一了第三方包的导出格式
  2. 把包的路径全部改到.vite/deps里
  3. 无论这个库有多少的额外export 和import, vite都会尽可能的将他们进行集成最后只生成一个或者几个模块。将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化。

- **源码** 通常需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。

  Vite 以 [原生 ESM](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 方式提供源码。<strong style="color:red">在 Vite 项目中，一个`import 语句即代表一个 HTTP 请求`。</strong>Vite Dev Server 会读取本地文件，返回浏览器可以解析的代码。当浏览器解析到新的 import 语句，又会发出新的请求，以此类推，直到所有的资源都加载完成。Vite 只需要在浏览器请求源码时进行转换并按需提供源码。即只在当前屏幕上实际使用时才会被处理。

![image-20230106131406201](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230106131406201.png)

#### 缓慢的更新[¶](https://cn.vitejs.dev/guide/why.html#slow-updates)

##### webpack

一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍需要整个重新构建并重载页面。并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热替换（HMR）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降。

##### vite

在 Vite 中HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。这让`vite`的`HMR`直接与当前应用的大小没有关系。

Vite 同时利用 HTTP 头来加速整个页面的重新加载，源码模块的请求会根据 `304 Not Modified` 进行协商缓存，而依赖模块请求则会通过 `Cache-Control: max-age=31536000,immutable` 进行强缓存。

除了 HTTP 缓存，Vite 还设置了本地文件系统的缓存，所有的预构建产物默认缓存在`node_modules/.vite`目录中。如果以下 3 个地方都没有改动，Vite 将一直使用缓存文件:

1. package.json 的 `dependencies` 字段
2. 各种包管理器的 lock 文件
3. `optimizeDeps` 配置内容

`node_modules/.vite/deps,`下：

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-27-20-43-image-20230427204334462.png" alt="image-20230427204334462" style="zoom:50%;" />



## webpack

### 简介

Webpack 是一种用于构建 JavaScript 应用程序的静态模块打包器，它能够以一种相对一致且开放的处理方式，加载应用中的所有资源文件（图片、CSS、视频、字体文件等），并将其合并打包成浏览器兼容的 Web 资源文件。

使用webpack ： `npm i webpack webpack-cli`

### webpack打包过程

- 1.识别入口js文件
- 2.通过逐层识别模块依赖。（Commonjs、amd或者es6的import，webpack都会对其进行分析。来获取代码的依赖）
- css打包成一个文件夹，图片资源打包成一个文件夹，利用html-webpack-plugin 把所有模块都打包进模板html
- 如果与输入相关的需求，找entry（比如多页面就有多个入口）
- 如果与输出相关的需求，找output（比如你需要定义输出文件的路径、名字等等）
- 如果与模块寻址相关的需求，找resolve（比如定义别名alias）
- 如果与转译相关的需求，找loader（比如处理sass处理es678N）。[webpack](https://so.csdn.net/so/search?q=webpack&spm=1001.2101.3001.7020)只认识js文件和JSON文件，所以打包的时候默认是会对这两种类型的文件进行打包。但实际的项目中，除了js和JSON，还有css， img等文件。这些文件就需要依赖loader来进行编译然后才能被浏览器识别并渲染出来。
- 如果与构建流程相关的需求，找plugin（比如我需要在打包完成后，将打包好的文件复制到某个目录，然后提交到git上）
- 4.最终形成打包后的代码



Webpack 的打包过程大致上可简化为：

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230214193230260.png" alt="image-20230214193230260" style="zoom:50%;" />

- **输入**：从文件系统读入代码文件；
- **模块递归处理**：调用 Loader 转译 Module 内容，并将结果转换为 AST，从中分析出模块依赖关系，进一步递归调用模块处理过程，直到所有依赖文件都处理完毕；
- **后处理**：所有模块递归处理完毕后开始执行后处理，包括模块合并、注入运行时、产物优化等，最终输出 Chunk 集合；
- **输出**：将 Chunk 写出到外部文件系统；



### webpack打包原理

- 1.`先逐级递归识别依赖，构建依赖图谱`
- 2.将代码转化成AST抽象语法树
- 3.在AST阶段中去处理代码
- 4.把AST抽象语法树变成浏览器可以识别的代码， 然后输出







### Loader和Plugin的区别

`Loader` 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

`Plugin` 就是插件，基于事件流框架 `Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

`Loader` 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

`Plugin` 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

- 如果与转译相关的需求，找loader（比如处理sass处理es678N）。[webpack](https://so.csdn.net/so/search?q=webpack&spm=1001.2101.3001.7020)只认识js文件和JSON文件，所以打包的时候默认是会对这两种类型的文件进行打包。但实际的项目中，除了js和JSON，还有css， img等文件。这些文件就需要依赖loader来进行编译然后才能被浏览器识别并渲染出来。
- 如果与构建流程相关的需求，找plugin（比如我需要在打包完成后，将打包好的文件复制到某个目录，然后提交到git上）



### 为什么 webpack 构建产物看着很丑？

我们在使用 webpack 构建项目后，会发现打包出来的代码非常的“丑”，这是为什么？原因就是：webpack 支持多种模块规范，但是最后都会变成`commonJS规范`（webpack5 对纯 esm 做了一定的优化），但是浏览器不支持`commonJS规范`，于是 webpack 自己实现了`require`和`module.exports`，所以会有很多 polyfill 代码的注入。

### webpack 按需加载的模块怎么在浏览器中运行？

在实际项目开发中，随着代码越写越多，构建后的 bundle 文件也会越来越大，我们往往按照种种策略对代码进行按需加载，将某部分代码在用户事件触发后再进行加载，那么 webpack 在运行时是怎么实现的呢？

其实原理很简单，就是以 JSONP 的方式加载按需的脚本



### 白话版 webpack 构建流程

#### 图解

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3817f158ef5c443b8ffc139289906902~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### 思路实现

简单模拟下 webpack 实现思路：

```JavaScript
class Compilation {
    constructor(options) {
        this.options = options;
        // 本次编译所有生成出来的模块
        this.modules = [];
        // 本次编译产出的所有代码块, 入口模块和依赖模块打包在一起成为代码块
        this.chunks = [];
        // 本次编译产出的资源文件
        this.assets = {};
    }
    build(callback) {
        //5.根据配置文件中的`entry`配置项找到所有的入口
        let entry = {xxx: 'xxx'};

        //6.从入口文件出发，调用所有配置的loader规则，比如说loader对模块进行编译
        for(let entryName in entry){
            // 6. 从入口文件出发,调用所有配置的Loader对模块进行编译
            const entryModule = this.buildModule(entryName, entryFilePath);
            this.modules.push(entryModule);

            //8.等把所有的模块编译完成后，根据模块之间的依赖关系，组装成一个个包含多个模块的chunk
            let chunk = {
                name: entryName, // 代码块的名称就是入口的名称
                entryModule, // 此代码块对应的入口模块
                modules: this.modules.filter((module) => module.names.includes(entryName)) // 此代码块包含的依赖模块
            };
            this.chunks.push(chunk);
        }

        //9.再把各个代码块chunk转换成一个一个的文件(asset)加入到输出列表
        this.chunks.forEach((chunk) => {
            const filename = this.options.output.filename.replace('[name]', chunk.name); // 获取输出文件名称
            this.assets[filename] = getSource(chunk);
        });
        // 调用编译结束的回掉
        callback(null, {
            modules: this.modules,
            chunks: this.chunks,
            assets: this.assets
        }, this.fileDependencies);

    }

    //当你编译 模块的时候，需要传递你这个模块是属于哪个代码块的，传入代码块的名称
    buildModule(name, modulePath) {
         // 6. 从入口文件出发,调用所有配置的Loader对模块进行编译, loader 只会在编译过程中使用， plugin则会贯穿整个流程
         // 读取模块内容
         let sourceCode = fs.readFileSync(modulePath, 'utf8');
         //创建一个模块对象
         let module = {
             id: moduleId, // 模块ID =》 相对于工作目录的相对路径
             names: [name], // 表示当前的模块属于哪个代码块（chunk）
             dependencies: [], // 表示当前模块依赖的模块
         }

         // 查找所有匹配的loader，自右向左读取loader， 进行转译， 通过loader翻译后的内容一定是JS内容
         sourceCode = loaders.reduceRight((sourceCode, loader) => {
             return require(loader)(sourceCode);
         }, sourceCode);

         // 7. 再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
         // 创建语法树, 遍历语法树，在此过程进行依赖收集， 绘制依赖图
         let ast = parser.parse(sourceCode, { sourceType: 'module' });
         traverse(ast, {});
         let { code } = generator(ast);

         // 把转译后的源代码放到module._source上
         module._source = code;
         // 再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理
         module.dependencies.forEach(({ depModuleId, depModulePath }) => {
            const depModule = this.buildModule(name, depModulePath);
            this.modules.push(depModule)
         });

         return module;
    }
}

function getSource(chunk) {
    return `
     (() => {
      var modules = {
        ${chunk.modules.map(
          (module) => `
          "${module.id}": (module) => {
            ${module._source}
          }
        `
      )}
      };
      var cache = {};
      function require(moduleId) {
        var cachedModule = cache[moduleId];
        if (cachedModule !== undefined) {
          return cachedModule.exports;
        }
        var module = (cache[moduleId] = {
          exports: {},
        });
        modules[moduleId](module, module.exports, require);
        return module.exports;
      }
      var exports ={};
      ${chunk.entryModule._source}
    })();
     `;
}

class Compiler {
    constructor(options) {
        this.options = options;
        this.hooks = {
            run: new SyncHook(),  //会在编译刚开始的时候触发此run钩子
            done: new SyncHook(), //会在编译 结束的时候触发此done钩子
        }
    }

    //4.执行`Compiler`对象的`run`方法开始执行编译
    run() {
        // 在编译前触发run钩子执行， 表示开始启动编译了
        this.hooks.run.call();
        // 编译成功之后的回掉
        const onCompiled = (err, stats, fileDependencies) => {
            // 10. 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统
            for(let filename in stats.assets) {
                fs.writeFileSync(filePath,stats.assets[filename], 'utf8' );
            }
            //当编译成功后会触发done这个钩子执行
            this.hooks.done.call();
        }
        //开始编译，编译 成功之后调用onCompiled方法
        this.compile(onCompiled);
    }

    compile(callback) {
        // webpack虽然只有一个Compiler， 但是每次编译都会产出一个新的Compilation, 用来存放本次编译产出的 文件、chunk、和模块
        // 比如：监听模式会触发多次编译
        let compilation = new Compilation(this.options);
        //执行compilation的build方法进行编译 ，编译 成功之后执行回调
        compilation.build(callback);
    }

}

function webpack(options) {
    //1.初始化参数，从配置文件和shell语句中读取并合并参数，并得到最终的配置对象
    let finalOptions = {...options, ...shellOptions};

    // 2.用上一步的配置对象初始化Compiler对象， 整个编译流程只有一个complier对象
    const compiler = new Compiler(finalOptions);

    // 3.加载所有在配置文件中配置的插件
    const { plugins } = finalOptions;
    for(let plugin of plugins){
        plugin.apply(compiler);
    }

    return compiler;
}

// webpackOptions webpack的配置项
const compiler = webpack(webpackOptions);
//4.执行对象的run方法开始执行编译
compiler.run();
复制代码
```





### Webpack 配置项分类

#### **流程类**

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230214194605196.png" alt="image-20230214194605196" style="zoom:50%;" />

作用于打包流程某个或若干个环节，直接影响编译打包效果的配置项

- 输入输出：
  - `entry`：用于定义项目入口文件，Webpack 会从这些入口文件开始按图索骥找出所有项目文件；
  - `context`：项目执行上下文路径；
  - `output`：配置产物输出路径、名称等；
- 模块处理：
  - `resolve`：用于配置模块路径解析规则，可用于帮助 Webpack 更精确、高效地找到指定模块
  - `module`：用于配置模块加载规则，例如针对什么类型的资源需要使用哪些 Loader 进行处理
  - `externals`：用于声明外部资源，Webpack 会直接忽略这部分资源，跳过这些资源的解析、打包操作
- 后处理：
  - `optimization`：用于控制如何优化产物包体积，内置 Dead Code Elimination、Scope Hoisting、代码混淆、代码压缩等功能
  - `target`：用于配置编译产物的目标运行环境，支持 web、node、electron 等值，不同值最终产物会有所差异
  - `mode`：编译模式短语，支持 `development`、`production` 等值，可以理解为一种声明环境的短语

这里的重点是，Webpack **首先**需要根据输入配置(`entry/context`) 找到项目入口文件；**之后**根据按模块处理(`module/resolve/externals` 等) 所配置的规则逐一处理模块文件，处理过程包括转译、依赖分析等；模块处理完毕后，最后**再根据**后处理相关配置项(`optimization/target` 等)合并模块资源、注入运行时依赖、优化产物结构等。





#### **工具类**

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230214194630723.png" alt="image-20230214194630723" style="zoom:50%;" />

除了核心的打包功能之外，Webpack 还提供了一系列用于提升研发效率的工具，大体上可划分为：

- 开发效率类：
  - `watch`：用于配置持续监听文件变化，持续构建
  - `devtool`：用于配置产物 Sourcemap 生成规则
  - `devServer`：用于配置与 HMR 强相关的开发服务器功能
- 性能优化类：
  - `cache`：Webpack 5 之后，该项用于控制如何缓存编译过程信息与编译结果
  - `performance`：用于配置当产物大小超过阈值时，如何通知开发者
- 日志类：
  - `stats`：用于精确地控制编译过程的日志内容，在做比较细致的性能调试时非常有用
  - `infrastructureLogging`：用于控制日志输出方式，例如可以通过该配置将日志输出到磁盘文件
- 等等

逻辑上，每一个工具类配置都在主流程之外提供额外的工程化能力，例如 `devtool` 用于配置产物 Sourcemap 生成规则，与 Sourcemap 强相关；`devServer` 用于配置与 HMR 相关的开发服务器功能；`watch` 用于实现持续监听、构建。







### 配置

#### 配置示例

```js
/* eslint-disable linebreak-style */
const { resolve } = require('path');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCssAssetsWebpackPlugin = require('optimize-css-assets-webpack-plugin');
const HtmlWebpackPlugin = require('html-webpack-plugin');

// 定义nodejs环境变量：决定使用browserslist的哪个环境
process.env.NODE_ENV = 'production';

// 复用loader
const commonCssLoader = [
  MiniCssExtractPlugin.loader,
  'css-loader',
  {
    // 还需要在package.json中定义browserslist
    loader: 'postcss-loader',
    options: {
      ident: 'postcss',
      plugins: () => [require('postcss-preset-env')()],
    },
  },
];

module.exports = {
  entry: './src/js/index.js',
  output: {
    filename: 'js/built.js',
    path: resolve(__dirname, 'build'),
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [...commonCssLoader],
      },
      {
        test: /\.less$/,
        use: [...commonCssLoader, 'less-loader'],
      },
      /*
        正常来讲，一个文件只能被一个loader处理。
        当一个文件要被多个loader处理，那么一定要指定loader执行的先后顺序：
      */
      {
        // 在package.json中eslintConfig --> airbnb
        test: /\.js$/,
        exclude: /node_modules/,
        // 优先执行
        enforce: 'pre',
        loader: 'eslint-loader',
        options: {
          fix: true,
        },
      },
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        options: {
          presets: [
            [
              '@babel/preset-env',
              {
                useBuiltIns: 'usage',
                corejs: { version: 3 },
                targets: {
                  chrome: '60',
                  firefox: '50',
                },
              },
            ],
          ],
        },
      },
      {
        test: /\.(jpg|png|gif)/,
        loader: 'url-loader', //webpack5可以不用
        options: {
          limit: 8 * 1024,
          name: '[hash:10].[ext]',
          outputPath: 'imgs',
          esModule: false,
        },
      },
      {
        test: /\.html$/,
        loader: 'html-loader',
      },
      {
        exclude: /\.(js|css|less|html|jpg|png|gif)/,
        loader: 'file-loader', //webpack5可以不用
        options: {
          outputPath: 'media',
        },
      },
    ],
  },
  plugins: [
    new MiniCssExtractPlugin({ //本插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载。本插件基于 webpack v5 的新特性构建，并且需要 webpack 5 才能正常工作。
      filename: 'css/built.css',
    }),
    new OptimizeCssAssetsWebpackPlugin(),//A Webpack plugin to optimize \ minimize CSS assets.⚠️ For webpack v5 or above please use css-minimizer-webpack-plugin instead.
    new HtmlWebpackPlugin({ //给它一个HTML5模版，然后生成一个HTML5文件，如果你有多个 webpack 入口点， 他们都会在生成的HTML文件中的 script 标签内。
      template: './src/index.html',
      minify: {
        collapseWhitespace: true,
        removeComments: true,
      },
    }),
  ],
  mode: 'production',
};

```







#### 配置结构详解

##### 单个配置对象

在前面章节中，我们已经编写了许多 Webpack 配置示例，其大多数都以单文件导出单个配置对象方式实现，类似：

```js
module.exports = {
  entry: './src/index.js',
};
```

实际上，Webpack 还支持以数组、函数方式配置运行参数，以适配不同场景应用需求，它们之间大致上区别：

- **单个配置对象**：比较常用的一种方式，逻辑简单，适合大多数业务项目；
- **配置对象数组**：每个数组项都是一个完整的配置对象，每个对象都会触发一次单独的构建，通常用于需要为同一份代码构建多种产物的场景，如 Library；
- **函数**：Webpack 启动时会执行该函数获取配置，我们可以在函数中根据环境参数(如 `NODE_ENV`)动态调整配置对象。

##### 使用配置数组

<font color="red">数组方式主要用于应对“同一份代码打包出多种产物”的场景</font>，可以通过 `--config-name` 参数指定需要构建的配置对象，例如上例配置中若执行 `npx webpack --config-name='amd'`，则仅使用数组中 `name='amd'` 的项做构建。

若是<font color="red">“多份代码打包多份产物”的场景，则建议使用 `entry` 配置多个应用入口</font>。

导出数组的方式很简单，如：

```js
// webpack.config.js
module.exports = [{
  entry: './src/index.js',
  // 其它配置...
}, {
  entry: './src/index.js',
  // 其它配置...
}];
```

使用数组方式时，Webpack 会在启动后创建多个 `Compilation` 实例，并行执行构建工作，但需要注意，`Compilation` 实例间基本上不作通讯，这意味着这种并行构建对运行性能并没有任何正向收益，例如某个 Module 在 `Compilation` 实例 A 中完成解析、构建后，在其它 `Compilation` 中依然需要完整经历构建流程，无法直接复用结果。

例如在构建 Library 时，我们通常需要同时构建出 ESM/CMD/UMD 等模块方案的产物，如：

```js
// webpack.config.js
module.exports = [
  {
    output: {
      filename: './dist-amd.js',
      libraryTarget: 'amd',
    },
    name: 'amd',
    entry: './app.js',
    mode: 'production',
  },
  {
    output: {
      filename: './dist-commonjs.js',
      libraryTarget: 'commonjs',
    },
    name: 'commonjs',
    entry: './app.js',
    mode: 'production',
  },
];
```

使用数组方式时，我们还可以借助 [webpack-merge](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-merge) 工具简化配置逻辑，将公共配置抽取为 `baseConfig` 对象，之后配合 `webpack-merge` 创建不同目标数组项，这种方式可有效减少重复的配置代码，非常推荐使用。

```js
const { merge } = require("webpack-merge");

const baseConfig = {
  output: {
    path: "./dist"
  },
  name: "amd",
  entry: "./app.js",
  mode: "production",
};

module.exports = [
  merge(baseConfig, {
    output: {
      filename: "[name]-amd.js",
      libraryTarget: "amd",
    },
  }),
  merge(baseConfig, {
    output: {
      filename: "./[name]-commonjs.js",
      libraryTarget: "commonjs",
    },
  }),
];
```







##### 使用配置函数

“**配置函数**”这种方式的意义在于，允许用户根据命令行参数动态创建配置对象，可用于实现简单的<font color="red">多环境治理策略 或者 配置内容需要等待异步请求时也可以用。</font>。不过这种方式并不常用于多环境治理，一是因为需要在配置函数内做许多逻辑判断，复杂场景下可能可读性会很低，维护成本高；二是强依赖于命令行参数，可能最终需要写出一串很长的运行命令，应用体验较差。目前社区比较流行通过不同配置文件区分不同环境的运行配置，配合 `--config` 参数实现环境治理。

配置函数方式要求在配置文件中导出一个函数，并在函数中返回 Webpack 配置对象，或配置数组，或 `Promise` 对象，如：

```js
// npx webpack --env app.type=miniapp --mode=production
module.exports = function (env, argv) {
  return {
    mode: argv.mode ? "production" : "development",
    devtool: argv.mode ? "source-map" : "eval",
    output: {
      path: path.join(__dirname, `./dist/${env.app.type}`,
      filename: '[name].js'
    },
    plugins: [
      new TerserPlugin({
        terserOptions: {
          compress: argv.mode === "production", 
        },
      }),
    ],
  };
};
```

运行时，Webpack 会传入两个环境参数对象：

- `env`：通过 `--env` 传递的命令行参数，适用于自定义参数，例如：



| 命令：                                                       | `env` 参数值：                                 |
| ------------------------------------------------------------ | ---------------------------------------------- |
| `npx webpack --env prod`                                     | `{ prod: true }`                               |
| `npx webpack --env prod --env min`                           | `{ prod: true, min: true }`                    |
| `npx webpack --env platform=app --env production`            | `{ platform: "app", production: true }`        |
| npx webpack --env foo=bar=app`                               | `{ foo: "bar=app"}`                            |
| `npx webpack --env app.platform="staging" --env app.name="test"` | `{ app: { platform: "staging", name: "test" }` |



- `argv`：命令行 [Flags](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcli%2F%23flags) 参数，支持 `entry`/`output-path`/`mode`/`merge` 等。



#### 环境治理策略

在现代前端工程化实践中，通常需要将同一个应用项目部署在不同环境(如生产环境、开发环境、测试环境)中，以满足项目参与各方的不同需求。这就要求我们能根据部署环境需求，对同一份代码执行各有侧重的打包策略，例如：

- 开发环境需要使用 `webpack-dev-server` 实现 Hot Module Replacement；
- 测试环境需要带上完整的 Soucemap 内容，以帮助更好地定位问题；
- 生产环境需要尽可能打包出更快、更小、更好的应用代码，确保用户体验。

Webpack 中有许多实现环境治理的方案，比如上面介绍过的，使用“配置函数”配合命令行参数动态计算配置对象。除此之外，业界比较流行将不同环境配置分别维护在单独的配置文件中，如：

```arduino
.
└── config
  ├── webpack.common.js
  ├── webpack.development.js
  ├── webpack.testing.js
  └── webpack.production.js
```

之后配合 `--config` 选项指定配置目标，如：

```arduino
npx webpack --config webpack.development.js
```

这种模式下通常会将部分通用配置放在基础文件中，如上例的 `webpack.common.js`，之后在其它文件中引入该模块并使用 [webpack-merge](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.org%2Fpackage%2Fwebpack-merge) 合并配置对象。

`webpack-merge` 是一个专为 Webpack 设计的数据合并(`merge`)的工具，功能逻辑与 Lodash 的 [merge](https://link.juejin.cn/?target=https%3A%2F%2Fdevdocs.io%2Flodash~4%2Findex%23merge) 函数、 [Object.assign](https://link.juejin.cn/?target=https%3A%2F%2Fdevdocs.io%2Fjavascript%2Fglobal_objects%2Fobject%2Fassign) 等相似，但支持更多特性，如：

- 支持数组属性合并，例如：

```js
merge({ arr: [1] }, { arr: [2] }) === { arr: [1, 2] }
```

- 支持函数属性合并，例如：

```js
const res = merge(
  { func: () => console.log(1) },
  { func: () => console.log(2) }
);
res.func();
// => 1,2 
```

- 支持设定对象合并策略，支持 `match/append/prepend/replace/merge` 规则；
- 支持传入自定义对象合并函数；
- 等等。

这些特性能更好地支持 Webpack 这种高度复杂的数据合并场景，例如对于 `module.rules` 数组，若只是使用 `Object.assign` 做合并，则只会导致后面对象属性替换了前面对象属性；而使用 `webpack-merge` 能够实现两个数组项合并，更符合预期。

接下来，我们用一个 [示例](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Fenv-manage%2Fwebpack.common.js) 简单串一下与 `webpack-merge` 实现环境管理的过程。首先我们需要将通用配置放在公共文件中，如：

```js
// webpack.common.js
const path = require("path");
const HTMLWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  entry: { main: "./src/index.js" },
  output: {
    filename: "[name].js",
    path: path.resolve(__dirname, "dist"),
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        use: ["babel-loader"],
      },
    ],
  },
  plugins: [new HTMLWebpackPlugin()],
};
```

其次，需要安装 `webpack-merge` 做配置合并操作：

```sql
yarn add -D webpack-merge
```

之后，创建对应环境配置文件，如 `webpack.development.js`，并输入开发环境专用配置代码，如：

```js
// webpack.development.js
const { merge } = require("webpack-merge");
const baseConfig = require("./webpack.common");

// 使用 webpack-merge 合并配置对象
module.exports = merge(baseConfig, {
  mode: "development",
  devtool: "source-map",
  devServer: { hot: true },
});
```

最后，执行构建命令并通过 `--config` 参数传入配置文件路径，如：

```ini
npx webpack --config=webpack.development.js
```

#### 核心配置

##### `entry` 配置详解

Webpack 的基本运行逻辑是从 **「入口文件」** 开始，递归加载、构建所有项目资源。`entry` 配置规则支持如下形态：

- 字符串：指定入口文件路径；
- 对象：对象形态功能比较完备，除了可以指定入口文件列表外，还可以指定入口依赖、Runtime 打包方式等；
- 函数：动态生成 Entry 配置信息，函数中可返回字符串、对象或数组；
- 数组：指明多个入口文件，数组项可以为上述介绍的文件路径字符串、对象、函数形式，Webpack 会将数组指明的入口全部打包成一个 Bundle。

例如：

```js
module.exports = {
  //...
  entry: {
    // 字符串形态
    home: './home.js',
    // 数组形态
    shared: ['react', 'react-dom', 'redux', 'react-redux'],
    // 对象形态
    personal: {
      import: './personal.js',
      filename: 'pages/personal.js',
      dependOn: 'shared',
      chunkLoading: 'jsonp',
      asyncChunks: true
    },
    // 函数形态
    admin: function() {
      return './admin.js';
    }
  },
};
```

这其中，**「对象」** 形态的配置逻辑最为复杂，支持如下配置属性：

- `import`：声明入口文件，支持路径字符串或路径数组(多入口)；
- `dependOn`：声明该入口的前置依赖 Bundle；
- `runtime`：设置该入口的 Runtime Chunk，若该属性不为空，Webpack 会将该入口的运行时代码抽离成单独的 Bundle；
- `filename`：效果与 [output.filename](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputfilename) 类同，用于声明该模块构建产物路径；
- `library`：声明该入口的 [output.library](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputlibrary) 配置，一般在构建 NPM Library 时使用；
- `publicPath`：效果与 [output.publicPath](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputpublicpath) 相同，用于声明该入口文件的发布 URL；
- `chunkLoading`：效果与 [output.chunkLoading](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputchunkloading) 相同，用于声明异步模块加载的技术方案，支持 `false/jsonp/require/import` 等值；
- `asyncChunks`：效果与 [output.asyncChunks](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputasyncchunks) 相同，用于声明是否支持异步模块加载，默认值为 `true`。

这些属性中，`dependOn` 与 `runtime` 最为晦涩难懂



###### `dependOn` 

使用 `entry.dependOn` 声明入口依赖：

`dependOn` 属性用于声明前置 Bundle 依赖，从效果上看能够减少重复代码，优化构建产物质量。例如：

```js
module.exports = {
  // ...
  entry: {
    main: "./src/index.js",
    foo: { import: "./src/foo.js", dependOn: "main" },
  },
};
```

> 提示：示例代码已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Fentry-obj%2Fwebpack.config.js)。

示例中，`foo` 入口的 `dependOn` 属性指向 `main` 入口，此时 Webpack 认为：客户端在加载 `foo` 产物之前必然会加载 `main`，因此可以将重复的模块代码、运行时代码等都放到 `main` 产物，减少不必要的重复，最终打包结果：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1558bef8b4cf42f5994750000e1b3725~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

左边为 `main` 产物，包含所有模块、运行时代码，与普通 Bundle 无异；右边为 `foo` 产物，代码结构非常清爽。作为对比，若不指定 `dependOn` 属性，则构建结果两边内容并无差异。

`dependOn` 适用于有明确入口依赖的场景，例如我们构建了一个主框架 Bundle，其中包含了项目基本框架(如 React)，之后还需要为每个页面单独构建 Bundle，这些页面代码也都依赖于主框架代码，此时可用 `dependOn` 属性优化产物内容，减少代码重复。



######  `runtime` 

使用 `entry.runtime` 管理运行时代码：

为支持产物代码在各种环境中正常运行，Webpack 会在产物文件中注入一系列运行时代码，用以支撑起整个应用框架。运行时代码的多寡取决于我们用到多少特性，例如：

- 需要导入导出文件时，将注入 `__webpack_require__.r` 等；
- 使用异步加载时，将注入 `__webpack_require__.l` 等；
- 等等。

不要小看运行时代码量，极端情况下甚至有可能超过业务代码总量！为此，必要时我们可以尝试使用 [runtime](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconcepts%2Fentry-points%2F%23entrydescription-object) 配置将运行时抽离为独立 Bundle，例如：

```js
const path = require("path");

module.exports = {
  mode: "development",
  devtool: false,
  entry: {
    main: { import: "./src/index.js", runtime: "common-runtime" },
    foo: { import: "./src/foo.js", runtime: "common-runtime" },
  },
  output: {
    clean: true,
    filename: "[name].js",
    path: path.resolve(__dirname, "dist"),
  },
};
```

> 提示：示例代码已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Fentry-runtime%2Fwebpack.config.js)。

示例中，`main` 与 `foo` 入口均将 `runtime` 声明为 `common-runtime`，此时 Webpack 会将这两个入口的运行时代码都抽取出来，放在 `common-runtime` Bundle 中，效果：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44051543ac17436abab8dd1844500435~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



##### 使用 `output` 声明输出方式

Webpack 的 [output](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F) 配置项用于声明：如何输出构建结果，比如产物放在什么地方、文件名是什么、文件编码等。`output` 支持许多子配置项，包括：

- [output.path](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputpath)：声明产物放在什么文件目录下；
- [output.filename](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputfilename)：声明产物文件名规则，支持 `[name]/[hash]` 等占位符；
- [output.publicPath](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputpublicpath)：文件发布路径，在 Web 应用中使用率较高；
- [output.clean](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputclean)：是否自动清除 `path` 目录下的内容，调试时特别好用；
- [output.library](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputlibrary)：NPM Library 形态下的一些产物特性，例如：Library 名称、模块化(UMD/CMD 等)规范；
- [output.chunkLoading](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputchunkloading)：声明加载异步模块的技术方案，支持 `false/jsonp/require` 等方式。
- 等等。

对于 Web 应用场景，多数情况下我们只需要使用 `path/filename/publicPath` 即可满足需求，其它属性使用率不高。

##### 使用 `target` 设置构建目标

虽然多数时候 Webpack 都被用于打包 Web 应用，但实际上 Webpack 还支持构建 Node、Electron、NW.js、WebWorker 等应用形态，这一特性主要通过 [target](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Ftarget%2F) 配置控制，支持如下数值：

- `node[[X].Y]`：编译为 Node 应用，此时将使用 Node 的 `require` 方法加载其它 Chunk，支持指定 Node 版本，如：`node12.13`；
- `async-node[[X].Y]`：编译为 Node 应用，与 `node` 相比主要差异在于：`async-node` 方式将以异步(Promise)方式加载异步模块(`node` 时直接使用 `require`)。支持指定 Node 版本，如：`async-node12.13`；
- `nwjs[[X].Y]`：编译为 NW.js 应用；
- `node-webkit[[X].Y]`：同 `nwjs`；
- `electron[[X].Y]-main`：构建为 Electron [主进程](https://link.juejin.cn/?target=https%3A%2F%2Fwww.electronjs.org%2Fzh%2Fdocs%2Flatest%2Ftutorial%2Fprocess-model%23%E4%B8%BB%E8%BF%9B%E7%A8%8B)；
- `electron[[X].Y]-renderer`：构建为 Electron [渲染进程](https://link.juejin.cn/?target=https%3A%2F%2Fwww.electronjs.org%2Fzh%2Fdocs%2Flatest%2Ftutorial%2Fprocess-model%23%E6%B8%B2%E6%9F%93%E5%99%A8%E8%BF%9B%E7%A8%8B)；
- `electron[[X].Y]-preload`：构建为 Electron Preload [脚本](https://link.juejin.cn/?target=https%3A%2F%2Fwww.electronjs.org%2Fzh%2Fdocs%2Flatest%2Ftutorial%2Fprocess-model%23preload-%E8%84%9A%E6%9C%AC)；
- `web`：构建为 Web 应用；
- `esX`：构建为特定版本 ECMAScript 兼容的代码，支持 `es5`、`es2020` 等；
- `browserslist`：根据浏览器平台与版本，推断需要兼容的 ES 特性，数据来源于 [Browserslist](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist%23queries) 项目，用法如：`browserslist: 'last 2 major versions'`。

不同构建目标会根据平台特性打包出略有差异的结果(主要体现在运行时与 NPM Library)，例如对于下面这种使用了异步导入的代码：

```js
// foo.js
export default "foo";

// index.js 
import("./foo").then(console.log);
```

使用如下配置，同时构建 `node` 与 `web` 版本：

```js
const path = require("path");
const { merge } = require("webpack-merge");

const baseConfig = {
  mode: "development",
  target: "web",
  devtool: false,
  entry: {
    main: { import: "./src/index.js" },
  },
  output: {
    clean: true,
    path: path.resolve(__dirname, "dist"),
  },
};

module.exports = [
  merge(baseConfig, { target: "web", output: { filename: "web-[name].js" } }),
  merge(baseConfig, { target: "node", output: { filename: "node-[name].js" } }),
];
```

> 提示：相关示例已上传到小册[仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Ftarget-node-web%2Fwebpack.config.js)，强烈建议你拉下来，对比两种目标下构建产物的差异。

之后，执行构建命令，结果：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/000c2d30c12940018df57f172d33c3b0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看到左边 `web` 版本中需要注入使用 JSONP 异步加载 JS 文件的运行时代码；而右边 `node` 版本则可以直接使用 Node 环境下的 `require` 实现异步加载，因此不需要注入相关运行时。

##### 使用 `mode` 短语

Webpack [内置](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fblob%2Fmain%2Flib%2Fconfig%2Fdefaults.js) 了许多构建优化策略，我们可以通过 [mode](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmode%2F) 配置项切换默认优化规则，支持如下值：

- `production`：默认值，生产模式，使用该值时 Webpack 会自动帮我们开启一系列优化措施：Three-Shaking、Terser 压缩代码、SplitChunk 提起公共代码，通常用于生产环境构建；
- `development`：开发模式，使用该值时 Webpack 会保留更语义化的 Module 与 Chunk 名称，更有助于调试，通常用于开发环境构建；
- `none`：关闭所有内置优化规则。

`mode` 规则比较简单，一般在开发模式使用 `mode = 'development'`，生产模式使用 `mode = 'production'` 即可。





#### 处理Html



HtmlWebpackPlugin({ //给它一个HTML5模版，然后生成一个HTML5文件，如果你有多个 webpack 入口点， 他们都会在生成的HTML文件中的 script 标签内。



#### 打包JS

##### 接入babel

Webpack 场景下，只需使用 `babel-loader` 即可接入 Babel 转译功能：

###### 安装依赖

```bash
npm i -D @babel/core @babel/preset-env babel-loader
```

###### 添加模块处理规则

```js
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: ['babel-loader'],
      },
    ],
  },
};
```

示例中，`module` 属性用于声明模块处理规则，`module.rules` 子属性则用于定义针对什么类型的文件使用哪些 Loader 处理器，上例可解读为：

- `test: /\.js$/`：用于声明该规则的过滤条件，只有路径名命中该正则的文件才会应用这条规则，示例中的 `/\.js$/` 表示对所有 `.js` 后缀的文件生效
- `use`：用于声明这条规则的 Loader 处理器序列，所有命中该规则的文件都会被传入 Loader 序列做转译处理



接入后，可以使用 `.babelrc` 文件或 `rule.options` 属性配置 Babel 功能逻辑，例如：

```js
// 预先安装 @babel/preset-env
// npm i -D @babel/preset-env
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-env'],
            },
          },
        ],
      },
    ],
  },
};
```

特别提一下，示例中的 `@babel/preset-env` 是一种 Babel 预设规则集 —— Preset，这种设计能按需将一系列复杂、数量庞大的配置、插件、Polyfill 等打包成一个单一的资源包，从而简化 Babel 的应用、学习成本。Preset 是 Babel 的主要应用方式之一，社区已经针对不同应用场景打包了各种 Preset 资源，例如：

- [`babel-preset-react`](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fbabel-preset-react)：包含 React 常用插件的规则集，支持 `preset-flow`、`syntax-jsx`、`transform-react-jsx` 等；
- [`@babel/preset-typescript`](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-preset-typescript)：用于转译 TypeScript 代码的规则集
- [`@babel/preset-flow`](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-preset-flow%2F)：用于转译 [Flow](https://link.juejin.cn/?target=https%3A%2F%2Fflow.org%2Fen%2Fdocs%2Fgetting-started%2F) 代码的规则集



###### 执行编译命令

```
npx webpack
```



##### 接入TS

Webpack 有很多种接入 TypeScript 的方法，包括 `ts-loader`、`awesome-ts-loader`、 `babel-loader`。

###### 使用 `ts-loader` 构建 TypeScript 代码

> 在配置ts-loader的时候遇到了 cannot find module error, 建议在./src 下加一个vue-shim.d.ts文件。复制以下代码： 
>
> `declare module "*.vue" { import Vue from "vue"; export default Vue; }`

1. 安装依赖

```bash
npm i -D typescript ts-loader
```

2. 配置 Webpack

```js
const path = require('path');

module.exports = {
  /* xxx */
  module: {
    rules: [
      {
        test: /\.ts$/,
        use: 'ts-loader'
      },
    ],
  },
  resolve: {
    extensions: ['.ts', '.js'],
  }
};
```

- 使用 `module.rules` 声明对所有符合 `/\.ts$/` 正则 —— 即 `.ts` 结尾的文件应用 `ts-loader` 加载器
- 使用 `resolve.extensions` 声明自动解析 `.ts` 后缀文件，这意味着代码如 `import "./a.ts"` 可以忽略后缀声明，简化为 `import "./a"` 文件

3. 创建 `tsconfig.json` 配置文件，并补充 TypeScript 配置信息

```json
// tsconfig.json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "moduleResolution": "node"
  }
}
```

4. 执行编译命令

```
npx webpack
```



###### 使用 `babel-loader`构建

如果项目中已经使用 `babel-loader`，你也可以选择使用 [`@babel/preset-typescript`](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-preset-typescript) 规则集，借助 `babel-loader` 完成 JavaScript 与 TypeScript 的转码工作，不过，`@babel/preset-typescript` 只是简单完成代码转换，并未做类似 `ts-loader` 的类型检查工作，但这样就会转换的更快。

1. 安装依赖

```css
npm i -D @babel/preset-typescript
```

2. 配置 Webpack

```js
// 预先安装 @babel/preset-env
// npm i -D @babel/preset-env
module.exports = {
  /* ... */
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: 'babel-loader',
            options: {
              presets: ['@babel/preset-typescript'],
            },
          },
        ],
      },
    ],
  },
};
```





##### 接入ESLint

1. 安装依赖

```bash
# 安装 webpack 依赖
yarn add -D webpack webpack-cli

# 安装 eslint 
yarn add -D eslint eslint-webpack-plugin

# 简单起见，这里直接使用 standard 规范
yarn add -D eslint-config-standard eslint-plugin-promise eslint-plugin-import eslint-plugin-node eslint-plugin-n
```

2. 在项目根目录添加 `.eslintrc` 配置文件，内容：

```json
// .eslintrc
{
  "extends": "standard"
}
```

> 提示：关于 ESLint 配置项的更多信息，可参考：[eslint.org/docs/user-g…](https://link.juejin.cn/?target=https%3A%2F%2Feslint.org%2Fdocs%2Fuser-guide%2Fconfiguring%2F)

3. 添加 `webpack.config.js` 配置文件，补充 `eslint-webpack-plugin` 配置：

```js
// webpack.config.js
const path = require('path')
const ESLintPlugin = require('eslint-webpack-plugin')

module.exports = {
  entry: './src/index',
  mode: 'development',
  devtool: false,
  output: {
    filename: '[name].js',
    path: path.resolve(__dirname, 'dist')
  },
  // 添加 eslint-webpack-plugin 插件实例
  plugins: [new ESLintPlugin()]
}
```

4. 执行编译命令

```
npx webpack
```

除常规 JavaScript 代码风格检查外，我们还可以使用适当的 ESLint 插件、配置集实现更丰富的检查、格式化功能，这里推荐几种使用率较高第三方扩展，建议读者跟进学习：

- [`eslint-config-airbnb`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fairbnb%2Fjavascript%2Ftree%2Fmaster%2Fpackages%2Feslint-config-airbnb)：Airbnb 提供的代码风格规则集，算得上 ESLint 生态第一个成名的规则集合
- [`eslint-config-standard`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstandard%2Feslint-config-standard)：[Standard.js](https://link.juejin.cn/?target=https%3A%2F%2Fstandardjs.com%2F) 代码风格规则集，史上最便捷的统一代码风格的方式
- [`eslint-plugin-vue`](https://link.juejin.cn/?target=https%3A%2F%2Feslint.vuejs.org%2F)：实现对 Vue SFC 文件的代码风格检查
- [`eslint-plugin-react`](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-plugin-react)：实现对 React 代码风格检查
- [`@typescript-eslint/eslint-plugin`](https://link.juejin.cn/?target=https%3A%2F%2Ftypescript-eslint.io%2Fdocs%2Fdevelopment%2Farchitecture%2Fpackages%2F)：实现对 TypeScript 代码风格检查
- [`eslint-plugin-sonarjs`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FSonarSource%2Feslint-plugin-sonarjs)：基于 `Sonar` 的代码质量检查工具，提供圈复杂度、代码重复率等检测功能







#### 打包css

##### 概览

原生 Webpack 并不能识别 CSS 语法，假如不做额外配置直接导入 `.css` 文件，会导致编译失败。为此，在 Webpack 中处理 CSS 文件，通常需要用到：

- [`css-loader`](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Floaders%2Fcss-loader%2F)：该 Loader 会将 CSS 等价翻译为形如 `module.exports = "${css}"` 的JavaScript 代码，使得 Webpack 能够如同处理 JS 代码一样解析 CSS 内容与资源依赖；

- [`style-loader`](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Floaders%2Fstyle-loader%2F)：**开发环境**：使用 `style-loader` 将在产物中注入一系列 runtime 代码，这些代码会将样式代码注入到页面 `<style>` 标签，使得样式生效。

  >  这种将 JS、CSS 代码合并进同一个产物文件的方式有几个问题：
  >
  > - JS、CSS 资源无法并行加载，从而降低页面性能；
  > - 资源缓存粒度变大，JS、CSS 任意一种变更都会致使缓存失效。
  >
  > 因此，生产环境中通常会用 [`mini-css-extract-plugin`](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fmini-css-extract-plugin) 插件替代 `style-loader`，将样式代码抽离成单独的 CSS 文件。

  

- [`mini-css-extract-plugin`](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fmini-css-extract-plugin)：**生产环境**：使用 `mini-css-extract-plugin` 将样式代码抽离到单独产物文件，并以 `<link>` 标签方式引入到页面中。

> PS：当 Webpack 版本低于 5.0 时，请使用 [`extract-text-webpack-plugin`](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fextract-text-webpack-plugin) 代替 `mini-css-extract-plugin`。





##### `css-loader` 

`css-loader` 提供了很多处理 CSS 代码的基础能力，包括 CSS 到 JS 转译、依赖解析、Sourcemap、css-in-module 等，基于这些能力，Webpack 才能像处理 JS 模块一样处理 CSS 模块代码。接入时首先需要安装依赖：

```bash
yarn add -D css-loader
```

之后修改 Webpack 配置，定义 `.css` 规则：

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ["css-loader"],
      },
    ],
  },
};
```

此后，执行 `npx webpack` 或其它构建命令即可。经过 `css-loader` 处理后，样式代码最终会被转译成一段 JS 字符串，但这段字符串只是被当作普通 JS 模块处理，并不会实际影响到页面样式



#####  `style-loader` 

与其它 Loader 不同，`style-loader` 并不会对代码内容做任何修改，而是简单注入一系列运行时代码，用于将 `css-loader` 转译出的 JS 字符串插入到页面的 `style` 标签。接入时同样需要安装依赖：

```csharp
yarn add -D style-loader css-loader
```

之后修改 Webpack 配置，定义 `.css` 规则：

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/i,
        use: ["style-loader", "css-loader"],
      },
    ],
  },
};
```

> PS：注意保持 `style-loader` 在前，`css-loader` 在后

上述配置语义上相当于 `style-loader(css-loader(css))` 链式调用，执行后样式代码会被转译为类似下面这样的代码：

```js
// Part1: css-loader 处理结果，对标到原始 CSS 代码
const __WEBPACK_DEFAULT_EXPORT__ = (
"body {\n    background: yellow;\n    font-weight: bold;\n}"
);
// Part2: style-loader 处理结果，将 CSS 代码注入到 `style` 标签
injectStylesIntoStyleTag(
 __WEBPACK_DEFAULT_EXPORT__
)
```

至此，运行页面触发 `injectStylesIntoStyleTag` 函数将 CSS 代码注入到 `<style>` 标签，样式才真正开始生效。







##### [`mini-css-extract-plugin`](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fmini-css-extract-plugin) 

使用时，首先需要安装依赖：

```csharp
yarn add -D mini-css-extract-plugin
```

之后，添加配置信息：

```js
const MiniCssExtractPlugin = require('mini-css-extract-plugin')
const HTMLWebpackPlugin = require('html-webpack-plugin')

module.exports = {
    module: {
        rules: [{
            test: /\.css$/,
            use: [
                // 根据运行环境判断使用那个 loader
                (process.env.NODE_ENV === 'development' ?
                    'style-loader' :
                    MiniCssExtractPlugin.loader),
                'css-loader'
            ]
        }]
    },
    plugins: [
        new MiniCssExtractPlugin(),
        new HTMLWebpackPlugin()
    ]
}
```

这里需要注意几个点：

- `mini-css-extract-plugin` 库同时提供 Loader、Plugin 组件，需要同时使用
- `mini-css-extract-plugin` 不能与 `style-loader` 混用，否则报错，所以上述示例中第 9 行需要判断 `process.env.NODE_ENV` 环境变量决定使用那个 Loader
- `mini-css-extract-plugin` 需要与 `html-webpack-plugin` 同时使用，才能将产物路径以 `link` 标签方式插入到 html 中

至此，运行 Webpack 后将同时生成 JS、CSS、HTML 三种产物文件



##### 预处理器

在 Webpack 中只需使用适当 Loader 即可接入预处理器，以 Less 为例，首先安装依赖：

```csharp
yarn add -D less less-loader
```

其次，修改 Webpack 配置，添加 `.less` 处理规则：

```js
module.exports = {
    module: {
        rules: [{
            test: /\.less$/,
            use: [
                'style-loader',
                'css-loader',
                'less-loader'
            ]
        }]
    }
}
```



##### Post-css

预处理器通常定义了一套 CSS 之上的超集语言；PostCSS 并没有定义一门新的语言，而是与 `@babel/core` 类似，只是实现了一套将 CSS 源码解析为 AST 结构，并传入 PostCSS 插件做处理的流程框架，具体功能都由插件实现。

> 预处理器之于 CSS，就像 TypeScript 与 JavaScript 的关系；而 PostCSS 之于 CSS，则更像 Babel 与 JavaScript。

PostCSS 的接入步骤也很简单，首先安装依赖：

```csharp
yarn add -D postcss postcss-loader
```

这个时候的 PostCSS 还只是个空壳，下一步还需要使用适当的 PostCSS 插件进行具体的功能处理，例如我们可以使用 [`autoprefixer`](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer) 插件自动添加浏览器前缀（ <font color="red">注意：autoprefixer需要在package.json添加browserslist或者添加.browserslistrc文件才生效</font>），首先安装依赖：

```csharp
yarn add -D autoprefixer
```

之后，修改 Webpack 配置：

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          "style-loader", 
          {
            loader: "css-loader",            
            options: {
              importLoaders: 1
            }
          }, 
          {
            loader: "postcss-loader",
            options: {
              postcssOptions: {
                // 添加 autoprefixer 插件
                plugins: [require("autoprefixer")],
              },
            },
          }
        ],
      },
    ],
  }
};
```

还可以选择将 PostCSS 相关配置抽离保存到 `postcss.config.js` 文件。

PostCSS 与预处理器并非互斥关系，我们完全可以在同一个项目中同时使用两者，例如：

```js
module.exports = {
  module: {
    rules: [
      {
        test: /\.less$/,
        use: [
          "style-loader", 
          {
            loader: "css-loader",            
            options: {
              importLoaders: 1
            }
          }, 
          "postcss-loader",
          "less-loader"
        ],
      },
    ],
  }
};
```

基于这一特性，我们既能复用预处理语法特性，又能应用 PostCSS 丰富的插件能力处理诸如雪碧图、浏览器前缀等问题。

PostCSS 最大的优势在于其简单、易用、丰富的插件生态，基本上已经能够覆盖样式开发的方方面面。实践中，经常使用的插件有：

- [autoprefixer](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer)：基于 [Can I Use](https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F) 网站上的数据，自动添加浏览器前缀
- [postcss-preset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjonathantneal%2Fpostcss-preset-env)：一款将最新 CSS 语言特性转译为兼容性更佳的低版本代码的插件
- [postcss-less](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fshellscape%2Fpostcss-less)：兼容 Less 语法的 PostCSS 插件，类似的还有：[postcss-sass](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FAleshaOleg%2Fpostcss-sass)、[poststylus](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmadeleineostoja%2Fpoststylus)
- [stylelint](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstylelint%2Fstylelint)：一个现代 CSS 代码风格检查器，能够帮助识别样式代码中的异常或风格问题





#### 打包图像资源

##### 在 Webpack 4 中导入图像

原生 Webpack 4 只能处理标准 JavaScript 模块，因此需要借助 Loader —— 例如 `file-loader`、`url-loader`、`raw-loader` 等完成图像加载操作，实践中我们通常需要按资源类型选择适当加载器，简单介绍：

- [file-loader](https://link.juejin.cn/?target=https%3A%2F%2Fv4.webpack.js.org%2Floaders%2Ffile-loader%2F)：将图像引用转换为 url 语句并生成相应图片文件，例如使用如下配置：

```js
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: ['file-loader']
    }],
  },
};
```

经过 `file-loader` 处理后，原始图片会被重命名并复制到产物文件夹，同时在代码中插入图片 URL 地址，形如：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6384383d6df4060b973bd3ad8f261eb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

- [url-loader](https://link.juejin.cn/?target=https%3A%2F%2Fv4.webpack.js.org%2Floaders%2Furl-loader%2F)：有两种表现，对于小于阈值 `limit` 的图像直接转化为 base64 编码；大于阈值的图像则调用 `file-loader` 进行加载，例如如下配置：

```js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      use: [{
        loader: 'url-loader',
        options: {
          limit: 1024
        }
      }]
    }],
  },
};
```

经过 `url-loader` 处理后，小于 `limit` 参数即 1024B 的图片会被转译为 Base64 编码，如：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d735d771f4c4436bc0b80e145098314~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

对于超过 `limit` 值的图片则直接调用 `file-loader` 完成加载。

`url-loader` 同样适用于大多数图片格式，且能将许多细小的图片直接内嵌进产物中，减少页面运行时需要发出的网络请求数，在 HTTP 1.1 及之前版本中能带来正向的性能收益。

- [raw-loader](https://link.juejin.cn/?target=https%3A%2F%2Fv4.webpack.js.org%2Floaders%2Fraw-loader)：不做任何转译，只是简单将文件内容复制到产物中，适用于 SVG 场景，例如如下配置：

```js
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.svg$/i,
        use: ['raw-loader'],
      },
    ],
  },
};
```

经过 `raw-loader` 处理后，SVG 资源会被直接复制成字符串形式：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c51ac80e214c41b2b695b2ea71e5ab33~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 提示：除 `raw-loader` 外，我们还可以使用如下 Loader 加载 SVG 资源：
>
> - [svg-inline-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsvg-inline-loader)：能够自动删除 SVG 图片中与显式无关的各种原信息，达到压缩效果；
> - [svg-url-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsvg-url-loader)：以 [DataURL](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FHTTP%2FBasics_of_HTTP%2FData_URIs) 方式导入 SVG 图片，相比于 Base64 更节省空间；
> - [react-svg-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Freact-svg-loader)：导入 SVG 图片并自动转化为 React 组件形态，效果类似 [@svgr/webpack](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F%40svgr%2Fwebpack)；
> - [vue-svg-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvue-svg-loader)：导入 SVG 图片并自动转化为 Vue 组件形态。







##### Webpack 5 中导入图像

上述 `file-loader`、`url-loader`、`raw-loader` 都并不局限于处理图片，它们还可以被用于加载任意类型的多媒体或文本文件，使用频率极高，几乎已经成为标配组件！所以 Webpack5 直接内置了这些能力，开箱即可使用。

用法上，原本需要安装、导入 Loader，Webpack5 之后只需要通过 `module.rules.type` 属性指定[资源类型](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fguides%2Fasset-modules%2F)即可，对比来看：

- `file-loader` 对标到 `type = "asset/resource"'`：

```js
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
-     use: ['file-loader']
+     type: 'asset/resource'
    }],
  },
};
```

> 提示：默认情况下，`asset/resource` 生成的文件会以 `[hash][ext][query]` 方式重命名，可以通过 [output.assetModuleFilename](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputassetmodulefilename) 属性控制。

- `url-loader` 对标到 `type = "asset"` 或 `type = "asset/inline"`：

```js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
-     use: [{
-       loader: 'url-loader',
-       options: {
-         limit: 1024
-       }
-     }]
+     type: "asset",
+     parser: {
+        dataUrlCondition: {
+          maxSize: 1024 // 1kb
+        }
+     }
    }],
  },
};
```

其中，[module.rules.parser.dataUrlCondition](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23ruleparserdataurlcondition) 用于限定文件大小阈值，对标 `url-loader` 的 `limit` 属性。

- `raw-loader` 对标到 `type = "asset/source"`：

```js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.svg$/i,
-       use: ['raw-loader']
+       type: "asset/source"
      },
    ],
  },
};
```







##### 图像优化：压缩

前面介绍的 Loader 与 Asset Modules 都只是解决了图像资源加载 —— 也就是让 Webpack 能够理解、处理图像资源，现实中我们还需要为 Web 页面中的图片做各种优化，提升页面性能，常见的优化方法包括：

- **图像压缩**：减少网络上需要传输的流量；
- **雪碧图**：减少 HTTP 请求次数；
- **响应式图片**：根据客户端设备情况下发适当分辨率的图片，有助于减少网络流量；
- **CDN**：减少客户端到服务器之间的物理链路长度，提升传输效率；
- 等等。

在 Webpack 生态中有不少优秀的图像压缩组件，包括：[image-webpack-loader](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftcoopman%2Fimage-webpack-loader)、[imagemin-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fimagemin-webpack-plugin)、[image-minimizer-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fimage-minimizer-webpack-plugin) 等，以我的使用经验来看，[image-webpack-loader](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftcoopman%2Fimage-webpack-loader) 组件功能齐全且用法简单，更推荐使用。基本用法首先安装依赖：

```arduino
yarn add -D image-webpack-loader
```

之后配置 Loader：

```js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(gif|png|jpe?g|svg)$/i,
      // type 属性适用于 Webpack5，旧版本可使用 file-loader
      type: "asset/resource",
      use: [{
        loader: 'image-webpack-loader',
        options: {
          // jpeg 压缩配置
          mozjpeg: {
            quality: 80
          },
          disable: process.env.NODE_ENV === 'development' //图像压缩是一种非常耗时的操作，建议只在生产环境下开启。
        }
      }]
    }],
  },
};
```

[image-webpack-loader](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftcoopman%2Fimage-webpack-loader) 底层依赖于 [imagemin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fimagemin%2Fimagemin) 及一系列的图像优化工具：

- [mozjpeg](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fimagemin%2Fimagemin-mozjpeg)：用于压缩 JPG(JPEG) 图片；
- [optipng](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkevva%2Fimagemin-optipng)：用于压缩 PNG 图片；
- [pngquant](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fimagemin%2Fimagemin-pngquant)：同样用于压缩 PNG 图片；
- [svgo](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkevva%2Fimagemin-svgo)：用于压缩 SVG 图片；
- [gifsicle](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fkevva%2Fimagemin-gifsicle)：用于压缩 Gif 图；
- [webp](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fimagemin%2Fimagemin-webp)：用于将 JPG/PNG 图压缩并转化为 WebP 图片格式。

基本上已经覆盖 Web 页面常用的图片格式，具体用法可点击上述链接查阅，此处不再赘述。





##### 图像优化：响应式图片

移动互联网时代，我们需要面对的客户端设备越来越多样复杂，分辨率从 PC 到平板电脑再到移动终端跨度极大：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f14b1077cf14b2196bf051e4eded84a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这会带来一个问题：同一张图片(主要是位图)在不同设备中，如果显示尺寸大于原始尺寸，最终效果会有明显颗粒感；而如果显示尺寸小于原始尺寸，又会造成带宽浪费。理想的解决方案是为不同设备提供不同的分辨率、不同尺寸的图片 —— 也就是所谓的[响应式图片](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FLearn%2FHTML%2FMultimedia_and_embedding%2FResponsive_images)。

Webpack 中有不少能够自动生成响应式图片的组件，例如： [resize-image-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fresize-image-loader)、[html-loader-srcset](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fhtml-loader-srcset)、[responsive-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fresponsive-loader) 等，以 [responsive-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fresponsive-loader) 为例，首先安装依赖：

```csharp
yarn add -D responsive-loader sharp
```

之后，修改配置：

```js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.(png|jpg)$/,
      oneOf: [{
        type: "javascript/auto",
        resourceQuery: /sizes?/,
        use: [{
          loader: "responsive-loader",
          options: {
            adapter: require("responsive-loader/sharp"),
          },
        }],
      }, {
        type: "asset/resource",
      }],
    }],
  }
};
```

注意，实践中我们通常没必要对项目里所有图片都施加响应式特性，因此这里使用 `resourceQuery` 过滤出带 `size/sizes` 参数的图片引用，使用方法：

```js
// 引用图片，并设置响应式参数
import responsiveImage from './webpack.jpg?sizes[]=300,sizes[]=600,sizes[]=1024';

const Picture = function () {
  return (
    <img
      srcSet={responsiveImage.srcSet}
      src={responsiveImage.src}
      sizes="(min-width: 1024px) 1024px, 100vw"
      loading="lazy"
    />
  );
};
```

上例的引用参数 `'./webpack.jpg?sizes[]=300,sizes[]=600,sizes[]=1024';` 最终将生成宽度分别为 300、600、1024 三张图片，之后设置 `img` 标签的 [srcset](https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3schools.com%2Ftags%2Fatt_source_srcset.asp) 属性即可实现图片响应式功能。

此外，我们还能简单地通过 `size` 参数精确控制不同条件下的图像尺寸：

```css
.foo {
    background: url("./webpack.jpg?size=1024");
}

@media (max-width: 480px) {
    .foo {
        background: url("./webpack.jpg?size=300");
    }
}
```

> 提示：除本文提及的基本功能外，[responsive-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fresponsive-loader) 还提供了许多用于控制产物、压缩比等特性的配置项，有需要的同学可到 [官网](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fresponsive-loader) 展开阅读。









#### 打包VUE

##### 使用 Vue-loader 处理 SFC 代码

形态上，Vue SFC(Single File Component) 文件(`*.vue`)是使用类 HTML 语法描述 Vue 组件的自定义文件格式，文件由四种类型的顶层语法块组成：

- `<template>`：用于指定 Vue 组件模板内容，支持类 HTML、Pug 等语法，其内容会被预编译为 JavaScript 渲染函数；
- `<script>`：用于定义组件选项对象，在 Vue2 版本支持导出普通对象或 [defineComponent](https://link.juejin.cn/?target=https%3A%2F%2Fv3.cn.vuejs.org%2Fapi%2Fglobal-api.html%23definecomponent) 值；Vue3 之后还支持 `<script setup>` 方式定义组件的 `setup()` 函数；
- `<style>`：用于定义组件样式，通过配置适当 Loader 可实现 Less、Sass、Stylus 等预处理器语法支持；也可通过添加 `scoped`、`module` 属性将样式封装在当前组件内；
- Custom Block：用于满足领域特定需求而预留的 SFC 扩展模块，例如 `<docs>`；Custom Block 通常需要搭配特定工具使用，详情可参考 [Custom Blocks | Vue Loader](https://link.juejin.cn/?target=https%3A%2F%2Fvue-loader.vuejs.org%2Fguide%2Fcustom-blocks.html%23example) 。

原生 Webpack 并不能处理这种内容格式的文件，为此我们需要引入专用于 Vue SFC 的加载器：`vue-loader`。首先，依然是安装依赖：

```bash
yarn add -D webpack webpack-cli vue-loader
```

之后，修改 Webpack 配置，加入 `vue-loader` 相关声明：

```js
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      {
        test: /\.vue$/,
        use: ["vue-loader"],
      },
            {
        test: /\.css$/,
        use: ["style-loader", "css-loader"],
      },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```

> 提示：`vue-loader` 库同时提供用于处理 SFC 代码转译的 Loader 组件，与用于处理上下文兼容性的 Plugin 组件，两者需要同时配置才能正常运行。

经过 `vue-loader` 处理后，SFC 各个模块会被等价转译为普通 JavaScript 模块，`<template>` 内容会被转译为用于构造 [Virtual Dom](https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fextras%2Frendering-mechanism.html%23virtual-dom) 结构的 `render` 函数；`<script>` 标签导出的对象会被转译为 JavaScript 对象字面量形式。例如：

![image-20230214214245209](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230214214245209.png)





##### ts

为了在 `<script>` 使用 TypeScript 编写组件逻辑，首先需要安装 `ts-loader` 等及相关依赖：

```bash
npm install -D typescript ts-loader
```

其次，修改 Webpack 配置，添加用于处理 TypeScript 代码的规则：

```js
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      { test: /\.vue$/, use: ["vue-loader"] },
      { test: /\.ts$/, use: ["ts-loader"] },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```

之后，设置 `<script>` 标签的 `lang = "typescript"`：

```js
<script lang="typescript">
export default {
  data() {
    return { message: "Hello World" };
  },
};
</script>
```

此后，`vue-loader` 会根据 `lang` 属性值，按 Webpack 配置的 TypeScript 规则，调用 `ts-loader` 处理这部分代码。

> 提示：同理，与处理普通 `.ts`、`.js` 文件类似的，我们还可以通过 Webpack 的 `module.rule` 配置项继续接入 ESLint、Babel、Flow 等工具，这些规则也都会对 Vue SFC 文件模块生效。



##### Less

```bash
yarn add -D less less-loader css-loader style-loader
```

其次，修改 Webpack 配置，添加 Less 文件相关处理规则：

```js
const path = require("path");
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      { test: /\.vue$/, use: ["vue-loader"] },
      {
        test: /\.less$/,
        use: ["style-loader", "css-loader", "less-loader"],
      },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```

之后，设置 `<style>` 标签的 `lang = "less"`：

```html
<style lang="less">
h3 {
  margin: 40px 0 0;
  color: #42b983;
  span {
    font-weight: normal;
  }
}
</style>
```

至此，Webpack 就会像处理其它 `.less` 文件一般，使用 `less-loader` 加载这一模块内容。

> 提示：其它 CSS 相关工具，如 Sass、Stylus、PostCSS 均遵循同样规则。





##### `<template>` 

`<template>` 的处理规则会稍微不同，因为绝大部分 Webpack 模板类 Loader 都会返回一个模板函数，而不是编译好的 HTML 片段，这与 Vue SFC 将 `<template>` 编译为 `render` 函数的规则相冲突，此时通常需要使用一个返回原始的 HTML 字符串的 loader，例如使用 `pug-plain-loader`，而不是 `pug-loader`。

接入过程，首先安装依赖：

```csharp
yarn add -D pug pug-plain-loader
```

其次，修改 Webpack 配置：

```js
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      { test: /\.pug$/, use: ["pug-plain-loader"] },
      { test: /\.vue$/, use: ["vue-loader"] }
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```

之后，设置 `<template>` 标签的 `lang = " pug"`：

```xml
<template lang="pug">
  div.hello
    h3 {{message}}
  </div>
</template>
```

至此，Webpack 就会像处理其它 `.pug` 文件一般使用 `pug-plain-loader` 加载这一模块内容。完整示例：

```js
const { VueLoaderPlugin } = require("vue-loader");

module.exports = {
  module: {
    rules: [
      { test: /\.pug$/, use: ["pug-plain-loader"] },
      { test: /\.vue$/, use: ["vue-loader"] },
      { test: /\.ts$/, use: ["ts-loader"] },
      {
        test: /\.less$/,
        use: ["style-loader", "css-loader", "less-loader"],
      },
    ],
  },
  plugins: [new VueLoaderPlugin()],
};
```





##### SSR

在 Vue 场景下，通常可以选择 [Nuxt.js](https://link.juejin.cn/?target=https%3A%2F%2Fnuxtjs.org%2F)、[Quasar](https://link.juejin.cn/?target=https%3A%2F%2Fquasar.dev%2F)、[`@vue/server-renderer`](https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fscaling-up%2Fssr.html) 等方案实现 SSR，这些技术的底层逻辑都包含三个大的步骤：

- 编译时，将同一组件构建为适合在客户端、服务器运行的两份副本；
- 服务端接收到请求时，调用 Render 工具将组件渲染为 HTML 字符串，并返回给客户端；
- 客户端运行 HTML，并再次执行组件代码，“激活(Hydrate)” 组件。

接下来，我们使用 Webpack、Vue3、Express、[`@vue/server-renderer`](https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fscaling-up%2Fssr.html) 框架搭建一套完备的 Vue SSR 引用，示例目录结构(代码已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTecvan-fe%2Fwebpack-book-samples%2Ftree%2Fmain%2F5-2_use-ssr))：详情看范文杰小册第五章



##### SSG

SSR 不是银弹，依然带来了不少新问题：

- 更高的架构复杂度，这意味着更高的维护、扩展、学习成本；
- Node 与浏览器环境不完全匹配，部分浏览器特定的代码，只能在某些生命周期钩子函数中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在 SSR 中运行；
- 组件要求更高，需要兼容 Node.js Server 运行环境；
- 服务端负载更高，毕竟相较于纯粹提供静态资源的 SPA 形式，SSR 需要在 Node 进程中执行大量 CPU 运算以渲染 HTML 片段。

因此，对于用户不敏感的应用，如公司官网、营销活动页等，还可以使用 [Static Site Generation](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fchrisvfritz%2Fprerender-spa-plugin) (或叫 Pre-renderer) 方式，在编译构建阶段提前生成各页面的静态 HTML 代码，这样技能满足 SEO 需求，又尽可能降低架构、编码复杂度。

在 Webpack4 环境下，可选择 [prerender-spa-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fchrisvfritz%2Fprerender-spa-plugin) 实现 SSG 功能，但实测发现该插件并不兼容 Webpack5





#### 启动本地服务

##### `webpack-dev-server`

`webpack-dev-server` 启动一套本地开发服务器。`webpack-dev-server` 主要提供两种功能：

- 结合 Webpack 工作流，提供基于 HTTP(S) 协议的静态资源服务；
- 提供资源热更新能力，在保持页面状态前提下自动更新页面代码，提升开发效率。

接入时，首先安装依赖：

```bash
yarn add -D webpack-dev-server
```

其次，修改 Webpack 配置，添加 `devServer` 配置项：

```js
const path = require('path')
const { VueLoaderPlugin } = require('vue-loader')
const HtmlWebpackPlugin = require('html-webpack-plugin')

module.exports = {
  devServer: {
    hot: true,
    open: true
  },
  module: {
    rules: [
      { test: /\.vue$/, use: ['vue-loader'] },
      { test: /\.css$/, use: ["style-loader", "css-loader"] },
    ]
  },
  plugins: [
    new VueLoaderPlugin(),
    new HtmlWebpackPlugin({
      templateContent: `
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Webpack App</title>
  </head>
  <body>
    <div id="app" />
  </body>
</html>
    `
    })
  ]
}
```

- `devServer.hot`：用于声明是否使用热更新能力，接受 bool 值。
- `devServer.open`：用于声明是否自动打开页面，接受 bool 值。

之后，运行 `npx webpack serve` 命令，即可自动打开带热更功能的页面







#### 打包NPM 库

##### 初始化项目

```bash
mkdir test-lib && cd test-lib
npm init -y
```

虽然有很多构建工具能够满足 NPM 库的开发需求，但现在暂且选择 Webpack，所以需要先装好基础依赖：

```bash
yarn add -D webpack webpack-cli
```

基础编译配置如下：

```js
// webpack.config.js
const path = require("path");

module.exports = {
  mode: "development",
  entry: "./src/index.js",
  output: {
    filename: "[name].js",
    path: path.join(__dirname, "./dist"),
+   library: {
+     name: "_",
+     type: "umd",
+   },
  },
};
```

> 提示：我们还可以在上例基础上叠加任意 Loader、Plugin，例如： `babel-loader`、`eslint-loader`、`ts-loader` 等。



##### 上述配置模块化方案

- [output.library.name](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputlibraryname)：用于定义模块名称，在浏览器环境下使用 `script` 加载该库时，可直接使用这个名字调用模块，例如：

```html
<!DOCTYPE html>
<html lang="en">
...
<body>
    <script src="https://examples.com/dist/main.js"></script>
    <script>
        // Webpack 会将模块直接挂载到全局对象上
        window._.add(1, 2)
    </script>
</body>

</html>
```

- [output.library.type](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputlibrarytype)：用于编译产物的模块化方案，可选值有：`commonjs`、`umd`、`module`、`jsonp` 等，通常选用兼容性更强的 `umd` 方案即可。

修改前后对应的产物内容如下：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9676ffea7de5445d809662f3355760b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

修改前(即没有配置模块化方案前)代码会被包装成一个 IIFE ；而使用 `output.library` （配置了模块化方案为umd）后，代码被包装成 UMD(Universal Module Definition) 模式：

```js
(function webpackUniversalModuleDefinition(root, factory) {
    if(typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if(typeof define === 'function' && define.amd)
        define([], factory);
    else if(typeof exports === 'object')
        exports["_"] = factory();
    else
        root["_"] = factory();
})(self, function() {
 // ...
});
```

这种形态会在 NPM 库启动时判断运行环境，自动选择当前适用的模块化方案，此后我们就能在各种场景下使用 `test-lib` 库，例如：

```js
// ES Module
import {add} from 'test-lib';

// CommonJS
const {add} = require('test-lib');

// HTML
<script src="https://examples.com/dist/main.js"></script>
<script>
    // Webpack 会将模块直接挂载到全局对象上
    window._.add(1, 2)
</script>
```



##### 排除第三方依赖

使用 [externals](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fexternals%2F) 配置项，将第三方依赖排除在打包系统之外：

```js
// webpack.config.js
module.exports = {
  // ...
+  externals: {
+   lodash: {
+     commonjs: "lodash",
+     commonjs2: "lodash",
+     amd: "lodash",
+     root: "_",
+   },
+ },
  // ...
};
```

> 提示： Webpack 编译过程会跳过 [externals](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fexternals%2F) 所声明的库，并假定消费场景已经安装了相关依赖，常用于 NPM 库开发场景；在 Web 应用场景下则常被用于优化性能。
>
> 例如，我们可以将 React 声明为外部依赖，并在页面中通过 `<script>` 标签方式引入 React 库，之后 Webpack 就可以跳过 React 代码，提升编译性能。

改造后，再次执行 `npx webpack`，编译结果如下：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d59a2a8dcc5c40f489b3c39dbafcc27c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

改造后，主要发生了两个变化：

1. 产物仅包含 `test-lib` 库代码，体积相比修改前大幅降低；
2. UMD 模板通过 `require`、`define` 函数中引入 `lodash` 依赖并传递到 `factory`。

至此，Webpack 不再打包 `lodash` 代码，我们可以顺手将 `lodash` 声明为 `peerDependencies`：

```json
{
  "name": "6-1_test-lib",
  // ...
+ "peerDependencies": {
+   "lodash": "^4.17.21"
+ }
}
```

实践中，多数第三方框架都可以沿用上例方式处理，包括 React、Vue、Angular、Axios、Lodash 等，方便起见，可以直接使用 [webpack-node-externals](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-node-externals) 排除所有 `node_modules` 模块，使用方法：

```js
// webpack.config.js
const nodeExternals = require('webpack-node-externals');

module.exports = {
  // ...
+  externals: [nodeExternals()]
  // ...
};
```





##### 抽离 CSS 代码

假设我们开发的 NPM 库中包含了 CSS 代码 ，我们通常需要使用 `mini-css-extract-plugin` 插件将样式抽离成单独文件，由用户自行引入。

这是因为 Webpack 处理 CSS 的方式有很多，例如使用 `style-loader` 将样式注入页面的 `<head>` 标签；使用 `mini-css-extract-plugin` 抽离样式文件。作为 NPM 库开发者，如果我们粗暴地将 CSS 代码打包进产物中，有可能与用户设定的方式冲突。

为此，需要在前文基础上添加如下配置：

```js
module.exports = {  
  // ...
+ module: {
+   rules: [
+     {
+       test: /\.css$/,
+       use: [MiniCssExtractPlugin.loader, "css-loader"],
+     },
+   ],
+ },
+ plugins: [new MiniCssExtractPlugin()],
};
```



##### 生成 Sourcemap

Sourcemap 是一种代码映射协议，它能够将经过压缩、混淆、合并的代码还原回未打包状态，帮助开发者在生产环境中精确定位问题发生的行列位置，所以一个成熟的 NPM 库除了提供兼容性足够好的编译包外，通常还需要提供 Sourcemap 文件。

接入方法很简单，只需要添加适当的 `devtool` 配置：

```js
// webpack.config.js
module.exports = {  
  // ...
+ devtool: 'source-map'
};
```

再次执行 `npx webpack` 就可以看到 `.map` 后缀的映射文件：

```markdown
├─ test-lib
│  ├─ package.json
│  ├─ webpack.config.js
│  ├─ src
│  │  ├─ index.css
│  │  ├─ index.js
│  ├─ dist
│  │  ├─ main.js
│  │  ├─ main.js.map
│  │  ├─ main.css
│  │  ├─ main.css.map
```

此后，业务方只需使用 `source-map-loader` 就可以将这段 Sourcemap 信息加载到自己的业务系统中，实现框架级别的源码调试能力。



##### 其它 NPM 配置

至此，开发 NPM 库所需的 Webpack 配置就算是介绍完毕了，接下来我们还可以用一些小技巧优化项目配置，提升开发效率，包括：

- 使用 `.npmignore` 文件忽略不需要发布到 NPM 的文件；
- 在 `package.json` 文件中，使用 `prepublishOnly` 指令，在发布前自动执行编译命令，例如：

```json
// package.json
{
  "name": "test-lib",
  // ...
  "scripts": {
    "prepublishOnly": "webpack --mode=production"
  },
  // ...
}
```

- 在 `package.json` 文件中，使用 `main` 指定项目入口，同时使用 `module` 指定 ES Module 模式下的入口，以允许用户直接使用源码版本，例如：

```json
{
  "name": "6-1_test-lib",
  // ...
  "main": "dist/main.js",
  "module": "src/index.js",
  "scripts": {
    "prepublishOnly": "webpack --mode=production"
  },
  // ...
}
```









### 优化

#### Webpack 底层的工作流程

大致可以总结为这么几个阶段：

1. 初始化阶段：
   - **初始化参数**：从配置文件、 配置对象、Shell 参数中读取，与默认配置结合得出最终的参数；
   - **创建编译器对象**：用上一步得到的参数创建 Compiler 对象；
   - **初始化编译环境**：包括注入内置插件、注册各种模块工厂、初始化 RuleSet 集合、加载配置的插件等；
   - **开始编译**：执行 compiler 对象的 run 方法，创建 Compilation 对象；
   - **确定入口**：根据配置中的 `entry` 找出所有的入口文件，调用 `compilation.addEntry` 将入口文件转换为 `dependence` 对象。
2. 构建阶段：
   - **编译模块(make)**：从 `entry` 文件开始，调用 `loader` 将模块转译为标准 JS 内容，调用 JS 解析器将内容转换为 AST 对象，从中找出该模块依赖的模块，再 **递归** 处理这些依赖模块，直到所有入口依赖的文件都经过了本步骤的处理；
   - **完成模块编译**：上一步递归处理所有能触达到的模块后，得到了每个模块被翻译后的内容以及它们之间的`依赖关系图`。
3. 封装阶段：
   - **合并(\**\*\*seal\*\**\*)**：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 `Chunk`；
   - **优化(optimization)**：对上述 `Chunk` 施加一系列优化操作，包括：tree-shaking、terser、scope-hoisting、压缩、Code Split 等；
   - **写入文件系统(emitAssets)**：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。

在这个过程中有不少可能造成性能问题的地方：

- 构建阶段：
  - 首先需要将文件的相对引用路径转换为绝对路径，这个过程可能涉及多次 IO 操作，执行效率取决于 **文件层次深度**；
  - 找到具体文件后，需要读入文件内容并调用 [loader-runner](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fwebpack%2Floader-runner%2Fblob%2FHEAD%2Flib%2FLoaderRunner.js) 遍历 Loader 数组完成内容转译，这个过程需要执行较密集的 CPU 操作，执行效率取决于 **Loader 的数量与复杂度**；
  - 需要将模块内容解析为 AST 结构，并遍历 AST 找出模块的依赖资源，这个过程同样需要较密集的 CPU 操作，执行效率取决于 **代码复杂度**；
  - 递归处理依赖资源，执行效率取决于 **模块数量**。
- 封装阶段：
  - 根据 `splitChunks` 配置、`entry` 配置、动态模块引用语句等，确定模块与 Chunk 的映射关系，其中 `splitChunks` 相关的分包算法非常复杂，涉及大量 CPU 计算；
  - 根据 `optimization` 配置执行一系列产物优化操作，特别是 [Terser](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fterser-webpack-plugin) 插件需要执行大量 AST 相关的运算，执行效率取决于 **产物代码量**；
- 等等。

Webpack 需要执行非常密集的 IO 与 CPU 操作，计算成本高，再加上 Webpack 以及大多数组件都使用 JavaScript 编写，无法充分利用多核 CPU 能力，所以在中大型项性能通常表现较差。不过，这些性能问题是可以被优化的！





#### 提高构建性能







##### 持久化缓存

###### Webpack5 

[持久化缓存](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fcache%2F%23cache) 算得上是 Webpack 5 最令人振奋的特性之一，它能够将首次构建的过程与结果数据持久化保存到本地文件系统，在下次执行构建时跳过解析、链接、编译等一系列非常消耗性能的操作，直接复用上次的 Module/ModuleGraph/Chunk 对象数据，迅速构建出最终产物。

在 Webpack5 中设置 `cache.type = 'filesystem'` 即可开启：

```js
module.exports = {
    //...
    cache: {
        type: 'filesystem'
    },
    //...
};
```

此外，`cache` 还提供了若干用于配置缓存效果、缓存周期的配置项，包括：

- `cache.type`：缓存类型，支持 `'memory' | 'filesystem'`，需要设置为 `filesystem` 才能开启持久缓存；
- `cache.cacheDirectory`：缓存文件路径，默认为 `node_modules/.cache/webpack` ；
- `cache.buildDependencies`：额外的依赖文件，当这些文件内容发生变化时，缓存会完全失效而执行完整的编译构建，通常可设置为各种配置文件，如：

```JavaScript
module.exports = {
  cache: {
    type: 'filesystem',
    buildDependencies: {
      config: [
        path.join(__dirname, 'webpack.dll_config.js'),
        path.join(__dirname, '.babelrc')
      ],
    },
  },
};
```

- `cache.managedPaths`：受控目录，Webpack 构建时会跳过新旧代码哈希值与时间戳的对比，直接使用缓存副本，默认值为 `['./node_modules']`；
- `cache.profile`：是否输出缓存处理过程的详细日志，默认为 `false`；
- `cache.maxAge`：缓存失效时间，默认值为 `5184000000` 。

使用时通常关注上述配置项即可，其它如 `idleTimeout`、`idleTimeoutAfterLargeChanges` 等项均与 Webpack 内部实现算法有关，与缓存效果关系不大。

###### 缓存原理

Webpack5 会将首次构建出的 Module、Chunk、ModuleGraph 等对象序列化后保存到硬盘中，后面再运行的时候，就可以跳过许多耗时的编译动作，直接复用缓存数据。

回过头来看看 Webpack 的构建过程，大致上可划分为三个阶段。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230220120107470.png" alt="image-20230220120107470" style="zoom:50%;" />

- 初始化，主要是根据配置信息设置内置的各类插件。
- Make - 构建阶段，从`entry`模块开始，执行：
  - 读入文件内容；
  - 调用 Loader 转译文件内容；
  - 调用 [acorn](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Facorn) 生成 AST 结构；
  - 分析 AST，确定模块依赖列表；
  - 遍历模块依赖列表，对每一个依赖模块重新执行上述流程，直到生成完整的模块依赖图 —— ModuleGraph 对象。
- Seal - 生成阶段，过程：
  - 遍历模块依赖图，对每一个模块执行：
    - 代码转译，如 `import` 转换为 `require` 调用；
    - 分析运行时依赖。
  - 合并模块代码与运行时代码，生成 chunk；
  - 执行产物优化操作，如 Tree-shaking；
  - 将最终结果写出到产物文件。

过程中存在许多 CPU 密集型操作，例如调用 Loader 链加载文件时，遇到 babel-loader、eslint-loader、ts-loader 等工具时可能需要重复生成 AST；分析模块依赖时则需要遍历 AST，执行大量运算；Seal 阶段也同样存在大量 AST 遍历，以及代码转换、优化操作，等等。假设业务项目中有 1000 个文件，则每次执行 `npx webpack` 命令时，都需要从 0 开始执行 1000 次构建、生成逻辑。

而 Webpack5 的持久化缓存功能则将构建结果保存到文件系统中，在下次编译时对比每一个文件的内容哈希或时间戳，未发生变化的文件跳过编译操作，直接使用缓存副本，减少重复计算；发生变更的模块则重新执行编译流程。缓存执行时机如下图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc6ac3a471664560b3db676e73cb0c62~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

如图，Webpack 在首次构建完毕后将 Module、Chunk、ModuleGraph 三类对象的状态序列化并记录到缓存文件中；在下次构建开始时，尝试读入并恢复这些对象的状态，从而跳过执行 Loader 链、解析 AST、解析依赖等耗时操作，提升编译性能。

###### Webpack4：使用 `cache-loader`

Webpack5 的持久化缓存用法简单，效果出众，但可惜在 Webpack4 及之前版本原生还没有相关实现，只能借助一些第三方组件实现类似效果，包括：

- 使用 `[cache-loader](https://www.npmjs.com/package/cache-loader)`；
- 使用 `[hard-source-webpack-plugin](https://github.com/mzgoddard/hard-source-webpack-plugin)`；
- 使用 Loader（如 `babel-loader`、`eslint-loader`)）自带的缓存能力。

先从 `cache-loader` 说起，`cache-loader` 能够将 Loader 处理结果保存到硬盘，下次运行时若文件内容没有发生变化则直接返回缓存结果，用法：

1. 安装依赖：

```Bash
yarn add -D cache
```

1. 修改配置，注意必须将 `cache-loader` 放在 `loader` 数组首位，例如：

```JavaScript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.js$/,
            use: ['cache-loader', 'babel-loader', 'eslint-loader']
        }]
    },
    // ...
};
```

`cache-loader` 只缓存了 Loader 执行结果，缓存范围与精度不如 Webpack5 内置的缓存功能，所以性能效果相对较低，以 ThreeJS 为例，`production` 模式下构建耗时从 10602ms 降低到 1540ms；`development` 模式从 11130ms 降低到 4247ms，多次测试性能提升稳定在 60% ~ 80% 之间。虽然比不上 Webpack5 的持久化缓存，但在 Webpack4 中不失为一种简单而有效的性能优化手段。

此外，`cache-loader` 还提供了一系列控制缓存逻辑的配置属性，特别是 `read/write` 可以用于改变缓存数据的持久化逻辑，借助这两个属性我们甚至能够实现多台机器间的缓存共享：

```JavaScript
const redis = require("redis");
const client = redis.createClient();

// 读数据
async function read(key, callback) {
  // ...
  const result = await client.get(key);
  const data = JSON.parse(result);
  callback(null, data);
}

// 写数据
async function write(key, data, callback) {
  // ...
  await client.set(key, JSON.stringify(data));
  callback();
}

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: "cache-loader",
            // 传入 read、write 函数
            options: { read, write },
          },
          "babel-loader",
        ],
      },
    ],
  },
};
```

借助这种能力，我们可以打通本地与线上 CI/CD 环境，实现开发与生产环境构建的构建性能优化。

###### Webpack4：使用 `hard-source-webpack-plugin`

[hard-source-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmzgoddard%2Fhard-source-webpack-plugin) 也是一种实现缓存功能的第三方组件，与 `cache-loader` 不同的是，它并不仅仅缓存了 Loader 运行结果，还保存了 Webpack 构建过程中许多中间数据，包括：模块、模块关系、模块 Resolve 结果、Chunks、Assets 等，效果几乎与 Webpack5 自带的 Cache 对齐。用法：

1. 安装依赖：

```Bash
yarn add -D hard-source-webpack-plugin
```

1. 添加配置：

```JavaScript
const HardSourceWebpackPlugin = require("hard-source-webpack-plugin");

module.exports = {
  // ...
  plugins: [
    new HardSourceWebpackPlugin(),
  ],
};
```

首次运行时，`hard-source-webpack-plugin` 会在缓存文件夹 `node_module/.cache` 写入一系列日志文件：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44c94fac904645f19fe1d342ff58ec03~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

下次运行时，`hard-source-webpack-plugin` 插件会复用缓存中记录的数据，跳过一系列构建步骤，从而提升构建性能。

`hard-source-webpack-plugin` 插件的底层逻辑与 Webpack5 的持久化缓存很相似，但优化效果稍微差一些，以 ThreeJS 为例，`production` 模式下构建耗时从 10602ms 降低到 1740ms；`development` 模式构建从 11130ms 降低到 3280ms，多次测试性能提升稳定在 62% ~ 88% 之间。

###### 使用组件自带的缓存功能

除了上面介绍的持久化缓存、`cache-loader`、`hard-source-webpack-plugin` 方案外，我们还可以使用 Webpack 组件自带的缓存能力提升特定领域的编译性能，这一类组件有：

- [babel-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fbabel-loader)；
- [eslint-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-loader)：旧版本 ESLint Webpack 组件，官方推荐使用 [eslint-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-webpack-plugin) 代替；
- [eslint-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-webpack-plugin)；
- [stylelint-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fstylelint-webpack-plugin)。

例如使用 `babel-loader` 时，只需设置 `cacheDirectory = true` 即可开启缓存功能，例如：

```JavaScript
module.exports = {
    // ...
    module: {
        rules: [{
            test: /\.m?js$/,
            loader: 'babel-loader',
            options: {
                cacheDirectory: true,
            },
        }]
    },
    // ...
};
```

以 Three.js 为例，开启缓存后生产环境构建耗时从 3500ms 降低到 1600ms；开发环境构建从 6400ms 降低到 4500ms，性能提升约 30% ~ 50% 。

默认情况下，缓存内容会被保存到 `node_modules/.cache/babel-loader` 目录，你也可以通过 `cacheDirectory = 'dir'` 属性设置缓存路径。

此外，ESLint 与 Stylelint 这一类耗时较长的 Lint 工具也贴心地提供了相应的缓存能力，只需设置 `cache = true` 即可开启，如：

```JavaScript
// webpack.config.js
module.exports = {
  plugins: [
    new ESLintPlugin({ cache: true }),
    new StylelintPlugin({ files: '**/*.css', cache: true }),
  ],
};
```

依然以 Three.js 为例，开启 ESLint 缓存后生产环境构建耗时从 6400ms 降低到 1400ms；开发环境构建从 7000ms 降低到 2100ms，性能提升达到 70% ~ 80%。





##### 并行构建

###### 简介

受限于 Node.js 的单线程架构，原生 Webpack 对所有资源文件做的所有解析、转译、合并操作本质上都是在同一个线程内串行执行，CPU 利用率极低，因此，理所当然地，社区出现了一些以多进程方式运行 Webpack，或 Webpack 构建过程某部分工作的方案(从而提升单位时间利用率)，例如：

- [HappyPack](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack)：多进程方式运行资源加载(Loader)逻辑；
- [Thread-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Floaders%2Fthread-loader%2F)：Webpack 官方出品，同样以多进程方式运行资源加载逻辑；
- [Parallel-Webpack](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fparallel-webpack)：多进程方式运行多个 Webpack 构建实例；
- [TerserWebpackPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fterser-webpack-plugin%23terseroptions)：支持多进程方式执行代码压缩、uglify 功能。

这些方案的核心设计都很类似：针对某种计算任务创建子进程，之后将运行所需参数通过 IPC 传递到子进程并启动计算操作，计算完毕后子进程再将结果通过 IPC 传递回主进程，寄宿在主进程的组件实例，再将结果提交给 Webpack。

理论上，并行确实能够提升系统运行效率，但 Node 单线程架构下，所谓的并行计算都只能依托与派生子进程执行，而创建进程这个动作本身就有不小的消耗 —— 大约 600ms，对于小型项目，构建成本可能可能很低，引入多进程技术反而导致整体成本增加。

###### 使用 HappyPack

[HappyPack](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Famireh%2Fhappypack) 能够将耗时的**文件加载**（Loader）操作拆散到多个子进程中并发执行，子进程执行完毕后再将结果合并回传到 Webpack 进程，从而提升构建性能。不过，HappyPack 的用法稍微有点难以理解，需要同时：

- 使用 `happypack/loader` 代替原本的 Loader 序列；
- 使用 `HappyPack` 插件注入代理执行 Loader 序列的逻辑。

基本用法：

1. 安装依赖：

```Bash
yarn add -D happypack
```

1. 将原有 `loader` 配置替换为 `happypack/loader`，如：

```JavaScript
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
};
```

1. 创建 `happypack` 插件实例，并将原有 loader 配置迁移到插件中，完整配置：

```JavaScript
const HappyPack = require("happypack");

module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        use: "happypack/loader",
        // 原始配置如：
        // use: [
        //  {
        //      loader: 'babel-loader',
        //      options: {
        //          presets: ['@babel/preset-env']
        //      }
        //  },
        //  'eslint-loader'
        // ]
      },
    ],
  },
  plugins: [
    new HappyPack({
      // 将原本定义在 `module.rules.use` 中的 Loader 配置迁移到 HappyPack 实例中
      loaders: [
        {
          loader: "babel-loader",
          option: {
            presets: ["@babel/preset-env"],
          },
        },
        "eslint-loader",
      ],
    }),
  ],
};
```

配置完毕后，再次启动 `npx webpack` 命令，即可使用 HappyPack 的多进程能力提升构建性能。

上述示例仅演示了使用 HappyPack 加载单一资源类型的场景，实践中我们还可以创建多个 HappyPack 插件实例，来加载多种资源类型 —— 只需要用 `id` 参数做好 Loader 与 Plugin 实例的关联即可，例如：

```JavaScript
const HappyPack = require('happypack');

module.exports = {
  // ...
  module: {
    rules: [{
        test: /\.js?$/,
        // 使用 `id` 参数标识该 Loader 对应的 HappyPack 插件示例
        use: 'happypack/loader?id=js'
      },
      {
        test: /\.less$/,
        use: 'happypack/loader?id=styles'
      },
    ]
  },
  plugins: [
    new HappyPack({
      // 注意这里要明确提供 id 属性
      id: 'js',
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```

这里的重点是：

- `js`、`less` 资源都使用 `happypack/loader` 作为唯一加载器，并分别赋予 `id = 'js' | 'styles'` 参数；
- 创建了两个 `HappyPack` 插件实例并分别配置 `id` 属性，以及用于处理 js 与 css 的 `loaders` 数组；
- 启动后，`happypack/loader` 与 `HappyPack` 插件实例将通过 `id` 值产生关联，以此实现对不同资源执行不同 Loader 序列。

上面这种多实例模式虽然能应对多种类型资源的加载需求，但默认情况下，HappyPack 插件实例 **自行管理** 自身所消费的进程，需要导致频繁创建、销毁进程实例 —— 这是非常昂贵的操作，反而会带来新的性能损耗。

为此，HappyPack 提供了一套简单易用的共享进程池接口，只需要创建 `HappyPack.ThreadPool` 对象，并通过 `size` 参数限定进程总量，之后将该例配置到各个 HappyPack 插件的 `threadPool` 属性上即可，例如：

```JavaScript
const os = require('os')
const HappyPack = require('happypack');
const happyThreadPool = HappyPack.ThreadPool({
  // 设置进程池大小
  size: os.cpus().length - 1
});

module.exports = {
  // ...
  plugins: [
    new HappyPack({
      id: 'js',
      // 设置共享进程池
      threadPool: happyThreadPool,
      loaders: ['babel-loader', 'eslint-loader']
    }),
    new HappyPack({
      id: 'styles',
      threadPool: happyThreadPool,
      loaders: ['style-loader', 'css-loader', 'less-loader']
    })
  ]
};
```

使用 `HappyPack.ThreadPool` 接口后，HappyPack 会预先创建好一组工作进程，所有插件实例的资源转译任务会通过内置的 `HappyThread` 对象转发到空闲进程做处理，避免频繁创建、销毁进程。

最后，我们再来看看 HappyPack 的执行流程：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b8c529796f1480f8454cc3ac5f6b2a9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

核心步骤：

- `happlypack/loader` 接受到转译请求后，从 Webpack 配置中读取出相应 HappyPack 插件实例；
- 调用插件实例的 `compile` 方法，创建 `HappyThread` 实例（或从 `HappyThreadPool` 取出空闲实例）；
- `HappyThread` 内部调用 `child_process.fork` 创建子进程，并执行`HappyWorkerChannel` 文件；
- `HappyWorkerChannel` 创建 `HappyWorker` ，开始执行 Loader 转译逻辑；

中间流程辗转了几层，最终由 `HappyWorker` 类重新实现了一套与 Webpack Loader 相似的转译逻辑，代码复杂度较高，大家稍作了解即可。

HappyPack 虽然确实能有效提升 Webpack 的打包构建速度，但它有一些明显的缺点：

- 作者已经明确表示不会继续维护，扩展性与稳定性缺乏保障，随着 Webpack 本身的发展迭代，可以预见总有一天 HappyPack 无法完全兼容 Webpack；
- HappyPack 底层以自己的方式重新实现了加载器逻辑，源码与使用方法都不如 Thread-loader 清爽简单，而且会导致一些意想不到的兼容性问题，如 `awesome-typescript-loader`；
- HappyPack 主要作用于文件加载阶段，并不会影响后续的产物生成、合并、优化等功能，性能收益有限。

###### 使用 Thread-loader

[Thread-loader](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Floaders%2Fthread-loader%2F) 与 HappyPack 功能类似，都是以多进程方式加载文件的 Webpack 组件，两者主要区别：

1. Thread-loader 由 Webpack 官方提供，目前还处于持续迭代维护状态，理论上更可靠；
2. Thread-loader 只提供了一个 Loader 组件，用法简单很多；
3. HappyPack 启动后会创建一套 Mock 上下文环境 —— 包含 `emitFile` 等接口，并传递给 Loader，因此对大多数 Loader 来说，运行在 HappyPack 与运行在 Webpack 原生环境相比没有太大差异；但 Thread-loader 并不具备这一特性，所以要求 Loader 内不能调用特定上下文接口，兼容性较差。

说一千道一万，先来看看基本用法：

1. 安装依赖：

```Bash
yarn add -D thread-loader
```

1. 将 Thread-loader 放在 `use` 数组首位，确保最先运行，如：

```JavaScript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: ["thread-loader", "babel-loader", "eslint-loader"],
      },
    ],
  },
};
```

启动后，Thread-loader 会在加载文件时创建新的进程，在子进程中使用 `loader-runner` 库运行 `thread-loader` 之后的 Loader 组件，执行完毕后再将结果回传到 Webpack 主进程，从而实现性能更佳的文件加载转译效果。

以 Three.js 为例，使用 Thread-loader 前，构建耗时大约为 11000ms 到 18000ms 之间，开启后耗时降低到 8000ms 左右，提升约37%。

此外，Thread-loader 还提供了一系列用于控制并发逻辑的配置项，包括：

- `workers`：子进程总数，默认值为 `require('os').cpus() - 1`；
- `workerParallelJobs`：单个进程中并发执行的任务数；
- `poolTimeout`：子进程如果一直保持空闲状态，超过这个时间后会被关闭；
- `poolRespawn`：是否允许在子进程关闭后重新创建新的子进程，一般设置为 `false` 即可；
- `workerNodeArgs`：用于设置启动子进程时，额外附加的参数。

使用方法跟其它 Loader 一样，都是通过 `use.options` 属性传递，如：

```JavaScript
module.exports = {
  module: {
    rules: [
      {
        test: /\.js$/,
        use: [
          {
            loader: "thread-loader",
            options: {
              workers: 2,
              workerParallelJobs: 50,
              // ...
            },
          },
          "babel-loader",
          "eslint-loader",
        ],
      },
    ],
  },
};
```

不过，Thread-loader 也同样面临着频繁的子进程创建、销毁所带来的性能问题，为此，Thread-loader 提供了 `warmup` 接口用于前置创建若干工作子进程，降低构建时延，用法：

```JavaScript
const threadLoader = require("thread-loader");

threadLoader.warmup(
  {
    // 可传入上述 thread-loader 参数
    workers: 2,
    workerParallelJobs: 50,
  },
  [
    // 子进程中需要预加载的 node 模块
    "babel-loader",
    "babel-preset-es2015",
    "sass-loader",
  ]
);
```

执行效果与 `HappyPack.ThreadPool` 相似，此处不再赘述。

与 HappyPack 相比，Thread-loader 有两个突出的优点，一是产自 Webpack 官方团队，后续有长期维护计划，稳定性有保障；二是用法更简单。但它不可避免的也存在一些问题：

- 在 Thread-loader 中运行的 Loader 不能调用 `emitAsset` 等接口，这会导致 `style-loader` 这一类加载器无法正常工作，解决方案是将这类组件放置在 `thread-loader` 之前，如 `['style-loader', 'thread-loader', 'css-loader']`；
- Loader 中不能获取 `compilation`、`compiler` 等实例对象，也无法获取 Webpack 配置。

这会导致一些 Loader 无法与 Thread-loader 共同使用，大家需要仔细加以甄别、测试。

###### 使用 Parallel-Webpack

Thread-loader、HappyPack 这类组件所提供的并行能力都仅作用于文件加载过程，对后续 AST 解析、依赖收集、打包、优化代码等过程均没有影响，理论收益还是比较有限的。对此，社区还提供了另一种并行度更高，以多个独立进程运行 Webpack 实例的方案 —— [Parallel-Webpack](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftrivago%2Fparallel-webpack)，基本用法：

1. 安装依赖：

```Bash
yarn add -D parallel-webpack
```

1. 在 `webpack.config.js` 配置文件中导出多个 Webpack 配置对象，如：

```JavaScript
module.exports = [{
    entry: 'pageA.js',
    output: {
        path: './dist',
        filename: 'pageA.js'
    }
}, {
    entry: 'pageB.js',
    output: {
        path: './dist',
        filename: 'pageB.js'
    }
}];
```

1. 执行 `npx parallel-webpack` 命令。

Parallel-Webpack 会为配置文件中导出的每个 Webpack 配置对象启动一个独立的构建进程，从而实现并行编译的效果。底层原理很简单，基本上就是在 Webpack 上套了个壳：

- 根据传入的配置项数量，调用 `worker-farm` 创建复数个工作进程；
- 工作进程内调用 Webpack 执行构建；
- 工作进程执行完毕后，调用 `node-ipc` 向主进程发送结束信号。

这种方式在需要同时执行多份配置的编译时特别有效，但若配置文件本身只是导出了单个配置对象则意义不大。

为了更好地支持多种配置的编译，Parallel-Webpack 还提供了 `createVariants` 函数，用于根据给定变量组合，生成多份 Webpack 配置对象，如：

```JavaScript
const createVariants = require('parallel-webpack').createVariants
const webpack = require('webpack')

const baseOptions = {
  entry: './index.js'
}

// 配置变量组合
// 属性名为 webpack 配置属性；属性值为可选的变量
// 下述变量组合将最终产生 2*2*4 = 16 种形态的配置对象
const variants = {
  minified: [true, false],
  debug: [true, false],
  target: ['commonjs2', 'var', 'umd', 'amd']
}

function createConfig (options) {
  const plugins = [
    new webpack.DefinePlugin({
      DEBUG: JSON.stringify(JSON.parse(options.debug))
    })
  ]
  return {
    output: {
      path: './dist/',
      filename: 'MyLib.' +
                options.target +
                (options.minified ? '.min' : '') +
                (options.debug ? '.debug' : '') +
                '.js'
    },
    plugins: plugins
  }
}

module.exports = createVariants(baseOptions, variants, createConfig)
```

上述示例使用 `createVariants` 函数，根据 `variants` 变量搭配出 16 种不同的 `minified`、`debug`、`target` 组合，最终生成如下产物：

```bash
[WEBPACK] Building 16 targets in parallel
[WEBPACK] Started building MyLib.umd.js
[WEBPACK] Started building MyLib.umd.min.js
[WEBPACK] Started building MyLib.umd.debug.js
[WEBPACK] Started building MyLib.umd.min.debug.js

[WEBPACK] Started building MyLib.amd.js
[WEBPACK] Started building MyLib.amd.min.js
[WEBPACK] Started building MyLib.amd.debug.js
[WEBPACK] Started building MyLib.amd.min.debug.js

[WEBPACK] Started building MyLib.commonjs2.js
[WEBPACK] Started building MyLib.commonjs2.min.js
[WEBPACK] Started building MyLib.commonjs2.debug.js
[WEBPACK] Started building MyLib.commonjs2.min.debug.js

[WEBPACK] Started building MyLib.var.js
[WEBPACK] Started building MyLib.var.min.js
[WEBPACK] Started building MyLib.var.debug.js
[WEBPACK] Started building MyLib.var.min.debug.js
```

虽然，parallel-webpack 相对于 Thread-loader、HappyPack 有更高的并行度，但进程实例之间并没有做任何形式的通讯，这可能导致相同的工作在不同进程 —— 或者说不同 CPU 核上被重复执行。

例如需要对同一份代码同时打包出压缩和非压缩版本时，在 parallel-webpack 方案下，前置的资源加载、依赖解析、AST 分析等操作会被重复执行，仅仅最终阶段生成代码时有所差异。

这种技术实现，对单 entry 的项目没有任何收益，只会徒增进程创建成本；但特别适合 MPA 等多 entry 场景，或者需要同时编译出 esm、umd、amd 等多种产物形态的类库场景。





##### 提高编译速度



###### 按需编译

Webpack 5.17.0 之后引入实验特性 [lazyCompilation](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fexperiments%2F%23experimentslazycompilation)，用于实现 `entry` 或异步引用模块的**按需编译**，这是一个非常实用的新特性！试想一个场景，你的项目中有一个入口（`entry`）文件及若干按路由划分的异步模块，Webpack 启动后会立即将这些入口与异步模块全部一次性构建好 —— 即使页面启动后实际上只是访问了其中一两个异步模块， 这些花在异步模块构建的时间着实是一种浪费！`lazyCompilation` 的出现正是为了解决这一问题。用法很简单：

```js
// webpack.config.js
module.exports = {
  // ...
  experiments: {
    lazyCompilation: true,
  },
};
```

启动 `lazyCompilation` 后，代码中通过异步引用语句如 `import('./xxx')` 导入的模块（以及未被访问到的 `entry`）都不会被立即编译，而是直到页面正式请求该模块资源（例如切换到该路由）时才开始构建，效果与 Vite 相似，能够极大提升冷启速度。

`lazyCompilation` 支持如下参数：

- `backend`： 设置后端服务信息，一般保持默认值即可；
- `entries`：设置是否对 `entry` 启动按需编译特性；
- `imports`：设置是否对异步模块启动按需编译特性；
- `test`：支持正则表达式，用于声明对那些异步模块启动按需编译特性。

`lazyCompilation` 还处于实验阶段，无法保证稳定性，接口形态也可能发生变更，建议只在开发环境使用。







###### 约束 Loader 执行范围

Loader 组件用于将各式文件资源转换为可被 Webpack 理解、构建的标准 JavaScript 代码。Loader 在执行内容转换的过程中需要比较密集的 CPU 运算，如 `babel-loader`、`eslint-loader`、`vue-loader` 等，需要反复执行代码到 AST，AST 到代码的转换。开发者可以根据实际场景，使用 `module.rules.include`、`module.rules.exclude` 等配置项，限定 Loader 的执行范围 —— 通常可以排除 `node_module` 文件夹，如：

```js
// webpack.config.js
module.exports = {
  // ...
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        use: ["babel-loader", "eslint-loader"],
      },
    ],
  },
};
```

配置 `exclude: /node_modules/` 属性后，Webpack 在处理 `node_modules` 中的 js 文件时会直接跳过这个 `rule` 项，不会为这些文件执行 Loader 逻辑。

此外，`exclude` 与 `include` 还支持类似 MongoDB 参数风格的值，也就是通过 `and/not/or` 属性配置组合过滤逻辑，如：

```js
const path = require("path");
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.js$/,
      exclude: {
        and: [/node_modules/],
        not: [/node_modules\/lodash/]
      },
      use: ["babel-loader", "eslint-loader"]
    }],
  }
};
```

详情可查阅 [官网](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23condition)。

上述配置的逻辑是：过滤 `node_modules` 文件夹中除 `lodash` 外的所有文件。使用这种能力，我们可以适当将部分需要转译处理的 NPM 包（例如代码中包含 ES6 语法）纳入 Loader 处理范围中。









###### 使用 `noParse` 跳过文件编译

>  提示：使用 [externals](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fexternals%2F) 也能将部分依赖放到构建体系之外，实现与 `noParse` 类似的效果，详情可查阅[官网](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fexternals%2F)。

有不少 NPM 库已经提前做好打包处理（文件合并、Polyfill、ESM 转 CJS 等），不需要二次编译就可以直接放在浏览器上运行，例如：

- Vue2 的 `node_modules/vue/dist/vue.runtime.esm.js` 文件；
- React 的 `node_modules/react/umd/react.production.min.js` 文件；
- Lodash 的 `node_modules/lodash/lodash.js` 文件。

对我们来说，这些资源文件都是独立、内聚的代码片段，没必要重复做代码解析、依赖分析、转译等操作，此时可以使用 `module.noParse` 配置项跳过这些资源，例如：

```js
// webpack.config.js
module.exports = {
  //...
  module: {
    noParse: /lodash|react/,
  },
};
```

> 提示： `noParse` 支持正则、函数、字符串、字符串数组等参数形式，具体可查阅[官网](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23modulenoparse)。

配置后，所有匹配该正则的文件都会跳过前置的构建、分析动作，直接将内容合并进 Chunk，从而提升构建速度。不过，使用 `noParse` 时需要注意：

- 由于跳过了前置的 AST 分析动作，构建过程无法发现文件中可能存在的语法错误，需要到运行（或 Terser 做压缩）时才能发现问题，所以必须确保 `noParse` 的文件内容正确性；
- 由于跳过了依赖分析的过程，所以文件中，建议不要包含 `import/export/require/define` 等模块导入导出语句 —— 换句话说，`noParse` 文件不能存在对其它文件的依赖，除非运行环境支持这种模块化方案；
- 由于跳过了内容分析过程，Webpack 无法标记该文件的导出值，也就无法实现 Tree-shaking。

综上，建议在使用 `noParse` 配置 NPM 库前，先检查 NPM 库默认导出的资源满足要求，例如 React@18 默认定义的导出文件是 `index.js`：

```js
// react package.json
{
  "name": "react",
  // ...
  "main": "index.js"
}
```

但 `node_module/react/index.js` 文件包含了模块导入语句 `require`：

```js
// node_module/react/index.js
'use strict';

if (process.env.NODE_ENV === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
```

此时，真正有效的代码被包含在 `react.development.js`（或 `react.production.min.js`）中，但 Webpack 只会打包这段 `index.js` 内容，也就造成了产物中实际上并没有真正包含 React。针对这个问题，我们可以先找到适用的代码文件，然后用 [resolve.alias](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fresolve%2F%23resolvealias) 配置项重定向到该文件：

```js
// webpack.config.js
module.exports = {
  // ...
  module: {
    noParse: /react|lodash/,
  },
  resolve: {
    alias: {
      react: path.join(
        __dirname,
        process.env.NODE_ENV === "production"
          ? "./node_modules/react/cjs/react.production.min.js"
          : "./node_modules/react/cjs/react.development.js"
      ),
    },
  },
};
```







#### 动态加载

##### 示例

Webpack 默认会将同一个 Entry 下的所有模块全部打包成一个产物文件 —— 包括那些与页面 [关键渲染路径](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fcritical-rendering-path%2F) 无关的代码，这会导致页面初始化时需要花费多余时间去下载这部分暂时用不上的代码，影响首屏渲染性能，例如：

```js
import someBigMethod from "./someBigMethod";

document.getElementById("someButton").addEventListener("click", () => {
  someBigMethod();
});
```

逻辑上，直到点击页面的 `someButton` 按钮时才会调用 `someBigMethod` 方法，因此这部分代码没必要出现在首屏资源列表中，此时我们可以使用 Webpack 的动态加载功能将该模块更改为异步导入，修改上述代码：

```js
document.getElementById("someButton").addEventListener("click", async () => {
  // 使用 `import("module")` 动态加载模块
  const someBigMethod = await import("./someBigMethod");
  someBigMethod();
});
```

此时，重新构建将产生额外的产物文件 `src_someBigMethod_js.js`，这个文件直到执行 `import` 语句时 —— 也就是上例 `someButton` 被点击时才被加载到浏览器，也就不会影响到关键渲染路径了。





##### 使用场景

动态加载是 Webpack 内置能力之一，我们不需要做任何额外配置就可以通过动态导入语句(`import`、`require.ensure`)轻易实现。但请 注意，这一特性有时候反而会带来一些新的性能问题：**一是过度使用会使产物变得过度细碎，产物文件过多，运行时 HTTP 通讯次数也会变多**，在 HTTP 1.x 环境下这可能反而会降低网络性能，得不偿失；**二是使用时 Webpack 需要在客户端注入一大段用于支持动态加载特性的 Runtime**：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd205317bb034096b726ae02f0752348~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这段代码即使经过压缩也高达 2.5KB 左右，如果动态导入的代码量少于这段 Runtime 代码的体积，那就完全是一笔赔本买卖了。

因此，请务必慎重，多数情况下我们没必要为小模块使用动态加载能力！目前社区比较常见的用法是配合 SPA 的前端路由能力实现页面级别的动态加载，例如在 Vue 中：

```js
import { createRouter, createWebHashHistory } from "vue-router";

const Home = () => import("./Home.vue");
const Foo = () => import(/* webpackChunkName: "sub-pages" */ "./Foo.vue");
const Bar = () => import(/* webpackChunkName: "sub-pages" */ "./Bar.vue");

// 基础页面
const routes = [
  { path: "/bar", name: "Bar", component: Bar },
  { path: "/foo", name: "Foo", component: Foo },
  { path: "/", name: "Home", component: Home },
];

const router = createRouter({
  history: createWebHashHistory(),
  routes,
});

export default router;
```

示例中，`Home/Foo/Bar` 三个组件均通过 `import()` 语句动态导入，这使得仅当页面切换到相应路由时才会加载对应组件代码。另外，`Foo` 与 `Bar` 组件的导入语句比较特殊：

```js
import(/* webpackChunkName: "sub-pages" */ "./Bar.vue");
```

`webpackChunkName` 用于指定该异步模块的 Chunk 名称，相同 Chunk 名称的模块最终会打包在一起，这一特性能帮助开发者将一些关联度较高，或比较细碎的模块合并到同一个产物文件，能够用于管理最终产物数量。





#### 压缩

##### 并行压缩

Webpack4 默认使用 [Uglify-js](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fuglifyjs-webpack-plugin) 实现代码压缩，Webpack5 之后则升级为 [Terser](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fterser-webpack-plugin%2F) —— 一种[性能](https://link.juejin.cn/?target=https%3A%2F%2Fblog.logrocket.com%2Fterser-vs-uglify-vs-babel-minify-comparing-javascript-minifiers%2F)与兼容性更好的 JavaScript 代码压缩混淆工具，两种组件都原生实现了多进程并行压缩能力。

以 Terser 为例，TerserWebpackPlugin 插件默认已开启并行压缩，开发者也可以通过 `parallel` 参数（默认值为 `require('os').cpus() - 1`）设置具体的并发进程数量，如：

```JavaScript
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
    optimization: {
        minimize: true,
        minimizer: [new TerserPlugin({
            parallel: 2 // number | boolean
        })],
    },
};
```

上述配置即可设定最大并行进程数为 2。此外，Webpack4 所使用的 `uglifyjs-webpack-plugin` 也提供了类似的功能，用法与 Terser 相同。



##### 使用 TerserWebpackPlugin 压缩 JS

[Terser](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fterser) 是当下 [最为流行](https://link.juejin.cn/?target=https%3A%2F%2Fnpmtrends.com%2Fbabel-minify-vs-terser-vs-uglify-js) 的 ES6 代码压缩工具之一，支持 [Dead-Code Eliminate](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FDead-code_elimination)、删除注释、删除空格、代码合并、变量名简化等等[一系列](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fterser%23compress-options)代码压缩功能。

Webpack5.0 后默认使用 Terser 作为 JavaScript 代码压缩器，简单用法只需通过 `optimization.minimize` 配置项开启压缩功能即可：

```js
module.exports = {
  //...
  optimization: {
    minimize: true
  }
};
```

> 提示：使用 `mode = 'production'` 启动生产模式构建时，默认也会开启 Terser 压缩。

Terser 支持许多压缩 [配置](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fterser%23compress-options)：

- `dead_code`：是否删除不可触达的代码 —— 也就是所谓的死代码；
- `booleans_as_integers`：是否将 Boolean 值字面量转换为 0、1；
- `join_vars`：是否合并连续的变量声明，如 `var a = 1; var b = 2;` 合并为 `var a=1,b=2;`；
- 等等。

多数情况下使用默认 Terser 配置即可，必要时也可以手动创建 [terser-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fterser-webpack-plugin) 实例并传入压缩配置实现更精细的压缩功能，例如：

```js
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            reduce_vars: true,
            pure_funcs: ["console.log"],
          },
          // ...
        },
      }),
    ],
  },
};
```

> 提示：示例中的 `minimize` 用于控制是否开启压缩，只有 `minimize = true'` 时才会调用 `minimizer` 声明的压缩器数组（没错，这是数组形式）执行压缩操作。
>
> 另外，Webpack4 默认使用 [uglifyjs-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fuglifyjs-webpack-plugin) 压缩代码，也可以通过 `minimizer` 数组替换为 Terser 插件。

[terser-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fterser-webpack-plugin) 是一个颇为复杂的 Webpack 插件，提供下述 [配置项](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fterser-webpack-plugin%23options)：

- `test`：只有命中该配置的产物路径才会执行压缩，功能与 [module.rules.test](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23ruletest) 相似；
- `include`：在该范围内的产物才会执行压缩，功能与 [module.rules.include](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23ruleinclude) 相似；
- `exclude`：与 `include` 相反，不在该范围内的产物才会执行压缩，功能与 [module.rules.exclude](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fmodule%2F%23ruleexclude) 相似；
- `parallel`：是否启动并行压缩，默认值为 `true`，此时会按 `os.cpus().length - 1` 启动若干进程并发执行；
- `minify`：用于配置压缩器，支持传入自定义压缩函数，也支持 `swc/esbuild/uglifyjs` 等值，下面我们再展开讲解；
- `terserOptions`：传入 `minify` —— “压缩器”函数的配置参数；
- `extractComments`：是否将代码中的备注抽取为单独文件，可配合特殊备注如 `@license` 使用。

这些配置项总结下来有两个值得关注的逻辑：

1. 可以通过 `test/include/exclude` 过滤插件的执行范围，这个功能配合 `minimizer` 的数组特性，可以实现针对不同产物执行不同的压缩策略，例如：

```js
const TerserPlugin = require("terser-webpack-plugin");

module.exports = {
  entry: { foo: "./src/foo.js", bar: "./src/bar.js" },
  output: {
    filename: "[name].js",
    // ...
  },
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        test: /foo\.js$/i,
        extractComments: "all",
      }),
      new TerserPlugin({
        test: /bar\.js/,
        extractComments: false,
      }),
    ],
  },
};
```

> 提示：示例代码已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Fminify-terser%2Fpackage.json)。

示例中，针对 `foo.js` 产物文件会执行 `exctractComments` 逻辑，将备注信息抽取为单独文件；而针对 `bar.js`，由于 `extractComments = false`，不单独抽取备注内容。

1. [terser-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fterser-webpack-plugin) 插件并不只是 Terser 的简单包装，它更像是一个代码压缩功能骨架，底层还支持使用 SWC、UglifyJS、ESBuild 作为压缩器，使用时只需要通过 `minify` 参数切换即可，例如：

```js
module.exports = {
  optimization: {
    minimize: true,
    minimizer: [
      new TerserPlugin({
        minify: TerserPlugin.swcMinify,
        // `terserOptions` 将被传递到 `swc` (`@swc/core`) 工具
        // 具体配置参数可参考：https://swc.rs/docs/config-js-minify
        terserOptions: {},
      }),
    ],
  },
};
```

> 提示：TerserPlugin 内置如下压缩器：
>
> - `TerserPlugin.terserMinify`：依赖于 `terser` 库；
> - `TerserPlugin.uglifyJsMinify`：依赖于 `uglify-js`，需要手动安装 `yarn add -D uglify-js`；
> - `TerserPlugin.swcMinify`：依赖于 `@swc/core`，需要手动安装 `yarn add -D` `@swc/core`；
> - `TerserPlugin.esbuildMinify`：依赖于 `esbuild`，需要手动安装 `yarn add -D esbuild`。
>
> 另外，`terserOptions` 配置也不仅仅专供 `terser` 使用，而是会透传给具体的 `minifier`，因此使用不同压缩器时支持的配置选项也会不同。

不同压缩器功能、性能差异较大，据我了解，ESBuild 与 SWC 这两个基于 Go 与 Rust 编写的压缩器性能更佳，且效果已经基本趋于稳定，虽然功能还比不上 Terser，但某些构建性能敏感场景下不失为一种不错的选择。

##### 使用 CssMinimizerWebpackPlugin 压缩 CSS

CSS 是一种灵活多变得略显复杂的声明式语言，同样的样式效果可以被表达成非常多样的代码语句，例如一个非常典型的案例：`margin: 10px`，可以被写成：

- `margin: 10px 10px;`
- `margin-left: 10px; margin-right: 10px;...`

这些不同的表述方式最终实现的样式效果相同，那理所当然的可以用最精简的方式压缩代码。扩展开来：

```css
h1::before,
h1:before {
  /* 下面各种备注都可以删除 */
  /* margin 值可简写 */
  margin: 10px 20px 10px 20px; 
  /* 颜色值也可以简写 */
  color: #ff0000; 
  /* 删除重复属性 */
  font-weight: 400;
  font-weight: 400; 
  /* position 字面量值可简化为百分比 */
  background-position: bottom right;
  /* 渐变参数可精简 */
  background: linear-gradient(
    to bottom,
    #ffe500 0%,
    #ffe500 50%,
    #121 50%,
    #121 100%
  ); 
  /* 初始值也可精简 */
  min-width: initial;
}
```

上述代码就有不少地方可以精简优化，使用 [cssnano](https://link.juejin.cn/?target=https%3A%2F%2Fcssnano.co%2F) 压缩后大致上可简化为：

```css
h1:before {
  margin: 10px 20px;
  color: red;
  font-weight: 400;
  background-position: 100% 100%;
  quotes: "«" "»";
  background: linear-gradient(180deg, #ffe500, #ffe500 50%, #121 0, #121);
  min-width: 0;
}
```

从原来的 422 个字符精简为 212 个字符，接近 50%，我们日常编写的 CSS 语句也跟上述示例类似，通常都会有不少可以优化压缩的地方。

Webpack 社区中有不少实现 CSS 代码压缩的插件，例如：[css-minimizer-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fcss-minimizer-webpack-plugin%2F)，用法：

1. 安装依赖：

```bash
yarn add -D css-minimizer-webpack-plugin
```

1. 修改 Webpack 配置：

```js
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
const MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  //...
  module: {
    rules: [
      {
        test: /.css$/,
        // 注意，这里用的是 `MiniCssExtractPlugin.loader` 而不是 `style-loader`
        use: [MiniCssExtractPlugin.loader, "css-loader"],
      },
    ],
  },
  optimization: {
    minimize: true,
    minimizer: [
      // Webpack5 之后，约定使用 `'...'` 字面量保留默认 `minimizer` 配置
      "...",
      new CssMinimizerPlugin(),
    ],
  },
  // 需要使用 `mini-css-extract-plugin` 将 CSS 代码抽取为单独文件
  // 才能命中 `css-minimizer-webpack-plugin` 默认的 `test` 规则
  plugins: [new MiniCssExtractPlugin()],
};
```

这里的配置逻辑，一是使用 `mini-css-extract-plugin` 将 CSS 代码抽取为单独的 CSS 产物文件，这样才能命中 `css-minimizer-webpack-plugin` 默认的 `test` 逻辑；二是使用 `css-minimizer-webpack-plugin` 压缩 CSS 代码。效果：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc053101d4e545d39c7be284488b6aa6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 提示：示例代码已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Fminify-css%2Fwebpack.config.js)。

与 `terser-webpack-plugin` 类似，`css-minimizer-webpack-plugin` 也支持 `test、include、exclude、minify、minimizerOptions` 配置，其中 `minify` 支持：

- `CssMinimizerPlugin.cssnanoMinify`：默认值，使用 [cssnano](https://link.juejin.cn/?target=https%3A%2F%2Fcssnano.co%2F) 压缩代码，不需要额外安装依赖；
- `CssMinimizerPlugin.cssoMinify`：使用 [csso](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcss%2Fcsso) 压缩代码，需要手动安装依赖 `yarn add -D csso`；
- `CssMinimizerPlugin.cleanCssMinify`：使用 [clean-css](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fclean-css%2Fclean-css) 压缩代码，需要手动安装依赖 `yarn add -D clean-css`；
- `CssMinimizerPlugin.esbuildMinify`：使用 [ESBuild](https://link.juejin.cn/?target=https%3A%2F%2Fesbuild.github.io%2F) 压缩代码，需要手动安装依赖 `yarn add -D esbuild`；
- `CssMinimizerPlugin.parcelCssMinify`：使用 [parcel-css](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fparcel-bundler%2Fparcel-css) 压缩代码，需要手动安装依赖 `yarn add -D` `@parcel/css`。

> 提示：同样的，`minimizerOptions` 也是直接透传给具体 `minify`，具体配置选项可参考 [官方文档](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fcss-minimizer-webpack-plugin%2F%23minimizeroptions)。

其中 `parcel-css` 与 ESBuild 压缩性能相对较佳：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b3e1450c9b4a6e8090374d9c77c707~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

但两者功能与兼容性稍弱，多数情况下推荐使用 `cssnano`。

##### 使用 HtmlMinifierTerser 压缩 HTML

现代 Web 应用大多会选择使用 React、Vue 等 MVVM 框架，这衍生出来的一个副作用是原生 HTML 的开发需求越来越少，HTML 代码占比越来越低，所以大多数现代 Web 项目中其实并不需要考虑为 HTML 配置代码压缩工作流。不过凡事都有例外，某些场景如 SSG 或官网一类偏静态的应用中就存在大量可被优化的 HTML 代码，为此社区也提供了一些相关的工程化工具，例如 `html-minifier-terser`。

[html-minifier-terser](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fhtml-minifier-terser) 是一个基于 JavaScript 实现的、高度可配置的 HTML 压缩器，支持一系列 [压缩特性](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fhtml-minifier-terser%23options-quick-reference) 如：

- `collapseWhitespace`：删除节点间的空字符串，如：

```html
<!-- 原始代码： -->
<div> <p>    foo </p>    </div>
<!-- 经过压缩的代码： -->
<div><p>foo</p></div>
```

- `removeComments`：删除备注，如：

```html
<!-- 原始代码： -->
<!-- some comment --><p>blah</p>

<!-- 经过压缩的代码： -->
<p>blah</p>
```

- `collapseBooleanAttributes`：删除 HTML 的 [Boolean 属性值](https://link.juejin.cn/?target=https%3A%2F%2Fwww.w3.org%2FTR%2Fhtml4%2Fintro%2Fsgmltut.html%23h-3.3.4.2)，如：

```xml
<!-- 原始代码： -->
<input value="foo" readonly="readonly">

<!-- 经过压缩的代码： -->
<input value="foo" readonly>
```

- 等等。

我们可以借助 [html-minimizer-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fhtml-minimizer-webpack-plugin%2F) 插件接入 `html-minifier-terser` 压缩器，步骤：

1. 安装依赖：

```csharp
yarn add -D html-minimizer-webpack-plugin
```

1. 修改 Webpack 配置，如：

```js
const HtmlWebpackPlugin = require("html-webpack-plugin");
const HtmlMinimizerPlugin = require("html-minimizer-webpack-plugin");

module.exports = {
  // ...
  optimization: {
    minimize: true,
    minimizer: [
      // Webpack5 之后，约定使用 `'...'` 字面量保留默认 `minimizer` 配置
      "...",
      new HtmlMinimizerPlugin({
        minimizerOptions: {
          // 折叠 Boolean 型属性
          collapseBooleanAttributes: true,
          // 使用精简 `doctype` 定义
          useShortDoctype: true,
          // ...
        },
      }),
    ],
  },
  plugins: [
    // 简单起见，这里我们使用 `html-webpack-plugin` 自动生成 HTML 演示文件
    new HtmlWebpackPlugin({
      templateContent: `<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
    <html>
      <head>
        <meta charset="UTF-8" />
        <title>webpack App</title>
      </head>
      <body>
        <input readonly="readonly"/>
        <!-- comments -->
        <script src="index_bundle.js"></script>
      </body>
    </html>`,
    }),
  ],
};
```

> 提示：示例代码已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2Fmain%2Fminify-html%2Fwebpack.config.js)。

这段配置的关键逻辑，一是通过 `html-webpack-plugin` 生成 HTML 文件，这里为了演示方便特意在 HTML 模板 `templateContent` 中插入一些可以被压缩的代码；二是通过 `html-minimizer-plugin` 压缩 HTML 代码，效果：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/025bcab658134b6995ea76211a7607db~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

上图中左边是正常构建结果，右图是经过 `html-minimizer-plugin` 压缩后的构建结果，可以看到如 `doctype` 标签被删掉若干不重要的声明，文档中的备注也被删除，等等。

与 `terser-webpack-plugin` 类似，[html-minimizer-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fhtml-minimizer-webpack-plugin%2F) 也支持 `include、test、minimizerOptions` 等等一系列配置，此处不再赘述。

注意，[html-minifier-terser](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fhtml-minifier-terser) 提供的默认配置有点过于保守，例如 `removeComments` —— 用于移除代码备注的配置，或者 `useShortDoctype` 用于简化 `<doctype>` 标签的配置，默认竟然都是 false，这放在当下浏览器功能已经非常强劲，兼容性问题已经被大大抹平的背景下，有点大可不必了。因此，建议你使用时先到 [官网](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fterser%2Fhtml-minifier-terser%23options-quick-reference) 仔细了解各项配置，尽可能开启更多压缩功能。





#### 数据统计

##### Webpack 社区提供了许多优秀的分析工具

能够将这些数据转换各种风格的可视化图表，帮助我们更高效地找出性能卡点，包括：

- [Webpack Analysis](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.github.io%2Fanalyse%2F) ：Webpack 官方提供的，功能比较全面的 `stats` 可视化工具；
- [Statoscope](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstatoscope%2Fstatoscope)：主要侧重于模块与模块、模块与 chunk、chunk 与 chunk 等，实体之间的关系分析；
- [Webpack Visualizer](https://link.juejin.cn/?target=https%3A%2F%2Fchrisbateman.github.io%2Fwebpack-visualizer%2F)：一个简单的模块体积分析工具，真的很简单！
- [Webpack Bundle Analyzer](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-bundle-analyzer)：应该是使用率最高的性能分析工具之一，主要实现以 Tree Map 方式展示各个模块的体积占比；
- [Webpack Dashboard](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-dashboard)：能够在编译过程实时展示编译进度、模块分布、产物信息等；
- [Unused Webpack Plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Funused-webpack-plugin)：能够根据 `stats` 数据反向查找项目中未被使用的文件。





###### Webpack Analysis

[Webpack Analysis](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.github.io%2Fanalyse%2F) 是 webpack 官方提供的可视化分析工具，相比于其它工具，它提供的视图更全，功能更强大，能够通过创建依赖关系图对你的包进行更彻底的检查。

使用上只需要将上一节 `webpack --json=stats.json` 命令生成的 `stats.json` 文件导入页面，就可以看到一些关键统计信息：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/faa5b4982c6d49679099edf11967ae29~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

点击页面中的 `modules/chunks/assets` 按钮，页面会渲染出对应实体的依赖关系图，例如：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b28a6b379e24edfabcbd1e9d3567b56~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

除 `modules/chunks/assets` 外，右上方菜单栏 **Hints** 还可以查看构建过程各阶段、各模块的处理耗时，可以用于对比分析各个阶段的性能情况：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3af3b249f4d64133ace6893bdadd5a8c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 提示：不过，实测发现 **Hints** 还不支持 webpack 5 版本的 `stats` 数据，等待官方更新吧。

[Webpack Analysis](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.github.io%2Fanalyse%2F) 提供了非常齐全的分析视角，信息几乎没有失真，但上手难度稍高，信息噪音比较多，所以社区还提供了一个简化版 [webpack-deps-tree](https://link.juejin.cn/?target=https%3A%2F%2Fmshustov.github.io%2Fwebpack-deps-tree%2Fstatic%2F)，功能相似但用法更简单、信息更简洁，大家可以根据实际需要交叉使用。

###### Statoscope

[Statoscope](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstatoscope%2Fstatoscope) 也是一个非常强大的可视化分析工具，主要提供如下功能：

- 完整的依赖关系视图，涵盖 modules/chunks/assets/entrypoints/packages 维度；
- entrypoints/chunks/packages/module 体积分析；
- 重复包检测；
- 多份 `stats` 数据对比；
- 等等。

有两种用法，一是将 `stats` 数据导入到 [Statoscope](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fstatoscope%2Fstatoscope) 在线页面；二是使用 `@statoscope/webpack-plugin` 插件，用法：

1. 安装依赖：

```sql
yarn add -D @statoscope/webpack-plugin
```

1. 注册插件：

```js
const StatoscopeWebpackPlugin = require('@statoscope/webpack-plugin').default;

module.exports = {
  ...
  plugins: [new StatoscopeWebpackPlugin()],
};
```

之后，运行 `npx webpack` 命令，编译结束后默认打开分析视图：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2d2eae9a84c4dad9af99532c82046aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看到，Statoscope 提供了多种维度的统计信息，包括：Chunk 数量、模块总数、重复模块树、编译耗时、Initial Chunk 体积等；更重要的是，Statoscope 还展示了模块与模块、Chunk、Entry 等维度的依赖关系：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89229aa5d14e4abe8c07e2866fd7e6d1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

我们可以据此推断出模块体积、为何需要打包该模块、有哪些模块被重复引用等信息。

###### Webpack Bundle Analyzer

[Webpack-bundle-analyzer](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-bundle-analyzer) 是一个非常有名的性能分析插件，只需要一些简单配置就可以在 Webpack 构建结束后生成 Tree Map 形态的模块分布统计图，用户可以通过对比 Tree Map 内容推断各模块的体积占比，是否包含重复模块、不必要的模块等，用法：

1. 安装模块依赖：

```csharp
yarn add -D webpack-bundle-analyzer
```

1. 添加插件：

```js
const BundleAnalyzerPlugin = require("webpack-bundle-analyzer")
  .BundleAnalyzerPlugin;

module.exports = {
  ...
  plugins: [new BundleAnalyzerPlugin()],
};
```

编译结束后，默认自动打开本地视图页面：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e303d6c4fc14656bfb4d385479c2900~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

也可以直接用 Webpack-bundle-analyzer 命令直接打开 `stats` 文件：

```bash
npx webpack-bundle-analyzer ./stats.json
```

基于 Webpack Bundle Analyzer 提供的视图，我们可以分析出：

- Bundle 包所包含的模块内容 —— 从而推断出产物中是否包含预期之外的模块；
- 确定模块体积大小与占比 —— 从而确定是否存在优化空间；
- 了解 Bundle 产物体积，以及经过压缩后的体积。

> 提示： [webpack-bundle-size-analyzer](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-bundle-size-analyzer)、[source-map-explorer](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fdanvk%2Fsource-map-explorer%20) 等工具也实现了类似功能，但分别适用于不同场景，建议你也了解一下相关用法，择优选用。

###### Webpack Visualizer

[Webpack Visualizer](https://link.juejin.cn/?target=https%3A%2F%2Fchrisbateman.github.io%2Fwebpack-visualizer%2F) 是一个在线分析工具，可用于检测、可视化 Webpack 产物的构成模块。有两种用法，一是将 `stats.json` 文件上传到在线 [页面](https://link.juejin.cn/?target=https%3A%2F%2Fchrisbateman.github.io%2Fwebpack-visualizer%2F)；二是使用 `webpack-visualizer-plugin` 生成统计页面，用法：

1. 安装依赖：

```csharp
yarn add —D webpack-visualizer-plugin
```

1. 添加插件：

```js
// webpack.config.js
const VisualizerPlugin = require('webpack-visualizer-plugin');

module.exports = {
  // ...
  plugins: [
    new Visualizer({
      filename: './stats.html'
    })
  ],
}
//...
```

两种方式最终都可以生成如下视图：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0df8d57ed3144d688f42d30a028fc1ad~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 提示：很遗憾，实测发现 [webpack-visualizer-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fchrisbateman%2Fwebpack-visualizer%23plugin-usage) 插件年久失修，只兼容 webpack 1.x ，所以现在几乎没有使用价值了。

此外，在线工具 [Webpack Chart](https://link.juejin.cn/?target=https%3A%2F%2Falexkuz.github.io%2Fwebpack-chart%2F) 也提供了类似的功能，功能重合度很高，这里就不展开讲了。

###### Webpack Dashboard

[webpack-dashboard](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-dashboard) 是一个命令行可视化工具，能够在编译过程中实时展示编译进度、模块分布、产物信息等，用法：

1. 安装依赖：

```csharp
yarn add -D webpack-dashboard
```

1. 注册插件：

```js
const DashboardPlugin = require("webpack-dashboard/plugin");

module.exports = {
  // ...
  plugins: [new DashboardPlugin()],
};
```

1. 注意了，需要用 `webpack-dashboard` 命令启动编译：

```bash
# 打包
npx webpack-dashboard -- webpack
# Dev Server
npx webpack-dashboard -- webpack-dev-server
# 运行 Node 程序
npx webpack-dashboard -- node index.js
```

之后，就可以在命令行看到一个漂亮的可视化界面：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/db6aca635d2048768123e27b79647896~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

###### Speed Measure Plugin

[SpeedMeasureWebpackPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fspeed-measure-webpack-plugin) 插件能够统计出各个 Loader、插件的处理耗时，开发者可以根据这些数据分析出哪些类型的文件处理更耗时间，用法：

1. 安装依赖：

```csharp
yarn add -D speed-measure-webpack-plugin
```

1. 修改配置：

```js
const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");

const smp = new SpeedMeasurePlugin();

const config = {
  entry: "./src/index.ts",
  // ...
};

// 注意，这里是用 `smp.wrap` 函数包裹住 Webpack 配置
module.exports = smp.wrap(config);
```

之后运行打包命令如 `npx webpack` 即可，运行效果：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1deeb71f04745b1ac71d05b5490f2b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

###### UnusedWebpackPlugin

最后分享 [UnusedWebpackPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Funused-webpack-plugin) 插件，它能够根据 webpack 统计信息，反向查找出工程项目里哪些文件没有被用到，我日常在各种项目重构工作中都会用到，非常实用。用法也比较简单：

```js
const UnusedWebpackPlugin = require("unused-webpack-plugin");

module.exports = {
  // ...
  plugins: [
    new UnusedWebpackPlugin({
      directories: [path.join(__dirname, "src")],
      root: path.join(__dirname, "../"),
    }),
  ],
};
```

示例中，`directories` 用于指定需要分析的文件目录；`root` 用于指定根路径，与输出有关。配置插件后，webpack 每次运行完毕都会输出 `directories` 目录中，有哪些文件没有被用到：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f342a98ef19e42e8ab756891b814d942~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



##### Webpack统计模块构建耗时、模块依赖关系等信息

内置了 [stats](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fstats%2F) 接口，推荐用法：

1. 添加 `profile = true` 配置：

```js
// webpack.config.js
module.exports = {
  // ...
  profile: true
}
```

2. 运行编译命令，并添加 `--json` 参数，参数值为最终生成的统计文件名，如：

```bash
npx webpack --json=stats.json
```

上述命令执行完毕后，会在文件夹下生成 `stats.json` 文件，内容大致如下：

```json
{
  "hash": "2c0b66247db00e494ab8",
  "version": "5.36.1",
  "time": 81,
  "builtAt": 1620401092814,
  "publicPath": "",
  "outputPath": "/Users/tecvan/learn-webpack/hello-world/dist",
  "assetsByChunkName": { "main": ["index.js"] },
  "assets": [
    // ...
  ],
  "chunks": [
    // ...
  ],
  "modules": [
    // ...
  ],
  "entrypoints": {
    // ...
  },
  "namedChunkGroups": {
    // ...
  },
  "errors": [
    // ...
  ],
  "errorsCount": 0,
  "warnings": [
    // ...
  ],
  "warningsCount": 0,
  "children": [
    // ...
  ]
}
```

`stats` 对象收集了 Webpack 运行过程中许多值得关注的信息，包括：

- `modules`：本次打包处理的所有模块列表，内容包含模块的大小、所属 `chunk`、构建原因、依赖模块等，特别是 `modules.profile` 属性，包含了构建该模块时，解析路径、编译、打包、子模块打包等各个环节所花费的时间，非常有用；
- `chunks`：构建过程生成的 `chunks` 列表，数组内容包含 `chunk` 名称、大小、包含了哪些模块等；
- `assets`：编译后最终输出的产物列表、文件路径、文件大小等；
- `entrypoints`：entry 列表，包括动态引入所生产的 entry 项也会包含在这里面；
- `children`：子 Compiler 对象的性能数据，例如 `extract-css-chunk-plugin` 插件内部就会调用 [compilation.createChildCompiler](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Ffaceyspacey%2Fextract-css-chunks-webpack-plugin%2Fblob%2FHEAD%2Fsrc%2Floader.js%23L82) 函数创建出子 Compiler 来做 CSS 抽取的工作。

篇幅有限，这里不展开介绍每个节点的具体内容，有需要的同学可以查阅 Webpack 官网的 [stats](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fstats%2F) 介绍文档，或到小册代码仓库查看[示例](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2FHEAD%2Fstats-with-profile%2Fstats.json)。

我们可以从这些数据中分析出模块之间的依赖关系、体积占比、编译构建耗时等



##### 测试打包速度

`speed-measure-webpack-plugin`用来测速



#### 优化开发效率

##### 开发模式禁用产物优化

Webpack 提供了许多产物优化功能，例如：Tree-Shaking、SplitChunks、Minimizer 等，这些能力能够有效减少最终产物的尺寸，提升生产环境下的运行性能，但这些优化在开发环境中意义不大，反而会增加构建器的负担(都是性能大户)。

因此，开发模式下建议关闭这一类优化功能，具体措施：

- 确保 `mode='development'` 或 `mode = 'none'`，关闭默认优化策略；
- `optimization.minimize` 保持默认值或 `false`，关闭代码压缩；
- `optimization.concatenateModules` 保持默认值或 `false`，关闭模块合并；
- `optimization.splitChunks` 保持默认值或 `false`，关闭代码分包；
- `optimization.usedExports` 保持默认值或 `false`，关闭 Tree-shaking 功能；
- ……

最终，建议开发环境配置如：

```js
module.exports = {
  // ...
  mode: "development",
  optimization: {
    removeAvailableModules: false,
    removeEmptyChunks: false,
    splitChunks: false,
    minimize: false,
    concatenateModules: false,
    usedExports: false,
  },
};
```

##### 最小化 `watch` 监控范围

在 `watch` 模式下（通过 `npx webpack --watch` 命令启动），Webpack 会持续监听项目目录中所有代码文件，发生变化时执行 `rebuild` 命令。

不过，通常情况下前端项目中部分资源并不会频繁更新，例如 `node_modules` ，此时可以设置 `watchOptions.ignored` 属性忽略这些文件，例如：

```js
// webpack.config.js
module.exports = {
  //...
  watchOptions: {
    ignored: /node_modules/
  },
};
```

##### 跳过 TS 类型检查

JavaScript 本身是一门弱类型语言，这在多人协作项目中经常会引起一些不必要的类型错误，影响开发效率。

类型检查涉及 AST 解析、遍历以及其它非常消耗 CPU 的操作，会给工程化流程带来比较大的性能负担，因此我们可以选择关闭 `ts-loader` 的类型检查功能：

```js
module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.ts$/,
      use: [
        {
          loader: 'ts-loader',
          options: {
            // 设置为“仅编译”，关闭类型检查
            transpileOnly: true
          }
        }
      ],
    }],
  }
};
```

有同学可能会问：“没有类型检查，那还用 TypeScript 干嘛？”，很简单，我们可以：

1. 可以借助编辑器的 TypeScript 插件实现代码检查；
2. 使用 `fork-ts-checker-webpack-plugin` 插件将类型检查能力剥离到 **子进程** 执行，例如：

```js
const ForkTsCheckerWebpackPlugin = require('fork-ts-checker-webpack-plugin');

module.exports = {
  // ...
  module: {
    rules: [{
      test: /\.ts$/,
      use: [
        {
          loader: 'ts-loader',
          options: {
            transpileOnly: true
          }
        }
      ],
    }, ],
  },
  plugins:[
    // fork 出子进程，专门用于执行类型检查
    new ForkTsCheckerWebpackPlugin()
  ]
};
```

这样，既可以获得 Typescript 静态类型检查能力，又能提升整体编译速度。

##### 优化 ESLint 性能

ESLint 能帮助我们极低成本发现代码风格问题，维护代码质量，但若使用不当 —— 例如在开发模式下使用 `eslint-loader` 实现实时代码检查，会带来比较高昂且不必要的性能成本，我们可以选择其它更聪明的方式接入 ESLint。

例如，使用新版本组件 [eslint-webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Feslint-webpack-plugin) 替代旧版 `eslint-loader`，两者差异在于，`eslint-webpack-plugin` 在模块构建完毕（`compilation.hooks.succeedModule` 钩子）后执行检查，不会阻断文件加载流程，性能更优，用法：

1. 安装依赖：

```csharp
yarn add -D eslint-webpack-plugin
```

1. 添加插件：

```js
const ESLintPlugin = require('eslint-webpack-plugin');
module.exports = {
  // ...
  plugins: [new ESLintPlugin(options)],
  // ...
};
```

或者，可以选择在特定条件、场景下执行 ESLint，减少对构建流程的影响，如：

- 使用编辑器插件完成 ESLint 检查、错误提示、自动 Fix，如 VS Code 的 [dbaeumer.vscode-eslint](https://link.juejin.cn/?target=https%3A%2F%2Fmarketplace.visualstudio.com%2Fitems%3FitemName%3Ddbaeumer.vscode-eslint) 插件；
- 使用 `husky`，仅在代码提交前执行 ESLint 代码检查；
- 仅在 `production` 构建中使用 ESLint，能够有效提高开发阶段的构建效率。



##### HMR



###### 使用 HMR

Webpack 生态下，只需要经过简单的配置，即可启动 HMR 功能，大致分两步：

1. 设置 `devServer.hot` 属性为 true：

```js
// webpack.config.js
module.exports = {
  // ...
  devServer: {
    // 必须设置 devServer.hot = true，启动 HMR 功能
    hot: true
  }
};
```

1. 之后，还需要在代码调用 `module.hot.accept` 接口，声明如何将模块安全地替换为最新代码，如：

```js
import component from "./component";
let demoComponent = component();

document.body.appendChild(demoComponent);
// HMR interface
if (module.hot) {
  // Capture hot update
  module.hot.accept("./component", () => {
    const nextComponent = component();

    // Replace old content with the hot loaded one
    document.body.replaceChild(nextComponent, demoComponent);

    demoComponent = nextComponent;
  });
}
```



###### `accept` 函数注意事项

从应用视角看，`module.hot.accept` 是 Webpack 开放出来，由用户自定义模块更新逻辑的重要函数，因此有必要单独拎出来，聊聊几个开发技巧：

1. **处理失败兜底逻辑**

`module.hot.accept` 函数只接受具体路径的 `path` 参数，也就是说，我们无法通过 `glob` 或类似风格的方式批量注册热更新回调。

一旦某个模块没有注册对应的 `module.hot.accept` 函数后，HMR 运行时会执行兜底策略，通常是刷新页面，确保页面上运行的始终是最新的代码，因此有时候你可能明明已经注册了 `accept` 回调，但热更新无法生效，此时可以检查一下文件路径是否真的命中资源。

1. **更新事件冒泡**

`module.hot.accept` 函数只能捕获当前模块对应子孙模块的更新事件，例如对于下面的模块依赖树：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/636a4ada949c4e048d416883c35f89da~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

示例中，更新事件会沿着模块依赖树自底向上逐级传递，从 `foo` 到 `index` ，从 `bar-1` 到 `bar` 再到 `index`，但不支持反向或跨子树传递，也就是说：

- 在 `foo.js` 中无法捕获 `bar.js` 及其子模块的变更事件；
- 在 `bar-1.js` 中无法捕获 `bar.js` 的变更事件。

这一特性与 DOM 事件规范中的冒泡过程极为相似，使用时如果摸不准模块的依赖关系，建议直接在应用的入口文件中编写热更新函数。

1. **使用无参数调用风格**

除上述调用方式外，`module.hot.accept` 函数还支持无参数调用风格，作用是捕获当前文件的变更事件，并从模块第一行开始重新运行该模块的代码，例如：

```js
// src/bar.js
console.log('bar');

module.hot.accept();
```

示例模块发生变动之后，会从头开始重复执行 `console.log` 语句。











###### 实现原理

Webpack HMR 特性的执行过程并不复杂，核心：

1. 使用 `webpack-dev-server` （后面简称 WDS）托管静态资源，同时以 Runtime 方式注入一段处理 HMR 逻辑的客户端代码；
2. 浏览器加载页面后，与 WDS 建立 WebSocket 连接；
3. Webpack 监听到文件变化后，增量构建发生变更的模块，并通过 WebSocket 发送 `hash` 事件；
4. 浏览器接收到 `hash` 事件后，请求 `manifest` 资源文件，确认增量变更范围；
5. 浏览器加载发生变更的增量模块；
6. Webpack 运行时触发变更模块的 `module.hot.accept` 回调，执行代码变更逻辑；
7. done。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b16905bf7c1342e5aedc1647241f8c06~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

首先是 **注入 HMR 客户端运行时**：在前面章节《[Runtime：模块编译打包及运行时逻辑](https://juejin.cn/book/7115598540721618944/section/7119036016274440192)》中，我们已经详细介绍了 Webpack 运行时概念与底层实现逻辑，在 HMR 场景下，执行 `npx webpack serve` 命令后，`webpack-dev-server` 首先会调用 `HotModuleReplacementPlugin` 插件向应用的主 Chunk 注入一系列 HMR Runtime，包括：

- 用于建立 WebSocket 连接，处理 `hash` 等消息的运行时代码；
- 用于加载热更新资源的 `RuntimeGlobals.hmrDownloadManifest` 与 `RuntimeGlobals.hmrDownloadUpdateHandlers` 接口；
- 用于处理模块更新策略的 `module.hot.accept` 接口；
- ……

经过 `HotModuleReplacementPlugin` 处理后，构建产物中即包含了所有运行 HMR 所需的客户端运行时与接口。这些 HMR 运行时会在浏览器执行一套基于 WebSocket 消息的时序框架，如图：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f11ad665cc384facb7edade1e0390a7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

**其次，实现增量构建**：除注入客户端代码外，`HotModuleReplacementPlugin` 插件还会借助 Webpack 的 `watch` 能力，在代码文件发生变化后执行增量构建，生成：

- `manifest` 文件：JSON 格式文件，包含所有发生变更的模块列表，命名为 `[hash].hot-update.json`；
- 模块变更文件：js 格式，包含编译后的模块代码，命名为 `[hash].hot-update.js`。

增量构建完毕后，Webpack 将触发 `compilation.hooks.done` 钩子，并传递本次构建的统计信息对象 `stats`。WDS 则监听 `done` 钩子，在回调中通过 WebSocket 发送模块更新消息：

```js
{"type":"hash","data":"${stats.hash}"}
```

实际效果：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abda76328bdd45ce945e5c3626a33b21~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

**再次，加载更新**：客户端通过 WebSocket 接收到 `hash` 消息后，首先发出 `manifest` 请求获取本轮热更新涉及的 chunk，如：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/788951089ec84360b17cc0bcefa23385~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 注意：在 Webpack 4 及之前，热更新文件以模块为单位，即所有发生变化的模块都会生成对应的热更新文件； Webpack 5 之后热更新文件以 chunk 为单位，如上例中，`main` chunk 下任意文件的变化都只会生成 `main.[hash].hot-update.js` 更新文件。

`manifest` 请求完成后，客户端 HMR 运行时开始下载发生变化的 chunk 文件，将最新模块代码加载到本地。

**最后，执行 `module.hot.accept` 回调**：经过上述步骤，浏览器加载完最新模块代码后，HMR 运行时会继续触发 `module.hot.accept` 回调，将最新代码替换到运行环境中。

`module.hot.accept` 是 HMR 运行时暴露给用户代码的重要接口之一，它在 Webpack HMR 体系中开了一个口子，让用户能够自定义模块热替换的逻辑，接口签名：

```js
module.hot.accept(path?: string, callback?: function);
```

它接受两个参数：

- `path`：指定需要拦截变更行为的模块路径；
- `callback`：模块更新后，将最新模块代码应用到运行环境的函数。

例如，对于如下代码：

```js
// src/bar.js
export const bar = 'bar'

// src/index.js
import { bar } from './bar';
const node = document.createElement('div')
node.innerText = bar;
document.body.appendChild(node)

module.hot.accept('./bar.js', function () {
    node.innerText = bar;
})
```

示例中，`module.hot.accept` 函数监听 `./bar.js` 模块的变更事件，一旦代码发生变动，就触发回调，将 `./bar.js` 导出的值替换到页面上，从而实现热更新效果。

回顾整个 HMR 过程，所有的状态流转均由 WebSocket 消息驱动，这部分逻辑由 HMR 运行时控制，开发者几乎无感，唯一需要关注的就是是为每一个需要支持 HMR 特性的文件注册 `module.hot.accept` 回调。



###### `vue-loader` 如何实现 HMR 

最后，我们来看一个实际案例 —— `vue-loader`，这是一个用于处理 Vue [Single File Component](https://link.juejin.cn/?target=https%3A%2F%2Fvue-loader.vuejs.org%2Fzh%2Fspec.html%23%E7%AE%80%E4%BB%8B) 的 Webpack 加载器，它能够将如下格式的内容转译为可在浏览器运行的等价代码：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2533c45468554dd4a09f4addaedcaa8a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

除常规的代码转译外，在 HMR 模式下，`vue-loader` 还会为每一个 Vue 文件注入一段处理模块替换的逻辑，如：

```js
"./src/a.vue":
/*!*******************!*\
    !*** ./src/a.vue ***!
    \*******************/
/***/
((module, __webpack_exports__, __webpack_require__) => {
    // 模块代码
    // ...
    /* hot reload */
    if (true) {
    var api = __webpack_require__( /*! ../node_modules/vue-hot-reload-api/dist/index.js */ "../node_modules/vue-hot-reload-api/dist/index.js")
    api.install(__webpack_require__( /*! vue */ "../node_modules/vue/dist/vue.runtime.esm.js"))
    if (api.compatible) {
        module.hot.accept()
        if (!api.isRecorded('45c6ab58')) {
        api.createRecord('45c6ab58', component.options)
        } else {
        api.reload('45c6ab58', component.options)
        }
        module.hot.accept( /*! ./a.vue?vue&type=template&id=45c6ab58& */ "./src/a.vue?vue&type=template&id=45c6ab58&", __WEBPACK_OUTDATED_DEPENDENCIES__ => {
        /* harmony import */
        _a_vue_vue_type_template_id_45c6ab58___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./a.vue?vue&type=template&id=45c6ab58& */ "./src/a.vue?vue&type=template&id=45c6ab58&");
        (function () {
            api.rerender('45c6ab58', {
            render: _a_vue_vue_type_template_id_45c6ab58___WEBPACK_IMPORTED_MODULE_0__.render,
            staticRenderFns: _a_vue_vue_type_template_id_45c6ab58___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns
            })
        })(__WEBPACK_OUTDATED_DEPENDENCIES__);
        })
    }
    }
    // ...

    /***/
}),
```

这段被注入用于处理模块热替换的代码，主要步骤有：

- 首次执行时，调用 `api.createRecord` 记录组件配置，`api` 为 `vue-hot-reload-api` 库暴露的接口；
- 执行 `module.hot.accept()` 语句，监听当前模块变更事件，当模块发生变化时调用 `api.reload`；
- 执行 `module.hot.accept("xxx.vue?vue&type=template&xxxx", fn)` ，监听 Vue 文件 template 代码的变更事件，当 template 模块发生变更时调用 `api.rerender`。

可以看到，`vue-loader` 对 HMR 的支持，基本上围绕 `vue-hot-reload-api` 展开，当代码文件发生变化触发 `module.hot.accept` 回调时，会根据情况执行 `vue-hot-reload-api` 暴露的 `reload` 与 `rerender` 函数，两者最终都会触发组件实例的 `$forceUpdate` 函数强制执行重新渲染。

另外，为什么这里需要调用两次 `module.hot.accept`？这是因为 `vue-loader` 在做转译时，会将 SFC 不同板块拆解成多个 module，例如 `template` 对应生成 `xxx.vue?vue&type=template` ；`script` 对应生成 `xxx.vue?vue&type=script`。



#### 设置 `resolve` 缩小搜索范围

Webpack 默认提供了一套同时兼容 CMD、AMD、ESM 等模块化方案的资源搜索规则 —— `enhanced-resolve`，它能将各种模块导入语句准确定位到模块对应的物理资源路径。例如：

- `import 'lodash'` 这一类引入 NPM 包的语句会被 `enhanced-resolve` 定位到对应包体文件路径 `node_modules/lodash/index.js` ；
- `import './a'` 这类不带文件后缀名的语句，则可能被定位到 `./a.js` 文件；
- `import '@/a'` 这类化名路径的引用，则可能被定位到 `$PROJECT_ROOT/src/a.js` 文件。

需要注意，这类增强资源搜索体验的特性背后涉及许多 IO 操作，本身可能引起较大的性能消耗，开发者可根据实际情况调整 `resolve` 配置，缩小资源搜索范围，包括：

**1. `resolve.extensions` 配置：**

例如，当模块导入语句未携带文件后缀时，如 `import './a'` ，Webpack 会遍历 `resolve.extensions` 项定义的后缀名列表，尝试在 `'./a'` 路径追加后缀名，搜索对应物理文件。

在 Webpack5 中，`resolve.extensions` 默认值为 `['.js', '.json', '.wasm']` ，这意味着 Webpack 在针对不带后缀名的引入语句时，可能需要执行三次判断逻辑才能完成文件搜索，针对这种情况，可行的优化措施包括：

- 修改 `resolve.extensions` 配置项，减少匹配次数；

- 代码中尽量补齐文件后缀名；
- 设置 `resolve.enforceExtension = true` ，强制要求开发者提供明确的模块后缀名，不过这种做法侵入性太强，不太推荐。

**2. `resolve.modules` 配置：**

类似于 Node 模块搜索逻辑，当 Webpack 遇到 `import 'lodash'` 这样的 npm 包导入语句时，会先尝试在当前项目 `node_modules` 目录搜索资源，如果找不到，则按目录层级尝试逐级向上查找 `node_modules` 目录，如果依然找不到，则最终尝试在全局 `node_modules` 中搜索。

在一个依赖管理良好的系统中，我们通常会尽量将 NPM 包安装在有限层级内，因此 Webpack 这一逐层查找的逻辑大多数情况下实用性并不高，开发者可以通过修改 `resolve.modules` 配置项，主动关闭逐层搜索功能，例如：

```js
// webpack.config.js
const path = require('path');

module.exports = {
  //...
  resolve: {
    modules: [path.resolve(__dirname, 'node_modules')],
  },
};
```

**3. `resolve.mainFiles` 配置：**

与 `resolve.extensions` 类似，`resolve.mainFiles` 配置项用于定义文件夹默认文件名，例如对于 `import './dir'` 请求，假设 `resolve.mainFiles = ['index', 'home']` ，Webpack 会按依次测试 `./dir/index` 与 `./dir/home` 文件是否存在。

因此，实际项目中应控制 `resolve.mainFiles` 数组数量，减少匹配次数。





#### 使用 `[hash]` 占位符优化 HTTP 资源缓存效率

##### 使用

Webpack 提供了一种模板字符串([Template String](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23template-strings))能力，用于根据构建情况动态拼接产物文件名称([output.filename](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foutput%2F%23outputfilename))，从性能角度看，比较值得关注的是其中的几个 Hash 占位符，包括：

- `[hash]/[fullhash]`：整个项目的内容 Hash 值，项目中任意模块变化都会产生新的 `fullhash`；（粒度整个项目）
- `[chunkhash]`：是根据不同的入口进行依赖文件解析，构建对应的chunk（模块），生成对应的hash值。只有被修改的chunk（模块）在重新构建之后才会生成新的hash值，不会影响其他的chunk。（粒度entry的每个入口文件）。
- `[contenthash]`：是跟每个生成的文件有关，每个文件都有一个唯一的hash值。当要构建的文件内容发生改变时，就会生成新的hash值，且该文件的改变并不会影响和它同一个模块下的其他文件。（粒度每个文件的内容）。

使用下述配置：

```js
module.exports = {
  // ...
  entry: { index: "./src/index.js", foo: "./src/foo.js" },
  output: {
    filename: "[name]-[contenthash].js",
    path: path.resolve(__dirname, "dist"),
  },
  plugins: [new MiniCssExtractPlugin({ filename: "[name]-[contenthash].css" })],
};
```

> 提示：也可以通过占位符传入 Hash 位数，如 `[contenthash:7]` ，即可限定生成的 Hash 长度。

可以看到每个产物文件名都会带上一段由产物内容计算出的唯一 Hash 值，文件内容不变，Hash 也不会变化，这就很适合用作 HTTP [持久缓存](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTTP%2FCaching%23expires_or_max-age) 资源：

```ini
# HTTP Response header

Cache-Control: max-age=31536000
```

此时，产物文件不会被重复下载，一直到文件内容发生变化，引起 Hash 变化生成不同 URL 路径之后，才需要请求新的资源文件，能有效提升网络性能，因此，生产环境下应尽量使用 `[contenthash]` 生成有版本意义的文件名。













##### **异步模块变化会引起主 Chunk Hash 同步发生变化**

例如对于下面这种模块关系：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/552fd8ddf01649a49f693f12ba297d8f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

构建后将生成入口 `index.js` 与异步模块 `async-a.js` 两个 Chunk 对应的产物：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e89cf6a8abff4380954e219006e611a3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



此时，若异步模块 `async-a` 或其子模块 `sync-c` 发生变化，理论上应该只会影响 `src_async-a` 的 Hash 值，但实际效果却是：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/412eb1f1e36f40b39dfe9d13bd7e5b39~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

父级 Chunk(`index`)也受到了影响，生成新的 Hash 值，这是因为在 `index` 中需要记录异步 Chunk 的真实路径：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd2ef56310024c05a2f9174e837d4f53~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

异步 Chunk 的路径变化自然也就导致了父级 Chunk 内容变化，此时可以用 `optimization.runtimeChunk` 将这部分代码抽取为单独的 Runtime Chunk，例如：

```js
module.exports = {
  entry: { index: "./src/index.js" },
  mode: "development",
  devtool: false,
  output: {
    filename: "[name]-[contenthash].js",
    path: path.resolve(__dirname, "dist")
  },
  // 将运行时代码抽取到 `runtime` 文件中
  optimization: { runtimeChunk: { name: "runtime" } },
};
```



之后，`async-a.js` 模块的变更只会影响 Runtime Chunk 内容，不再影响主 Chunk。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17895ee7fd4649e3b0f86e523ede7d36~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

综上，建议至少为生成环境启动 `[contenthash]` 功能，并搭配 `optimization.runtimeChunk` 将运行时代码抽离为单独产物文件。













#### Source-map

<strong style="color: red">一般线上环境不发source-map，而是将打包出来的source-map文件上传到监控平台，线上报错的时候会自动定位到监控平台。</strong>通过代理的方式将线上的sourcemap请求代理到本地。

`source-map` 是一种将经过编译、压缩、混淆的代码映射回源码的技术，它能够帮助开发者迅速定位到更有意义、更结构化的源码中，方便调试。不过，`source-map` 操作本身也有很大构建性能开销，建议读者根据实际场景慎重选择最合适的 `source-map` 方案。

针对 `source-map` 功能，Webpack 提供了 `devtool` 选项，可以配置 `eval`、`source-map`、`cheap-source-map` 等值，不考虑其它因素的情况下，最佳实践：

- 开发环境使用 `eval` ，确保最佳编译速度；

- 生产环境使用 `source-map`，获取最高质量。

> 参考：[webpack.js.org/configurati…](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fdevtool%2F)

```js
/*
  source-map: 一种 提供源代码到构建后代码映射 技术 （如果构建后代码出错了，通过映射可以追踪源代码错误）

    [inline-|hidden-|eval-][nosources-][cheap-[module-]]source-map

    source-map：外部
      错误代码准确信息 和 源代码的错误位置
    inline-source-map：内联
      只生成一个内联source-map
      错误代码准确信息 和 源代码的错误位置
    hidden-source-map：外部
      错误代码错误原因，但是没有错误位置
      不能追踪源代码错误，只能提示到构建后代码的错误位置
    eval-source-map：内联
      每一个文件都生成对应的source-map，都在eval
      错误代码准确信息 和 源代码的错误位置
    nosources-source-map：外部
      错误代码准确信息, 但是没有任何源代码信息
    cheap-source-map：外部
      错误代码准确信息 和 源代码的错误位置 
      只能精确的行
    cheap-module-source-map：外部
      错误代码准确信息 和 源代码的错误位置 
      module会将loader的source map加入

    内联 和 外部的区别：1. 外部生成了文件，内联没有 2. 内联构建速度更快

    开发环境：速度快，调试更友好
      速度快(eval>inline>cheap>...)
        eval-cheap-souce-map
        eval-source-map
      调试更友好  
        souce-map
        cheap-module-souce-map
        cheap-souce-map

      --> eval-source-map  / eval-cheap-module-souce-map

    生产环境：源代码要不要隐藏? 调试要不要更友好
      内联会让代码体积变大，所以在生产环境不用内联
      nosources-source-map 全部隐藏
      hidden-source-map 只隐藏源代码，会提示构建后代码错误信息

      --> source-map / cheap-module-souce-map
*/

```



#### oneOf

```js
 rules: [
      {
        // 在package.json中eslintConfig --> airbnb
        test: /\.js$/,
        exclude: /node_modules/,
        // 优先执行
        enforce: 'pre',
        loader: 'eslint-loader',
        options: {
          fix: true,
        },
      },
      {
        // 跟switch一样，满足一个test就跳出来了，不往下找了
        // 注意：不能有两个配置处理同一种类型文件
        oneOf: [
          {
            test: /\.css$/,
            use: [...commonCssLoader],
          },
          {
            test: /\.less$/,
            use: [...commonCssLoader, 'less-loader'],
          },
          {
            test: /\.js$/,
            exclude: /node_modules/,
            loader: 'babel-loader',
            options: {
              presets: [
                [
                  '@babel/preset-env',
                  {
                    useBuiltIns: 'usage',
                    corejs: { version: 3 },
                    targets: {
                      chrome: '60',
                      firefox: '50',
                    },
                  },
                ],
              ],
            },
          },
          {
            test: /\.(jpg|png|gif)/,
            loader: 'url-loader',
            options: {
              limit: 8 * 1024,
              name: '[hash:10].[ext]',
              outputPath: 'imgs',
              esModule: false,
            },
          },
        ]
```



#### Code split

##### 配置示例

```js
  entry: {
    index: './src/js/index.js',
    test: './src/js/test.js',
  },    

optimization: {
        // 优化配置项
        splitChunks: {
            // 切分代码块
            // chunks: 表示哪些代码需要优化，有三个可选值：initial(初始块)、async(按需加载块)、all(全部块)，默认为async
            // minSize: 表示在压缩前的最小模块大小，默认为30000
            // minChunks: 表示被引用次数，默认为1
            // maxAsyncRequests: 按需加载时候最大的并行请求数，默认为5
            // maxInitialRequests: 一个入口最大的并行请求数，默认为3
            // automaticNameDelimiter: 命名连接符
            // name: 拆分出来块的名字，默认由块名和hash值自动生成
            // cacheGroups: 缓存组。缓存组的属性除上面所有属性外，还有test, priority, reuseExistingChunk
            // test: 用于控制哪些模块被这个缓存组匹配到
            // priority: 缓存组打包的先后优先级
            // reuseExistingChunk: 如果当前代码块包含的模块已经有了，就不在产生一个新的代码块

            maxInitialRequests: 5,
            cacheGroups: {
                lib: {
                    // 将所有引用路劲来自于 node_modules 的模块作为 lib 块切割出来，因为它们几乎不会改动，各页面可以共用
                    test: /[\\/]node_modules[\\/](?!element-ui).*[\\/]/,
                    name: 'lib',
                    chunks: 'all'
                },
                common: {
                    // 将所有引用路劲来自于 src/common 或 src/lib 的模块作为 common 块切割出来，因为不常改动，各页面也可以共用
                    test: /([\\/]src[\\/]common[\\/]|[\\/]src[\\/]lib[\\/])/,
                    name: 'common',
                    chunks: 'all'
                },
                'element-ui': {
                    // 将所有引用路劲来自于 src/common 或 src/lib 的模块作为 common 块切割出来，因为不常改动，各页面也可以共用
                    test: /[\\/]node_modules[\\/]element-ui[\\/]/,
                    name: 'element-ui',
                    chunks: 'all'
                }
            }
        }
    }
```



##### 深入理解 Chunk

Chunk 是 Webpack 内部一个非常重要的底层设计，用于组织、管理、优化最终产物，在构建流程进入生成(Seal)阶段后：

1. Webpack 首先根据 `entry` 配置创建若干 Chunk 对象；
2. 遍历构建(Make)阶段找到的所有 Module 对象，同一 Entry 下的模块分配到 Entry 对应的 Chunk 中；
3. 遇到异步模块则创建新的 Chunk 对象，并将异步模块放入该 Chunk；
4. 分配完毕后，根据 SplitChunksPlugin 的启发式算法进一步对这些 Chunk 执行**裁剪、拆分、合并、代码调优**，最终调整成运行性能(可能)更优的形态；
5. 最后，将这些 Chunk 一个个输出成最终的产物(Asset)文件，编译工作到此结束。

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/73dad47e4d3e45419a9ad3f7ff746fa0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看出，Chunk 在构建流程中起着承上启下的关键作用 —— 一方面作为 Module 容器，根据一系列默认 **分包策略** 决定哪些模块应该合并在一起打包；另一方面根据 `splitChunks` 设定的 **策略** 优化分包，决定最终输出多少产物文件。



##### webpack默认分包处理

###### 默认分包处理

**Chunk 分包结果的好坏直接影响了最终应用性能**，Webpack 默认会将以下三种模块做分包处理：

- Initial Chunk：`entry` 模块及相应子模块打包成 Initial Chunk；同一个 `entry` 下触达到的模块组织成一个 Chunk；
- Async Chunk：通过 `import('./xx')` 等语句导入的异步模块及相应子模块组成的 Async Chunk；
- Runtime Chunk：运行时代码抽离成 Runtime Chunk，可通过 [entry.runtime](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Fentry-context%2F%23dependencies) 配置项实现。`entry.runtime` 不为空时，会将运行时模块单独组织成一个 Chunk。



###### **Entry Chunk:**

Webpack 首先会为每一个 `entry` 创建 `Chunk` 对象，例如对于如下配置：

```js
module.exports = {
  entry: {
    main: "./src/main",
    home: "./src/home",
  }
};
```

遍历 `entry` 对象属性并创建出 `chunk[main]` 、`chunk[home]` 两个对象，此时两个 Chunk 分别包含 `main` 、`home` 模块：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a40257760914ba08783bf2d6a3c1bef~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

初始化完毕后，Webpack 会根据 `ModuleGraph` 的依赖关系数据，将 `entry` 下所触及的所有 Module 塞入 Chunk （发生在 [visitModules](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2Fwebpack%2Fwebpack%2Fblob%2FHEAD%2Flib%2FbuildChunkGraph.js%23L187-L188) 方法），比如对于如下文件依赖：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d7fbfc917b1416cb1ee86216c3131a0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

`main.js` 以同步方式直接或间接引用了 a/b/c/d 四个文件，Webpack 会首先为 `main.js` 模块创建 Chunk 与 EntryPoint 对象，之后将 a/b/c/d 模块逐步添加到 `chunk[main]` 中，最终形成：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83a4ebfe25b940d5adfb9d04a7507646~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



###### **Async Chunk:**

其次，Webpack 会将每一个异步导入语句（`import(xxx)` 及 `require.ensure`）处理为一个单独的 Chunk 对象，并将其子模块都加入这个 Chunk 中 —— 我们称之为 Async Chunk。例如对于下面的例子：

```js
// index.js
import './sync-a.js'
import './sync-b.js'

import('./async-a.js')

// async-a.js
import './sync-c.js'
```

在入口模块 `index.js` 中，以同步方式引入 sync-a、sync-b；以异步方式引入 async-a 模块；同时，在 async-a 中以同步方式引入 `sync-c` 模块，形成如下模块依赖关系图：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/716dba615b424147ad4076ce0a735eb5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

此时，Webpack 会为入口 `index.js`、异步模块 `async-a.js` 分别创建分包，形成如下 Chunk 结构：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892f542a06ae4d31a18130e93b07648a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

并且 `chunk[index]` 与 `chunk[async-a]` 之间形成了单向依赖关系，Webpack 会将这种依赖关系保存在 `ChunkGroup._parents` 、`ChunkGroup._children` 属性中。





###### **Runtime Chunk:**

最后，除了 `entry`、异步模块外，Webpack5 还支持将 Runtime 代码单独抽取为 Chunk。这里说的 Runtime 代码是指一些为了确保打包产物能正常运行，而由 Webpack 注入的一系列基础框架代码，举个例子，常见的 Webpack 打包产物结构如：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de9a9cbc02a9452baa1feddcd7c5ef71~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

上图红框圈出来的一大段代码就是 Webpack 动态生成的运行时代码，编译时，Webpack 会根据业务代码，决定输出哪些支撑特性的运行时代码（基于 `Dependency` 子类），例如：

- 需要 `__webpack_require__.f`、`__webpack_require__.r` 等功能实现最起码的模块化支持；
- 如果用到动态加载特性，则需要写入 `__webpack_require__.e` 函数；
- 如果用到 Module Federation 特性，则需要写入 `__webpack_require__.o` 函数；
- 等等。

虽然每段运行时代码可能都很小，但随着特性的增加，最终结果会越来越大，特别对于多 entry 应用，在每个入口都重复打包一份相似的运行时显得有点浪费，为此 Webpack5 提供了 `entry.runtime` 配置项用于声明如何打包运行时代码。用法上只需在 `entry` 项中增加字符串形式的 `runtime` 值，例如：

```js
module.exports = {
  entry: {
    index: { import: "./src/index", runtime: "solid-runtime" },
  }
};
```

在 `compilation.seal` 函数中，Webpack 首先为 `entry` 创建 `EntryPoint`，之后判断 `entry` 配置中是否带有 `runtime` 属性，有则创建以 `runtime` 值为名的 Chunk，因此，上例配置将生成两个 Chunk：`chunk[index.js]` 、`chunk[solid-runtime]`，并据此最终产出两个文件：

- 入口 index 对应的 `index.js` 文件；
- 运行时配置对应的 `solid-runtime.js` 文件。

在多 `entry` 场景中，只要为每个 `entry` 都设定相同的 `runtime` 值，Webpack 运行时代码就会合并写入到同一个 Runtime Chunk 中，最终达成产物性能优化效果。例如对于如下配置：

```js
module.exports = {
  entry: {
    index: { import: "./src/index", runtime: "solid-runtime" },
    home: { import: "./src/home", runtime: "solid-runtime" },
  }
};
```

入口 `index`、`home` 共享相同的 `runtime` 值，最终生成三个 Chunk，分别为：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dcbe4fdd5f2d41d0af0b7fcf990a9bb7~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

此时入口 `chunk[index]`、`chunk[home]` 与运行时 `chunk[solid-runtime]` 也会形成父子依赖关系。

###### 分包规则的问题

默认分包规则最大的问题是无法解决模块重复，如果多个 Chunk 同时包含同一个 Module，那么这个 Module 会被不受限制地重复打包进这些 Chunk。比如假设我们有两个入口 main/index 同时依赖了同一个模块：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b483355b9b3e4acfb022a2e3aa54d226~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

默认情况下，Webpack 不会对此做额外处理，只是单纯地将 c 模块同时打包进 main/index 两个 Chunk，最终形成：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/452ebaf82f7c4df88ae7b5334ff17cba~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看到 `chunk` 间互相孤立，模块 c 被重复打包，对最终产物可能造成不必要的性能损耗！

为了解决这个问题，Webpack 3 引入 `CommonChunkPlugin` 插件试图将 entry 之间的公共依赖提取成单独的 `chunk`，但 `CommonChunkPlugin` 本质上还是基于 Chunk 之间简单的父子关系链实现的，很难推断出提取出的第三个包应该作为 `entry` 的父 `chunk` 还是子 `chunk`，`CommonChunkPlugin` 统一处理为父 `chunk`，某些情况下反而对性能造成了不小的负面影响。

为此，在 Webpack4 之后才专门引入了更复杂的数据结构 —— `ChunkGroup` 专门实现关系链管理，配合 `SplitChunksPlugin` 能够更高效、智能地实现**启发式分包。**







##### SplitChunksPlugin

######  简介

[SplitChunksPlugin](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.docschina.org%2Fplugins%2Fsplit-chunks-plugin%2F) 是 Webpack 4 之后内置实现的最新分包方案，与 Webpack3 时代的 `CommonsChunkPlugin` 相比，它能够基于一些更灵活、合理的启发式规则将 Module 编排进不同的 Chunk，最终构建出性能更佳，缓存更友好的应用产物。

`SplitChunksPlugin` 的用法比较抽象，算得上 Webpack 的一个难点，主要能力有：

- `SplitChunksPlugin`支持根据 Module 路径、Module 被引用次数、Chunk 大小、Chunk 请求数等决定是否对 Chunk 做进一步拆解，这些决策都可以通过`optimization.splitChunks`

  相应配置项调整定制，基于这些能力我们可以实现：

  - 单独打包某些特定路径的内容，例如 `node_modules` 打包为 `vendors`；
  - 单独打包使用频率较高的文件；

- `SplitChunksPlugin` 还提供了 `optimization.splitChunks.cacheGroup` 概念，用于对不同特点的资源做分组处理，并为这些分组设置更有针对性的分包规则；

- `SplitChunksPlugin`还内置了`default`与`defaultVendors`两个`cacheGroup`，提供一些开箱即用的分包特性：

  - `node_modules` 资源会命中 `defaultVendors` 规则，并被单独打包；
  - 只有包体超过 20kb 的 Chunk 才会被单独打包；
  - 加载 Async Chunk 所需请求数不得超过 30；
  - 加载 Initial Chunk 所需请求数不得超过 30。(提示：这里所说的请求数不能等价对标到 http 资源请求数，下面会细讲。)

由于 Webpack4 开始已经内置支持 `SplitChunksPlugin` ，我们不需要额外安装依赖，直接修改 [optimization.splitChunks](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fconfiguration%2Foptimization%2F%23optimizationsplitchunks) 配置项即可实现自定义的分包策略：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // ...
    },
  },
}
```

`splitChunks` 主要有两种类型的配置：

- `minChunks/minSize/maxInitialRequest` 等分包条件，满足这些条件的模块都会被执行分包；
- `cacheGroup` ：用于为特定资源声明特定分包条件，例如可以为 `node_modules` 包设定更宽松的分包条件。

下面展开细讲。



###### 设置分包范围

首先，`SplitChunksPlugin` 默认情况下只对 Async Chunk 生效，我们可以通过 `splitChunks.chunks` 调整作用范围，该配置项支持如下值：

- 字符串 `'all'` ：对 Initial Chunk 与 Async Chunk 都生效，建议优先使用该值；
- 字符串 `'initial'` ：只对 Initial Chunk 生效；
- 字符串 `'async'` ：只对 Async Chunk 生效；
- 函数 `(chunk) => boolean` ：该函数返回 `true` 时生效；

例如：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
}
```

设置为 `all` 效果最佳，此时 Initial Chunk、Async Chunk 都会被 `SplitChunksPlugin` 插件优化。





###### 根据 Module 使用频率分包

`SplitChunksPlugin` 支持按 Module 被 Chunk 引用的次数决定是否分包，借助这种能力我们可以轻易将那些被频繁使用的模块打包成独立文件，减少代码重复。

用法很简单，只需用 `splitChunks.minChunks` 配置项设定最小引用次数，例如：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      // 设定引用次数超过 2 的模块才进行分包
      minChunks: 2
    },
  },
}
```

注意，这里“被 Chunk 引用次数”并不直接等价于被 `import` 的次数，而是取决于上游调用者是否被视作 Initial Chunk 或 Async Chunk 处理，例如：

```js
// common.js
export default "common chunk";

// async-module.js
import common from './common'

// entry-a.js
import common from './common'
import('./async-module')

// entry-b.js
import common from './common'
```

上例包含四个模块，形成如下模块关系图：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88d54f6ffcfe44658fddb93c4bd57e95~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

其中，`entry-a`、`entry-b` 分别被视作 Initial Chunk 处理；`async-module` 被 `entry-a` 以异步方式引入，因此被视作 Async Chunk 处理。那么对于 `common` 模块来说，分别被三个不同的 Chunk 引入，此时引用次数为 3，配合下面的配置：

```js
// webpack.config.js
module.exports = {
  entry: {
    entry1: './src/entry-a.js',
    entry2: './src/entry-b.js'
  },
  // ...
  optimization: {
    splitChunks: {      
      minChunks: 2,
      //...
    }
  }
};
```

> 提示：示例已上传到 [小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2FTecvan-fe%2Fwebpack-book-samples%2Ftree%2Fmain%2Fsplitchunks-basic)。

`common` 模块命中 `optimization.splitChunks.minChunks = 2` 规则，因此该模块**可能**会被单独分包，最终产物：

- `entry1.js`
- `entry1.js`
- `async-module.js`
- `common.js`

强调一下，上面说的是“**可能**”，`minChunks` 并不是唯一条件，此外还需要满足诸如 `minSize`、`chunks` 等限制条件才会真正执行分包，接着往下看。

###### 限制分包数量

在 `minChunks` 基础上，为防止最终产物文件数量过多导致 HTTP 网络请求数剧增，反而降低应用性能，Webpack 还提供了 `maxInitialRequest/maxAsyncRequest` 配置项，用于限制分包数量：

- `maxInitialRequest`：用于设置 Initial Chunk 最大并行请求数；
- `maxAsyncRequests`：用于设置 Async Chunk 最大并行请求数。

这里所说的“请求数”，是指加载一个 Chunk 时所需要加载的所有分包数。例如对于一个 Chunk A，如果根据分包规则(如模块引用次数、第三方包)分离出了若干子 Chunk A[¡]，那么加载 A 时，浏览器需要同时加载所有的 A[¡]，此时并行请求数等于 ¡ 个分包加 A 主包，即 ¡+1。

> 提示：通过 [emitAssets](https://link.juejin.cn/?target=https%3A%2F%2Fwebpack.js.org%2Fapi%2Fcompilation-object%2F%23emitasset) 等方式直接输出产物文件不在此范畴。

举个例子，对于上例所说的模块关系：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1d537299ed44da947a7dbf03e22a18~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

若 `minChunks = 2` ，则 `common` 模块命中 `minChunks` 规则被独立分包，浏览器请求 `entry-a` 时，则需要同时请求 `common` 包，并行请求数为 1 + 1=2。

而对于下述模块关系：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6ddb044d1d649a297ec76000bcad3d6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

若 `minChunks = 2` ，则 `common-1` 、`common-2` 同时命中 `minChunks` 规则被分别打包，浏览器请求 `entry-b` 时需要同时请求 `common-1` 、`common-2` 两个分包，并行数为 2 + 1 = 3，此时若 `maxInitialRequest = 2`，则分包数超过阈值，`SplitChunksPlugin` 会 **放弃 `common-1`、`common-2` 中体积较小的分包**。`maxAsyncRequest` 逻辑与此类似，不在赘述。

并行请求数关键逻辑总结如下：

- Initial Chunk 本身算一个请求；
- Async Chunk 不算并行请求；
- 通过 `runtimeChunk` 拆分出的 runtime 不算并行请求；
- 如果同时有两个 Chunk 满足拆分规则，但是 `maxInitialRequests`(或 `maxAsyncRequest`) 的值只能允许再拆分一个模块，那么体积更大的模块会被优先拆解。

###### 限制分包体积

除上面介绍的 `minChunks` —— 模块被引用次数，以及 `maxXXXRequest` —— 包数量，这两个条件外，Webpack 还提供了一系列与 Chunk 大小有关的分包判定规则，借助这些规则我们可以实现当包体过小时直接取消分包 —— 防止产物过"碎"；当包体过大时尝试对 Chunk 再做拆解 —— 避免单个 Chunk 过大。

这一规则相关的配置项有：

- `minSize`： 超过这个尺寸的 Chunk 才会正式被分包；
- `maxSize`： 超过这个尺寸的 Chunk 会尝试进一步拆分出更小的 Chunk；
- `maxAsyncSize`： 与 `maxSize` 功能类似，但只对异步引入的模块生效；
- `maxInitialSize`： 与 `maxSize` 类似，但只对 `entry` 配置的入口模块生效；
- `enforceSizeThreshold`： 超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 Size 限制。

那么，结合前面介绍的两种规则，`SplitChunksPlugin` 的主体流程如下：

1. `SplitChunksPlugin` 尝试将命中 `minChunks` 规则的 Module 统一抽到一个额外的 Chunk 对象；

2. 判断该 Chunk 是否满足 `maxInitialRequests` 阈值，若满足则进行下一步；

3. 判断该 Chunk 资源的体积是否大于上述配置项

    

   ```
   minSize
   ```

    

   声明的下限阈值；

   - 如果体积**小于** `minSize` 则取消这次分包，对应的 Module 依然会被合并入原来的 Chunk
   - 如果 Chunk 体积**大于** `minSize` 则判断是否超过 `maxSize`、`maxAsyncSize`、`maxInitialSize` 声明的上限阈值，如果超过则尝试将该 Chunk 继续分割成更小的部分

> 提示：虽然 `maxSize` 等阈值规则会产生更多的包体，但缓存粒度会更小，命中率相对也会更高，配合持久缓存与 HTTP2 的多路复用能力，网络性能反而会有正向收益。

以上述模块关系为例：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8a66c3358fb42e59660a0640210f359~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

若此时 Webpack 配置的 `minChunks` 大于 2，且 `maxInitialRequests` 也同样大于 2，如果 `common` 模块的体积大于上述说明的 `minxSize` 配置项则分包成功，`commont` 会被分离为单独的 Chunk，否则会被合并入原来的 3 个 Chunk。

> 提示：注意，这些条件的优先级顺序为： `maxInitialRequest/maxAsyncRequests < maxSize < minSize`。而命中 `enforceSizeThreshold` 阈值的 Chunk 会直接跳过这些条件判断，强制进行分包。

###### 缓存组 `cacheGroups` 简介

上述 `minChunks`、`maxInitialRequest`、`minSize` 都属于分包条件，决定是否对什么情况下对那些 Module 做分包处理。此外， `SplitChunksPlugin` 还提供了 `cacheGroups` 配置项用于为不同文件组设置不同的规则，例如：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      cacheGroups: {
        vendors: {
            test: /[\\/]node_modules[\\/]/,
            minChunks: 1,
            minSize: 0
        }
      },
    },
  },
};
```

示例通过 `cacheGroups` 属性设置 `vendors` 缓存组，所有命中 `vendors.test` 规则的模块都会被归类 `vendors` 分组，优先应用该组下的 `minChunks`、`minSize` 等分包配置。

`cacheGroups` 支持上述 `minSice/minChunks/maxInitialRequest` 等条件配置，此外还支持一些与分组逻辑强相关的属性，包括：

- `test`：接受正则表达式、函数及字符串，所有符合 `test` 判断的 Module 或 Chunk 都会被分到该组；
- `type`：接受正则表达式、函数及字符串，与 `test` 类似均用于筛选分组命中的模块，区别是它判断的依据是文件类型而不是文件名，例如 `type = 'json'` 会命中所有 JSON 文件；
- `idHint`：字符串型，用于设置 Chunk ID，它还会被追加到最终产物文件名中，例如 `idHint = 'vendors'` 时，输出产物文件名形如 `vendors-xxx-xxx.js` ；
- `priority`：数字型，用于设置该分组的优先级，若模块命中多个缓存组，则优先被分到 `priority` 更大的组。

缓存组的作用在于能为不同类型的资源设置更具适用性的分包规则，一个典型场景是将所有 `node_modules` 下的模块统一打包到 `vendors` 产物，从而实现第三方库与业务代码的分离。

Webpack 提供了两个开箱即用的 `cacheGroups`，分别命名为 `default` 与 `defaultVendors`，默认配置：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      cacheGroups: {
        default: {
          idHint: "",
          reuseExistingChunk: true,
          minChunks: 2,
          priority: -20
        },
        defaultVendors: {
          idHint: "vendors",
          reuseExistingChunk: true,
          test: /[\\/]node_modules[\\/]/i,
          priority: -10
        }
      },
    },
  },
};
```

这两个配置组能帮助我们：

- 将所有 `node_modules` 中的资源单独打包到 `vendors-xxx-xx.js` 命名的产物
- 对引用次数大于等于 2 的模块 —— 也就是被多个 Chunk 引用的模块，单独打包

开发者也可以将默认分组设置为 false，关闭分组配置，例如：

```js
module.exports = {
  //...
  optimization: {
    splitChunks: {
      cacheGroups: {
        default: false
      },
    },
  },
};
```

###### 配置项与最佳实践

最后，我们再回顾一下 `SplitChunksPlugin` 支持的配置项：

- `minChunks`：用于设置引用阈值，被引用次数超过该阈值的 Module 才会进行分包处理；
- `maxInitialRequest/maxAsyncRequests`：用于限制 Initial Chunk(或 Async Chunk) 最大并行请求数，本质上是在限制最终产生的分包数量；
- `minSize`： 超过这个尺寸的 Chunk 才会正式被分包；
- `maxSize`： 超过这个尺寸的 Chunk 会尝试继续做分包；
- `maxAsyncSize`： 与 `maxSize` 功能类似，但只对异步引入的模块生效；
- `maxInitialSize`： 与 `maxSize` 类似，但只对 `entry` 配置的入口模块生效；
- `enforceSizeThreshold`： 超过这个尺寸的 Chunk 会被强制分包，忽略上述其它 size 限制；
- `cacheGroups`：用于设置缓存组规则，为不同类型的资源设置更有针对性的分包策略。

结合这些特性，业界已经总结了许多惯用的最佳分包策略，包括：

- 针对`node_modules`资源：
  - 可以将 `node_modules` 模块打包成单独文件(通过 `cacheGroups` 实现)，防止业务代码的变更影响 NPM 包缓存，同时建议通过 `maxSize` 设定阈值，防止 vendor 包体过大；
  - 更激进的，如果生产环境已经部署 HTTP2/3 一类高性能网络协议，甚至可以考虑将每一个 NPM 包都打包成单独文件，具体实现可查看小册[示例](https://link.juejin.cn/?target=https%3A%2F%2Fgithub1s.com%2FTecvan-fe%2Fwebpack-book-samples%2Fblob%2F50c9a47ce3%2Fsplitchunks-seperate-npm%2Fwebpack.config.js%23L19-L20)；
- 针对业务代码：
  - 设置 `common` 分组，通过 `minChunks` 配置项将使用率较高的资源合并为 Common 资源；
  - 首屏用不上的代码，尽量以异步方式引入；
  - 设置 `optimization.runtimeChunk` 为 `true`，将运行时代码拆分为独立资源。

常用策略一是单独打包 `node_modules` 代码(习惯称为 `vendor`)，二是单独打包被频繁使用的模块(习惯称为 `common`)。不过，现实世界很复杂，同样的方法放在不同场景可能会有完全相反的效果，建议你根据自己项目的实际情况(代码量、基础设施环境)，择优选用上述实践。





##### 使用外置依赖

设想一个场景，假如我们手头上有 10 个用 React 构建的 SPA 应用，这 10 个应用都需要各自安装、打包、部署、分发同一套相似的 React 基础依赖，最终用户在访问这些应用时也需要重复加载相同基础包代码，那有没有办法节省这部分流量呢？有 —— 使用 Webpack 的 `externals` 特性。

虽然结果上看浏览器还是得消耗这部分流量，但结合 CDN 系统特性，一是能够就近获取资源，缩短网络通讯链路；二是能够将资源分发任务前置到节点服务器，减轻原服务器 QPS 负担；三是用户访问不同站点能共享同一份 CDN 资源副本。所以网络性能效果往往会比重复打包好很多。

`externals` 不仅适用于优化产物性能，在特定环境下还能用于跳过若干运行时模块，例如 Node 中的 `fs/net` 等，避免将这部分源码错误打包进 Bundle，详情可参考 [webpack-node-externals](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fwebpack-node-externals) 工具。

`externals` 的主要作用是将部分模块排除在 Webpack 打包系统之外，例如：

```js
module.exports = {
  // ...
  externals: {
    lodash: "_",
  },
};
```

使用上述配置后，Webpack 不再将这些模块打包到产物中：

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a16f771ffd4377ac8a8a2cefada387~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

注意，使用 `externals` 时必须确保这些外置依赖代码已经被正确注入到上下文环境中，这在 Web 应用中通常可以通过 CDN 方式实现，例如：

```js
module.exports = {
  // ...
  externals: {
    react: "React",
    lodash: "_",
  },
  plugins: [
    new HtmlWebpackPlugin({
      templateContent: `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Webpack App</title>
  <script defer crossorigin src="//unpkg.com/react@18/umd/react.development.js"></script>
  <script defer crossorigin src="//unpkg.com/lodash@4.17.21/lodash.min.js"></script>
</head>
<body>
  <div id="app" />
</body>
</html>
  `,
    }),
  ],
};
```

示例中，`externals` 声明了 `react` 与 `lodash` 两个外置依赖，并在后续的 `html-webpack-plugin` 模板中注入这两个模块的 CDN 引用，以此构成完整 Web 应用。



#### tree-shaking

##### 注释

/* @__PURE__ */ 是给 JavaScript 的压缩和优化工具看的，比如 UglifyJS，Terser，以及 webpack 等。它们会认为紧跟在这个标记后面的函数是一个纯函数。纯函数的特点是对于相同的输入，总是会返回相同的输出，而且不会有任何副作用。因此，如果这个函数的返回值没有被使用，那么这个函数调用就可以被安全地移除，以减小最终生成的代码大小。


这个标记并不是 JavaScript 语言的一部分，而是这些工具定义的一种约定，用来进行更有效的代码优化。





##### 核心原理

Webpack 中，Tree-shaking 的实现，一是需要先 「**标记**」 出模块导出值中哪些没有被用过；二是使用代码压缩插件 —— 如 [Terser](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fterser-webpack-plugin) 删掉这些没被用到的导出变量。

> 标记功能需要配置 `optimization.usedExports = true` 开启

标记的效果就是删除那些没有被其它模块使用的“**导出语句**”，比如：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05e8226fab374ee5a3d65bac3d249e54~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

示例中，`bar.js` 模块（左二）导出了两个变量：`bar` 与 `foo`，其中 `foo` 没有被其它模块用到，所以经过标记后，构建产物（右一）中 `foo` 变量对应的导出语句就被删除了。作为对比，如果没有启动标记功能（`optimization.usedExports = false` 时），则变量无论有没有被用到，都会保留导出语句，如上图右二的产物代码所示。

注意，这个时候 `foo` 变量对应的代码 `const foo='foo'` 都还保留完整，这是因为标记功能只会影响到模块的导出语句，真正执行“**Shaking**”操作的是 Terser 插件。例如在上例中， `foo` 变量经过标记后，已经变成一段 Dead Code —— 不可能被执行到的代码，这个时候只需要用 Terser 提供的 DCE 功能就可以删除这一段定义语句，以此实现完整的 Tree Shaking 效果。



##### 使用 

Tree-Shaking 是一种基于 ES Module 规范的 Dead Code Elimination 技术，它会在运行过程中静态分析模块之间的导入导出，判断哪些模块导出值没有被其它模块使用 —— 相当于模块层面的 Dead Code，并将其删除。

完成 Tree Shaking 操作需要符合以下条件：

- 使用 ES6 Module 语法（即 `import` 和 `export`）。
- 确保没有 `@babel/preset-env`等工具将 ES6Module 语法转换为 CommonJS 模块。
- `optimization: { minimize: true, usedExports: true }`。
- 使用支持 Tree Shaking 的包。



在 Webpack 中，启动 Tree Shaking 功能必须同时满足两个条件：

- 配置 `optimization.usedExports` 为 `true`，标记模块导入导出列表；
- 启动代码优化功能，可以通过如下方式实现：
  - 配置 `mode = production`
  - 配置 `optimization.minimize = true`
  - 提供 `optimization.minimizer` 数组

例如：

```js
// webpack.config.js
module.exports = {
  mode: "production",
  optimization: {
    usedExports: true,
  },
};
```

之后，Webpack 会对所有使用 ESM 方案的模块启动 Tree-Shaking，例如对于下面的代码：

```js
// index.js
import {bar} from './bar';
console.log(bar);

// bar.js
export const bar = 'bar';
export const foo = 'foo';
```

`bar.js` 模块导出了 `bar` 、`foo` ，但只有 `bar` 值被 `index` 模块使用，经过 Tree Shaking 处理后，`foo` 变量会被视作无用代码删除，最终有效的代码结构：

```js
// index.js
import {bar} from './bar';
console.log(bar);

// bar.js
export const bar = 'bar';
```





##### **sideEffect** (副作用) 

其定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。

webpack v4 开始新增了一个 `sideEffects` 特性，通过给 `package.json` 加入 `sideEffects: false` 声明该包模块是否包含副作用，从而可以为 Tree Shaking 提供更大的优化空间。

举例说明

```js
// a.js
// 无副作用，仅仅是单纯的 export
function a () {
  console.log('a')
}
export default {
  a
}
// b.js
function b () {
  console.log('b')
}

// 执行了特殊行为
Array.prototype.fun = () => {}

export default {
  b
}
```

如果 a 在 import 后未使用，Tree Shaking 完全可以将其优化掉；但是 b 在 import 后未使用，但因为存在他还执行了为数组原型添加了方法，副作用还是会被保留下来。这时就需要使用  `sideEffects: false` ，可以强制标识该包模块不存在副作用，那么不管它是否真的有副作用，只要它没有被引用到，整个 模块/包 都会被完整的移除。

如果你的项目中存在一些副作用代码 b 需要被保留下来，比如 polyfill、css、scss、less 等，可以按下面方法一样配置；保证必要的代码不被 Tree Shaking

```json
// package.json
{
  "name": "your-project",
  "sideEffects": ["./src/b.js", "*.css"]
}
```









#### 使用 Scope Hoisting 合并模块

##### 使用场景

默认情况下 Webpack 会将模块打包成一个个单独的函数，例如：

```js
// common.js
export default "common";

// index.js
import common from './common';
console.log(common);
```

经过 Webpack 打包后会生成：

```js
"./src/common.js":
  ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
     const __WEBPACK_DEFAULT_EXPORT__ = ("common");
     __webpack_require__.d(__webpack_exports__, {
      /* harmony export */
      "default": () => (__WEBPACK_DEFAULT_EXPORT__)
      /* harmony export */
    });
  }),
"./src/index.js":
  ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
      var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./common */ "./src/common.js");
      console.log(_common__WEBPACK_IMPORTED_MODULE_0__)
  })
```

这种处理方式需要将每一个模块都包裹进一段相似的函数模板代码中。为此，Webpack 提供了 Scope Hoisting 功能，用于 **将符合条件的多个模块合并到同一个函数空间** 中，从而减少产物体积，优化性能。例如上述示例经过 Scope Hoisting 优化后，生成代码：

```js
((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
    ;// CONCATENATED MODULE: ./src/common.js
    /* harmony default export */ const common = ("common");
    
    ;// CONCATENATED MODULE: ./src/index.js
    console.log(common);
})
```





##### Webpack 提供了三种开启 Scope Hoisting 的方法

- 使用 `mode = 'production'` 开启生产模式；
- 使用 `optimization.concatenateModules` 配置项；
- 直接使用 `ModuleConcatenationPlugin` 插件。

```js
const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');

module.exports = {
    // 方法1： 将 `mode` 设置为 production，即可开启
    mode: "production",
    // 方法2： 将 `optimization.concatenateModules` 设置为 true
    optimization: {
        concatenateModules: true,
        usedExports: true,
        providedExports: true,
    },
    // 方法3： 直接使用 `ModuleConcatenationPlugin` 插件
    plugins: [new ModuleConcatenationPlugin()]
};
```

三种方法最终都会调用 `ModuleConcatenationPlugin` 完成模块分析与合并操作。







##### 以下场景下会失效

与 Tree-Shaking 类似，Scope Hoisting 底层基于 ES Module 方案的 [静态特性](https://link.juejin.cn/?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F52965907%2Fwhat-is-the-meaning-of-static-import-in-es6)，推断模块之间的依赖关系，并进一步判断模块与模块能否合并，因此在以下场景下会失效：

1. **非 ESM 模块**

遇到 AMD、CMD 一类模块时，由于导入导出内容的动态性，Webpack 无法确保模块合并后不会产生意料之外的副作用，因此会关闭 Scope Hoisting 功能。这一问题在导入 NPM 包尤其常见，许多框架都会自行打包后再上传到 NPM，并且默认导出的是兼容性更佳的 CommonJS 包，因而无法使用 Scope Hoisting 功能，此时可通过 `mainFileds` 属性尝试引入框架的 ESM 版本：

```js
module.exports = {
  resolve: {
    // 优先使用 jsnext:main 中指向的 ES6 模块化语法的文件
    mainFields: ['jsnext:main', 'browser', 'main']
  },
};
```

2. **模块被多个 Chunk 引用**

如果一个模块被多个 Chunk 同时引用，为避免重复打包，Scope Hoisting 同样会失效，例如：

```js
// common.js
export default "common"

// async.js
import common from './common';

// index.js 
import common from './common';
import("./async");
```

示例中，入口 `index.js` 与异步模块 `async.js` 同时依赖 `common.js` 文件，`common.js` 无法被合并入任一 Chunk，而是作为生成为单独的作用域，最终打包结果：

```js
 "./src/common.js":
  (() => {
    var __WEBPACK_DEFAULT_EXPORT__ = ("common");
  }),
 "./src/index.js":
  (() => {
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./common */ "./src/common.js");
    __webpack_require__.e( /*! import() */ "src_async_js").then(__webpack_require__.bind(__webpack_require__, /*! ./async */ "./src/async.js"));
  }),  
```

#### 监控产物体积

站在生产者角度我们有必要尽可能优化代码在网络上分发的效率，用尽可能少的网络流量交付应用功能。所幸 Webpack 专门为此提供了一套 [性能监控方案](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwebpack%2Fwebpack%2Fissues%2F3216)，当构建生成的产物体积超过阈值时抛出异常警告，以此帮助我们时刻关注资源体积，避免因项目迭代增长带来过大的网络传输，用法：

```js
module.exports = {
  // ...
  performance: {    
    // 设置所有产物体积阈值
    maxAssetSize: 172 * 1024,
    // 设置 entry 产物体积阈值
    maxEntrypointSize: 244 * 1024,
    // 报错方式，支持 `error` | `warning` | false
    hints: "error",
    // 过滤需要监控的文件类型
    assetFilter: function (assetFilename) {
      return assetFilename.endsWith(".js");
    },
  },
};
```

若此时产物体积超过 172KB，则报错：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7a142bb02ea4615b3cb5e3bb73a9da4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 提示：这里的报错不会阻断构建功能， 依然能正常打包出应用产物。

那么我们应该设置多大的阈值呢？这取决于项目具体场景，不过，一个比较好的 [经验法则](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fyour-first-performance-budget%2F%23budget-for-quantity-based-metrics) 是确保 [关键路径](https://link.juejin.cn/?target=https%3A%2F%2Fweb.dev%2Fcritical-rendering-path%2F) 资源体积始终小于 170KB，超过这个体积就应该使用上面介绍的若干方法做好裁剪优化。

















#### pwa

看尚硅谷代码



#### 多进程打包

```js
          {
            test: /\.js$/,
            exclude: /node_modules/,
            use: [
              /* 
                开启多进程打包。 
                进程启动大概为600ms，进程通信也有开销。
                只有工作消耗时间比较长（处理js代码），才需要多进程打包，所以这里就给了babel使用
              */
              {
                loader: 'thread-loader',
                options: {
                  workers: 2 // 进程2个
                }
              },
              {
                loader: 'babel-loader',
                options: {
                  presets: [
                    [
                      '@babel/preset-env',
                      {
                        useBuiltIns: 'usage',
                        corejs: { version: 3 },
                        targets: {
                          chrome: '60',
                          firefox: '50'
                        }
                      }
                    ]
                  ],
                  // 开启babel缓存
                  // 第二次构建时，会读取之前的缓存
                  cacheDirectory: true
                }
              }
            ]
          },
```



#### Dll

`externals` 是一种将某些模块作为外部依赖导入的方式，不会被打包到最终的 bundle 中。这些模块会被视为外部依赖，需要在构建之前手动在 HTML 文件中引入这些资源。这样可以避免将一些较大的库打包进 bundle，减小 bundle 的体积，提高页面加载速度。

例如，在 Webpack 配置中可以这样配置 `externals`：

```
module.exports = {
  // ...
  externals: {
    jquery: 'jQuery',
    lodash: '_',
  },
  // ...
};
```

这表示在构建过程中，如果遇到 `jquery` 和 `lodash` 两个模块，会将其视为外部依赖，在最终生成的 bundle 文件中，不会包含这两个模块的代码。

而 `dll` 是一种将一些公共的代码或库打包成单独的 bundle，方便多个页面或应用进行共享。首先需要针对这些公共库或代码进行一次单独的打包，生成一个独立的 bundle。然后在需要使用这些库或代码的页面或应用中，通过引入这个 bundle 来获取到这些公共的代码库。





#### Webpack 的热更新原理

(敲黑板，这道题必考)

`Webpack` 的热更新又称热替换（`Hot Module Replacement`），缩写为 `HMR`。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。

HMR的核心就是客户端从服务端拉去更新后的文件，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个 `Websocket`，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 `Ajax` 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 `jsonp` 请求获取该chunk的增量更新。





## vite

### 总览

#### 什么是vite

- 一个开发服务器，它基于 [原生 ES 模块](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) 提供了 [丰富的内建功能](https://cn.vitejs.dev/guide/features.html)，如速度快到惊人的 [模块热更新（HMR）](https://cn.vitejs.dev/guide/features.html#hot-module-replacement)。

- 一套构建指令，它使用 [Rollup](https://rollupjs.org/) 打包你的代码，并且它是预配置的，可输出用于生产环境的高度优化过的静态资源。



架构图：

![image-20230216121347448](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230216121347448.png)



### 优缺点

#### 优点

尤雨溪说：

整合了esbuild和rollup在彼此领域的优点：

esbuild非常快但是对构建资源的优化支持的不够好，比如控制代码块的拆分。插件之间的链接也不太好。

rollup成熟且灵活，但是慢。当项目中有esm和cjs混用的依赖时，rollup的处理会有问题





#### 缺点

尤雨溪说：

1. 相对较慢的生产构建速度(最痛)。因为rollup比esbuild或bun这种native bundlers 要慢。
2. 开发和生产环境的不一致。因为开发环境由esbuild处理依赖，源码交由原生es模块提供服务；而生产环境依赖和源码都交给rollup。所以像commonjs的处理和模块转换方式都不一样。
   - 比如我遇到一个场景：现象是动效在生产环境正常，开发环境播放不了。原因是该动效需要等两张图片加载，而这两张图片在生产环境会变成base64。开发环境要等加载，又由于我设了一个动效关闭的时间，所以图片没加载回来就被关闭了。当然实际解法有很多，比如开发环境也弄成base64等等。
3. 开发环境有很多没有打包的esmodules，会有很大网络开销，最终导致首页加载慢。
4. Confusing ssr externals issues (不知道是啥)
5. 代码块分割的控制比不上webpack。
6. lack of first-party Module Federation support









### 性能利器——Esbuild

做了以下三件事：

#### 依赖预构建——作为 Bundle 工具

##### 缓存

###### 文件系统缓存[#](https://cn.vitejs.dev/guide/dep-pre-bundling.html#file-system-cache)

Vite 将预构建的依赖项缓存到 `node_modules/.vite` 中。它会基于以下几个来源来决定是否需要重新运行预构建步骤：

- 包管理器的锁文件内容，例如 `package-lock.json`，`yarn.lock`，`pnpm-lock.yaml`，或者 `bun.lockb`；
- 补丁文件夹的修改时间；
- `vite.config.js` 中的相关字段；
- `NODE_ENV` 的值。

只有在上述其中一项发生更改时，才需要重新运行预构建。

如果出于某些原因你想要强制 Vite 重新构建依赖项，你可以在启动开发服务器时指定 `--force` 选项，或手动删除 `node_modules/.vite` 缓存目录。



###### 浏览器缓存[#](https://cn.vitejs.dev/guide/dep-pre-bundling.html#browser-cache)

已预构建的依赖请求使用 HTTP 头 `max-age=31536000, immutable` 进行强缓存，以提高开发期间页面重新加载的性能。一旦被缓存，这些请求将永远不会再次访问开发服务器。如果安装了不同版本的依赖项（这反映在包管理器的 lockfile 中），则会通过附加版本查询自动失效。如果你想通过本地编辑来调试依赖项，您可以：

1. 通过浏览器开发工具的 Network 选项卡暂时禁用缓存；
2. 重启 Vite 开发服务器指定 `--force` 选项，来重新构建依赖项;
3. 重新载入页面。



##### 缺点

但是Esbuild 作为打包工具有一些缺点：

- 不支持降级到 `ES5` 的代码。这意味着在低端浏览器代码会跑不起来。
- 不支持 `const enum` 等语法。这意味着单独使用这些语法在 esbuild 中会直接抛错。
- 不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力(如`renderChunk`钩子)在 Esbuild 当中完全没有。
- 不支持自定义 Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。



#### 单文件编译——作为 TS 和 JSX 编译工具

在依赖预构建阶段， Esbuild 作为 Bundler 的角色存在。而在 TS(X)/JS(X) 单文件编译上面，Vite 使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。可以在架构图中`Vite Plugin Pipeline`部分注意到:

![image-20230216123026636](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230216123026636.png)

也就是说，Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行，因此，我们可以得出下面这个结论:

这部分能力用来替换原先 Babel 或者 TSC 的功能， 因为Babel 和 TSC都太慢了。

 Esbuild 在编译 `TS`(或者 `TSX`) 文件时仅仅抹掉了类型相关的代码，暂时没有能力实现类型检查。

因此，`vite build`之前会先执行`tsc`命令，也就是借助 TS 官方的编译器进行类型检查。

当然，要解决类型问题，我更推荐大家使用 TS 的编辑器插件。在开发阶段就能早早把问题暴露出来并解决，不至于等到项目要打包上线的时候。

#### 代码压缩——作为压缩工具

> Vite 从 2.6 版本开始，就官宣默认使用 Esbuild 来进行生产环境的代码压缩，包括 JS 代码和 CSS 代码。

从架构图中可以看到，在生产环境中 Esbuild 压缩器通过插件的形式融入到了 Rollup 的打包流程中:

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230216123007584.png" alt="image-20230216123007584" style="zoom:50%;" />

为什么 Vite 要将 Esbuild 作为生产环境下默认的压缩工具呢？因为压缩效率实在太高了！

传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。但 Terser 其实很慢，主要有 2 个原因。

1. 压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程。
2. JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言。

因此，Esbuild 这种从头到尾**共享 AST** 以及**原生语言编写**的 Minifier 在性能上能够甩开传统工具的好几十倍。





#### 为什么 Esbuild 性能极高？

Esbuild 是由 Figma 的 CTO 「Evan Wallace」基于 Golang 开发的一款打包工具，相比传统的打包工具，主打性能优势，在构建速度上可以比传统工具快 `10~100` 倍。那么，它是如何达到这样超高的构建性能的呢？主要原因可以概括为 4 点。

1. **使用 Golang 开发**，构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。
2. **多核并行**。内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势。
3. **从零造轮子**。 几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能。
4. **高效的内存利用**。Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -> TS -> JS -> string)，造成内存的大量浪费。



### 构建基石——Rollup

#### 为什么生产环境仍需打包[¶](https://cn.vitejs.dev/guide/why.html#why-bundle-for-production)

尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。

#### 做了两件事

##### 生产环境 Bundle

生产环境做到完全`no-bundle`也不行，会有网络性能问题（比如每个组件都单独请求，首页加载上百个请求）。为了在生产环境中也能取得优秀的产物性能，Vite 默认选择在生产环境中利用 `Rollup` 打包，并基于 Rollup 本身成熟的打包能力进行扩展和优化，主要包含 3 个方面:

1. CSS 代码分割。如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的`缓存复用率`。
2. 自动预加载。Vite 会自动为入口 chunk 的依赖自动生成预加载标签`<link rel="modulepreload">` ，这种适当预加载的做法会让浏览器提前下载好资源，优化页面性能。如:

```html
<head>
  <!-- 省略其它内容 -->
  <!-- 入口 chunk -->
  <script type="module" crossorigin src="/assets/index.250e0340.js"></script>
  <!--  自动预加载入口 chunk 所依赖的 chunk-->
  <link rel="modulepreload" href="/assets/vendor.293dca09.js">
</head>
```



3. 异步 Chunk 加载优化。在异步引入的 Chunk 中，通常会有一些公用的模块，如现有两个异步引入的 Chunk: `A` 和 `B`，而且两者有一个公共依赖 C，如下图:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5adc9b7c9426424f99be3a7044e3469f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

一般情况下，Rollup 打包之后，会先请求 A，然后浏览器在加载 A 的过程中才决定请求和加载 C，但 Vite 进行优化之后，请求 A 的同时会自动预加载 C，通过优化 Rollup 产物依赖加载方式节省了不必要的网络开销。

##### 兼容插件机制

无论是开发阶段还是生产环境，Vite 都根植于 Rollup 的插件机制和生态，如下面的架构图所示:

![image-20230216122925551](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230216122925551.png)

在开发阶段，Vite 借鉴了 [WMR](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpreactjs%2Fwmr) 的思路，自己实现了一个 `Plugin Container`，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑，而 Vite 的插件写法完全兼容 Rollup，因此在生产环境中将所有的 Vite 插件传入 Rollup 也没有问题。

反过来说，Rollup 插件却不一定能完全兼容 Vite。不过目前仍然有不少 Rollup 插件可以直接复用到 Vite 中，你可以通过这个站点查看所有兼容 Vite 的 Rollup 插件: [vite-rollup-plugins.patak.dev/](https://link.juejin.cn/?target=https%3A%2F%2Fvite-rollup-plugins.patak.dev%2F) 。

 Vite 的做法是从头到尾根植于的 Rollup 的生态，设计了和 Rollup 非常吻合的插件机制。



#### 为什么 Rollup 构建产物很干净？

- rollup 只对 ESM 模块进行打包，对于 cjs 模块也会通过插件将其转化为 ESM 模块进行打包。不会像 webpack 有很多的代码注入。
- rollup 对打包结果也支持多种 format 的输出，比如：esm、cjs、am 等等，但是 rollup 并不保证代码可靠运行，需要运行环境可靠支持。比如我们输出 esm 规范代码，代码运行时完全依赖高版本浏览器原生去支持 esm，rollup 不会像 webpack 一样注入一系列兼容代码。
- rollup 实现了强大的 tree-shaking 能力。









### 从零搭建vite开发vue环境

##### 安装vite

```kotlin
pnpm i vite -D
```

启动 Vite。启动 Vite 的时候使用 npx。这是一个 Npm5.2 新增加的命令，用于执行软件包中的可执行文件。 以往的可执行文件只能通过全局安装或者从 node_modules/.bin 中查找。

```
npx vite
```

无需任何配置就可以提供一个Typescript 的前端开发环境，支持自动热更新。可以考虑把 Vite 安装到全局。这样你就可以全局使用 Typescript 开发前端了。

最后在 package.json 中添加一个启动脚本，下次在启动开发环境运行 pnpm dev ，就可以启动 Vite 开发代码了。

```json
  "scripts": {
    "dev": "vite"
  },
```





##### 使用vue

安装 Vue3.0 软件包。

```kotlin
pnpm i vue@"3.2.37"
```

Vue3.0 默认的包是不支持模板编译功能的。也就是说， template 语法现在还不能用。在 Vue3.0 中编译功能推荐在构建阶段完成，而不是放到浏览器中运行。如果希望在浏览器中的话，可以选择 ./node_modules/vue/dist/vue.global.js 这个包。

你可以这样理解，Vite 默认只能支持 TS 代码。而 Vue 的模板需要在编译阶段转换为 Typescript 代码 (渲染函数)才可以运行。





##### 让 Vite 可以编译 Vue 模版

如果让 Vite 可以编译 Vue 模版，可以通过安装 Vite 的 Vue 插件实现。Vue 插件不但提供了模板的编译，同时还支持 Vue 单文件 (SFC) 组件的编译。

安装 Vite 的Vue插件。

```kotlin
pnpm i @vitejs/plugin-vue@"3.0.3" -D
```

添加一个 vite.config.ts。

```javascript
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";

// https://vitejs.dev/config/

export default defineConfig({

  plugins: [vue()],

});
```

在引用 .vue 模块时候，编辑器中 import 语句会有红色的警告。这是因为Typescript 默认是不支持 .vue 类型的模块的。可以通过添加一个模块的类型定义来解决这个问题。

src/shims-vue.d.ts

```typescript
declare module "*.vue" {
  import { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
```

添加后可以看到红色警告随即消失。





##### 支持jsx语法

安装这个插件

```kotlin
pnpm i @vitejs/plugin-vue-jsx@"2.0.0" -D
```

vite.config.ts

```javascript
import vueJsx from '@vitejs/plugin-vue-jsx'

export default defineConfig({

  plugins: [
    // 添加JSX插件
    vueJsx({
      // options are passed on to @vue/babel-plugin-jsx
    })
  ],

})
```

由于在ts中使用 JSX 语法，在 vscode编辑器中会提示错误。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e6689deeb7d4d32acb66c4a4e8b2a17~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这个提示的意思是不支持 JSX 语法造成的。而不是需要安装 React。只需要在 tsconfig 中配置一下 jsx 语法支持就行了。

./tsconfig.json

```json
{
    "compilerOptions": {
        "declaration": true, /* 生成相关的 '.d.ts' 文件。 */
        "declarationDir": "./dist/types", /* '.d.ts' 文件输出目录 */
        "jsx": "preserve",
    },
    "include": [
        "./**/*.*",
        "./shims-vue.d.ts",
    ],
    "exclude": [
        "node_modules"
    ],
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": "true"
}
```



### 按需加载

#### 本质

利用ESModule的动态加载，然后vite会把这部分单独打包成一个chunk

#### 举例

对路由组件进行动态引入。比如在 React 应用中使用 `@loadable/component` 进行组件异步加载:

```ts
import React from "react";
import ReactDOM from "react-dom";
import loadable from "@loadable/component";
import { BrowserRouter, Routes, Route } from "react-router-dom";

const Foo = loadable(() => import("./routes/Foo"));
const Bar = loadable(() => import("./routes/Bar"));

ReactDOM.render(
  <React.StrictMode>
    <BrowserRouter>
      <Routes>
        <Route path="/foo" element={<Foo />} />
        <Route path="/bar" element={<Bar />} />
      </Routes>
    </BrowserRouter>
  </React.StrictMode>,
  document.getElementById("root")
);
```

这样在生产环境中，Vite 也会将动态引入的组件单独打包成一个 chunk。

当然，对于组件内部的逻辑，我们也可以通过动态 import 的方式来延迟执行，进一步优化首屏的加载性能，如下代码所示:

```ts
function App() {
  const computeFunc = async () => {
    // 延迟加载第三方库
    // 需要注意 Tree Shaking 问题
    // 如果直接引入包名，无法做到 Tree-Shaking，因此尽量导入具体的子路径
    const { default: merge } = await import("lodash-es/merge");
    const c = merge({ a: 1 }, { b: 2 });
    console.log(c);
  };
  return (
    <div className="App">
      <p>
        <button type="button" onClick={computeFunc}>
          Click me
        </button>
      </p>
    </div>
  );
}

export default App;
```







### 配置文件

#### 介绍

###### vite.config.js可以使用esmodule规范

因为vite在读取这个vite.config.js的时候会率先node去解析文件语法, 如果发现你是esmodule规范会直接将你的esmodule规范进行替换变成commonjs规范



#### 基本配置

##### 配置公共资源路径

base: https://cn.vitejs.dev/guide/build.html#public-base-path

`experimental.renderBuiltUrl`：https://cn.vitejs.dev/guide/build.html#advanced-base-options

vite配置的`experimental.renderBuiltUrl`函数返回的URL将被插入到生成的JavaScript、CSS或HTML文件中。例如，如果你的JavaScript文件中有一个动态导入，如`import('./my-module.js')`，那么Vite会在构建时将这个导入替换为一个请求URL，如`import('/assets/my-module.4gfd8s9.js')`。



##### 环境变量

###### vite处理环境变量

vite内置了dotenv这个第三方库处理环境变量

dotenv会自动读取.env文件, 并解析这个文件中的对应环境变量 并将其注入到process对象下(vite考虑到和其他配置的一些冲突问题, 他不会直接注入到process对象下)





###### 使用

.env: 所有环境都需要用到的环境变量
.env.development: 开发环境需要用到的环境变量(默认情况下vite将我们的开发环境取名为development)
.env.production: 生产环境需要用到的环境变量(默认情况下vite将我们的生产环境取名为production)

- 在服务端中我们可以调用vite的loadEnv来获取env，当我们调用loadenv的时候, 他会做如下几件事:

  1. 直接找到.env文件 并解析其中的环境变量 并放进一个对象里
  2. 会将传进来的mode这个变量（mode变量有默认值，也可以通过命令行里--mode newName 去改本次执行的mode的变量的值）的值进行拼接: ```.env.development```,  并根据我们提供的目录去取对应的配置文件并进行解析, 并放进一个对象 。

  ```js
  export default defineConfig(({ command, mode }) => {
      // 是build 还是serve主要取决于我们敲的命令是开启开发环境还是生产环境
      // console.log("process", process.cwd()); 当前env文件所在的目录
      const env = loadEnv(mode, process.cwd(), "");
      return envResolver[command]();
  })
  ```

  

- 在客户端, vite会将对应的环境变量注入到import.meta.env里去。为了防止我们将隐私性的变量直接送进import.meta.env中, vite做了一层拦截, 如果你的环境变量不是以`VITE_`开头的, 他就不会帮你注入到客户端中去, 如果我们想要更改这个前缀, 可以去使用envPrefix配置



###### 配置环境变量

- root
- envDir: 用来配置当前环境变量的文件地址

```js
export default defineConfig({
    envPrefix: "ENV_",
})
```





##### 区分生产环境和开发环境

`isDev`变量是vite自带的一个全局变量，它在开发模式下为`true`，在生产模式下为`false`。因此可以根据这个变量来控制插件的调用。



> vite.config.js

```js
import {defineConfig, loadEnv} from "vite";
import viteBaseConfig from "./vite.base.config";
import viteDevConfig from "./vite.dev.config";
import viteProdConfig from "./vite.prod.config";

// 策略模式
const envResolver = {
    "build": () => {
        console.log("生产环境");
        return ({ ...viteBaseConfig, ...viteProdConfig })
    },
    "serve": () => {
        console.log("开发环境");
        return  ({ ...viteBaseConfig, ...viteProdConfig }) // 新配置里是可能会被配置envDir .envA
    }
}

export default defineConfig(({ command, mode }) => {
    // 是build 还是serve主要取决于我们敲的命令是开启开发环境还是生产环境
    // console.log("process", process.cwd()); 当前env文件所在的目录
    const env = loadEnv(mode, process.cwd(), "");
    return envResolver[command]();
})
```











##### 配置别名

```js
export default defineConfig({
    resolve:{
      alias:{
        "@":path.resolve(__dirname,'./src')
      }
    }
});
```



此时文件中输入@是没有提示路径的，需要我们在tsconfig.json中添加两项配置：

```ts
"compilerOptions":{
	...
	"baseUrl": "./",
	"paths": {
		"@/*": ["src/*"]
	}
}
```







#### 处理css

###### vite天生就支持对css文件的直接处理

1. vite在读取到main.js中引用到了Index.css
2. 直接去使用fs模块去读取index.css中文件内容
3. 直接创建一个style标签, 将index.css中文件内容直接copy进style标签里
4. 将style标签插入到index.html的head中
5. 将该css文件中的内容直接替换为js脚本(方便热更新或者css模块化), 同时设置Content-Type为js 从而让浏览器以JS脚本的形式来执行该css后缀的文件



###### <span id="configCSS">配置css</span>

```js
export default defineConfig({
    css: { // 对css的行为进行配置
      
/*modules配置最终会丢给postcss-modules这个库去处理*/
        modules: { // 是对css模块化的默认行为进行覆盖
            localsConvention: "camelCaseOnly", // 修改生成的module里配置对象的key的展示形式(驼峰还是中划线形式)
            scopeBehaviour: "local", // 配置当前的模块化行为是模块化（模块化就是会给每个类名加哈希值）还是全局化 
            generateScopedName: "[name]_[local]_[hash:5]" //生成的类名的规则(可以配置为函数, 也可以配置成字符串规则：https://github.com/webpack/loader-utils#interpolatename）
            // generateScopedName: (name, filename, css) => {
            //     // name -> 代表的是你此刻css文件中的类名
            //     // filename -> 是你当前css文件的绝对路径
            //     // css -> 给的就是你当前样式
            //    返回值就决定了他最终显示的类型
            //     return `${name}_${Math.random().toString(36).substr(3, 8) }`;
            // }
            hashPrefix: "hello", // 生成hash会根据你的类名 + 一些其他的字符串(文件名 + 他内部随机生成一个字符串)去进行生成, 配置hashPrefix, 你配置的这个字符串会参与到最终的hash生成。
            globalModulePaths: ["./componentB.module.css"], // 代表你不想参与到css模块化的路径
        },
  

/*配置css预处理的一些全局参数*/
        preprocessorOptions: { // key + config （key代表预处理器的名）
            less: { // 整个的配置对象都会最终成为less编译时的执行参数
                math: "always",
                globalVars: { // 定义全局变量
                    mainColor: "red",
                }
            },
        },
  
/*假设我们的代码被压缩或者被编译过了, 这个时候假设程序出错, 他将不会产生正确的错误位置信息 如果设置了sourceMap, 他就会有一个索引文件map */
        devSourcemap: true,
  
/*该属性配置的就是postcss库的配置，也可以不在这里配置，直接在同级新建一个postcss.config.js文件去进行配置，它会自动去读取。在这里写的优先级会比单独的那个文件高*/  
        postcss:{
					plugins:[postcssPresetEnv({
            importFrom:path.resolve(_dirname,"./variable.css") //声明一些文件要全局记录下来。因为postcss是一个文件一个文件去解析的，也就是说上一个文件跟正在解析的这个文件是没有任何关联的，这里就是要声明一个文件跟其他所有文件都是有关的，在解析其他文件的时候也要考虑这个文件。（这个配置可能已经被废弃，详情看使用时给出的警告）
          })]
        }
    },
});
```





###### CSS 预处理器

Vite 本身对 CSS 各种预处理器语言(`Sass/Scss`、`Less`和`Stylus`)做了内置支持。也就是说，即使你不经过任何的配置也可以直接使用各种 CSS 预处理器。

由于 Vite 底层会调用 CSS 预处理器的官方库进行编译，而 Vite 为了实现按需加载，并没有内置这些工具库，而是让用户根据需要安装。因此，我们首先安装 Sass 的官方库，安装命令如下:

```bash
pnpm i sass -D
```

我们封装一个全局的主题色，新建`src/variable.scss`文件，内容如下:

```scss
// variable.scss
$theme-color: red;
```

然后，我们在原来 Header 组件的样式中应用这个变量:

```scss
@import "../../variable";

.header {
  color: $theme-color;
}
```

回到浏览器访问页面，可以看到样式依然生效。你可能会注意到，每次要使用`$theme-color`属性的时候我们都需要手动引入`variable.scss`文件，那有没有自动引入的方案呢？这就需要在 Vite 中进行一些自定义配置了，在配置文件中增加如下的内容:

```ts
// vite.config.ts
import { normalizePath } from 'vite';
// 如果类型报错，需要安装 @types/node: pnpm i @types/node -D
import path from 'path';

// 全局 scss 文件的路径
// 用 normalizePath 解决 window 下的路径问题
const variablePath = normalizePath(path.resolve('./src/variable.scss'));


export default defineConfig({
  // css 相关的配置
  css: {
    preprocessorOptions: {
      scss: {
        // additionalData 的内容会在每个 scss 文件的开头自动注入
        additionalData: `@import "${variablePath}";`
      }
    }
  }
})
```

现在你可以直接在文件中使用全局文件的变量，相当于之前手动引入的方式显然方便了许多:

```scss
.header {
  color: $theme-color;
}
```

同样的，你可以对 `less`和`stylus`进行一些能力的配置，如果有需要你可以去下面的官方文档中查阅更多的配置项:

- [Sass](https://link.juejin.cn/?target=https%3A%2F%2Fsass-lang.com%2Fdocumentation%2Fjs-api%2Fmodules%23render)
- [Less](https://link.juejin.cn/?target=https%3A%2F%2Flesscss.org%2Fusage%2F%23less-options)
- [Stylus](https://link.juejin.cn/?target=https%3A%2F%2Fstylus-lang.com%2Fdocs%2Fjs.html)



###### CSS Modules

CSS Modules 在 Vite 也是一个开箱即用的能力，Vite 会对后缀带有`.module`的样式文件自动应用 CSS Modules。接下来我们通过一个简单的例子来使用这个功能。

首先，将 Header 组件中的`index.scss`更名为`index.module.scss`，然后稍微改动一下`index.tsx`的内容，如下:

```ts
// index.tsx
import styles from './index.module.scss';
export function Header() {
  return <p className={styles.header}>This is Header</p>
};
```

现在打开浏览器，可以看见 p 标签的类名已经被处理成了哈希值的形式:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b81adefe16484da98bebf6174db36300~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

说明现在 CSS Modules 已经正式生效了！同样的，你也可以在配置文件中的`css.modules`选项来配置 CSS Modules 的功能，比如下面这个例子:

```ts
// vite.config.ts
export default {
  css: {
    modules: {
      // 一般我们可以通过 generateScopedName 属性来对生成的类名进行自定义
      // 其中，name 表示当前文件名，local 表示类名
      generateScopedName: "[name]__[local]___[hash:base64:5]"
    },
    preprocessorOptions: {
      // 省略预处理器配置
    }

  }
}
```

再次访问页面，我们可以发现刚才的类名已经变成了我们自定义的形式:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fc26be6dffd4b13b8b15603ba069f62~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这是一个 CSS Modules 中很常见的配置，对开发时的调试非常有用。其它的一些配置项不太常用，大家可以去这个[地址](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmadyankin%2Fpostcss-modules)进行查阅。





###### PostCSS

一般你可以通过 `postcss.config.js` 来配置 postcss ，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口，我们可以直接在 Vite 配置文件中进行操作。见[这里](#configCSS)

由于有 CSS 代码的 AST (抽象语法树)解析能力，PostCSS 可以做的事情非常多，甚至能实现 CSS 预处理器语法和 CSS Modules，社区当中也有不少的 PostCSS 插件，除了刚刚提到的`autoprefixer`插件，常见的插件还包括:

- [postcss-pxtorem](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcuth%2Fpostcss-pxtorem)： 用来将 px 转换为 rem 单位，在适配移动端的场景下很常用。
- [postcss-preset-env](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcsstools%2Fpostcss-preset-env): 通过它，你可以编写最新的 CSS 语法，不用担心兼容性问题。
- [cssnano](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fcssnano%2Fcssnano): 主要用来压缩 CSS 代码，跟常规的代码压缩工具不一样，它能做得更加智能，比如提取一些公共样式进行复用、缩短一些常见的属性值等等。

关于 PostCSS 插件，这里还给大家推荐一个站点：[www.postcss.parts/](https://link.juejin.cn/?target=https%3A%2F%2Fwww.postcss.parts%2F) ，



###### CSS In JS

社区中有两款主流的`CSS In JS` 方案: `styled-components`和`emotion`。

对于 CSS In JS 方案，在构建侧我们需要考虑`选择器命名问题`、`DCE`(Dead Code Elimination 即无用代码删除)、`代码压缩`、`生成 SourceMap`、`服务端渲染(SSR)`等问题，而`styled-components`和`emotion`已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件。

具体来说，上述的两种主流 CSS in JS 方案在 Vite 中集成方式如下:

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    react({
      babel: {
        // 加入 babel 插件
        // 以下插件包都需要提前安装
        // 当然，通过这个配置你也可以添加其它的 Babel 插件
        plugins: [
          // 适配 styled-component
          "babel-plugin-styled-components"
          // 适配 emotion
          "@emotion/babel-plugin"
        ]
      },
      // 注意: 对于 emotion，需要单独加上这个配置
      // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法
      jsxImportSource: "@emotion/react"
    })
  ]
})
```

###### CSS 原子化框架

在目前的社区当中，CSS 原子化框架主要包括`Tailwind CSS` 和 `Windi CSS`。Windi CSS 作为前者的替换方案，实现了按需生成 CSS 类名的功能，开发环境下的 CSS 产物体积大大减少，速度上比`Tailwind CSS v2`快 20~100 倍！当然，Tailwind CSS 在 v3 版本也引入 [JIT(即时编译)](https://link.juejin.cn/?target=https%3A%2F%2Fv2.tailwindcss.com%2Fdocs%2Fjust-in-time-mode) 的功能，解决了开发环境下 CSS 产物体积庞大的问题。接下来我们将这两个方案分别接入到 Vite 中，在实际的项目中你只需要使用其中一种就可以了。我个人比较喜欢 Windi CSS 本身的`attributify`、`shortcuts`等独有的特性，因此首先从 windicss 开始说起。

1. Windi CSS 接入

首先安装 `windicss` 及对应的 Vite 插件:

```css
pnpm i windicss vite-plugin-windicss -D
```

随后我们在配置文件中来使用它:

```ts
// vite.config.ts
import windi from "vite-plugin-windicss";

export default {
  plugins: [
    // 省略其它插件
    windi()
  ]
}
```

接着要注意在`src/main.tsx`中引入一个必需的 import 语句:

```ts
// main.tsx
// 用来注入 Windi CSS 所需的样式，一定要加上！
import "virtual:windi.css";
```

这样我们就完成了 Windi CSS 在 Vite 中的接入，接下来我们在 Header 组件中来测试，组件代码修改如下:

```tsx
// src/components/Header/index.tsx
import { devDependencies } from "../../../package.json";

export function Header() {
  return (
    <div className="p-20px text-center">
      <h1 className="font-bold text-2xl mb-2">
        vite version: {devDependencies.vite}
      </h1>
    </div>
  );
}
```



除了本身的原子化 CSS 能力，Windi CSS 还有一些非常好用的高级功能，在此我给大家推荐自己常用的两个能力: **attributify** 和 **shortcuts**。

要开启这两个功能，我们需要在项目根目录新建`windi.config.ts`，配置如下:

```ts
import { defineConfig } from "vite-plugin-windicss";

export default defineConfig({
  // 开启 attributify
  attributify: true,
});
```

首先我们来看看`attributify`，翻译过来就是`属性化`，也就是说我们可以用 props 的方式去定义样式属性，如下所示:

```html
<button 
  bg="blue-400 hover:blue-500 dark:blue-500 dark:hover:blue-600"
  text="sm white"
  font="mono light"
  p="y-2 x-4"
  border="2 rounded blue-200"
>
  Button
</button>
```

这样的开发方式不仅省去了繁琐的 className 内容，还加强了语义化，让代码更易维护，大大提升了开发体验。

不过使用`attributify`的时候需要注意类型问题，你需要添加`types/shim.d.ts`来增加类型声明，以防类型报错:

```ts
import { AttributifyAttributes } from 'windicss/types/jsx';

declare module 'react' {
  type HTMLAttributes<T> = AttributifyAttributes;
}
```

`shortcuts` 用来封装一系列的原子化能力，尤其是一些常见的类名集合，我们在 `windi.config.ts`来配置它:

```ts
//windi.config.ts
import { defineConfig } from "vite-plugin-windicss";

export default defineConfig({
  attributify: true,
  shortcuts: {
    "flex-c": "flex justify-center items-center",
  }
});
```

比如这里封装了`flex-c`的类名，接下来我们可以在业务代码直接使用这个类名:

```HTML
<div className="flex-c"></div>
<!-- 等同于下面这段 -->
<div className="flex justify-center items-center"></div>
```



2. Tailwind CSS

> 小册中对应的 GitHub [代码地址](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsanyuan0704%2Fjuejin-book-vite%2Ftree%2Fmain%2Fother%2Ftailwind-demo)。

首先安装 `tailwindcss` 及其必要的依赖:

```ts
pnpm install -D tailwindcss postcss autoprefixer
```

然后新建两个配置文件`tailwind.config.js`和`postcss.config.js`:

```ts
// tailwind.config.js
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

// postcss.config.js
// 从中你可以看到，Tailwind CSS 的编译能力是通过 PostCSS 插件实现的
// 而 Vite 本身内置了 PostCSS，因此可以通过 PostCSS 配置接入 Tailwind CSS 
// 注意: Vite 配置文件中如果有 PostCSS 配置的情况下会覆盖掉 post.config.js 的内容!
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
```

接着在项目的入口 CSS 中引入必要的样板代码:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

现在，你就可以在项目中安心地使用 Tailwind 样式了，如下所示:

```ts
// App.tsx

import logo from "./logo.svg";
import "./App.css";

function App() {
  return (
    <div>
      <header className="App-header">
        <img src={logo} className="w-20" alt="logo" />
        <p className="bg-red-400">Hello Vite + React!</p>
      </header>
    </div>
  );
}

export default App;
```



























#### 处理静态资源

官网https://cn.vitejs.dev/guide/assets.html#importing-asset-as-url

对于客户端来说，静态资源就是图片、视频这些。对于服务端来说除了要访问数据库的api以外都是静态资源。

##### 图片加载

vite对于图片几乎是开箱即用。

###### 1. 使用场景

在日常的项目开发过程中，我们一般会遇到三种加载图片的场景:

1. 在 HTML 或者 JSX 中，通过 img 标签来加载图片，如:

```html
<img src="../../assets/a.png"></img>
```

2. 在 CSS 中通过 background 属性加载图片，如:

```css
background: url('../../assets/b.png') norepeat;
```

3. 在 JavaScript 中，通过脚本的方式动态指定图片的`src`属性，如:

```ts
document.getElementById('hero-img').src = '../../assets/c.png'
```



###### 2. 在 Vite 中使用

接下来让我们在目前的脚手架项目来进行实际的编码，你可以在 Vite 的配置文件中配置一下别名，方便后续的图片引入:

```ts
// vite.config.ts
import path from 'path';

{
  resolve: {
    // 别名配置
    alias: {
      '@assets': path.join(__dirname, 'src/assets')
    }
  }
}
```

alias 别名配置不仅在 JavaScript 的 import 语句中生效，在 CSS 代码的 `@import` 和 `url`导入语句中也同样生效。



###### 3. SVG 组件方式加载

刚才我们成功地在 Vite 中实现了图片的加载，上述这些加载的方式对于 svg 格式来说依然是适用的。不过，我们通常也希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性。

SVG 组件加载在不同的前端框架中的实现不太相同，社区中也已经了有了对应的插件支持:

- Vue2 项目中可以使用 [vite-plugin-vue2-svg](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpakholeung37%2Fvite-plugin-vue2-svg)插件。
- Vue3 项目中可以引入 [vite-svg-loader](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjpkleemans%2Fvite-svg-loader)。
- React 项目使用 [vite-plugin-svgr](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fpd4d10%2Fvite-plugin-svgr)插件。

现在让我们在 React 脚手架项目中安装对应的依赖:

```ts
pnpm i vite-plugin-svgr -D
```

然后需要在 vite 配置文件添加这个插件:

```ts
// vite.config.ts
import svgr from 'vite-plugin-svgr';

{
  plugins: [
    // 其它插件省略
    svgr()
  ]
}
```

随后注意要在 `tsconfig.json` 添加如下配置，否则会有类型错误:

```json
{
  "compilerOptions": {
    // 省略其它配置
    "types": ["vite-plugin-svgr/client"]
  }
}
```

接下来让我们在项目中使用 svg 组件:

```ts
import { ReactComponent as ReactLogo } from '@assets/icons/logo.svg';

export function Header() {
  return (
    // 其他组件内容省略
     <ReactLogo />
  )
}
```



##### JSON 加载

Vite 中已经内置了对于 JSON 文件的解析，底层使用`@rollup/pluginutils` 的 `dataToEsm` 方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块，使用姿势如下:

```ts
import { version } from '../../../package.json';
```

不过你也可以在配置文件禁用按名导入的方式:

```ts
// vite.config.ts

{
  json: {
    stringify: true
  }
}
```

这样会将 JSON 的内容解析为`export default JSON.parse("xxx")`，这样会失去`按名导出`的能力，不过在 JSON 数据量比较大的时候，可以优化解析性能。

##### Web Worker 脚本

Vite 中使用 Web Worker 也非常简单，我们可以在新建`Header/example.js`文件:

```js
const start = () => {
  let count = 0;
  setInterval(() => {
    // 给主线程传值
    postMessage(++count);
  }, 2000);
};

start();
```

然后在 Header 组件中引入，引入的时候注意加上`?worker`后缀，相当于告诉 Vite 这是一个 Web Worker 脚本文件:

```ts
import Worker from './example.js?worker';
// 1. 初始化 Worker 实例
const worker = new Worker();
// 2. 主线程监听 worker 的信息
worker.addEventListener('message', (e) => {
  console.log(e);
});
```



##### Web Assembly 文件

Vite 对于 `.wasm` 文件也提供了开箱即用的支持，预编译的 `.wasm` 文件可以通过 `?init` 来导入。默认导出一个初始化函数，返回值为所导出 wasm 实例对象的 Promise：

```
import init from './example.wasm?init'

init().then((instance) => {
  instance.exports.test()
})
```

`init` 函数还可以将传递给 `WebAssembly.instantiate` 的导入对象作为其第二个参数：

```
init({
  imports: {
    someFunc: () => {
      /* ... */
    },
  },
}).then(() => {
  /* ... */
})
```

在生产构建当中，体积小于 `assetInlineLimit` 的 `.wasm` 文件将会被内联为 base64 字符串。否则，它们将作为资源复制到 `dist` 目录中，并按需获取。



##### 其它静态资源

除了上述的一些资源格式，Vite 也对下面几类格式提供了内置的支持:

- 媒体类文件，包括`mp4`、`webm`、`ogg`、`mp3`、`wav`、`flac`和`aac`。
- 字体类文件。包括`woff`、`woff2`、`eot`、`ttf` 和 `otf`。
- 文本类。包括`webmanifest`、`pdf`和`txt`。

也就是说，你可以在 Vite 将这些类型的文件当做一个 ES 模块来导入使用。如果你的项目中还存在其它格式的静态资源，你可以通过`assetsInclude`配置让 Vite 来支持加载:

```ts
// vite.config.ts

{
  assetsInclude: ['.gltf']
}
```

##### 特殊资源后缀

Vite 中引入静态资源时，也支持在路径最后加上一些特殊的 query 后缀，包括:

- `?url`: 表示获取资源的路径，这在只想获取文件路径而不是内容的场景将会很有用。（默认就是这种方式）
- `?raw`: 表示将指定的 JavaScript 文件以纯文本的形式导入到当前的模块。这意味着文件内容不会被当作 JavaScript 代码进行解析，而是以字符串的形式传递给接收的变量 。
- `?inline`: 表示资源强制内联，而不是打包成单独的文件。





##### 生产环境处理

在生产环境下，我们又面临着一些新的问题。

###### 1. 自定义部署域名

一般在我们访问线上的站点时，站点里面一些静态资源的地址都包含了相应域名的前缀，如:

```html
<img src="https://sanyuan.cos.ap-beijing.myqcloud.com/logo.png" />
```

以上面这个地址例子，`https://sanyuan.cos.ap-beijing.myqcloud.com`是 CDN 地址前缀，`/logo.png`则是我们开发阶段使用的路径。那么，我们是不是需要在上线前把图片先上传到 CDN，然后将代码中的地址手动替换成线上地址呢？这样就太麻烦了！

在 Vite 中我们可以有更加自动化的方式来实现地址的替换，只需要在配置文件中指定`base`参数即可:

```ts
// vite.config.ts
// 是否为生产环境，在生产环境一般会注入 NODE_ENV 这个环境变量，见下面的环境变量文件配置
const isProduction = process.env.NODE_ENV === 'production';
// 填入项目的 CDN 域名地址
const CDN_URL = 'xxxxxx';

// 具体配置
{
  base: isProduction ? CDN_URL: '/'
}

// .env.development
NODE_ENV=development

// .env.production
NODE_ENV=production
```

注意在项目根目录新增的两个环境变量文件`.env.development`和`.env.production`，顾名思义，即分别在开发环境和生产环境注入一些环境变量，这里为了区分不同环境我们加上了`NODE_ENV`，你也可以根据需要添加别的环境变量。

> 打包的时候 Vite 会自动将这些环境变量替换为相应的字符串。

接着执行`pnpm run build`，可以发现产物中的静态资源地址已经自动加上了 CDN 地址前缀，当然，HTML 中的一些 JS、CSS 资源链接也一起加上了 CDN 地址前缀:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15adeface82d4320b330b440c049f3ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

当然，有时候可能项目中的某些图片需要存放到另外的存储服务，一种直接的方案是将完整地址写死到 src 属性中，如:

```ts
<img src="https://my-image-cdn.com/logo.png">
```

这样做显然是不太优雅的，我们可以通过定义环境变量的方式来解决这个问题，在项目根目录新增`.env`文件:

```ts
// 开发环境优先级: .env.development > .env
// 生产环境优先级: .env.production > .env
// .env 文件
VITE_IMG_BASE_URL=https://my-image-cdn.com
```

然后进入 `src/vite-env.d.ts`增加类型声明:

```ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string;
  // 自定义的环境变量
  readonly VITE_IMG_BASE_URL: string;
}

interface ImportMeta {
  readonly env: ImportMetaEnv;
}
```

值得注意的是，如果某个环境变量要在 Vite 中通过 `import.meta.env` 访问，那么它必须以`VITE_`开头，如`VITE_IMG_BASE_URL`。接下来我们在组件中来使用这个环境变量:

```html
<img src={new URL('./logo.png', import.meta.env.VITE_IMG_BASE_URL).href} />
```

接下来在`开发环境`启动项目或者`生产环境`打包后可以看到环境变量已经被替换，地址能够正常显示:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40484ed4df404b87b40b104cf2b9fdee~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6c4637475bb49818c9c5dd09001bb66~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



###### 2. 单文件 or 内联？

在 Vite 中，所有的静态资源都有两种构建方式，一种是打包成一个单文件，另一种是通过 base64 编码的格式内嵌到代码中。

对于比较小的资源，适合内联到代码中，一方面对`代码体积`的影响很小，另一方面可以减少不必要的网络请求，`优化网络性能`。而对于比较大的资源，就推荐单独打包成一个文件，而不是内联了，否则可能导致上 MB 的 base64 字符串内嵌到代码中，导致代码体积瞬间庞大，页面加载性能直线下降。

Vite 中内置的优化方案是下面这样的:

- 如果静态资源体积 >= 4KB，则提取成单独的文件
- 如果静态资源体积 < 4KB，则作为 base64 格式的字符串内联

上述的`4 KB`即为提取成单文件的临界值，当然，这个临界值你可以通过`build.assetsInlineLimit`自行配置，如下代码所示:

```ts
// vite.config.ts
{
  build: {
    // 8 KB
    assetsInlineLimit: 8 * 1024
  }
}
```

> svg 格式的文件不受这个临时值的影响，始终会打包成单独的文件，因为它和普通格式的图片不一样，需要动态设置一些属性

###### 3. 图片压缩

图片资源的体积往往是项目产物体积的大头，如果能尽可能精简图片的体积，那么对项目整体打包产物体积的优化将会是非常明显的。在 JavaScript 领域有一个非常知名的图片压缩库[imagemin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fimagemin)，作为一个底层的压缩工具，前端的项目中经常基于它来进行图片压缩，比如 Webpack 中大名鼎鼎的`image-webpack-loader`。社区当中也已经有了开箱即用的 Vite 插件——`vite-plugin-imagemin`，首先让我们来安装它:

```ts
pnpm i vite-plugin-imagemin -D
```

随后在 Vite 配置文件中引入:

```ts
//vite.config.ts
import viteImagemin from 'vite-plugin-imagemin';

{
  plugins: [
    // 忽略前面的插件
    viteImagemin({
      // 无损压缩配置，无损压缩下图片质量不会变差
      optipng: {
        optimizationLevel: 7
      },
      // 有损压缩配置，有损压缩下图片质量可能会变差
      pngquant: {
        quality: [0.8, 0.9],
      },
      // svg 优化
      svgo: {
        plugins: [
          {
            name: 'removeViewBox'
          },
          {
            name: 'removeEmptyAttrs',
            active: false
          }
        ]
      }
    })
  ]
}
```



###### 4. 雪碧图优化

在实际的项目中我们还会经常用到各种各样的 svg 图标，虽然 svg 文件一般体积不大，但 Vite 中对于 svg 文件会始终打包成单文件，大量的图标引入之后会导致网络请求增加，大量的 HTTP 请求会导致网络解析耗时变长，页面加载性能直接受到影响。这个问题怎么解决呢？

> HTTP2 的多路复用设计可以解决大量 HTTP 的请求导致的网络加载性能问题，因此雪碧图技术在 HTTP2 并没有明显的优化效果，这个技术更适合在传统的 HTTP 1.1 场景下使用(比如本地的 Dev Server)。

比如在 Header 中分别引入 5 个 svg 文件:

```ts
import Logo1 from '@assets/icons/logo-1.svg';
import Logo2 from '@assets/icons/logo-2.svg';
import Logo3 from '@assets/icons/logo-3.svg';
import Logo4 from '@assets/icons/logo-4.svg';
import Logo5 from '@assets/icons/logo-5.svg';
```

这里顺便说一句，Vite 中提供了`import.meta.glob`的语法糖来解决这种**批量导入**的问题，如上述的 import 语句可以写成下面这样:

```ts
const icons = import.meta.glob('../../assets/icons/logo-*.svg');
```

结果如下:

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb4489676ca341689048f9595a8f0fae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以看到对象的 value 都是动态 import，适合按需加载的场景。在这里我们只需要同步加载即可，可以使用 `import.meta.globEager`来完成:

```ts
const icons = import.meta.globEager('../../assets/icons/logo-*.svg');
```

`icons`的结果打印如下: ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/038367c43dad4c399e3d00597ae852e3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

接下来我们稍作解析，然后将 svg 应用到组件当中:

```ts
// Header/index.tsx
const iconUrls = Object.values(icons).map(mod => mod.default);

// 组件返回内容添加如下
{iconUrls.map((item) => (
  <img src={item} key={item} width="50" alt="" />
))}
```

回到页面中，我们发现浏览器分别发出了 5 个 svg 的请求:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3646903dde814c6c8cb7097b93f98667~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

合并图标的方案也叫`雪碧图`，我们可以通过`vite-plugin-svg-icons`来实现这个方案，首先安装一下这个插件:

```ts
pnpm i vite-plugin-svg-icons -D
```

接着在 Vite 配置文件中增加如下内容:

```ts
// vite.config.ts
import { createSvgIconsPlugin } from 'vite-plugin-svg-icons';

{
  plugins: [
    // 省略其它插件
    createSvgIconsPlugin({
      iconDirs: [path.join(__dirname, 'src/assets/icons')]
    })
  ]
}
```

在 `src/components`目录下新建`SvgIcon`组件:

```ts
// SvgIcon/index.tsx
export interface SvgIconProps {
  name?: string;
  prefix: string;
  color: string;
  [key: string]: string;
}

export default function SvgIcon({
  name,
  prefix = 'icon',
  color = '#333',
  ...props
}: SvgIconProps) {
  const symbolId = `#${prefix}-${name}`;

  return (
    <svg {...props} aria-hidden="true">
      <use href={symbolId} fill={color} />
    </svg>
  );
}
```

现在我们回到 Header 组件中，稍作修改:

```ts
// index.tsx
const icons = import.meta.globEager('../../assets/icons/logo-*.svg');
const iconUrls = Object.values(icons).map((mod) => {
  // 如 ../../assets/icons/logo-1.svg -> logo-1
  const fileName = mod.default.split('/').pop();
  const [svgName] = fileName.split('.');
  return svgName;
});

// 渲染 svg 组件
{iconUrls.map((item) => (
  <SvgIcon name={item} key={item} width="50" height="50" />
))}
```

最后在`src/main.tsx`文件中添加一行代码:

```ts
import 'virtual:svg-icons-register';
```

现在回到浏览器的页面中，发现雪碧图已经生成:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37cb9d4403594a35a1c8c999d536d80c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

雪碧图包含了所有图标的具体内容，而对于页面每个具体的图标，则通过 `use` 属性来引用雪碧图的对应内容:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/17497a3a9abe40d2a5145bca8d2041f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

如此一来，我们就能将所有的 svg 内容都内联到 HTML 中，省去了大量 svg 的网络请求。





#### 处理ts

vite他天生就可以转换ts, 因为vite在开发时态是基于esbuild, 而esbuild是天生支持对ts文件的转换的。



vite不会对ts文件进行类型检查，想要执行类型检查再打包可以这样配置

```
"script":{
	"build": tsc --noEmit && vite build
}
```





#### vite接入 ESLint

除了安装编辑器插件，我们也可以通过 Vite 插件的方式在开发阶段进行 ESLint 扫描，以命令行的方式展示出代码中的规范问题，并能够直接定位到原文件。

首先我们安装 Vite 中的 ESLint 插件:

```ts
pnpm i vite-plugin-eslint -D
```

然后在 `vite.config.ts` 中接入:

```ts
// vite.config.ts
import viteEslint from 'vite-plugin-eslint';

// 具体配置
{
  plugins: [
    // 省略其它插件
    viteEslint(),
  ]
}
```

现在你可以试着重新启动项目， ESLint 的错误已经能够及时显示到命令行窗口中了。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe73069469414debbef973c6a9f0f8ae~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 由于这个插件采用另一个进程来运行 ESLint 的扫描工作，因此不会影响 Vite 项目的启动速度。



#### 写jsx/tsx

##### 安装

```js
yarn add @vitejs/plugin-vue-jsx
复制代码
```

**or**

```js
npm install @vitejs/plugin-vue-jsx -D
复制代码
```

##### 配置

**在 `vite.config.ts` 文件中挂载**

```ts
import vueJsx from '@vitejs/plugin-vue-jsx'
export default defineConfig({
 plugins: [ vueJsx()]
})
复制代码
```

**`tsconfig.json` 文件中**

```json
{
  // include 需要包含tsx
"include": ["src/*", "src/**/*.vue", "src/**/*.tsx", "src/**/*.jsx", "src/**/*.ts", "src/**/*.js"],
 "compilerOptions": {
    // 在.tsx文件里支持JSX
    "jsx": "preserve",
 }
}
复制代码
```

##### 使用

###### 新建**.tsx

```js
// index.tsx
export default definedComponents({
  setup(props){
    return ()=>(
      <div>
      Hello,World
      </div>
    )
  }
})
```

###### 新建**.vue

**不需要`template`。`script`上加`lang='tsx'`**

```js
<script lang="tsx">
import { defineComponent } from 'vue'
export default defineComponent({
  setup() {
    return () => <div>Hello,World</div>
  }
})
</script>

```







#### 预构建(重复预构建会导致页面反复刷新)

##### 自定义配置详解

Vite 将预构建相关的配置项都集中在`optimizeDeps`属性上，我们来一一拆解这些子配置项背后的含义和应用场景。

###### 入口文件——entries

第一个是参数是`optimizeDeps.entries`，通过这个参数你可以自定义预构建的入口文件。

实际上，在项目第一次启动时，Vite 会默认抓取项目中所有的 HTML 文件，将 HTML 文件作为应用入口，然后根据入口文件扫描出项目中用到的第三方依赖，最后对这些依赖逐个进行编译。

那么，当默认扫描 HTML 文件的行为无法满足需求的时候，比如项目入口为`vue`格式文件时，你可以通过 entries 参数来配置:

```ts
// vite.config.ts
{
  optimizeDeps: {
    // 为一个字符串数组
    entries: ["./src/main.vue"];
  }
}
```

当然，entries 配置也支持 [glob 语法](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fmrmlnc%2Ffast-glob)，非常灵活，如:

```ts
// 将所有的 .vue 文件作为扫描入口
entries: ["**/*.vue"];
```

不光是`.vue`文件，Vite 同时还支持各种格式的入口，包括: `html`、`svelte`、`astro`、`js`、`jsx`、`ts`和`tsx`。可以看到，只要可能存在`import`语句的地方，Vite 都可以解析，并通过内置的扫描机制搜集到项目中用到的依赖，通用性很强。

###### 添加一些依赖——include

除了 `entries`，`include` 也是一个很常用的配置，它决定了可以强制预构建的依赖项，使用方式很简单:

```ts
// vite.config.ts
optimizeDeps: {
  // 配置为一个字符串数组，将 `lodash-es` 和 `vue`两个包强制进行预构建
  include: ["lodash-es", "vue"];
}
```

它在使用上并不难，真正难的地方在于，如何找到合适它的使用场景。前文中我们提到，Vite 会根据应用入口(`entries`)自动搜集依赖，然后进行预构建，某些情况下 Vite 默认的扫描行为并不能百分百准确地搜集到所有的依赖，这就需要联合配置`include`来达到完美的预构建效果了。接下来，我们好好梳理一下到底有哪些需要配置`include`的场景。

###### 场景一: 动态 import

在某些动态 import 的场景下，由于 Vite 天然按需加载的特性，经常会导致某些依赖只能在运行时被识别出来。

```ts
// src/locales/zh_CN.js
import objectAssign from "object-assign";
console.log(objectAssign);

// main.tsx
const importModule = (m) => import(`./locales/${m}.ts`);
importModule("zh_CN");
```

在这个例子中，动态 import 的路径只有运行时才能确定，无法在预构建阶段被扫描出来。因此，我们在访问项目时控制台会出现下面的日志信息:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/595857912ca34a2d8ad45086313209e5~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这段 log 的意思是: Vite 运行时发现了新的依赖，随之重新进行依赖预构建，并刷新页面。这个过程也叫**二次预构建**。在一些比较复杂的项目中，这个过程会执行很多次，如下面的日志信息所示:

```java
[vite] new dependencies found: @material-ui/icons/Dehaze, @material-ui/core/Box, @material-ui/core/Checkbox, updating...
[vite] ✨ dependencies updated, reloading page...
[vite] new dependencies found: @material-ui/core/Dialog, @material-ui/core/DialogActions, updating...
[vite] ✨ dependencies updated, reloading page...
[vite] new dependencies found: @material-ui/core/Accordion, @material-ui/core/AccordionSummary, updating...
[vite] ✨ dependencies updated, reloading page...
```

然而，二次预构建的成本也比较大。我们不仅需要把预构建的流程重新运行一遍，还得重新刷新页面，并且需要重新请求所有的模块。尤其是在大型项目中，这个过程会严重拖慢应用的加载速度！因此，我们要尽力避免运行时的**二次预构建**。具体怎么做呢？你可以通过`include`参数提前声明需要按需加载的依赖:

```ts
// vite.config.ts
{
  optimizeDeps: {
    include: [
      // 按需加载的依赖都可以声明到这个数组里
      "object-assign",
    ];
  }
}
```

###### 场景二: 某些包被手动 exclude

`exclude` 是`optimizeDeps`中的另一个配置项，与`include`相对，用于将某些依赖从预构建的过程中排除。不过这个配置并不常用，也不推荐大家使用。如果真遇到了要在预构建中排除某个包的情况，需要注意`它所依赖的包`是否具有 ESM 格式，如下面这个例子:

```ts
// vite.config.ts
{
  optimizeDeps: {
    exclude: ["@loadable/component"];
  }
}
```

可以看到浏览器控制台会出现如下的报错:

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e72fecff62ec477686aeb539ee66aa4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这是为什么呢? 我们刚刚手动 exclude 的包`@loadable/component`本身具有 ESM 格式的产物，但它的某个依赖`hoist-non-react-statics`的产物并没有提供 ESM 格式，导致运行时加载失败。

这个时候`include`配置就派上用场了，我们可以强制对`hoist-non-react-statics`这个间接依赖进行预构建:

```ts
// vite.config.ts
{
  optimizeDeps: {
    include: [
      // 间接依赖的声明语法，通过`>`分开, 如`a > b`表示 a 中依赖的 b
      "@loadable/component > hoist-non-react-statics",
    ];
  }
}
```

在`include`参数中，我们将所有不具备 ESM 格式产物包都声明一遍，这样再次启动项目就没有问题了。

##### 自定义 Esbuild 行为

Vite 提供了`esbuildOptions` 参数来让我们自定义 Esbuild 本身的配置，常用的场景是加入一些 Esbuild 插件:

```ts
// vite.config.ts
{
  optimizeDeps: {
    esbuildOptions: {
       plugins: [
        // 加入 Esbuild 插件
      ];
    }
  }
}
```

###### 特殊情况: 第三方包出现问题怎么办？

由于我们无法保证第三方包的代码质量，在某些情况下我们会遇到莫名的第三方库报错。我举一个常见的案例——`react-virtualized`库。这个库被许多组件库用到，但它的 ESM 格式产物有明显的问题，在 Vite 进行预构建的时候会直接抛出这个错误：

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c20f1531d19f40d197b18e1949523829~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

原因是这个库的 ES 产物莫名其妙多出了一行无用的代码:

```js
// WindowScroller.js 并没有导出这个模块
import { bpfrpt_proptype_WindowScroller } from "../WindowScroller.js";
```

其实我们并不需要这行代码，但它却导致 Esbuild 预构建的时候直接报错退出了。那这一类的问题如何解决呢？

###### 1. 改第三方库代码

首先，我们能想到的思路是**直接修改第三方库的代码**，不过这会带来团队协作的问题，你的改动需要同步到团队所有成员，比较麻烦。

好在，我们可以使用`patch-package`这个库来解决这类问题。一方面，它能记录第三方库代码的改动，另一方面也能将改动同步到团队每个成员。

`patch-package` 官方只支持 npm 和 yarn，而不支持 pnpm，不过社区中已经提供了支持`pnpm`的版本，这里我们来安装一下相应的包:

```bash
pnpm i @milahu/patch-package -D
```

> 注意: 要改动的包在 package.json 中必须声明确定的版本，不能有`~`或者`^`的前缀。

接着，我们进入第三方库的代码中进行修改，先删掉无用的 import 语句，再在命令行输入:

```bash
npx patch-package react-virtualized
```

现在根目录会多出`patches`目录记录第三方包内容的更改，随后我们在`package.json`的`scripts`中增加如下内容：

```json
{
  "scripts": {
    // 省略其它 script
    "postinstall": "patch-package"
  }
}
```

这样一来，每次安装依赖的时候都会通过 `postinstall` 脚本自动应用 patches 的修改，解决了团队协作的问题。

###### 2. 加入 Esbuild 插件

第二种方式是通过 Esbuild 插件修改指定模块的内容，这里我给大家展示一下新增的配置内容:

> 关于 Esbuild 插件的实现细节，大家不用深究，我们将在**底层双引擎**的部分给大家展开介绍

```js
// vite.config.ts
const esbuildPatchPlugin = {
  name: "react-virtualized-patch",
  setup(build) {
    build.onLoad(
      {
        filter:
          /react-virtualized\/dist\/es\/WindowScroller\/utils\/onScroll.js$/,
      },
      async (args) => {
        const text = await fs.promises.readFile(args.path, "utf8");

        return {
          contents: text.replace(
            'import { bpfrpt_proptype_WindowScroller } from "../WindowScroller.js";',
            ""
          ),
        };
      }
    );
  },
};

// 插件加入 Vite 预构建配置
{
  optimizeDeps: {
    esbuildOptions: {
      plugins: [esbuildPatchPlugin];
    }
  }
}
```



##### 手动启动项目

少数场景下我们不希望用本地的缓存文件，比如需要调试某个包的预构建结果，我推荐使用下面任意一种方法清除缓存:

1. 删除`node_modules/.vite`目录。
2. 在 Vite 配置文件中，将`server.force`设为`true`。(注意，Vite 3.0 中配置项有所更新，你需要将 `optimizeDeps.force` 设为`true`)
3. 命令行执行`npx vite --force`或者`npx vite optimize`。

> Vite 项目的启动可以分为两步，第一步是依赖预构建，第二步才是 Dev Server 的启动，`npx vite optimize`相比于其它的方案，仅仅完成第一步的功能。



### 使用

#### `@fs/` 前缀

用于引用在项目外部的模块时。

```
例如：import something from '@fs/some/external/module.js'
`@fs/` 前缀 用于告诉 Vite，它应该在文件系统中查找 `some/external/module.js` （你可以理解成这个路径会被视为绝对路径）
```





### 深入 HMR API

#### 简介

Vite 作为一个完整的构建工具，本身实现了一套 HMR 系统，这套 HMR 系统基于原生的 ESM 模块规范来实现，在文件发生改变时 Vite 会侦测到相应 ES 模块的变化，从而触发相应的 API，实现局部的更新。

Vite 的 HMR API 设计基于一套完整的 [ESM HMR 规范](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwithastro%2Fesm-hmr)来实现，这个规范由同时期的 no-bundle 构建工具 Snowpack、WMR 与 Vite 一起制定，是一个比较通用的规范。

我们可以直观地来看一看 HMR API 的类型定义:

```ts
interface ImportMeta {
  readonly hot?: {
    readonly data: any
    accept(): void
    accept(cb: (mod: any) => void): void
    accept(dep: string, cb: (mod: any) => void): void
    accept(deps: string[], cb: (mods: any[]) => void): void
    prune(cb: () => void): void
    dispose(cb: (data: any) => void): void
    decline(): void
    invalidate(): void
    on(event: string, cb: (...args: any[]) => void): void
  }
}
```

这里稍微解释一下，`import.meta`对象为现代浏览器原生的一个内置对象，Vite 所做的事情就是在这个对象上的 `hot` 属性中定义了一套完整的属性和方法。因此，在 Vite 当中，你就可以通过`import.meta.hot`来访问关于 HMR 的这些属性和方法，比如`import.meta.hot.accept()`。接下来，我们就来一一熟悉这些 API 的使用方式。

#### 模块更新时逻辑: hot.accept

在 `import.meta.hot` 对象上有一个非常关键的方法`accept`，因为它决定了 Vite 进行热更新的边界。

从字面上来看，它表示接受的意思。没错，它就是用来**接受模块更新**的。 一旦 Vite 接受了这个更新，当前模块就会被认为是 HMR 的边界。那么，Vite 接受谁的更新呢？这里会有三种情况：

- 接受**自身模块**的更新
- 接受**某个子模块**的更新
- 接受**多个子模块**的更新

这三种情况分别对应 accept 方法三种不同的使用方式。

##### **1. 接受自身更新**

当模块接受自身的更新时，则当前模块会被认为 HMR 的边界。也就是说，除了当前模块，其他的模块均未受到任何影响。下面是我准备的一张示例图，你可以参考一下：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b518a7964444dbe8d12c177b3ed59c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

为了加深你的理解，这里我们以一个实际的例子来操练一下。这个例子已经放到了 [Github 仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsanyuan0704%2Fjuejin-book-vite%2Ftree%2Fmain%2F13-hmr-api) 中，你可以把这个链接克隆到本地，然后跟着我一步步添加内容。首先展示一下整体的目录结构:

```css
.
├── favicon.svg
├── index.html
├── node_modules
│   └── ...
├── package.json
├── src
│   ├── main.ts
│   ├── render.ts
│   ├── state.ts
│   ├── style.css
│   └── vite-env.d.ts
└── tsconfig.json
```

这里我放出一些关键文件的内容，如下面的 `index.html`：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <p>
      count: <span id="count">0</span>
    </p>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
```

里面的 DOM 结构比较简单，同时引入了 `/src/main.ts` 这个文件，内容如下:

```ts
import { render } from './render';
import { initState } from './state';
render();
initState();
```

文件依赖了`render.ts`和`state.ts`，前者负责渲染文本内容，而后者负责记录当前的页面状态:

```ts
// src/render.ts
// 负责渲染文本内容
import './style.css'
export const render = () => {
  const app = document.querySelector<HTMLDivElement>('#app')!
  app.innerHTML = `
    <h1>Hello Vite!</h1>
    <p target="_blank">This is hmr test.123</p>
  `
}
// src/state.ts
// 负责记录当前的页面状态
export function initState() {
  let count = 0;
  setInterval(() => {
    let countEle = document.getElementById('count');
    countEle!.innerText =  ++count + '';
  }, 1000);
}
```

好了，仓库当中关键的代码就目前这些了。现在，你可以执行`pnpm i`安装依赖，然后`npm run dev`启动项目，在浏览器访问可以看到这样的内容:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a3165aa161147fabcd3a41a5cda1a1c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

同时，每隔一秒钟，你可以看到这里的`count`值会加一。OK，现在你可以试着改动一下 `render.ts` 的渲染内容，比如增加一些文本:

```diff
// render.ts
export const render = () => {
  const app = document.querySelector<HTMLDivElement>('#app')!
  app.innerHTML = `
    <h1>Hello Vite!</h1>
+   <p target="_blank">This is hmr test.123 这是增加的文本</p>
  `
}
```

效果如下所示:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd3ce3fb51d4c47b1f157075c6fc141~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

页面的渲染内容是更新了，但不知道你有没有注意到最下面的`count`值瞬间被置零了，并且查看控制台，也有这样的 log：

```css
[vite] page reload src/render.ts
```

很明显，当 `render.ts` 模块发生变更时，Vite 发现并没有 HMR 相关的处理，然后直接刷新页面了。

现在让我们在`render.ts`中加上如下的代码:

```diff
// 条件守卫
+ if (import.meta.hot) {
+  import.meta.hot.accept((mod) => mod.render())
+ }
```

`import.meta.hot`对象只有在开发阶段才会被注入到全局，生产环境是访问不到的，另外增加条件守卫之后，打包时识别到 if 条件不成立，会自动把这部分代码从打包产物中移除，来优化资源体积。因此，我们需要增加这个条件守卫语句。

接下来，可以注意到我们对于 `import.meta.hot.accept`的使用:

```javascript
import.meta.hot.accept((mod) => mod.render())
```

这里我们传入了一个回调函数作为参数，入参即为 Vite 给我们提供的更新后的模块内容，在浏览器中打印`mod`内容如下，正好是`render`模块最新的内容:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6142727d2162489c9e613341f5e4ca5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们在回调中调用了一下 `mod.render` 方法，也就是当模块变动后，每次都重新渲染一遍内容。这时你可以试着改动一下渲染的内容，然后到浏览器中注意一下`count`的情况，并没有被重新置零，而是保留了原有的状态:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/51fbe46db84f4d82ba073d8d8f0ec2fd~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

没错，现在 `render` 模块更新后，只会重新渲染这个模块的内容，而对于 state 模块的内容并没有影响，并且控制台的 log 也发生了变化:

```css
[vite] hmr update /src/render.ts
```

现在我们算是实现了初步的 HMR，也在实际的代码中体会到了 accept 方法的用途。当然，在这个例子中我们传入了一个回调函数来手动调用 render 逻辑，但事实上你也可以什么参数都不传，这样 Vite 只会把 `render`模块的最新内容执行一遍，但 `render` 模块内部只声明了一个函数，因此直接调用`import.meta.hot.accept()`并不会重新渲染页面。

##### **2. 接受依赖模块的更新**

先给大家放一张原理图，直观地感受一下:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2309dff1019c40a1a1e5d072f3ed0dd3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

还是拿示例项目来举例，`main`模块依赖`render` 模块，也就是说，`main`模块是`render`父模块，那么我们也可以在 `main` 模块中接受`render`模块的更新，此时 HMR 边界就是`main`模块了。

我们将 `render`模块的 accept 相关代码先删除:

```diff
// render.ts
- if (import.meta.hot) {
-   import.meta.hot.accept((mod) => mod.render())
- }
```

然后再`main`模块增加如下代码:

```diff
// main.ts
import { render } from './render';
import './state';
render();
+if (import.meta.hot) {
+  import.meta.hot.accept('./render.ts', (newModule) => {
+    newModule.render();
+  })
+}
```

在这里我们同样是调用 accept 方法，与之前不同的是，第一个参数传入一个依赖的路径，也就是`render`模块的路径，这就相当于告诉 Vite: 我监听了 `render` 模块的更新，当它的内容更新的时候，请把最新的内容传给我。同样的，第二个参数中定义了模块变化后的回调函数，这里拿到了 `render` 模块最新的内容，然后执行其中的渲染逻辑，让页面展示最新的内容。

通过接受一个依赖模块的更新，我们同样又实现了 HMR 功能，你可以试着改动 `render`模块的内容，可以发现页面内容正常更新，并且状态依然保持着原样。

##### **3. 接受多个子模块的更新**

接下来是最后一种 accept 的情况——接受多个子模块的更新。有了上面两种情况的铺垫，这里再来理解第三种情况就容易多了，我依然先给出原理示意图:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3449473d985b42668d8628a726ae871a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这里的意思是**父模块可以接受多个子模块的更新，当其中任何一个子模块更新之后，父模块会成为 HMR 边界**。还是拿之前的例子来演示，现在我们更改`main`模块代码:

```javascript
// main.ts
import { render } from './render';
import { initState } from './state';
render();
initState();
+if (import.meta.hot) {
+  import.meta.hot.accept(['./render.ts', './state.ts'], (modules) => {
+    console.log(modules);
+  })
+}
```

在代码中我们通过 accept 方法接受了`render`和`state`两个模块的更新，接着让我们手动改动一下某一个模块的代码，观察一下回调中`modules`的打印内容。例如当我改动 `state`模块的内容时，回调中拿到的 modules 是这样的:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7e66edd02b3456fa45c47fd44bc2eb3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

可以看到 Vite 给我们的回调传来的参数`modules`其实是一个数组，和我们第一个参数声明的子模块数组一一对应。因此`modules`数组第一个元素是 `undefined`，表示`render`模块并没有发生变化，第二个元素为一个 Module 对象，也就是经过变动后`state`模块的最新内容。于是在这里，我们根据 `modules` 进行自定义的更新，修改 `main.ts`:

```ts
// main.ts
import { render } from './render';
import { initState } from './state';
render();
initState();
if (import.meta.hot) {
  import.meta.hot.accept(['./render.ts', './state.ts'], (modules) => {
    // 自定义更新
    const [renderModule, stateModule] = modules;
    if (renderModule) {
      renderModule.render();
    }
    if (stateModule) {
      stateModule.initState();
    }
  })
}
```

现在，你可以改动两个模块的内容，可以发现，页面的相应模块会更新，并且对其它的模块没有影响。但实际上你会发现另外一个问题，当改动了`state`模块的内容之后，页面的内容会变得错乱:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1628e31f424d4089ad9c891c8e739ebe~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这是为什么呢？

我们快速回顾一下 `state`模块的内容:

```ts
// state.ts
export function initState() {
  let count = 0;
  setInterval(() => {
    let countEle = document.getElementById('count');
    countEle!.innerText =  ++count + '';
  }, 1000);
}
```

其中设置了一个定时器，但当模块更改之后，这个定时器并没有被销毁，紧接着我们在 accept 方法调用 `initState` 方法又创建了一个新的定时器，导致 count 的值错乱。那如何来解决这个问题呢？这就涉及到新的 HMR 方法——`dispose`方法了。

#### 模块销毁时逻辑: hot.dispose

这个方法相较而言就好理解多了，代表在模块更新、旧模块需要销毁时需要做的一些事情，拿刚刚的场景来说，我们可以通过在`state`模块中调用 dispose 方法来轻松解决定时器共存的问题，代码改动如下:

```ts
// state.ts
let timer: number | undefined;
if (import.meta.hot) {
  import.meta.hot.dispose(() => {
    if (timer) {
      clearInterval(timer);
    }
  })
}
export function initState() {
  let count = 0;
  timer = setInterval(() => {
    let countEle = document.getElementById('count');
    countEle!.innerText =  ++count + '';
  }, 1000);
}
```

此时，我们再来到浏览器观察一下 HMR 的效果:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206543cbd39241aabea49c189740ec7e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

可以看到，当我稍稍改动一下`state`模块的内容(比如加个空格)，页面确实会更新，而且也没有状态错乱的问题，说明我们在模块销毁前清除定时器的操作是生效的。但你又可以很明显地看到一个新的问题: 原来的状态丢失了，`count`的内容从`64`突然变成`1`。这又是为什么呢？

让我们来重新梳理一遍热更新的逻辑:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c72ca8f5cff463ba75a862f4a14f5e9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

当我们改动了`state`模块的代码，`main`模块接受更新，执行 accept 方法中的回调，接着会执行 `state` 模块的`initState`方法。注意了，此时新建的 `initState` 方法的确会初始化定时器，但同时也会初始化 count 变量，也就是`count`从 0 开始计数了！

这显然是不符合预期的，我们期望的是每次改动`state`模块，之前的状态都保存下来。怎么来实现呢？

#### 共享数据: hot.data 属性

这就不得不提到 hot 对象上的 data 属性了，这个属性用来在不同的模块实例间共享一些数据。使用上也非常简单，让我们来重构一下 `state` 模块:

```diff
let timer: number | undefined;
if (import.meta.hot) {
+  // 初始化 count
+  if (!import.meta.hot.data.count) {
+    import.meta.hot.data.count = 0;
+  }
  import.meta.hot.dispose(() => {
    if (timer) {
      clearInterval(timer);
    }
  })
}
export function initState() {
+  const getAndIncCount = () => {
+    const data = import.meta.hot?.data || {
+      count: 0
+    };
+    data.count = data.count + 1;
+    return data.count;
+  };
  timer = setInterval(() => {
    let countEle = document.getElementById('count');
+    countEle!.innerText =  getAndIncCount() + '';
  }, 1000);
}
```

我们在 `import.meta.hot.data` 对象上挂载了一个`count` 属性，在二次执行`initState`的时候便会复用 `import.meta.hot.data` 上记录的 count 值，从而实现状态的保存。

此时，我们终于大功告成，基本实现了这个示例应用的 HMR 的功能。在这个过程中，我们用到了核心的`accept`、`dispose` 和`data`属性和方法。当然还有一些方法将会给大家进行介绍，但相较而言就比较简单了，而且用的也不多，大家只需要留下初步的印象，知道这些方法的用途是什么，需要用到的时候再来查阅即可。

#### 其它方法

**1. import.meta.hot.decline()**

这个方法调用之后，相当于表示此模块不可热更新，当模块更新时会强制进行页面刷新。感兴趣的同学可以继续拿上面的例子来尝试一下。

**2. import.meta.hot.invalidate()**

这个方法就更简单了，只是用来强制刷新页面。

**3. 自定义事件**

你还可以通过 `import.meta.hot.on` 来监听 HMR 的自定义事件，内部有这么几个事件会自动触发:

- `vite:beforeUpdate` 当模块更新时触发；
- `vite:beforeFullReload` 当即将重新刷新页面时触发；
- `vite:beforePrune` 当不再需要的模块即将被剔除时触发；
- `vite:error` 当发生错误时（例如，语法错误）触发。

如果你想自定义事件可以通过上节中提到的 `handleHotUpdate` 这个插件 Hook 来进行触发:

```ts
// 插件 Hook
handleHotUpdate({ server }) {
  server.ws.send({
    type: 'custom',
    event: 'custom-update',
    data: {}
  })
  return []
}
// 前端代码
import.meta.hot.on('custom-update', (data) => {
  // 自定义更新逻辑
})
```















### 打包Rollup

#### vite中配置

```ts
export default defineConfig({
  build:{
    rollupOptions:{
        ......
    }
  }
});
```



#### 常用配置解读

##### 1. 多产物配置

在打包 JavaScript 类库的场景中，我们通常需要对外暴露出不同格式的产物供他人使用，不仅包括 `ESM`，也需要包括诸如`CommonJS`、`UMD`等格式，保证良好的兼容性。那么，同一份入口文件，如何让 Rollup 给我们打包出不一样格式的产物呢？我们基于上述的配置文件来进行修改:

```js
// rollup.config.js
/**
 * @type { import('rollup').RollupOptions }
 */
const buildOptions = {
  input: ["src/index.js"],
  // 将 output 改造成一个数组
  output: [
    {
      dir: "dist/es",
      format: "esm",
    },
    {
      dir: "dist/cjs",
      format: "cjs",
    },
  ],
};

export default buildOptions;
```

从代码中可以看到，我们将`output`属性配置成一个数组，数组中每个元素都是一个描述对象，决定了不同产物的输出行为。

##### 2. 多入口配置

除了多产物配置，Rollup 中也支持多入口配置，而且通常情况下两者会被结合起来使用。接下来，就让我们继续改造之前的配置文件，将 `input` 设置为一个数组或者一个对象，如下所示:

```js
{
  input: ["src/index.js", "src/util.js"]
}
// 或者
{
  input: {
    index: "src/index.js",
    util: "src/util.js",
  },
}
```

如果不同入口对应的打包配置不一样，我们也可以默认导出一个`配置数组`，如下所示:

```js
// rollup.config.js
/**
 * @type { import('rollup').RollupOptions }
 */
const buildIndexOptions = {
  input: ["src/index.js"],
  output: [
    // 省略 output 配置
  ],
};

/**
 * @type { import('rollup').RollupOptions }
 */
const buildUtilOptions = {
  input: ["src/util.js"],
  output: [
    // 省略 output 配置
  ],
};

export default [buildIndexOptions, buildUtilOptions];
```

如果是比较复杂的打包场景(如 [Vite 源码本身的打包](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fmain%2Fpackages%2Fvite%2Frollup.config.js))，我们需要将项目的代码分成几个部分，用不同的 Rollup 配置分别打包，这种配置就很有用了。

##### 3. 自定义`output`配置

刚才我们提到了`input`的使用，主要用来声明入口，可以配置成字符串、数组或者对象，使用比较简单。而`output`与之相对，用来配置输出的相关信息，常用的配置项如下:

```js
output: {
  // 产物输出目录
  dir: path.resolve(__dirname, 'dist'),
  // 以下三个配置项都可以使用这些占位符:
  // 1. [name]: 去除文件后缀后的文件名
  // 2. [hash]: 根据文件名和文件内容生成的 hash 值
  // 3. [format]: 产物模块格式，如 es、cjs
  // 4. [extname]: 产物后缀名(带`.`)
  // 入口模块的输出文件名
  entryFileNames: `[name].js`,
  // 非入口模块(如动态 import)的输出文件名
  chunkFileNames: 'chunk-[hash].js',
  // 静态资源文件输出文件名
  assetFileNames: 'assets/[name]-[hash][extname]',
  // 产物输出格式，包括`amd`、`cjs`、`es`、`iife`、`umd`、`system`
  format: 'cjs',
  // 是否生成 sourcemap 文件
  sourcemap: true,
  // 如果是打包出 iife/umd 格式，需要对外暴露出一个全局变量，通过 name 配置变量名
  name: 'MyBundle',
  // 全局变量声明
  globals: {
    // 项目中可以直接用`$`代替`jquery`
    jquery: '$'
  }
}
```

##### 4. 依赖 external

对于某些第三方包，有时候我们不想让 Rollup 进行打包，也可以通过 external 进行外部化:

```ts
{
  external: ['react', 'react-dom']
}
```

在 SSR 构建或者使用 ESM CDN 的场景中，这个配置将非常有用，具体细节我们会在**高级应用**这一章展开。

##### 5. 接入插件能力

###### 举例

虽然 Rollup 能够打包`输出`出 `CommonJS` 格式的产物，但对于`输入`给 Rollup 的代码并不支持 CommonJS，仅仅支持 ESM。目前为止，还是有不少第三方依赖只有 CommonJS 格式产物而并未提供 ESM 产物，比如项目中用到 `lodash` 时，打包项目会出现这样的报错：

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05d69896d9fe438bad7d1ffa7922c842~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?) 因此，我们需要引入额外的插件去解决这个问题。

首先需要安装两个核心的插件包:

```js
pnpm i @rollup/plugin-node-resolve @rollup/plugin-commonjs 
```

- `@rollup/plugin-node-resolve`是为了允许我们加载第三方依赖，否则像`import React from 'react'` 的依赖导入语句将不会被 Rollup 识别。
- `@rollup/plugin-commonjs` 的作用是将 CommonJS 格式的代码转换为 ESM 格式

然后让我们在配置文件中导入这些插件:

```js
// rollup.config.js
import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";

/**
 * @type { import('rollup').RollupOptions }
 */
export default {
  input: ["src/index.js"],
  output: [
    {
      dir: "dist/es",
      format: "esm",
    },
    {
      dir: "dist/cjs",
      format: "cjs",
    },
  ],
  // 通过 plugins 参数添加插件
  plugins: [resolve(), commonjs()],
};
```

现在我们以`lodash`这个只有 CommonJS 产物的第三方包为例测试一下:

```js
pnpm i lodash
```

在 `src/index.js` 加入如下的代码:

```js
import { merge } from "lodash";
console.log(merge);
```

然后执行 `npm run build`，你可以发现产物已经正常生成了:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93d76ca19ce941a5b803ad367bdffa54~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



###### 配置

在 Rollup 配置文件中，`plugins`除了可以与 `output` 配置在同一级，也可以配置在 output 参数里面，如:

```js
// rollup.config.js
import { terser } from 'rollup-plugin-terser'
import resolve from "@rollup/plugin-node-resolve";
import commonjs from "@rollup/plugin-commonjs";

export default {
  output: {
    // 加入 terser 插件，用来压缩代码
    plugins: [terser()]
  },
  plugins: [resolve(), commonjs()]
}
```

> 当然，你可以将上述的 terser 插件放到最外层的 `plugins` 配置中。

需要注意的是，`output.plugins`中配置的插件是有一定限制的，只有使用`Output 阶段`相关钩子(具体内容将在下一节展开)的插件才能够放到这个配置中，大家可以去[这个站点](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fawesome%23output)查看 Rollup 的 Output 插件列表。



###### 比较常用的 Rollup 插件库

- [@rollup/plugin-json](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fjson)： 支持`.json`的加载，并配合`rollup`的`Tree Shaking`机制去掉未使用的部分，进行按需打包。
- [@rollup/plugin-babel](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fbabel)：在 Rollup 中使用 Babel 进行 JS 代码的语法转译。
- [@rollup/plugin-typescript](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Ftypescript): 支持使用 TypeScript 开发。
- [@rollup/plugin-alias](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Falias)：支持别名配置。
- [@rollup/plugin-replace](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Freplace)：在 Rollup 进行变量字符串的替换。
- [rollup-plugin-visualizer](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbtd%2Frollup-plugin-visualizer): 对 Rollup 打包产物进行分析，自动生成产物体积可视化分析图。





#### JavaScript API 方式调用

有些场景下我们需要基于 Rollup 定制一些打包过程，配置文件就不够灵活了，这时候我们需要用到对应 JavaScript API 来调用 Rollup，主要分为`rollup.rollup`和`rollup.watch`两个 API，接下来我们以具体的例子来学习一下。

##### 首先是 `rollup.rollup`

用来一次性地进行 Rollup 打包，你可以新建`build.js`，内容如下:

```js
// build.js
const rollup = require("rollup");

// 常用 inputOptions 配置
const inputOptions = {
  input: "./src/index.js",
  external: [],
  plugins:[]
};

const outputOptionsList = [
  // 常用 outputOptions 配置
  {
    dir: 'dist/es',
    entryFileNames: `[name].[hash].js`,
    chunkFileNames: 'chunk-[hash].js',
    assetFileNames: 'assets/[name]-[hash][extname]',
    format: 'es',
    sourcemap: true,
    globals: {
      lodash: '_'
    }
  }
  // 省略其它的输出配置
];

async function build() {
  let bundle;
  let buildFailed = false;
  try {
    // 1. 调用 rollup.rollup 生成 bundle 对象
    bundle = await rollup.rollup(inputOptions);
    for (const outputOptions of outputOptionsList) {
      // 2. 拿到 bundle 对象，根据每一份输出配置，调用 generate 和 write 方法分别生成和写入产物
      const { output } = await bundle.generate(outputOptions);
      await bundle.write(outputOptions);
    }
  } catch (error) {
    buildFailed = true;
    console.error(error);
  }
  if (bundle) {
    // 最后调用 bundle.close 方法结束打包
    await bundle.close();
  }
  process.exit(buildFailed ? 1 : 0);
}

build();
```

主要的执行步骤如下:

- 通过 `rollup.rollup`方法，传入 `inputOptions`，生成 bundle 对象；
- 调用 bundle 对象的 generate 和 write 方法，传入`outputOptions`，分别完成产物和生成和磁盘写入。
- 调用 bundle 对象的 close 方法来结束打包。

接着你可以执行`node build.js`，这样，我们就可以完成了以编程的方式来调用 Rollup 打包的过程。

##### `rollup.watch`来完成`watch`模式下的打包

即每次源文件变动后自动进行重新打包。你可以新建`watch.js`文件，内容入下:

```js
// watch.js
const rollup = require("rollup");

const watcher = rollup.watch({
  // 和 rollup 配置文件中的属性基本一致，只不过多了`watch`配置
  input: "./src/index.js",
  output: [
    {
      dir: "dist/es",
      format: "esm",
    },
    {
      dir: "dist/cjs",
      format: "cjs",
    },
  ],
  watch: {
    exclude: ["node_modules/**"],
    include: ["src/**"],
  },
});

// 监听 watch 各种事件
watcher.on("restart", () => {
  console.log("重新构建...");
});

watcher.on("change", (id) => {
  console.log("发生变动的模块id: ", id);
});

watcher.on("event", (e) => {
  if (e.code === "BUNDLE_END") {
    console.log("打包信息:", e);
  }
});
```

现在你可以通过执行`node watch.js`开启 Rollup 的 watch 打包模式，当你改动一个文件后可以看到如下的日志，说明 Rollup 自动进行了重新打包，并触发相应的事件回调函数:

```js
发生生变动的模块id: /xxx/src/index.js
重新构建...
打包信息: {
  code: 'BUNDLE_END',
  duration: 10,
  input: './src/index.js',
  output: [
    // 输出产物路径
  ],
  result: {
    cache: { /* 产物具体信息 */ },
    close: [AsyncFunction: close],
    closed: false,
    generate: [AsyncFunction: generate],
    watchFiles: [
      // 监听文件列表
    ],
    write: [AsyncFunction: write]
  }
}
```

基于如上的两个 JavaScript API 我们可以很方便地在代码中调用 Rollup 的打包流程，相比于配置文件有了更多的操作空间，你可以在代码中通过这些 API 对 Rollup 打包过程进行定制，甚至是二次开发。















#### 分包策略

##### Vite 默认拆包策略

Vite 中已经内置了一份拆包的策略。

一方面 Vite 实现了自动 **CSS 代码分割**的能力，即实现一个 chunk 对应一个 css 文件，比如index.js`对应一份`index.css`，而按需加载的 chunk `Danamic.js`也对应单独的一份`Danamic.css`文件，与 JS 文件的代码分割同理，这样做也能提升 CSS 文件的缓存复用率。

另一方面， Vite 基于 Rollup 的`manualChunks`API 实现了`应用拆包`的策略:

- 首页应用代码及其用到的第三方依赖都打包到 `index.js` 中且其它页面用到这部分依赖的话不会再打包这部分依赖。
- 对于 `Async Chunk` 而言 ，动态 import 的代码会被拆分成单独的 chunk，如上述的`Dynacmic`组件。
- 动态加载的二级页面都用了某个依赖，那这部分依赖会提取到一个bundle里



##### 自定义拆包策略

针对更细粒度的拆包，Vite 的底层打包引擎 Rollup 提供了`manualChunks`，让我们能自定义拆包策略，它属于 Vite 配置的一部分，`manualChunks` 主要有两种配置的形式，可以配置为一个对象或者一个函数。

###### 对象的配置

在对象格式的配置中，`key`代表 chunk 的名称，`value`为一个字符串数组，每一项为第三方包的包名。

```ts
// vite.config.ts
{
  build: {
    rollupOptions: {
      output: {
        // manualChunks 配置
        manualChunks: {
          // 将 React 相关库打包成单独的 chunk 中
          'react-vendor': ['react', 'react-dom'],
          // 将 Lodash 库的代码单独打包
          'lodash': ['lodash-es'],
          // 将组件库的代码打包
          'library': ['antd', '@arco-design/web-react'],
        },
      },
    }
  },
}
```

###### 函数的配置

而 Vite 中的默认拆包策略也是通过函数的方式来进行配置的，我们可以在 Vite 的实现中瞧一瞧:

```ts
// Vite 部分源码
function createMoveToVendorChunkFn(config: ResolvedConfig): GetManualChunk {
  const cache = new Map<string, boolean>()
  // 返回值为 manualChunks 的配置
  return (id, { getModuleInfo }) => {
    // Vite 默认的配置逻辑其实很简单
    // 主要是为了把 Initial Chunk 中的第三方包代码单独打包成`vendor.[hash].js`
    if (
      id.includes('node_modules') &&
      !isCSSRequest(id) &&
      // 判断是否为 Initial Chunk
      staticImportedByEntry(id, getModuleInfo, cache)
    ) {
      return 'vendor'
    }
  }
}
```

Rollup 会对每一个模块调用 manualChunks 函数，在 manualChunks 的函数入参中你可以拿到`模块 id` 及`模块详情信息`，经过一定的处理后返回 `chunk 文件的名称`，这样当前 id 代表的模块便会打包到你所指定的 chunk 文件中。

我们现在来试着把刚才的拆包逻辑用函数来实现一遍:

```ts
manualChunks(id) {
  if (id.includes('antd') || id.includes('@arco-design/web-react')) {
    return 'library';
  }
  if (id.includes('lodash')) {
    return 'lodash';
  }
  if (id.includes('react')) {
    return 'react';
  }
}
```

打包后结果如下:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3495634bb0284597bfcdc071fbf27d45~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

看上去好像各个第三方包的 chunk (如`lodash`、`react`等等)都能拆分出来，但实际上你可以运行 `npx vite preview` 预览产物，会发现产物根本没有办法运行起来，页面出现白屏，同时控制台出现如下的报错:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f4250e42ed9445b985cb8c539f69694e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

这也就是函数配置的坑点所在了，虽然灵活而方便，但稍不注意就陷入此类的产物错误问题当中。那上面的这个报错究竟是什么原因导致的呢？

###### 解决循环引用问题

从报错信息追溯到产物中，可以发现`react-vendor.js`与`index.js`发生了循环引用:

```ts
// react-vendor.e2c4883f.js
import { q as objectAssign } from "./index.37a7b2eb.js";

// index.37a7b2eb.js
import { R as React } from "./react-vendor.e2c4883f.js";
```

这是很典型的 ES 模块循环引用的场景，我们可以用一个最基本的例子来复原这个场景:

```ts
// a.js
import { funcB } from './b.js';

funcB();

export var funcA = () => {
  console.log('a');
} 
// b.js
import { funcA } from './a.js';

funcA();

export var funcB = () => {
  console.log('b')
}
```

接着我们可以执行一下`a.js`文件:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
</head>
<body>
  <script type="module" src="/a.js"></script>
</body>
</html>
```

在浏览器中打开会出现类似的报错:

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f71a39e22848419aac513906df7d39bb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

代码的执行原理如下:

- JS 引擎执行 `a.js` 时，发现引入了 `b.js`，于是去执行 `b.js`
- 引擎执行`b.js`，发现里面引入了`a.js`(出现循环引用)，认为`a.js`已经加载完成，继续往下执行
- 执行到`funcA()`语句时发现 funcA 并没有定义，于是报错。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee8c028b04564b95a093720ac9c3f60b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

而对于如上打包产物的执行过程也是同理:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f640e0e85e64bd7b20bb2f1ca47f2a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可能你会有疑问: `react-vendor`为什么需要引用`index.js`的代码呢？其实也很好理解，我们之前在`manualChunks`中仅仅将路径包含 `react` 的模块打包到`react-vendor`中，殊不知，像`object-assign`这种 react 本身的依赖并没有打包进`react-vendor`中，而是打包到另外的 chunk 当中，从而导致如下的循环依赖关系:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec3419b5b2f8410cbefd332e1e7224b2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

那我们能不能避免这种问题呢？当然是可以的，之前的 `manualChunks`逻辑过于简单粗暴，仅仅通过路径 id 来决定打包到哪个 chunk 中，而漏掉了间接依赖的情况。如果针对像`object-assign`这种间接依赖，我们也能识别出它属于 react 的依赖，将其自动打包到`react-vendor`中，这样就可以避免循环引用的问题。

我们来梳理一下解决的思路:

- 1. 确定 react 相关包的入口路径。
- 1. 在 manualChunks 中拿到模块的详细信息，向上追溯它的引用者，如果命中 react 的路径，则将模块放到 `react-vendor`中。

接下来让我们进行实际代码的实现:

```ts
// 确定 react 相关包的入口路径
const chunkGroups = {
  'react-vendor': [
    require.resolve('react'),
    require.resolve('react-dom')
  ],
}

// Vite 中的 manualChunks 配置
function manualChunks(id, { getModuleInfo }) { 
  for (const group of Object.keys(chunkGroups)) {
    const deps = chunkGroups[group];
    if (
      id.includes('node_modules') && 
      // 递归向上查找引用者，检查是否命中 chunkGroups 声明的包 
      isDepInclude(id, deps, [], getModuleInfo)
     ) { 
      return group;
    }
  }
}
```

实际上核心逻辑包含在`isDepInclude`函数，用来递归向上查找引用者模块:

```ts
// 缓存对象
const cache = new Map();

function isDepInclude (id: string, depPaths: string[], importChain: string[], getModuleInfo): boolean | undefined  {
  const key = `${id}-${depPaths.join('|')}`;
  // 出现循环依赖，不考虑
  if (importChain.includes(id)) {
    cache.set(key, false);
    return false;
  }
  // 验证缓存
  if (cache.has(key)) {
    return cache.get(key);
  }
  // 命中依赖列表
  if (depPaths.includes(id)) {
    // 引用链中的文件都记录到缓存中
    importChain.forEach(item => cache.set(`${item}-${depPaths.join('|')}`, true));
    return true;
  }
  const moduleInfo = getModuleInfo(id);
  if (!moduleInfo || !moduleInfo.importers) {
    cache.set(key, false);
    return false;
  }
  // 核心逻辑，递归查找上层引用者
  const isInclude = moduleInfo.importers.some(
    importer => isDepInclude(importer, depPaths, importChain.concat(id), getModuleInfo)
  );
  // 设置缓存
  cache.set(key, isInclude);
  return isInclude;
};
```

对于这个函数的实现，有两个地方需要大家注意:

- 1. 我们可以通过 manualChunks 提供的入参`getModuleInfo`来获取模块的详情`moduleInfo`，然后通过`moduleInfo.importers`拿到模块的引用者，针对每个引用者又可以递归地执行这一过程，从而获取引用链的信息。
- 1. 尽量使用缓存。由于第三方包模块数量一般比较多，对每个模块都向上查找一遍引用链会导致开销非常大，并且会产生很多重复的逻辑，使用缓存会极大加速这一过程。

完成上述`manualChunks`的完整逻辑后，现在我们来执行`npm run build`来进行打包:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4f6b899bd274e92bdda466d4d9165fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

可以发现`react-vendor`可以正常拆分出来，查看它的内容:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8484e9fb9ef040c98bb161c7e225d02a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

从中你可以看出`react`的一些间接依赖已经成功打包到了`react-vendor`当中

###### 终极解决方案

尽管上述的解决方案已经能帮我们正常进行产物拆包，但从实现上来看，还是显得略微繁琐，那么有没有开箱即用的拆包方案，能让我们直接用到项目中呢？

答案是肯定的，接下来我就给大家介绍 Vite 自定义拆包的终极解决方案——`vite-plugin-chunk-split`。

首先安装一下这个插件:

```ts
pnpm i vite-plugin-chunk-split -D
```

然后你可以在项目中引入并使用:

```ts
// vite.config.ts
import { chunkSplitPlugin } from 'vite-plugin-chunk-split';

export default {
  plugins:[
      chunkSplitPlugin({
    // 指定拆包策略
    customSplitting: {
      // 1. 支持填包名。`react` 和 `react-dom` 会被打包到一个名为`render-vendor`的 chunk 里面(包括它们的依赖，如 object-assign)
      'react-vendor': ['react', 'react-dom'],
      // 2. 支持填正则表达式。src 中 components 和 utils 下的所有文件被会被打包为`component-util`的 chunk 中
      'components-util': [/src\/components/, /src\/utils/]
    }
  })
  ]
}
```

相比于手动操作依赖关系，使用插件只需几行配置就能完成，非常方便。当然，这个插件还可以支持多种打包策略，包括 unbundle 模式打包，你可以去 [使用文档](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsanyuan0704%2Fvite-plugin-chunk-split%2Fblob%2Fmaster%2FREADME-CN.md) 探索更多使用姿势。





#### 压缩

##### JavaScript 压缩

在 Vite 生产环境构建的过程中，JavaScript 产物代码会自动进行压缩，相关的配置参数如下:

```ts
// vite.config.ts
export default {
  build: {
    // 类型: boolean | 'esbuild' | 'terser'
    // 默认为 `esbuild`
    minify: 'esbuild',
    // 产物目标环境
    target: 'modules',
    // 如果 minify 为 terser，可以通过下面的参数配置具体行为
    // https://terser.org/docs/api-reference#minify-options
    terserOptions: {}
  }
}
```

值得注意的是`target`参数，也就是压缩产物的目标环境。Vite 默认的参数是`modules`，即如下的 browserlist:

```ts
['es2019', 'edge88', 'firefox78', 'chrome87', 'safari13.1']
```

可能你会有疑问，既然是压缩代码，为什么还跟目标环境有关系呢？

其实，对于 JS 代码压缩的理解仅仅停留在去除空行、混淆变量名的层面是不够的，为了达到极致的压缩效果，压缩器一般会根据浏览器的目标，会对代码进行语法层面的转换，比如下面这个例子:

```ts
// 业务代码中
info == null ? undefined : info.name
```

如果你将 `target` 配置为`exnext`，也就是最新的 JS 语法，会发现压缩后的代码变成了下面这样:

```ts
info?.name
```

这就是压缩工具在背后所做的事情，将某些语句识别之后转换成更高级的语法，从而达到更优的代码体积。

因此，设置合适的 `target` 就显得特别重要了，一旦目标环境的设置不能覆盖所有的用户群体，那么极有可能在某些低端浏览器中出现语法不兼容问题，从而发生**线上事故**。

笔者曾在生产环境中就见过这种情况，由于 Vite 默认的 target 无法覆盖所有支持原生 ESM 的浏览器，经过压缩器的语法转换后，在某些 iOS 机型(iOS 11.2)上出现白屏事故，最后通过指定 target 为 `es2015` 或者`es6` 解决了这个问题。

因此，为了线上的稳定性，推荐大家最好还是将 target 参数设置为`ECMA`语法的最低版本`es2015`/`es6`。

##### CSS 压缩

对于 CSS 代码的压缩，Vite 中的相关配置如下:

```ts
// vite.config.ts
export default {
  build: {
    // 设置 CSS 的目标环境
    cssTarget: ''
  }
}
```

默认情况下 Vite 会使用 Esbuild 对 CSS 代码进行压缩，一般不需要我们对 `cssTarget` 进行配置。

不过在需要兼容安卓端微信的 webview 时，我们需要将 `build.cssTarget` 设置为 `chrome61`，以防止 vite 将 `rgba()` 颜色转化为 `#RGBA` 十六进制符号的形式，出现样式问题。





##### gzip

有插件 比如 vite-plugin-conpression，具体配置看文档。

这里只能打包出gzip(.gz后缀)文件，还需要后端配合返回这个文件给你并且设置一个响应头 content-encoding：gzip，然后浏览器就会解压（如果文件不是很大就不用压缩，因为浏览器解压是需要时间的）



#### cdn

有插件 比如 vite-plugin-cdn-import



#### 配置

```js
export default defineConfig({
    build: {
        rollupOptions: { // 配置rollup的一些构建策略
          	input:{ //多入口
              main: path.resolve(__dirname,"./index.html"),
              product:path.resolve(__dirname,"./prod.html")
            }
            output: { // 控制输出
                // 在rollup里面, hash代表将你的文件名和文件内容进行组合计算得来的结果
                assetFileNames: "[hash].[name].[ext]",
          			manualChunks:(id) =>{
      						if(id.includes("node_modules")){ //node_modules 打包成一个包
  									return "vendor"
									}
    						}
            }
        },
        assetsInlineLimit: 4096000, // 小于4000kb的图片就转换成base64 字符直接放在你引用这张图片的文件中
        outDir: "dist", // 定义打包输出的目录名
        assetsDir: "static", //定义打包输出的静态文件目录名
        emptyOutDir: true, // 打包前清除输出目录中的所有文件
				minify:false, //是否对代码进行压缩
    },
    plugins:[
      viteCompression() //打包出gzip(.gz后缀)文件，后端返回这个文件给你并且设置一个响应头 content-encoding：gzip，然后浏览器就会解压（如果文件不是很大就不用压缩，因为浏览器解压是需要时间的）
    ]
});
```



##### 打包成库

需要配置【导出模块类型】并确定导出的文件名。配置如下:

vite.config.ts

```php
const rollupOptions = {

  external: ["vue", "vue-router"],
  output: {
    globals: {
      vue: "Vue",
    },
  },
};

export default defineConfig({

  .....  

  // 添加库模式配置

  build: {
    rollupOptions,
    minify:false,
    lib: {
      entry: "./src/entry.ts",
      name: "SmartyUI",
      fileName: "smarty-ui",
      // 导出模块格式
      formats: ["esm", "umd","iife"],
    },
  },
});
```

接着添加一个 npm 运行脚本，方便运行。

package.json

```json
  "scripts": {
    "build": "vite build"
  },
```



### 原理

#### 打包相关

##### vite的默认分包

首页和首页用到的依赖都打包进主包。在其他页面再用到这个依赖就不会被打包了，index.html会请求这个主包。

测试一下二级页面比如a和b都用了某个依赖，则这个依赖会怎么打包，



##### 确定打包入口

```js
const input = libOptions
    ? options.rollupOptions?.input ||
      (typeof libOptions.entry === 'string'
        ? resolve(libOptions.entry)
        : Array.isArray(libOptions.entry)
        ? libOptions.entry.map(resolve)
        : Object.fromEntries(
            Object.entries(libOptions.entry).map(([alias, file]) => [
              alias,
              resolve(file),
            ]),
          ))
    : typeof options.ssr === 'string'
    ? resolve(options.ssr)
    : options.rollupOptions?.input || resolve('index.html')
```









#### **vite热更新的实现**

在创建httpserver的同时，会创建一个websocket server。同时通过`chokidar`创建一个watcher，监听文件的变化。当文件发生变化时，通过websocket发送消息给client，客户端收到消息，进行相关的处理。

![image-20230427205403653](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-27-20-54-image-20230427205403653.png)

#### alias的原理

大致就是将vite.config.js配置别名里的path的路径先裁剪掉用户文件里写的相对路径处理之后的前面部分（如果用户有在别名之后用了相对路径的话 如 `@/../../lo.js`），然后再在文件里用裁剪剩余的部分替换掉 别名和相对路径部分 。最后变成一个绝对路径。

[没看懂点击这](https://www.bilibili.com/video/BV1GN4y1M7P5?p=18&vd_source=0b12706181dace1502b9c644984e8c2c)

```js
module.exports = function(aliasConf, JSContent) {
    const entires = Object.entries(aliasConf);
    let lastContent = JSContent;
    entires.forEach(entire => {
        const [alia, path] = entire;
        // 会做path的相对路径的处理
        const srcIndex = path.indexOf("/src");// 这里只考虑相对路径处理之后就是src，官方的方式去找相对路径的话更加复杂
        // alias别名最终做的事情就是一个字符串替换
        const realPath = path.slice(srcIndex, path.length);
        lastContent = JSContent.replace(alia, realPath);

    })
    return lastContent;
}
```

rollup里的alias插件的代码简化如下：

```ts
export default alias(options) {
  // 获取 entries 配置
  const entries = getEntries(options);
  return {
    // 传入三个参数，当前模块路径、引用当前模块的模块路径、其余参数
    resolveId(importee, importer, resolveOptions) {
      // 先检查能不能匹配别名规则
      const matchedEntry = entries.find((entry) => matches(entry.find, importee));
      // 如果不能匹配替换规则，或者当前模块是入口模块，则不会继续后面的别名替换流程
      if (!matchedEntry || !importerId) {
        // return null 后，当前的模块路径会交给下一个插件处理
        return null;
      }
      // 正式替换路径
      const updatedId = normalizeId(
        importee.replace(matchedEntry.find, matchedEntry.replacement)
      );
      // 每个插件执行时都会绑定一个上下文对象作为 this
      // 这里的 this.resolve 会执行所有插件(除当前插件外)的 resolveId 钩子
      return this.resolve(
        updatedId,
        importer,
        Object.assign({ skipSelf: true }, resolveOptions)
      ).then((resolved) => {
        // 替换后的路径即 updateId 会经过别的插件进行处理
        let finalResult: PartialResolvedId | null = resolved;
        if (!finalResult) {
          // 如果其它插件没有处理这个路径，则直接返回 updateId
          finalResult = { id: updatedId };
        }
        return finalResult;
      });
    }
  }
}
```



### vitejs/plugin-legacy

#### 主流程

`@vitejs/plugin-legacy`插件的工作原理主要包括以下几个步骤：

1.  **生成Legacy模块**：在[`legacyPostPlugin`](packages/plugin-legacy/src/index.ts#L300-L628)的`renderChunk`方法中，对每个模块通过`@babel/preset-env`进行转换，生成对应的legacy模块。这些legacy模块会进行转换，以便能在旧版浏览器中运行，并以SystemJS模块的形式输出。这样做的好处是，即使在旧版浏览器中，也能支持代码分割。
2.  **生成Polyfill模块**：在[`legacyGenerateBundlePlugin`](packages/plugin-legacy/src/index.ts#L228-L298)的`generateBundle`方法中，生成一个包含SystemJS运行时和必要polyfills的polyfill模块。这些polyfills是根据指定的浏览器目标和最终打包的代码中实际使用的特性来确定的。
3.  **注入`<script nomodule>`标签**：在[`legacyPostPlugin`](packages/plugin-legacy/src/index.ts#L300-L628)的`transformIndexHtml`方法中，为生成的HTML注入`<script nomodule>`标签，以便在不支持现代JavaScript特性的浏览器中有条件地加载polyfills和legacy模块。
4.  **注入`import.meta.env.LEGACY`环境变量**：在legacyConfigPlugin的`config`方法中，注入`import.meta.env.LEGACY`环境变量，该变量只在legacy生产构建中为`true`，在所有其他情况下为`false`。改写build.target。

这些步骤是通过在Vite的不同生命周期中执行不同的任务来实现的。例如，[`legacyConfigPlugin`](packages/plugin-legacy/src/index.ts#L182-L226)在配置阶段修改Vite的构建目标，以便生成适合旧版浏览器的代码；[`legacyGenerateBundlePlugin`](packages/plugin-legacy/src/index.ts#L228-L298)在生成bundle阶段，根据需要生成polyfill模块；[`legacyPostPlugin`](packages/plugin-legacy/src/index.ts#L300-L628)在后处理阶段，对每个模块进行转换，生成对应的legacy模块，并在生成的HTML中注入`<script nomodule>`标签。

#### 入口**viteLegacyPlugin**方法

整合传入的配置然后初始化一些值

最终返回这三个插件  `return [legacyConfigPlugin, legacyGenerateBundlePlugin, legacyPostPlugin]`





#### legacyConfigPlugin

1. 改写build.target。
2. 注入`import.meta.env.LEGACY`环境变量

```js
    config(config2, env) {
      if (env.command === "build" && !config2.build?.ssr) {
        if (!config2.build) {
          config2.build = {};
        }
        if (!config2.build.cssTarget) {
          config2.build.cssTarget = "chrome61";
        }
        if (genLegacy) {
          overriddenBuildTarget = config2.build.target !== void 0;
          config2.build.target = [
            "es2020",
            "edge79",
            "firefox67",
            "chrome64",
            "safari12"
          ];
        }
      }
      return {
        define: {
          "import.meta.env.LEGACY": env.command === "serve" || config2.build?.ssr ? false : legacyEnvVarMarker
        }
      };
    },
```



#### legacyGenerateBundlePlugin

在Vite的`generateBundle`生命周期钩子中生成polyfill模块。

主要工作流程：

1. 它会检查当前的构建是否是legacy构建。isLegacyBundle
2. 如果当前构建不是legacy构建，且存在需要为现代浏览器生成的polyfills，那么它会调用buildPolyfillChunk函数来生成一个包含这些polyfills的模块。
3. 如果当前构建是legacy构建，且配置了需要生成legacy模块，那么它会首先检查目标浏览器是否需要`Promise` polyfill（因为SystemJS依赖于`Promise`），然后调用buildPolyfillChunk函数来生成一个包含SystemJS运行时和所有必要polyfills的模块。

在生成polyfill模块时，`buildPolyfillChunk`函数会使用Vite的`build`函数来构建一个包含所有polyfills的虚拟模块，然后将这个模块添加到构建的输出bundle中。[`buildPolyfillChunk`](packages/plugin-legacy/src/index.ts#L685-L748)函数使用Vite的`build`函数并不是对整个项目源码进行重新构建。它创建了一个包含所有需要的polyfills的虚拟模块，并只对这个虚拟模块进行构建。

在这个过程中，`build`函数接收一个配置对象，其中`root`属性设置为插件文件的目录，`plugins`属性包含一个专门用于生成polyfills的插件，`rollupOptions.input`属性设置为一个包含虚拟模块ID的对象。这样，`build`函数就会只对这个虚拟模块进行构建，而不会触及项目的其他源码。

构建完成后，生成的polyfill模块会被添加到构建的输出bundle中，这样在最终生成的代码中就可以包含这些polyfills了。

















### vite--ssg

#### 原理

##### 一些第三方依赖

使用jsdom获得web api，jsdom 是许多网络标准（尤其是 WHATWG DOM 和 HTML 标准）的纯 JavaScript 实现，可与 Node.js 配合使用。

`class **CookieJar** extends **toughCookie**.**CookieJar` 操作 cookie

通过critters 提取首页css。将提取的样式用`<style>`标签添加到 HTML 文档的 `<head>` 中，从而无需发出额外的请求就能获取这些样式。 CSS 的其余部分可以异步加载。

@unhead/vue处理document head

yargs处理命令行交互



##### ViteSSG函数

1. 包装createApp()方法。比如会根据是否在客户端环境中运行来决定使用`createClientApp`还是`createSSRApp`。这个函数还会创建一个路由器，并根据是否在客户端环境中运行来决定使用`createWebHistory`还是`createMemoryHistory`。如果在客户端环境中运行，它会等待文档和路由就绪，然后挂载应用。
2. 如果在客户端，则直接执行包装后的createApp()方法，创建一个客户端应用实例。然后这个应用实例会被挂载到DOM中，开始接管页面的渲染。
3. 如果不是客户端，则将包装后的createApp方法暴露出去，等build for server的时候会用到这个方法，但都没有app.mount这个操作。详情使用看下面第3、4点。



##### build函数

###### 执行步骤

vite-ssg的build里面也还是用vite的build

1. `buildLog('Build for client...')`：先按照 CSR 进行打包，且打包时获取ssr.manifest.js ，ssg也是要CSR的形式部署，只不过利用ssr模式打包出来的内容改善了index.html（其实就是把首页路由的内容插到了index.html里面）。

2. `buildLog('Build for server...')`：再按照ssr模式打包，Vite从你给的入口进去打包用到的应用代码。第二次[`viteBuild`](src/node/build.ts#L87-L107)生成的服务器端代码被保存在`serverEntry`变量中。然后，这个`serverEntry`被import()，就会执行这里面的代码。比如入口文件会执行viteSSG()，viteSSG()方法返回createApp()(vite重写的createApp方法)。

3. server环境vite-ssg源码第一次调用createApp()。用于动态生成路由表，因为有可能路由表是后端返回等动态组成的。

   

4. `  buildLog('Rendering Pages...', routesPaths.length)`：然后进行服务端渲染(SSR)，主要执行了以下步骤：

   1.  创建应用实例：通过调用[`createApp`](src/node/build.ts#L115-L117)函数，默认给每一个一级路由创建一个新的应用实例。
   2.  路由导航：如果存在路由，会通过[`router.push(route)`](src/node/build.ts#L149)和[`router.isReady()`](src/node/build.ts#L150)进行路由导航，确保路由组件被正确地解析和加载。
   3.  渲染应用：使用vue的[`renderToString`](src/node/build.ts#L156)函数将应用实例渲染为HTML字符串。这个函数会触发应用的生命周期钩子函数，并收集应用的依赖模块。然后该字符串会插入到index.html
   4.  插入预加载链接：通过[`renderPreloadLinks`](src/node/build.ts#L170)函数，将当前页面需要的CSS和JavaScript资源插入到HTML中，以优化页面加载性能。
   5.  渲染HTML头部：如果存在`head`对象，会通过[`renderDOMHead`](src/node/build.ts#L173)函数将其渲染到HTML的`<head>`标签中。



>  如果是ssr，ssr是构建一份csr的和一份ssr的，然后根据请求的路径（首页or二级页面都可）实时生成对应的html。相当于vite-ssg build里的Render Pages阶段放到服务端里实时执行，也是用vue的renderToString方法渲染出组件后插入到index.html里，如果你想先ssg构建出带静态部分的html，然后动态的由服务端渲染，比如next就可以这么做。





###### 默认会把每个路由都打包出一个html文件变成多页应用

默认会把每个路由都打包出一个html文件变成多页应用。可以通过**includedRoutes()**方法告诉它要把哪些路由打包成一个html。这个方法要在入口文件(如main.ts)中export出来。

```js
// 获取要处理的路由
let routesPaths = includeAllRoutes // 这个值也是可以在vite.config.ts配置的
    ? routesToPaths(routes) // 这个时内部的犯法
    : await includedRoutes(routesToPaths(routes), routes || [])

// uniq
routesPaths = Array.from(new Set(routesPaths))
  
  
// 对每个路由就是处理
for (const route of routesPaths) {
    queue.add(async () => {})
)
await queue.start().onIdle()
await fs.remove(ssgOut) // 服务端渲染完就删除服务端构建的内容
```



###### 如果开启了要模拟jsDom

vite就会利用jsdom在global里挂载window和document等，这样在node运行时下是可以调用jsdom的。

但是如果vue模版里访问浏览器api是不行的(是vue就不行，跟ssg无关)，因为vite-ssg的build方法里改写index.html时由于会使用vue的**renderToString**，这个方法里面最终会调用ssrRender这个方法，而ssrRender会执行打包后的入口main.mjs里的defineComponent:

```js
const _sfc_main = /* @__PURE__ */ defineComponent({
  setup(__props) {
  ......
    const a = computed(() => window.document);
    watch(
      a,
      () => {
        console.log("window.document", window.document); // 如果vite.config.ts里的ssg配置开启了mock的话，那这里是可以访问到window.document的
      },
      { immediate: true }
    );
    return (_ctx, _push, _parent, _attrs) => {
      ......
      _push(`<h2>${ssrInterpolate(_ctx.window.ducument)}</h2>`); // 这里_ctx里是没有window的，所以直接报错！！！！！！
    };
  }
});
```

在 Vue 模板中直接访问浏览器api，如 `window` 或 `document`，会导致错误。因为 Vue 模板是基于组件实例的数据上下文的，里面并没有浏览器api(从上面打包后的代码就可以看出来)。

在 Vue 模板中，你只能访问以下几种类型的数据：

- 组件的 props
- 组件的 data
- 组件的 computed properties
- 组件的 methods
- JavaScript 的全局对象，如 `Math` 和 `Date`
- Vue 的内置指令，如 `v-if` 和 `v-for`

如果你需要在模板中使用 `window` 或 `document`，你应该在组件的方法或计算属性中进行，并将结果暴露给模板。

例如：

``` javascript
export default {
  computed: {
    title() {
      return document.title;
    }
  }
}
```

然后在模板中这样使用：

``` html
<template>
  <h1>{{ title }}</h1>
</template>
```





##### Q&A

###### 如果首页里有一些依据接口的分支会怎么处理

比如如果接口返回的值是某某就展示a，如果是接口返回的是另一个值我就要展示b，那就按没有这个接口值的情况来处理。比如：

```js
 // HomePage.vue
	<h1 v-if="coinBalance">有{{ coinBalance }}</h1>
        <h1 v-if="coinBalance && coinBalance > 1000">有大于{{ coinBalance }}</h1>
        <h1 v-else-if="coinBalance && coinBalance < 1000">有小于{{ coinBalance }}</h1>
        <h1 v-else>无{{ coinBalance }}</h1>
// 这个ssg打包出来的index.html里就只有 最下面那个 ‘无’
```



###### 为什么要进行一个客户端构建和一个服务器端构建

在SSR应用中，代码在两个环境中运行：在Node.js服务器上（服务器端）和在浏览器中（客户端）。这两个环境有着不同的全局变量、APIs和运行时特性。有些代码只在一个环境中运行。例如，浏览器特定的代码（如操作DOM的代码）只能在客户端构建中运行，而Node.js特定的代码（如文件系统操作的代码）只能在服务器端构建中运行。

1.  **客户端构建**：这个构建版本是为浏览器准备的。它包含了所有的客户端代码，包括与用户交互的代码、DOM操作等。这个构建版本会被浏览器下载并在浏览器中执行。

2.  **服务器端构建**：这个构建版本是为Node.js服务器准备的。它包含了所有的服务器端代码，包括预渲染应用到HTML的代码。这个构建版本会在服务器上执行，执行完就会被删掉。





###### ssr-manifest.json为什么在客户端构建的时候生成

因为它主要包含了客户端构建的信息，例如每个模块的依赖关系，以及每个模块对应的客户端资源文件，以便在服务器端渲染(SSR)过程中使用。

在服务器端渲染(SSR)过程中，`ssr-manifest.json`文件被用于生成预加载链接。具体来说，当一个页面被服务器端渲染时，它会根据`ssr-manifest.json`文件，找出这个页面所依赖的模块（注意⚠️：这里依赖的模块是指依赖的应用代码(js/css)，不是node_modules里的东西），然后生成对应的预加载链接，插入到HTML中。

你可以在[`build`](src/node/build.ts#L29-L225)函数中看到，`ssr-manifest.json`文件是在客户端构建完成后，通过[`fs.readFile`](src/node/build.ts#L134)函数读取的，然后在服务器端渲染(SSR)过程中，通过[`renderPreloadLinks`](src/node/build.ts#L170)函数使用的。

```js
// render current page's preloadLinks
        renderPreloadLinks(jsdom.window.document, ctx.modules || new Set<string>(), ssrManifest)
```





###### 第一个createApp和第二个createApp的作用区别

在`src/node/build.ts`文件中，有两个[`createApp()`](src/node/build.ts#L115)。

1. 第一次调用[`createApp`](src/node/build.ts#L119)是在获取路由信息。以便在后续的服务器端渲染(SSR)过程中，对每个路由进行渲染。如果路由信息并不是静态定义的，而是在应用运行时动态生成的。例如，可能会根据用户的权限、应用的配置、服务器的响应等因素来动态生成路由。此时就可以通过在ViteSSG()里传入一个函数利用各种app、router、请求等信息获得动态的路由表。这个传进去的fn会在viteSSG内部通过await去执行。

   

2. 第二次调用[`createApp`](src/node/build.ts#L145)在一个循环里，是在服务器端渲染(SSR)过程中，对每个路由进行渲染。在这个过程中，会创建一个新的服务器端应用实例，然后使用这个应用实例对当前路由进行渲染，生成静态的HTML。















#### 增长业务里的实践

##### 做法

###### 入口Main-ssg.ts

```js
export const createApp = ViteSSG(App, { base: '/bingo', routes }, ({ app, router, initialState }) => {
    initStore(app, router);
});

export function includedRoutes() {
    return ['/'];
}
```

目前的ssg就只ssg了首页，然后二级页都是加载了首页后通过前端路由转到二级页再csr。所以目前这个方案有个问题：如果直接访问二级页，加载首包慢了就会先看到首页再跳到二级页。（当然我们这没有二级页的入口，所以这个问题没关系）



###### 配置

```json
// vite.config.ts
        ssgOptions: {
            mock: true,
            entry: './src/main-ssg.ts',
        },
```



###### 打包的入口

main.ts是client打包的入口，vite默认的打包入口是index.html，我的index.html里引了main.ts。main.ts里也是`export const createApp = ViteSSG(App)`这种写法，但其实直接写`ViteSSG(APP)`就行，因为`ViteSSG()`这个方法里有这么一段：

```js
async function createApp$1$1(client = false, routePath) {...}  // createApp$1$1这个方法就是包装了vue的createApp
if (isClient) {
    (async () => {
      const { app, router } = await createApp$1$1(true); // *****
      await router.isReady();
      app.mount(rootContainer, true);
    })();
  }
```



main-ssg是server打包的入口，在vite.config.ts里ssgOptions里配置



##### 收益

- - -  SSG 方案全量上线，html end P90 1.3S，页面触达率 94.84%。远超过H5平均触达率88%。

    - 活动曝光次留提升2.2pp；发邀用户提升2.9pp，助力设备提升46.66pp，回流设备提升15pp，发邀率提升6.8pp，视频播放渗透提升6pp，cac降低13pp；

      



#### 增长业务里实践遇到的问题

##### 有的包用到了node运行时没有的api(如浏览器api、yoda api)

解决方法的本质是要让其在node端时不运行。

###### 方案1：使用 conditional import(较好的方法)

本质是让会执行浏览器api的对像变成空。

例如：

```json
// package.json
"imports": {
        "#weblogger": {
            "node": "./node-libs/radar.js", // 在node环境下就引用这个文件，这个文件是自己写的，里面就直接返回一个空对像{}如：`export defalut {}`
            "default": "@ks/weblogger/lib/log.hybrid"
        },
        "#radar": {
            "node": "./node-libs/radar.js",
            "default": "@ks-radar/radar"
        },
        "#launchSdk": {
            "node": "./node-libs/launchSdk.js",
            "default": "@ks-share/share-launch-app"
        }
    },

```







###### **方案2：使用 dynamic import**

这样就会分包，不会打包到首页的包里，所以就不会在server里执行。



###### **方案3：使用依赖注入**

a的内部代码依赖b，如果没了b，a就不行了，但是我现在把b通过参数的方式传给a，而不是让a在其代码内部主动引用b，这样a和b就解偶了。表达的就是一种注入的方式。比如inject也是依赖注入的一种表现。



比如bingo就是通过在客户端的入口main.ts里provide radar （radar会调用浏览器的api）

本质是让会执行浏览器api的对像变成空。

```tsx
export default function useRadar() {
    const radar = inject<Radar>('radar'); // 这样引用雷达，在客户端能正常获取，在server里会返回undefined（因为服务端的入口main-ssg.ts没有provide这个radar）
    const fmp = () => {
        radar?.fmp();
    };
		......
    return {
        fmp,
				......
    };
}
```

客户端的入口src/main.ts里provide()提供radar

```js
//src/main.ts
export const createApp = ViteSSG(App, { base: '/bingo', routes }, ({ app, router, initialState }) => {
		......
    app.provide('logger', loggerUtils);
    app.provide('radar', radar);
    // ...
});
```



这个方法会出现一个问题：调用useRadar的时候由于不是在vue的运行时里执行的所以无法inject，所以要这么写：

```js
            app.runWithContext(() => {
                useRadar(router, config.url); // 在runWithContext里才能inject
            });
```





##### 希望某些方法在ssg时不执行 

###### 法一：在mounted等客户端才会调的钩子里调用这些包

###### 法二：利用环境变量

```js
if(!import.meta.env.SSR){
	fn()...
}
```





##### 上报元素曝光但上报的文案是由主接口下发

比如上报某个按钮的曝光，这个按钮里的文案是主接口下发的，所以要将上报逻辑改成等主接口回来之后再上报。

原本的上报逻辑没有等主接口回来是因为主接口没回来会有全局loading（所以元素一定是在主接口回来之后才会曝光），ssg之后没有loading了，有点骨架屏的意思。



##### 主接口未回来之前会看到主页面

不知道咋解，因为没有全局loading等主接口，请求index.html就看到主页面了，如果主接口报错就会先看到主页面再跳到兜底页，会闪一下。







### vitepress

#### 原理

就是把markdown解成html后插入到`<template><div>{{html}}</div></template>`里就变成vue组件了，后续流程就跟处理vue组件一样了。

为什么每个文档都是一个js文件：然后给plugin-vue去处理，每个文档打包成一个js文件是因为编译阶段会在首页注入`import(每一个md文件)`(动态导入所以就每个文件都是一个包了)。

为什么每个文档都是一个html：ssg的时候生成的，利用renderToString()去处理上面说的vue组件即可。



vitepress不是用vue-router，没法用Sentry去监听router的错误





我跟着神三元的《[基于 Vite 的 SSG 框架开发实战](https://juejin.cn/video/7163857336258265102/section)》搞了一个在`properties/apps/mini-island`，主要学习的点在于如何用vite搞一个开发服务器`src/node/dev.ts`，如何打包ssg和client`src/node/build.ts`，用`src/plugin-island`配合前两者。看看约定式路由`src/plugin-routes`，就是它让文档都动态引入，所以每个文档都是一个js文件。





### rollup-plugin-visualizer

注册了个**generateBundle**钩子，所以只能算bundle的大小，也算不到ssr生成的html的大小。



## vite插件

### 插件原理



#### 首先明确

1. 一系列的编译过程指的就是 Vite 的插件工作流水线(Pipeline)

   - 开发环境：Vite 在开发阶段实现了一个按需加载的服务器，每一个文件请求进来都会经历一系列的编译流程，然后 Vite 会将编译结果响应给浏览器。

   - 生产环境下：Vite 同样会执行一系列编译过程，将编译结果交给 Rollup 进行模块打包。

2. Vite 的插件机制是与 Rollup 兼容的
   - 在生产环境中 Vite 直接调用 Rollup 进行打包，所以 Rollup 可以调度各种插件；
   - 在开发环境中，Vite 模拟了 Rollup 的插件机制，设计了一个`PluginContainer` 对象来调度各个插件。

3. Rollup 的插件开发整体上是非常简洁和灵活的，总结为以下几个方面:
   - **插件逻辑集中管理**。各个阶段的 Hook 都可以放在一个插件中编写，比如上述两个 Webpack 的 Loader 和 Plugin 功能在 Rollup 只需要用一个插件，分别通过 transform 和 renderChunk 两个 Hook 来实现。
   - **插件 API 简洁，符合直觉**。Rollup 插件基本上只需要返回一个包含 name 和各种钩子函数的对象即可，也就是声明一个 name 属性，然后写几个钩子函数即可。
   - **插件间的互相调用**。比如的`alias`插件，可以通过插件上下文对象的`resolve`方法，继续调用其它插件的 `resolveId`钩子，类似的还有`load`方法，这就大大增加了插件的灵活性。



#### 虚拟模块

虚拟模块（virtual module）是一种特殊的模块，它们并不存在于实际的文件系统中，而是在构建过程中由 Vite 动态生成并提供给 Vite 内部的模块解析系统。这种虚拟模块可以在运行时被其他模块作为依赖引入，无需真实的文件存在。

虚拟模块的概念有助于开发者实现高度自定义的灵活构建过程。最典型的用例之一就是 CSS 模块和动态导入外部的 JSON 数据。Vue 3 的开发版本提供的虚拟 CSS 模块机制使得我们可以将 CSS 文件引入 JavaScript 作为模块，Vite 会自动处理和应用这些 CSS。同样，虚拟模块还可以动态处理 JSON 文件，使得无需打包阶段将其写入硬盘即可被其他代码引入。

虚拟模块在 Vite 内部的插件被深度地使用，社区当中也有不少知名的插件(如 `vite-plugin-windicss`、`vite-plugin-svg-icons`等)也使用了虚拟模块的技术。

虚拟模块在 Vite 中为构建过程提供了高度的自定义能力。通过编写插件和虚拟模块，开发者可以实现复杂的构建逻辑，不必受限于基于文件系统的传统模块解析方式。





#### 插件hook

##### rollup插件

###### 根据这两个构建阶段分为两类hook

Rollup 两大构建阶段（`Build`和`Output`）。

- `Build Hook`即在`Build`阶段执行的钩子函数，在这个阶段主要进行模块代码的转换、AST 解析以及模块依赖的解析，那么这个阶段的 Hook 对于代码的操作粒度一般为`模块`级别，也就是单文件级别。
- `Ouput Hook`(官方称为`Output Generation Hook`)，则主要进行代码的打包，对于代码而言，操作粒度一般为 `chunk`级别(一个 chunk 通常指很多文件打包到一起的产物)。

###### 根据不同的 Hook 执行方式分类

**1. Async & Sync**

首先是`Async`和`Sync`钩子函数，两者其实是相对的，分别代表`异步`和`同步`的钩子函数，两者最大的区别在于同步钩子里面不能有异步逻辑，而异步钩子可以有。

**2. Parallel**

这里指并行的钩子函数。如果有多个插件实现了这个钩子的逻辑，一旦有钩子函数是异步逻辑，则并发执行钩子函数，不会等待当前钩子完成(底层使用 `Promise.all`)。

比如对于`Build`阶段的`buildStart`钩子，它的执行时机其实是在构建刚开始的时候，各个插件可以在这个钩子当中做一些状态的初始化操作，但其实插件之间的操作并不是相互依赖的，也就是可以并发执行，从而提升构建性能。反之，对于需要**依赖其他插件处理结果**的情况就不适合用 `Parallel` 钩子了，比如 `transform`。

**3. Sequential**

**Sequential** 指串行的钩子函数。这种 Hook 往往适用于插件间处理结果相互依赖的情况，前一个插件 Hook 的返回值作为后续插件的入参，这种情况就需要等待前一个插件执行完 Hook，获得其执行结果，然后才能进行下一个插件相应 Hook 的调用，如`transform`。

**4. First**

如果有多个插件实现了这个 Hook，那么 Hook 将依次运行，直到返回一个非 null 或非 undefined 的值为止。比较典型的 Hook 是 `resolveId`，一旦有插件的 resolveId 返回了一个路径，将停止执行后续插件的 resolveId 逻辑。

刚刚我们介绍了 Rollup 当中不同插件 Hook 的类型，实际上不同的类型是可以叠加的，`Async`/`Sync` 可以搭配后面三种类型中的任意一种，比如一个 Hook既可以是 `Async` 也可以是 `First` 类型，接着我们将来具体分析 Rollup 当中的插件工作流程，里面会涉及到具体的一些 Hook，大家可以具体地感受一下。







###### Build 阶段工作流

![image-20230522173257849](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-05-22-17-32-image-20230522173257849.png)



1. 首先经历 `options` 钩子进行配置的转换，得到处理后的配置对象。
2. 随之 Rollup 会调用`buildStart`钩子，正式开始构建流程。
3. Rollup 先进入到 `resolveId` 钩子中解析文件路径。(从 `input` 配置指定的入口文件开始)。
4. Rollup 通过调用`load`钩子加载模块内容。
5. 紧接着 Rollup 执行所有的 `transform` 钩子来对模块内容进行进行自定义的转换，比如 babel 转译。
6. 现在 Rollup 拿到最后的模块内容，进行 AST 分析，得到所有的 import 内容，调用 moduleParsed 钩子:
   - **6.1** 如果是普通的 import，则执行 `resolveId` 钩子，继续回到步骤`3`。
   - **6.2** 如果是动态 import，则执行 `resolveDynamicImport` 钩子解析路径，如果解析成功，则回到步骤`4`加载模块，否则回到步骤`3`通过 `resolveId` 解析路径。
7. 直到所有的 import 都解析完毕，Rollup 执行`buildEnd`钩子，Build 阶段结束。

当然，在 Rollup 解析路径的时候，即执行`resolveId`或者`resolveDynamicImport`的时候，有些路径可能会被标记为`external`(翻译为`排除`)，也就是说不参加 Rollup 打包过程，这个时候就不会进行`load`、`transform`等等后续的处理了。

在流程图最上面，不知道大家有没有注意到`watchChange`和`closeWatcher`这两个 Hook，这里其实是对应了 rollup 的`watch`模式。当你使用 `rollup --watch` 指令或者在配置文件配有`watch: true`的属性时，代表开启了 Rollup 的`watch`打包模式，这个时候 Rollup 内部会初始化一个 `watcher` 对象，当文件内容发生变化时，watcher 对象会自动触发`watchChange`钩子执行并对项目进行重新构建。在当前**打包过程结束**时，Rollup 会自动清除 watcher 对象调用`closeWacher`钩子。





###### Output 阶段工作流

![image-20230522173531104](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-05-22-17-35-image-20230522173531104.png)

1. 执行所有插件的 `outputOptions` 钩子函数，对 `output` 配置进行转换。
2. 执行 `renderStart`，并发执行 renderStart 钩子，正式开始打包。
3. 并发执行所有插件的`banner`、`footer`、`intro`、`outro` 钩子(底层用 Promise.all 包裹所有的这四种钩子函数)，这四个钩子功能很简单，就是往打包产物的固定位置(比如头部和尾部)插入一些自定义的内容，比如协议声明内容、项目介绍等等。
4. 从入口模块开始扫描，针对动态 import 语句执行 `renderDynamicImport`钩子，来自定义动态 import 的内容。
5. 对每个即将生成的 `chunk`，执行 `augmentChunkHash`钩子，来决定是否更改 chunk 的哈希值，在 `watch` 模式下即可能会多次打包的场景下，这个钩子会比较适用。
6. 如果没有遇到 `import.meta` 语句，则进入下一步，否则:
   - **6.1** 对于 `import.meta.url` 语句调用 `resolveFileUrl` 来自定义 url 解析逻辑
   - **6.2** 对于其他`import.meta` 属性，则调用 `resolveImportMeta` 来进行自定义的解析。
7. 接着 Rollup 会生成所有 chunk 的内容，针对每个 chunk 会依次调用插件的`renderChunk`方法进行自定义操作，也就是说，在这里时候你可以直接操作打包产物了。
8. 随后会调用 `generateBundle` 钩子，这个钩子的入参里面会包含所有的打包产物信息，包括 `chunk` (打包后的代码)、`asset`(最终的静态资源文件)。你可以在这里删除一些 chunk 或者 asset，最终这些内容将不会作为产物输出。
9. 前面提到了`rollup.rollup`方法会返回一个`bundle`对象，这个对象是包含`generate`和`write`两个方法，两个方法唯一的区别在于后者会将代码写入到磁盘中，同时会触发`writeBundle`钩子，传入所有的打包产物信息，包括 chunk 和 asset，和 `generateBundle`钩子非常相似。不过值得注意的是，这个钩子执行的时候，产物已经输出了，而 generateBundle 执行的时候产物还并没有输出。顺序如下图所示:

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/12142ea189be4a8f918cf247f408487e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

10. 当上述的`bundle`的`close`方法被调用时，会触发`closeBundle`钩子，到这里 Output 阶段正式结束。

> 注意: 当打包过程中任何阶段出现错误，会触发 renderError 钩子，然后执行closeBundle钩子结束打包。





##### vite和rollup常用 Hook

######  Vite **开发阶段**会调用这些rollup钩子

- **服务器启动阶段**: `options`和`buildStart`钩子会在服务启动时被调用。
- **请求响应阶段**: 当浏览器发起请求时，Vite 内部依次调用`resolveId`、`load`和`transform`钩子。
- **服务器关闭阶段**: Vite 会依次执行`buildEnd`和`closeBundle`钩子。

除了以上钩子，其他 Rollup 插件钩子(如`moduleParsed`、`renderChunk`)均不会在 Vite **开发阶段**调用。

<mark>生产环境下，由于 Vite 直接使用 Rollup，所有 Rollup 的插件钩子都会生效。</mark>





###### **路径解析: resolveId**

resolveId 钩子一般用来解析模块路径，是`Async + First`类型即`异步优先`的钩子。

resolveId 钩子函数入参分别是`当前模块路径`、`引用当前模块的模块路径`、`解析参数`，返回值可以是 null、string 或者一个对象，我们分情况讨论。

- 返回值为 null 时，会默认交给下一个插件的 resolveId 钩子处理。
- 返回值为 string 时，则停止后续插件的处理。这里为了让替换后的路径能被其他插件处理，特意调用了 this.resolve 来交给其它插件处理，否则将不会进入到其它插件的处理。
- 返回值为一个对象，也会停止后续插件的处理，不过这个对象就可以包含[更多的信息](https://link.juejin.cn/?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23resolveid)了，包括解析后的路径、是否被 enternal、是否需要 tree-shaking 等等，不过大部分情况下返回一个 string 就够用了。

这里我们拿官方的 [alias 插件](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Fblob%2Fmaster%2Fpackages%2Falias%2Fsrc%2Findex.ts) 来说明，这个插件用法演示如下:

```js
// rollup.config.js
import alias from '@rollup/plugin-alias';
module.exports = {
  input: 'src/index.js',
  output: {
    dir: 'output',
    format: 'cjs'
  },
  plugins: [
    alias({
      entries: [
        // 将把 import xxx from 'module-a' 
        // 转换为 import xxx from './module-a'
        { find: 'module-a', replacement: './module-a.js' },
      ]
    })
  ]
};
```

插件的代码简化后如下:

```js
export default alias(options) {
  // 获取 entries 配置
  const entries = getEntries(options);
  return {
    // 传入三个参数，当前模块路径、引用当前模块的模块路径、其余参数
    resolveId(importee, importer, resolveOptions) {
      // 先检查能不能匹配别名规则
      const matchedEntry = entries.find((entry) => matches(entry.find, importee));
      // 如果不能匹配替换规则，或者当前模块是入口模块，则不会继续后面的别名替换流程
      if (!matchedEntry || !importerId) {
        // return null 后，当前的模块路径会交给下一个插件处理
        return null;
      }
      // 正式替换路径
      const updatedId = normalizeId(
        importee.replace(matchedEntry.find, matchedEntry.replacement)
      );
      // 每个插件执行时都会绑定一个上下文对象作为 this
      // 这里的 this.resolve 会执行所有插件(除当前插件外)的 resolveId 钩子
      return this.resolve(
        updatedId,
        importer,
        Object.assign({ skipSelf: true }, resolveOptions)
      ).then((resolved) => {
        // 替换后的路径即 updateId 会经过别的插件进行处理
        let finalResult: PartialResolvedId | null = resolved;
        if (!finalResult) {
          // 如果其它插件没有处理这个路径，则直接返回 updateId
          finalResult = { id: updatedId };
        }
        return finalResult;
      });
    }
  }
}
```



###### **load**

load 为`Async + First`类型，即**异步优先**的钩子，和`resolveId`类似。它的作用是通过 resolveId 解析后的路径来加载模块内容。

load 钩子的入参是模块 id，返回值一般是 null、string 或者一个对象：

- 如果返回值为 null，则交给下一个插件处理；
- 如果返回值为 string 或者对象，则终止后续插件的处理，如果是对象可以包含 SourceMap、AST 等[更详细的信息](https://link.juejin.cn/?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23load)。

我们以官方的 [image 插件](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Fblob%2Fmaster%2Fpackages%2Fimage%2Fsrc%2Findex.js) 为例来介绍一下 load 钩子的使用。源码简化后如下所示:

```js
const mimeTypes = {
  '.jpg': 'image/jpeg',
  // 后面图片类型省略
};

export default function image(opts = {}) {
  const options = Object.assign({}, defaults, opts);
  return {
    name: 'image',
    load(id) {
      const mime = mimeTypes[extname(id)];
      if (!mime) {
        // 如果不是图片类型，返回 null，交给下一个插件处理
        return null;
      }
      // 加载图片具体内容
      const isSvg = mime === mimeTypes['.svg'];
      const format = isSvg ? 'utf-8' : 'base64';
      const source = readFileSync(id, format).replace(/[\r\n]+/gm, '');
      const dataUri = getDataUri({ format, isSvg, mime, source });
      const code = options.dom ? domTemplate({ dataUri }) : constTemplate({ dataUri });

      return code.trim();
    }
  };
}
```



###### **代码转换: transform**

`transform` ，为`Async + Sequential`类型，也就是`异步串行`钩子，作用是对加载后的模块内容进行自定义的转换。

[transform 钩子](https://link.juejin.cn/?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23transform)的入参分别为`模块（文件）代码`、`模块 ID`，返回一个包含 `code`(代码内容) 和 `map`(SourceMap 内容) 属性的对象，当然也可以返回 null 来跳过当前插件的 transform 处理。需要注意的是，**当前插件返回的代码会作为下一个插件 transform 钩子的第一个入参**，实现类似于瀑布流的处理。

我们以官方的 `replace` 插件为例，这个插件的使用方式如下:

```js
// rollup.config.js
import replace from '@rollup/plugin-replace';

module.exports = {
  input: 'src/index.js',
  output: {
    dir: 'output',
    format: 'cjs'
  },
  plugins: [
    // 将会把代码中所有的 __TEST__ 替换为 1
    replace({
      __TEST__: 1
    })
  ]
};
```

内部实现也并不复杂，主要通过字符串替换来实现，核心逻辑简化如下:

```js
import MagicString from 'magic-string';

export default function replace(options = {}) {
  return {
    name: 'replace',
    transform(code, id) {
      // 省略一些边界情况的处理
      // 执行代码替换的逻辑，并生成最后的代码和 SourceMap
      return executeReplacement(code, id);
    }
  }
}

function executeReplacement(code, id) {
  const magicString = new MagicString(code);
  // 通过 magicString.overwrite 方法实现字符串替换
  if (!codeHasReplacements(code, id, magicString)) {
    return null;
  }

  const result = { code: magicString.toString() };

  if (isSourceMapEnabled()) {
    result.map = magicString.generateMap({ hires: true });
  }

  // 返回一个带有 code 和 map 属性的对象
  return result;
}
```



###### **改Chunk: renderChunk**

这个时候已经生成了chunk，你可以改这个chunk。如果你想看生成这个chunk的过程，那你应该去看rollup本身，而不是看插件，插件顶多是通过改rollup的配置去影响生成。

renderChunk 函数可以看到有两个入参，分别为 `chunk 代码内容`、[chunk 元信息](https://link.juejin.cn/?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23generatebundle)，返回值跟 `transform` 钩子类似，既可以返回包含 code 和 map 属性的对象，也可以通过返回 null 来跳过当前钩子的处理。

这里我们继续以 `replace`插件举例，在这个插件中，也同样实现了 renderChunk 钩子函数:

```js
export default function replace(options = {}) {
  return {
    name: 'replace',
    transform(code, id) {
      // transform 代码省略
    },
    renderChunk(code, chunk) {
      const id = chunk.fileName;
      // 省略一些边界情况的处理
      // 拿到 chunk 的代码及文件名，执行替换逻辑
      return executeReplacement(code, id);
    },
  }
}
```

可以看到这里 replace 插件为了替换结果更加准确，在 renderChunk 钩子中又进行了一次替换，因为后续的插件仍然可能在 transform 中进行模块内容转换，进而可能出现符合替换规则的字符串。



###### **改bundle: generateBundle**

这个时候已经有bundle了，你可以改这个bundle。如果你想看生成这个bundle的过程，那你应该去看rollup本身，而不是看插件，插件顶多是通过改rollup的配置去影响生成。

generateBundle 也是`异步串行`的钩子，你可以在这个钩子里面自定义删除一些无用的 chunk 或者静态资源，或者自己添加一些文件。

入参分别为`output 配置`、[所有打包产物的元信息对象](https://link.juejin.cn/?target=https%3A%2F%2Frollupjs.org%2Fguide%2Fen%2F%23generatebundle)，通过操作元信息对象你可以删除一些不需要的 chunk 或者静态资源，也可以通过 插件上下文对象的`emitFile`方法输出自定义文件。

这里我们以 Rollup 官方的`html`插件来具体说明，这个插件的作用是通过拿到 Rollup 打包后的资源来生成包含这些资源的 HTML 文件，源码简化后如下所示:

```js
export default function html(opts: RollupHtmlOptions = {}): Plugin {
  // 初始化配置
  return {
    name: 'html',
    async generateBundle(output: NormalizedOutputOptions, bundle: OutputBundle) {
      // 省略一些边界情况的处理
      // 1. 获取打包后的文件
      const files = getFiles(bundle);
      // 2. 组装 HTML，插入相应 meta、link 和 script 标签
      const source = await template({ attributes, bundle, files, meta, publicPath, title});
      // 3. 通过上下文对象的 emitFile 方法，输出 html 文件
      const htmlFile: EmittedAsset = {
        type: 'asset',
        source,
        name: 'Rollup HTML Asset',
        fileName
      };
      this.emitFile(htmlFile);
    }
  }
}
```







##### vite独有 Hook

这些 Hook 只会在 Vite 内部调用，而放到 Rollup 中会被直接忽略。

###### 给配置再加点料: config

Vite 在读取完配置文件（即`vite.config.ts`）之后，会拿到用户导出的配置对象，然后执行 config 钩子。在这个钩子里面，你可以对配置文件导出的对象进行自定义的操作，如下代码所示:

```ts
// 返回部分配置（推荐）
const editConfigPlugin = () => ({
  name: 'vite-plugin-modify-config',
  config: () => ({
    alias: {
      react: require.resolve('react')
    }
  })
})
```

官方推荐的姿势是在 config 钩子中返回一个配置对象，这个配置对象会和 Vite 已有的配置进行深度的合并。不过你也可以通过钩子的入参拿到 config 对象进行自定义的修改，如下代码所示:

```ts
const mutateConfigPlugin = () => ({
  name: 'mutate-config',
  // command 为 `serve`(开发环境) 或者 `build`(生产环境)
  config(config, { command }) {
    // 生产环境中修改 root 参数
    if (command === 'build') {
      config.root = __dirname;
    }
  }
})
```

在一些比较深层的对象配置中，这种直接修改配置的方式会显得比较麻烦，如 `optimizeDeps.esbuildOptions.plugins`，需要写很多的样板代码，类似下面这样:

```ts
// 防止出现 undefined 的情况
config.optimizeDeps = config.optimizeDeps || {}
config.optimizeDeps.esbuildOptions = config.optimizeDeps.esbuildOptions || {}
config.optimizeDeps.esbuildOptions.plugins = config.optimizeDeps.esbuildOptions.plugins || []
```

因此这种情况下，建议直接返回一个配置对象，这样会方便很多:

```ts
config() {
  return {
    optimizeDeps: {
      esbuildOptions: {
        plugins: []
      }
    }
  }
}
```

######  记录最终配置: configResolved

Vite 在解析完配置之后会调用`configResolved`钩子，这个钩子一般用来记录最终的配置信息，而不建议再修改配置，用法如下图所示:

```ts
const exmaplePlugin = () => {
  let config

  return {
    name: 'read-config',

    configResolved(resolvedConfig) {
      // 记录最终配置
      config = resolvedConfig
    },

    // 在其他钩子中可以访问到配置
    transform(code, id) {
      console.log(config)
    }
  }
}
```

###### 获取 Dev Server 实例: configureServer

这个钩子仅在**开发阶段**会被调用，用于扩展 Vite 的 Dev Server，一般用于增加自定义 server 中间件，如下代码所示:

```ts
const myPlugin = () => ({
  name: 'configure-server',
  configureServer(server) {
    // 姿势 1: 在 Vite 内置中间件之前执行
    server.middlewares.use((req, res, next) => {
      // 自定义请求处理逻辑
    })
    // 姿势 2: 在 Vite 内置中间件之后执行 
    return () => {
      server.middlewares.use((req, res, next) => {
        // 自定义请求处理逻辑
      })
    }
  }
})
```

###### 转换 HTML 内容: transformIndexHtml

这个钩子用来灵活控制 HTML 的内容，你可以拿到原始的 html 内容后进行任意的转换:

```ts
const htmlPlugin = () => {
  return {
    name: 'html-transform',
    transformIndexHtml(html) {
      return html.replace(
        /<title>(.*?)</title>/,
        `<title>换了个标题</title>`
      )
    }
  }
}
// 也可以返回如下的对象结构，一般用于添加某些标签
const htmlPlugin = () => {
  return {
    name: 'html-transform',
    transformIndexHtml(html) {
      return {
        html,
        // 注入标签
        tags: [
          {
            // 放到 body 末尾，可取值还有`head`|`head-prepend`|`body-prepend`，顾名思义
            injectTo: 'body',
            // 标签属性定义
            attrs: { type: 'module', src: './index.ts' },
            // 标签名
            tag: 'script',
          },
        ],
      }
    }
  }
}
```

###### 热更新处理: handleHotUpdate

这个钩子会在 Vite 服务端处理热更新时被调用，你可以在这个钩子中拿到热更新相关的上下文信息，进行热更模块的过滤，或者进行自定义的热更处理。下面是一个简单的例子:

```ts
const handleHmrPlugin = () => {
  return {
    async handleHotUpdate(ctx) {
      // 需要热更的文件
      console.log(ctx.file)
      // 需要热更的模块，如一个 Vue 单文件会涉及多个模块
      console.log(ctx.modules)
      // 时间戳
      console.log(ctx.timestamp)
      // Vite Dev Server 实例
      console.log(ctx.server)
      // 读取最新的文件内容
      console.log(await read())
      // 自行处理 HMR 事件
      ctx.server.ws.send({
        type: 'custom',
        event: 'special-update',
        data: { a: 1 }
      })
      return []
    }
  }
}

// 前端代码中加入
if (import.meta.hot) {
  import.meta.hot.on('special-update', (data) => {
    // 执行自定义更新
    // { a: 1 }
    console.log(data)
    window.location.reload();
  })
}
```

以上就是 Vite 独有的五个钩子，我们来重新梳理一下:

- `config`: 用来进一步修改配置。
- `configResolved`: 用来记录最终的配置信息。
- `configureServer`: 用来获取 Vite Dev Server 实例，添加中间件。
- `transformIndexHtml`: 用来转换 HTML 的内容。
- `handleHotUpdate`: 用来进行热更新模块的过滤，或者进行自定义的热更新处理。

##### vite开发阶段插件所有Hook 执行顺序

> 请求响应阶段: 如果是 `html` 文件，仅执行`transformIndexHtml`钩子；对于非 HTML 文件，则依次执行`resolveId`、`load`和`transform`钩子。

![image-20230522154354611](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-05-22-15-43-image-20230522154354611.png)



#### Vite 插件的**应用情景**和**应用顺序**

##### 应用环境

默认情况下 Vite 插件同时被用于开发环境和生产环境，你可以通过`apply`属性来决定应用场景:

```ts
{
  // 'serve' 表示仅用于开发环境，'build'表示仅用于生产环境
  apply: 'serve'
}
```

`apply`参数还可以配置成一个函数，进行更灵活的控制:

```ts
apply(config, { command }) {
  // 只用于非 SSR 情况下的生产环境构建
  return command === 'build' && !config.build.ssr
}
```





##### Vite 中插件的执行顺序

hook是核心顺序，enforce就是控制如果有多个插件实现此钩子，这个插件在钩子里注册的回调函数在这个钩子里的执行顺序。

先注册的插件先执行，后注册的插件后执行。适用于大多数插件钩子，包括`transform`，`config`，`configureServer`等。但是，对于一些特定的钩子，如`resolveId`，`load`，`renderChunk`等，Vite会按照相反的顺序执行插件，即最后注册的插件将首先执行。

Vite会等待每个插件的方法执行完成（包括异步操作）后再执行下一个插件的方法



<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-05-22-15-46-image-20230522154620771.png" alt="image-20230522154620771"/>

```json
{
  // 默认为`normal`，可取值还有`pre`和`post`
  enforce: 'pre'
}
```

Vite 会依次执行如下的插件:

- Alias (路径别名)相关的插件。
- ⭐️ 带有 `enforce: 'pre'` 的用户插件。
- Vite 核心插件。
- ⭐️ 没有 enforce 值的用户插件，也叫`普通插件`。
- Vite 生产环境构建用的插件。
- ⭐️ 带有 `enforce: 'post'` 的用户插件。
- Vite 后置构建插件(如压缩插件)。





#### 一个简单的插件示例

Vite 插件与 Rollup 插件结构类似，为一个`name`和各种插件 Hook 的对象:

```ts
{
  // 插件名称
  name: 'vite-plugin-xxx',
  load(code) { //你可以理解为一个 Rollup 插件基本就是各种 Hook 函数的组合
    // 钩子逻辑
  },
}
```

> 如果插件是一个 npm 包，在`package.json`中的包命名也推荐以`vite-plugin`开头

一般情况下因为要考虑到外部传参，我们不会直接写一个对象，而是实现一个返回插件对象的`工厂函数`，如下代码所示:

```ts
// myPlugin.js
export function myVitePlugin(options) {
  console.log(options)
  return {
    name: 'vite-plugin-xxx',
    load(id) {
      // 在钩子逻辑中可以通过闭包访问外部的 options 传参
    }
  }
}

// 使用方式
// vite.config.ts
import { myVitePlugin } from './myVitePlugin';
export default {
  plugins: [myVitePlugin({ /* 给插件传参 */ })]
}
```



### 写个插件

#### 辅助写插件的工具工具包

https://github.com/antfu/vite-plugin-inspect

https://github.com/rollup/plugins/tree/master/packages/pluginutils



#### 实战案例 1: 虚拟模块加载

首先通过脚手架命令初始化一个`react + ts`项目:

```ts
pnpm create vite
```

然后通过`pnpm i`安装依赖，接着新建`plugins`目录，开始插件的开发:

>plugins/virtual-module.ts

```ts
import { Plugin } from 'vite';

// 虚拟模块名称
const virtualFibModuleId = 'virtual:fib';
// Vite 中约定对于虚拟模块，解析后的路径需要加上`\0`前缀
const resolvedFibVirtualModuleId = '\0' + virtualFibModuleId;

export default function virtualFibModulePlugin(): Plugin {
  return {
    name: 'vite-plugin-virtual-module',
    resolveId(id) {
      if (id === virtualFibModuleId) { 
        return resolvedFibVirtualModuleId;
      }
    },
    load(id) {
      // 加载虚拟模块
      if (id === resolvedFibVirtualModuleId) {
        return 'export default function fib(n) { return n <= 1 ? n : fib(n - 1) + fib(n - 2); }';
      }
    }
  }
}
```

接着我们在项目中来使用这个插件:

```ts
// vite.config.ts
import virtual from './plugins/virtual-module.ts'

// 配置插件
{
  plugins: [react(), virtual()]
}
```

然后在`main.tsx`中加入如下的代码:

```ts
import fib from 'virtual:fib';

alert(`结果: ${fib(10)}`)
```

这里我们使用了 `virtual:fib` 这个虚拟模块，虽然这个模块不存在真实的文件系统中，但你打开浏览器后可以发现这个模块导出的函数是可以正常执行的:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/216e84976e3c408cb845b64bf329943f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

接着我们来尝试一下如何通过虚拟模块来读取内存中的变量，在`virtual-module.ts`中增加如下代码:

```diff
+ import { Plugin, ResolvedConfig } from 'vite';

const virtualFibModuleId = 'virtual:fib';
const resolvedFibVirtualModuleId = '\0' + virtualFibModuleId;

+ const virtualEnvModuleId = 'virtual:env';
+ const resolvedEnvVirtualModuleId = '\0' + virtualEnvModuleId;

export default function virtualFibModulePlugin(): Plugin {
+   let config: ResolvedConfig | null = null;
  return {
    name: 'vite-plugin-virtual-fib-module',
+     configResolved(c: ResolvedConfig) {
+       config = c;
+     },
    resolveId(id) {
      if (id === virtualFibModuleId) { 
        return resolvedFibVirtualModuleId;
      }
+       if (id === virtualEnvModuleId) { 
+        return resolvedEnvVirtualModuleId;
+      }
    },
    load(id) {
      if (id === resolvedFibVirtualModuleId) {
        return 'export default function fib(n) { return n <= 1 ? n : fib(n - 1) + fib(n - 2); }';
      }
+      if (id === resolvedEnvVirtualModuleId) {
+        return `export default ${JSON.stringify(config!.env)}`;
+      }
    }
  }
}
```

在新增的这些代码中，我们注册了一个新的虚拟模块`virtual:env`，紧接着我们去项目去使用:

```ts
// main.tsx
import env from 'virtual:env';
console.log(env)
```

`virtual:env`一般情况下会有类型问题，我们需要增加一个类型声明文件来声明这个模块:

```ts
// types/shim.d.ts
declare module 'virtual:*' {
  export default any;
}
```

这样就解决了类型报错的问题。接着你可以去浏览器观察一下输出的情况:

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59c04f44a5334138ab722400c03c071c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

Vite 环境变量能正确地在浏览器中打印出来，说明在内存中计算出来的`virtual:env`模块的确被成功地加载了。从中你可以看到，虚拟模块的内容完全能够被动态计算出来。





#### 实战案例 2: Svg 组件形式加载

在一般的项目开发过程中，我们有时候希望能将 svg 当做一个组件来引入，这样我们可以很方便地修改 svg 的各种属性，相比于`img`标签的引入方式也更加优雅。

接下来我们就来写一个 Vite 插件，实现在 React 项目能够通过组件方式来使用 svg 资源。首先安装一下需要的依赖:

```bash
pnpm i resolve @svgr/core -D
```

接着在`plugins`目录新建 `svgr.ts`:

```ts
import { Plugin } from 'vite';
import * as fs from 'fs';
import * as resolve from 'resolve';

interface SvgrOptions {
  // svg 资源模块默认导出，url 或者组件
  defaultExport: 'url' | 'component';
}

export default function viteSvgrPlugin(options: SvgrOptions) {
  const { defaultExport='url' } = options;
  return {
    name: 'vite-plugin-svgr',
    async transform(code ,id) {
      // 转换逻辑: svg -> React 组件
    }
  }
}
```

让我们先来梳理一下开发需求，用户通过传入`defaultExport`可以控制 svg 资源的默认导出:

- 当 `defaultExport`为 `component`，默认当做组件来使用，即:

```ts
import Logo from './Logo.svg'

// 在组件中直接使用
<Logo />
```

- 当`defaultExports`为`url`，默认当做 url 使用，如果需要用作组件，可以通过`具名导入`的方式来支持:

```ts
import logoUrl, { ReactComponent as Logo } from './logo.svg';

// url 使用
<img src={logoUrl} />
// 组件方式使用
<Logo />
```

明确了需求之后，接下来让我们来整理一下插件开发的整体思路，主要逻辑在 `transform`钩子中完成，流程如下:

1. 根据 id 入参过滤出 svg 资源；
2. 读取 svg 文件内容；
3. 利用 `@svgr/core` 将 svg 转换为 React 组件代码;
4. 处理默认导出为 url 的情况；
5. 将组件的 jsx 代码转译为浏览器可运行的代码。

下面是插件的完整的代码，你可以参考学习:

```js
import { Plugin } from 'vite';
import * as fs from 'fs';
import * as resolve from 'resolve';

interface SvgrOptions {
  defaultExport: 'url' | 'component';
}

export default function viteSvgrPlugin(options: SvgrOptions): Plugin {
  const { defaultExport='component' } = options;

  return {
    name: 'vite-plugin-svgr',
    async transform(code, id) {
      // 1. 根据 id 入参过滤出 svg 资源；
      if (!id.endsWith('.svg')) {
        return code;
      }
      const svgrTransform = require('@svgr/core').transform;
      // 解析 esbuild 的路径，后续转译 jsx 会用到，我们这里直接拿 vite 中的 esbuild 即可
      const esbuildPackagePath = resolve.sync('esbuild', { basedir: require.resolve('vite') });
      const esbuild = require(esbuildPackagePath);
      // 2. 读取 svg 文件内容；
      const svg = await fs.promises.readFile(id, 'utf8');
      // 3. 利用 `@svgr/core` 将 svg 转换为 React 组件代码
      const svgrResult = await svgrTransform(
        svg,
        {},
        { componentName: 'ReactComponent' }
      );
      // 4. 处理默认导出为 url 的情况
      let componentCode = svgrResult;
      if (defaultExport === 'url') {
        // 加上 Vite 默认的 `export default 资源路径`
        componentCode += code;
        componentCode = componentCode.replace('export default ReactComponent', 'export { ReactComponent }');
      }
      // 5. 利用 esbuild，将组件中的 jsx 代码转译为浏览器可运行的代码;
      const result = await esbuild.transform(componentCode, {
        loader: 'jsx',
      });
      return {
        code: result.code,
        map: null // TODO
      };
    },
  };
}
```

接下来让我们在项目中使用这个插件:

```ts
// vite.config.ts
import svgr from './plugins/svgr';

// 返回的配置
{
  plugins: [
    // 省略其它插件
    svgr()
  ]
}
```

接着我们在项目中用组件的方式引入 svg:

```ts
// App.tsx
import Logo from './logo.svg'

function App() {
  return (
    <>
      <Logo />
    </>
  )
}

export default App;
```





### 内置插件

Vite 内置插件有下面这几类:

- 别名插件
- 核心构建插件
- 生产环境特有插件
- 开发环境特有插件

##### 1.别名插件

别名插件有两个，分别是 [vite:pre-alias](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F72cb33e947e7aa72d27ed0c5eacb2457d523dfbf%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FpreAlias.ts) 和 [@rollup/plugin-alias](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F72cb33e947e7aa72d27ed0c5eacb2457d523dfbf%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Findex.ts%23L3)。 前者主要是为了将 bare import 路径重定向到预构建依赖的路径，如:

```ts
// 假设 React 已经经过 Vite 预构建
import React from 'react';
// 会被重定向到预构建产物的路径
import React from '/node_modules/.vite/react.js'
```

后者则是实现了比较通用的路径别名(即`resolve.alias`配置)的功能，使用的是 [Rollup 官方 Alias 插件](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Falias%23rollupplugin-alias)。

##### 2. 核心构建插件

###### 2.1 module preload 特性的 Polyfill

当你在 Vite 配置文件中开启下面这个配置时:

```ts
{
  build: {
    polyfillModulePreload: true
  }
}
```

Vite 会自动应用 `modulePreloadPolyfillPlugin` 插件，在产物中注入 module preload 的 Polyfill 代码，[具体实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FmodulePreloadPolyfill.ts%23L7) 摘自之前我们提到过的 `es-module-shims`这个库，实现原理如下:

1. 扫描出当前所有的 modulepreload 标签，拿到 link 标签对应的地址，通过执行 fetch 实现预加载；
2. 同时通过 MutationObserver 监听 DOM 的变化，一旦发现包含 modulepreload 属性的 link 标签，则同样通过 fetch 请求实现预加载。

> 由于部分支持原生 ESM 的浏览器并不支持 module preload，因此某些情况下需要注入相应的 polyfill 进行降级。

###### 2.2 路径解析插件

路径解析插件(即`vite:resolve`)是 Vite 中比较核心的插件。它一方面实现了 [Node.js 官方的 resolve 算法](https://link.juejin.cn/?target=https%3A%2F%2Fnodejs.org%2Fapi%2Fmodules.html%23modules_all_together)，另一方面需要支持前面所说的各项特性，可以说是专门给 Vite 实现了一套路径解析算法。



###### 2.3 内联脚本加载插件

对于 HTML 中的内联脚本，Vite 会通过`vite:html-inline-script-proxy` 插件来进行加载。比如下面这个 script 标签:

```ts
<script type="module">
import React from 'react';
console.log(React)
</script>
```

这些内容会在后续的`build-html`插件从 HTML 代码中剔除，并且变成下面的这一行代码插入到项目入口模块的代码中:

```js
import '/User/xxx/vite-app/index.html?http-proxy&index=0.js'
```

而 `vite:html-inline-script-proxy` 就是用来加载这样的模块，实现如下:

```ts
const htmlProxyRE = /\?html-proxy&index=(\d+)\.js$/

export function htmlInlineScriptProxyPlugin(config: ResolvedConfig): Plugin {
  return {
    name: 'vite:html-inline-script-proxy',
    load(id) {
      const proxyMatch = id.match(htmlProxyRE)
      if (proxyMatch) {
        const index = Number(proxyMatch[1])
        const file = cleanUrl(id)
        const url = file.replace(normalizePath(config.root), '')
        // 内联脚本的内容会被记录在 htmlProxyMap 这个表中
        const result = htmlProxyMap.get(config)!.get(url)![index]
        if (typeof result === 'string') {
          // 加载脚本的具体内容
          return result
        } else {
          throw new Error(`No matching HTML proxy module found from ${id}`)
        }
      }
    }
  }
}
```

###### 2.4 CSS 编译插件

即名为`vite:css`的[插件](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fcss.ts%23L137)，主要实现下面这些功能:

- `CSS 预处理器的编译`
- `CSS Modules`
- `Postcss 编译`
- 通过 @import `记录依赖`，便于 HMR

这个插件的核心在于`compileCSS`函数的实现，感兴趣的同学可以阅读一下[这部分的源码](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fcss.ts%23L568)。

###### 2.5 Esbuild 转译插件

即名为`vite:esbuild`的[插件](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fesbuild.ts)，用来进行 `.js`、`.ts`、`.jsx`和`tsx`，代替了传统的 Babel 或者 TSC 的功能，这也是 Vite 开发阶段性能强悍的一个原因。插件中主要的逻辑是`transformWithEsbuild`函数，顾名思义，你可以通过这个函数进行代码转译。当然，Vite 本身也导出了这个函数，作为一种通用的 transform 能力，你可以这样来使用:

```ts
import { transformWithEsbuild } from 'vite';

// 传入两个参数: code, filename
transformWithEsbuild('<h1>hello</h1>', './index.tsx').then(res => {
  // {
  //   warnings: [],
  //   code: '/* @__PURE__ */ React.createElement("h1", null, "hello");\n',
  //   map: {/* sourcemap 信息 */}
  // }
  console.log(res);
})
```

###### 2.6 静态资源加载插件

静态资源加载插件包括如下几个:

- **vite:json** 用来加载 JSON 文件，通过`@rollup/pluginutils`的`dataToEsm`方法可实现 JSON 的按名导入，具体实现见[链接](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fjson.ts%23L30)；
- **vite:wasm** 用来加载 `.wasm` 格式的文件，具体实现见[链接](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fwasm.ts%23L45)；
- **vite:worker** 用来 Web Worker 脚本，插件内部会使用 Rollup 对 Worker 脚本进行打包，具体实现见[链接](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fworker.ts)；
- **vite:asset**，开发阶段实现了其他格式静态资源的加载，而生产环境会通过 `renderChunk` 钩子将静态资源地址重写为产物的文件地址，如`./img.png` 重写为 `https://cdn.xxx.com/assets/img.91ee297e.png`。

值得注意的是，Rollup 本身存在 [asset cascade](https://link.juejin.cn/?target=https%3A%2F%2Fbundlers.tooling.report%2Fhashing%2Fasset-cascade%2F) 问题，即静态资源哈希更新，引用它的 JS 的哈希并没有更新([issue 链接](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Frollup%2Fissues%2F3415))。因此 Vite 在静态资源处理的时候，并没有交给 Rollup 生成资源哈希，而是自己根据资源内容生成哈希([源码实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fasset.ts%23L306))，并手动进行路径重写，以此避免 `asset-cascade` 问题。

##### 3. 生产环境特有插件

###### 3.1 全局变量替换插件

提供全局变量替换功能，如下面的这个配置:

```ts
// vite.config.ts
const version = '2.0.0';

export default {
  define: {
    __APP_VERSION__: `JSON.stringify(${version})`
  }
}
```

全局变量替换的功能和我们之前在 Rollup 插件小节中提到的[@rollup/plugin-replace](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Freplace) 差不多，当然在实现上 Vite 会有所区别:

- 开发环境下，Vite 会通过将所有的全局变量挂载到`window`对象，而不用经过 define 插件的处理，节省编译开销；
- 生产环境下，Vite 会使用 [define 插件](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fmain%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fdefine.ts)，进行字符串替换以及 sourcemap 生成。

> 特殊情况: SSR 构建会在开发环境经过这个插件，仅替换字符串。

###### 3.2 CSS 后处理插件

CSS 后处理插件即`name`为`vite:css-post`的插件，它的功能包括`开发阶段 CSS 响应结果处理`和`生产环境 CSS 文件生成`。

首先，在开发阶段，这个插件会将之前的 CSS 编译插件处理后的结果，包装成一个 ESM 模块，返回给浏览器，[点击查看实现代码](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fcss.ts%23L284)。

其次，生产环境中，Vite 默认会通过这个插件进行 CSS 的 code splitting，即对于每个异步 chunk，Vite 会将其依赖的 CSS 代码单独打包成一个文件，关键代码如下([源码链接](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fcss.ts%23L400)):

```ts
const fileHandle = this.emitFile({
  name: chunk.name + '.css',
  type: 'asset',
  source: chunkCSS
});
```

如果 CSS 的 code splitting 功能被关闭(通过`build.cssCodeSplit`配置)，那么 Vite 会将所有的 CSS 代码打包到同一个 CSS 文件中，[点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fcss.ts%23L433)。

最后，插件会调用 Esbuild 对 CSS 进行压缩，实现在 `minifyCSS` 函数中，[点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fcss.ts%23L905)。

###### 3.3 HTML 构建插件

`HTML` 构建插件 即`build-html`插件。之前我们在`内联脚本加载插件`中提到过，项目根目录下的`html`会转换为一段 JavaScript 代码，如下面的这个例子:

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  // 普通方式引入
  <script src="./index.ts"></script>
  // 内联脚本
  <script type="module">
    import React from 'react';
    console.log(React)
  </script>
</body>
</html>
```

首先，当 Vite 在生产环境`transform`这段入口 HTML 时，会做 3 件事情:

1. 对 HTML 执行各个插件中带有 `enforce: "pre"` 属性的 transformIndexHtml 钩子；

> 我们知道插件本身可以带有 `enforce: "pre"|"post"` 属性，而 transformIndexHtml 本身也可以带有这个属性，用于在不同的阶段进行 HTML 转换。后文会介绍 transformIndexHtml 钩子带有 `enforce: "post"` 时的执行时机。

1. 将其中的 script 标签内容删除，并将其转换为 `import 语句`如`import './index.ts'`，并记录下来；
2. 在 transform 钩子中返回记录下来的 import 内容，将 import 语句作为模块内容进行加载。也就是说，虽然 Vite 处理的是一个 HTML 文件，但最后进行打包的内容却是一段 JS 的内容，[点击查看具体实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fmain%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fhtml.ts%23L233)。代码简化后如下所示:

```ts
export function buildHtmlPlugin() {
  name: 'vite:build',
  transform(html, id) {
    if (id.endsWith('.html')) {
      let js = '';
      // 省略 HTML AST 遍历过程(通过 @vue/compiler-dom 实现)
      // 收集 script 标签，转换成 import 语句，拼接到 js 字符串中
      return js;
    }
  }
}
```

其次，在生成产物的最后一步即`generateBundle`钩子中，拿到入口 Chunk，分析入口 Chunk 的内容, 分情况进行处理。

如果只有 import 语句，先通过 Rollup 提供的 `chunk` 和 `bundle` 对象获取入口 chunk 所有的依赖 chunk，并将这些 chunk 进行后序排列，如 `a 依赖 b，b 依赖 c`，最后的依赖数组就是`[c, b, a]`。然后依次将 c，b, a 生成三个 script 标签，插入 HTML 中。最后，Vite 会将入口 chunk 的内容从 bundle 产物中移除，因此它的内容只要 import 语句，而它 import 的 chunk 已经作为 script 标签插入到了 HTML 中，那入口 Chunk 的存在也就没有意义了。

如果除了 import 语句，还有其它内容， Vite 就会将入口 Chunk 单独生成一个 `script 标签`，分析出依赖的后序排列(和上一种情况分析手段一样)，然后通过注入 `<link rel="modulepreload"> 标签`对入口文件的依赖 chunk 进行预加载。

最后，插件会调用用户插件中带有 `enforce: "post"` 属性的 transformIndexHtml 钩子，对 HTML 进行进一步的处理。[点击查看具体实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fmain%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fhtml.ts%23L471)。

###### 3.3 Commonjs 转换插件

我们知道，在开发环境中，Vite 使用 Esbuild 将 Commonjs 转换为 ESM，而生产环境中，Vite 会直接使用 Rollup 的官方插件 [@rollup/plugin-commonjs](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fcommonjs)。

###### 3.4 date-uri 插件

date-uri 插件用来支持 import 模块中含有 Base64 编码的情况，如:

```ts
import batman from 'data:application/json;base64, eyAiYmF0bWFuIjogInRydWUiIH0=';
```

[点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FdataUri.ts%23L14)。

###### 3.5 dynamic-import-vars 插件

用于支持在动态 import 中使用变量的功能，如下示例代码:

```ts
function importLocale(locale) {
  return import(`./locales/${locale}.js`);
}
```

内部使用的是 Rollup 的官方插件 [@rollup/plugin-dynamic-import-vars](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Frollup%2Fplugins%2Ftree%2Fmaster%2Fpackages%2Fdynamic-import-vars)。

###### 3.6 import-meta-url 支持插件

用来转换如下格式的资源 URL:

```ts
new URL('./foo.png', import.meta.url)
```

将其转换为生产环境的 URL 格式，如:

```ts
// 使用 self.location 来保证低版本浏览器和 Web Worker 环境的兼容性
new URL('./assets.a4b3d56d.png, self.location)
```

同时，对于动态 import 的情况也能进行支持，如下面的这种写法:

```ts
function getImageUrl(name) {
  return new URL(`./dir/${name}.png`, import.meta.url).href
}
```

Vite 识别到`./dir/${name}.png`这样的模板字符串，会将整行代码转换成下面这样:

```ts
function getImageUrl(name) {
    return import.meta.globEager('./dir/**.png')[`./dir/${name}.png`].default;
}
```

[点击查看具体实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F2b7e836f84b56b5f3dc81e0f5f161a9b5f9154c0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FassetImportMetaUrl.ts%23L18)

###### 3.7 生产环境 import 分析插件

`vite:build-import-analysis` 插件会在生产环境打包时用作 import 语句分析和重写，主要目的是对动态 import 的模块进行预加载处理。

对含有动态 import 的 chunk 而言，会在插件的`tranform`钩子中被添加这样一段工具代码用来进行模块预加载，逻辑并不复杂，你可以参考[源码实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FimportAnalysisBuild.ts%23L43)。关键代码简化后如下:

```ts
function preload(importModule, deps) {
  return Promise.all(
    deps.map(dep => {
      // 如果异步模块的依赖还没有加载
      if (!alreadyLoaded(dep)) { 
        // 创建 link 标签加载，包括 JS 或者 CSS
        document.head.appendChild(createLink(dep))  
        // 如果是 CSS，进行特殊处理，后文会介绍
        if (isCss(dep)) {
          return new Promise((resolve, reject) => {
            link.addEventListener('load', resolve)
            link.addEventListener('error', reject)
          })
        }
      }
    })
  ).then(() => importModule())
}
```

我们知道，Vite 内置了 CSS 代码分割的能力，当一个模块通过动态 import 引入的时候，这个模块会被单独打包成一个 chunk，与此同时这个模块中的样式代码也会打包成单独的 CSS 文件。如果异步模块的 CSS 和 JS 同时进行预加载，那么在某些浏览器下(如 IE)就会出现 [FOUC 问题](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFlash_of_unstyled_content%23%3A~%3Atext%3DA%20flash%20of%20unstyled%20content%2Cbefore%20all%20information%20is%20retrieved.)，页面样式会闪烁，影响用户体验。但 Vite 通过监听 link 标签 `load` 事件的方式来保证 CSS 在 JS 之前加载完成，从而解决了 FOUC 问题。你可以注意下面这段关键代码:

```ts
if (isCss) {
  return new Promise((res, rej) => {
    link.addEventListener('load', res)
    link.addEventListener('error', rej)
  })
}
```

现在，我们已经知道了预加载的实现方法，那么 Vite 是如何将动态 import 编译成预加载的代码的呢？

从源码的`transform`钩子[实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FimportAnalysisBuild.ts%23L111)中，不难发现 Vite 会将动态 import 的代码进行转换，如下代码所示:

```ts
// 转换前
import('a')
// 转换后
__vitePreload(() => 'a', __VITE_IS_MODERN__ ?"__VITE_PRELOAD__":void)
```

其中，`__vitePreload` 会被加载为前文中的 `preload` 工具函数，`__VITE_IS_MODERN__` 会在 [renderChunk](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FimportAnalysisBuild.ts%23L208) 中被替换成 true 或者 false，表示是否为 Modern 模式打包，而对于`"__VITE_PRELOAD__"`，Vite 会在 [generateBundle](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FimportAnalysisBuild.ts%23L208) 阶段，分析出 a 模块所有依赖文件(包括 CSS)，将依赖文件名的数组作为 preload 工具函数的第二个参数。

同时，对于 Vite 独有的 import.meta.glob 语法，也会在这个插件中进行编译，如:

```ts
const modules = import.meta.glob('./dir/*.js')
```

会通过插件转换成下面这段代码:

```ts
const modules = {
  './dir/foo.js': () => import('./dir/foo.js'),
  './dir/bar.js': () => import('./dir/bar.js')
}
```

具体的实现在 [transformImportGlob](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2F075128a8dd0a2680540179dad2277a797f793199%2Fpackages%2Fvite%2Fsrc%2Fnode%2FimportGlob.ts%23L11) 函数中，除了被该插件使用外，这个函数被还依赖预构建、开发环境 import 分析等核心流程使用，属于一类比较底层的逻辑，感兴趣的同学可以精读一下这部分的实现源码。

###### 3.8 JS 压缩插件

Vite 中提供了两种 JS 代码压缩的工具，即 Esbuild 和 Terser，分别由两个插件插件实现:

- **vite:esbuild-transpile** ([点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fesbuild.ts%23L219))。在 renderChunk 阶段，调用 Esbuild 的 transform API，并指定 minify 参数，从而实现 JS 的压缩。
- **vite:terser**([点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fterser.ts%23L23))。同样也在 renderChunk 阶段，Vite 会单独的 Worker 进程中调用 Terser 进行 JS 代码压缩。

###### 3.9 构建报告插件

主要由三个插件输出构建报告:

- **vite:manifest**([点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fmanifest.ts))。提供打包后的各种资源文件及其关联信息，如下内容所示:

```json
// manifest.json
{
  "index.html": {
    "file": "assets/index.8edffa56.js",
    "src": "index.html",
    "isEntry": true,
    "imports": [
      // JS 引用
      "_vendor.71e8fac3.js"
    ],
    "css": [
      // 样式文件应用
      "assets/index.458f9883.css"
    ],
    "assets": [
      // 静态资源引用
      "assets/img.9f0de7da.png"
    ]
  },
  "_vendor.71e8fac3.js": {
    "file": "assets/vendor.71e8fac3.js"
  }
}
```

- **vite:ssr-manifest**([点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Fmanifest.ts))。提供每个模块与 chunk 之间的映射关系，方便 SSR 时期通过渲染的组件来确定哪些 chunk 会被使用，从而按需进行预加载。最后插件输出的内容如下:

```ts
ts
复制代码// ssr-manifest.json
{
  "node_modules/object-assign/index.js": [
    "/assets/vendor.71e8fac3.js"
  ],
  "node_modules/object-assign/index.js?commonjs-proxy": [
    "/assets/vendor.71e8fac3.js"
  ],
  // 省略其它模块信息
}
```

- **vite:reporter**([点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2Freporter.ts))。主要提供打包时的命令行构建日志:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d5b15eb7fd347da9b838c983047321b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

##### 4. 开发环境特有插件

###### 4.1 客户端环境变量注入插件

在开发环境中，Vite 会自动往 HTML 中注入一段 client 的脚本([点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fserver%2Fmiddlewares%2FindexHtml.ts%23L159)):

```ts
<script type="module" src="/@vite/client"></script>
```

这段脚本主要提供`注入环境变量`、`处理 HMR 更新逻辑`、`构建出现错误时提供报错界面`等功能，而我们这里要介绍的`vite:client-inject`就是来完成环境变量的注入，将 client 脚本中的`__MODE__`、`__BASE__`、`__DEFINE__`等等字符串替换为运行时的变量，实现环境变量以及 HMR 相关上下文信息的注入，[点击查看插件实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FclientInjections.ts)。

###### 4.2 开发阶段 import 分析插件

最后，Vite 会在开发阶段加入 import 分析插件，即`vite:import-analysis`。与之前所介绍的`vite:build-import-analysis`相对应，主要处理 import 语句相关的解析和重写，但`vite:import-analysis` 插件的关注点会不太一样，主要围绕 Vite 开发阶段的各项特性来实现，我们可以来梳理一下这个插件需要做哪些事情:

- 对 bare import，将路径名转换为真实的文件路径，如:

```ts
// 转换前
import 'foo'
// 转换后
// tip: 如果是预构建的依赖，则会转换为预构建产物的路径
import '/@fs/project/node_modules/foo/dist/foo.js'
```

主要调用 `PluginContainer`的上下文对象方法即`this.resolve`实现，这个方法会调用所有插件的 resolveId 方法，包括之前介绍的`vite:pre-alias`和`vite:resolve`，完成路径解析的核心逻辑，[点击查看实现](https://link.juejin.cn/?target=)。

- 对于 HMR 的客户端 API，即 `import.meta.hot`，Vite 在识别到这样的 import 语句后，一方面会注入 import.meta.hot 的实现，因为浏览器原生并不具备这样的 API，[点击查看注入代码](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FimportAnalysis.ts%23L502)；另一方面会识别 accept 方法，并判断 accept 是否为`接受自身更新`的类型(如果对 HMR 更新类型还不了解，可以回顾一下[第十三节](https://juejin.cn/book/7050063811973218341/section/7065976180020609032)的内容)，如果是，则标记为上`isSelfAccepting` 的 flag，便于 HMR 在服务端进行更新时进行`HMR Boundary`的查找。对于具体的查找过程，下一节会详细介绍。
- 对于全局环境变量读取语句，即 `import.meta.env`，Vite 会注入 `import.meta.env` 的实现，也就是如下的`env`字符串:

```ts
// config 即解析完的配置
let env = `import.meta.env = ${JSON.stringify({
  ...config.env,
  SSR: !!ssr
})};`
// 对用户配置的 define 对象中，将带有 import.meta.env 前缀的全局变量挂到 import.meta.env 对象上
for (const key in config.define) {
  if (key.startsWith(`import.meta.env.`)) {
    const val = config.define[key]
    env += `${key} = ${
      typeof val === 'string' ? val : JSON.stringify(val)
    };`
  }
}
```

- 对于`import.meta.glob`语法，Vite 同样会调用之前提到的`transformImportGlob` 函数来进行语法转换，但与生产环境的处理不同，在转换之后，Vite 会将该模块通过 glob 导入的依赖模块记录在 server 实例上，以便于 HMR 更新的时候能得到更准确的模块依赖信息，[点击查看实现](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fblob%2Fv2.7.0%2Fpackages%2Fvite%2Fsrc%2Fnode%2Fplugins%2FimportAnalysis.ts%23L324)。



### 要自己安装的常用的插件

#### Vite 语法降级与 Polyfill 注入

用于生产环境的构建包会假设目标浏览器支持现代 JavaScript 语法。默认情况下，Vite 的目标浏览器是指能够 [支持原生 ESM script 标签](https://caniuse.com/es6-module) 和 [支持原生 ESM 动态导入](https://caniuse.com/es6-module-dynamic-import) 的。作为参考，Vite 使用这个 [browserslist](https://github.com/browserslist/browserslist) 作为查询标准：

```
defaults and supports es6-module and supports es6-module-dynamic-import, not opera > 0, not samsung > 0, not and_qq > 0
```

你也可以通过 [`build.target` 配置项](https://vitejs.cn/config/#build-target) 指定构建目标，最低支持 `es2015`。

请注意，默认情况下 Vite 只处理语法转译，且 **默认不包含任何 polyfill**。你可以前往 [Polyfill.io](https://polyfill.io/v3/) 查看，这是一个基于用户浏览器 User-Agent 字符串自动生成 polyfill 包的服务。

Vite 官方已经为我们封装好了一个开箱即用的方案: `@vitejs/plugin-legacy`。这个插件内部同样使用 `@babel/preset-env` 以及 `core-js`等一系列基础库来进行语法降级和 Polyfill 注入。

##### 插件使用

首先让我们来安装一下官方的插件:

```ts
pnpm i @vitejs/plugin-legacy -D
```

随后在项目中使用它:

```ts
// vite.config.ts
import legacy from '@vitejs/plugin-legacy';
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    // 省略其它插件
    legacy({
      // 设置目标浏览器，browserslist 配置语法
      targets: ['ie >= 11'],
    })
  ]
})
```

我们可以通过`targets`指定目标浏览器，这个参数在插件内部会透传给`@babel/preset-env`。





###### [@vitejs/plugin-legacy](https://github.com/vitejs/vite/tree/main/packages/plugin-legacy) 

[参考资料](https://blog.csdn.net/qj11803017/article/details/121766133)

首先安装插件：`pnpm add @vitejs/plugin-legacy -D`
·然后在vite.config.js中配置

```javascript
import legacyPlugin from '@vitejs/plugin-legacy'
export default defineConfig( {
    plugins: [
        legacyPlugin({
            targets:['chrome 52'],  // 需要兼容的目标列表，可以设置多个
            additionalLegacyPolyfills:['regenerator-runtime/runtime'] // 面向IE11时需要此插件
        })
    ]
})
```





###### [build.target](https://vitejs.cn/config/#build-target)

- **类型：** `string | string[]`

- **默认：** `'modules'`

  设置最终构建的浏览器兼容目标。默认值是一个 Vite 特有的值——`'modules'`，这是指 [支持原生 ES 模块的浏览器](https://caniuse.com/es6-module)。

  另一个特殊值是 “esnext” —— 即假设有原生动态导入支持，并且将会转译得尽可能小：

  - 如果 [`build.minify`](https://vitejs.cn/config/#build-minify) 选项为 `'terser'`， `'esnext'` 将会强制降级为 `'es2019'`。
  - 其他情况下将完全不会执行转译。

  转换过程将会由 esbuild 执行，并且此值应该是一个合法的 [esbuild 目标选项](https://esbuild.github.io/api/#target)。自定义目标也可以是一个 ES 版本（例如：`es2015`）、一个浏览器版本（例如：`chrome58`）或是多个目标组成的一个数组。

  注意：如果代码包含不能被 `esbuild` 安全地编译的特性，那么构建将会失败。查看 [esbuild 文档](https://esbuild.github.io/content-types/#javascript) 获取更多细节。



###### [build.cssTarget](https://vitejs.cn/config/#build-csstarget)

- **类型：** `string | string[]`

- **默认值：** 与 [`build.target`](https://vitejs.cn/config/#build-target) 一致

  此选项允许用户为 CSS 的压缩设置一个不同的浏览器 target，此处的 target 并非是用于 JavaScript 转写目标。

  应只在针对非主流浏览器时使用。 最直观的示例是当你要兼容的场景是安卓微信中的 webview 时，它支持大多数现代的 JavaScript 功能，但并不支持 [CSS 中的 `#RGBA` 十六进制颜色符号](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors)。 这种情况下，你需要将 `build.cssTarget` 设置为 `chrome61`，以防止 vite 将 `rgba()` 颜色转化为 `#RGBA` 十六进制符号的形式。













##### 插件效果

在引入插件后，我们可以尝试执行`npm run build`对项目进行打包，可以看到如下的产物信息:

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b0cd1289814da78e89c90cc7aed81a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

相比一般的打包过程，多出了`index-legacy.js`、`vendor-legacy.js`以及`polyfills-legacy.js`三份产物文件。让我们继续观察一下`index.html`的产物内容:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/assets/favicon.17e50649.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
    <!-- 1. Modern 模式产物 -->
    <script type="module" crossorigin src="/assets/index.c1383506.js"></script>
    <link rel="modulepreload" href="/assets/vendor.0f99bfcc.js">
    <link rel="stylesheet" href="/assets/index.91183920.css">
  </head>
  <body>
    <div id="root"></div>
    <!-- 2. Legacy 模式产物 -->
    <script nomodule>兼容 iOS nomodule 特性的 polyfill，省略具体代码</script>
    <script nomodule id="vite-legacy-polyfill" src="/assets/polyfills-legacy.36fe2f9e.js"></script>
    <script nomodule id="vite-legacy-entry" data-src="/assets/index-legacy.c3d3f501.js">System.import(document.getElementById('vite-legacy-entry').getAttribute('data-src'))</script>
  </body>
</html>
```

通过官方的`legacy`插件， Vite 会分别打包出`Modern`模式和`Legacy`模式的产物，然后将两种产物插入同一个 HTML 里面，`Modern`产物被放到 `type="module"`的 script 标签中，而`Legacy`产物则被放到带有 [nomodule](https://link.juejin.cn/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FHTML%2FElement%2Fscript%23attr-nomodule) 的 script 标签中。浏览器的加载策略如下图所示:

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230219214916811.png" alt="image-20230219214916811" style="zoom:50%;" />









##### 插件执行原理

在具体的代码语法层面，插件还需要考虑语法降级和 Polyfill 按需注入的问题，接下来我们就来分析一下 Vite 的官方`legacy`插件是如何解决这些问题的。

官方的`legacy`插件是一个相对复杂度比较高的插件，这里我梳理了画了一张简化后的流程图，接下来我们就根据这张流程图来一一拆解这个插件在各个钩子阶段到底做了些什么。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3363652bc9bd4118af2896c9b1cce9cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

首先是在`configResolved`钩子中调整了`output`属性，这么做的目的是让 Vite 底层使用的打包引擎 Rollup 能另外打包出一份`Legacy 模式`的产物，实现代码如下:

```ts
const createLegacyOutput = (options = {}) => {
  return {
    ...options,
    // system 格式产物
    format: 'system',
    // 转换效果: index.[hash].js -> index-legacy.[hash].js
    entryFileNames: getLegacyOutputFileName(options.entryFileNames),
    chunkFileNames: getLegacyOutputFileName(options.chunkFileNames)
  }
}

const { rollupOptions } = config.build
const { output } = rollupOptions
if (Array.isArray(output)) {
  rollupOptions.output = [...output.map(createLegacyOutput), ...output]
} else {
  rollupOptions.output = [createLegacyOutput(output), output || {}]
}
```

接着，在`renderChunk`阶段，插件会对 Legacy 模式产物进行语法转译和 Polyfill 收集，值得注意的是，这里并不会真正注入`Polyfill`，而仅仅只是收集`Polyfill`，:

```ts
{
  renderChunk(raw, chunk, opts) {
    // 1. 使用 babel + @babel/preset-env 进行语法转换与 Polyfill 注入
    // 2. 由于此时已经打包后的 Chunk 已经生成
    //   这里需要去掉 babel 注入的 import 语句，并记录所需的 Polyfill
    // 3. 最后的 Polyfill 代码将会在 generateBundle 阶段生成
  }
}
```

由于场景是应用打包，这里直接使用 @babel/preset-env 的`useBuiltIns: 'usage'`来进行全局 Polyfill 的收集是比较标准的做法。

回到 Vite 构建的主流程中，接下来会进入`generateChunk`钩子阶段，现在 Vite 会对之前收集到的`Polyfill`进行统一的打包，实现也比较精妙，主要逻辑集中在`buildPolyfillChunk`函数中:

```ts
// 打包 Polyfill 代码
async function buildPolyfillChunk(
  name,
  imports
  bundle,
  facadeToChunkMap,
  buildOptions,
  externalSystemJS
) {
  let { minify, assetsDir } = buildOptions
  minify = minify ? 'terser' : false
  // 调用 Vite 的 build API 进行打包
  const res = await build({
    // 根路径设置为插件所在目录
    // 由于插件的依赖包含`core-js`、`regenerator-runtime`这些运行时基础库
    // 因此这里 Vite 可以正常解析到基础 Polyfill 库的路径
    root: __dirname,
    write: false,
    // 这里的插件实现了一个虚拟模块
    // Vite 对于 polyfillId 会返回所有 Polyfill 的引入语句
    plugins: [polyfillsPlugin(imports, externalSystemJS)],
    build: {
      rollupOptions: {
        // 访问 polyfillId
        input: {
          // name 暂可视作`polyfills-legacy`
          // pofyfillId 为一个虚拟模块，经过插件处理后会拿到所有 Polyfill 的引入语句
          [name]: polyfillId
        },
      }
    }
  });
  // 拿到 polyfill 产物 chunk
  const _polyfillChunk = Array.isArray(res) ? res[0] : res
  if (!('output' in _polyfillChunk)) return
  const polyfillChunk = _polyfillChunk.output[0]
  // 后续做两件事情:
  // 1. 记录 polyfill chunk 的文件名，方便后续插入到 Modern 模式产物的 HTML 中；
  // 2. 在 bundle 对象上手动添加 polyfill 的 chunk，保证产物写到磁盘中
}
```

因此，你可以理解为这个函数的作用即通过 `vite build` 对`renderChunk`中收集到 polyfill 代码进行打包，生成一个单独的 chunk:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/48ef64e0100a46f38b602b3b9a08560b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> 需要注意的是，polyfill chunk 中除了包含一些 core-js 和 regenerator-runtime 的相关代码，也包含了 `SystemJS` 的实现代码，你可以将其理解为 ESM 的加载器，实现了在旧版浏览器下的模块加载能力。

现在我们已经能够拿到 Legacy 模式的产物文件名及 Polyfill Chunk 的文件名，那么就可以通过`transformIndexHtml`钩子来将这些产物插入到 HTML 的结构中:

```ts
{
  transformIndexHtml(html) {
    // 1. 插入 Polyfill chunk 对应的 <script nomodule> 标签
    // 2. 插入 Legacy 产物入口文件对应的 <script nomodule> 标签
  }
}
```

OK，Vite 官方的 legacy 插件的主要原理就介绍到这里，为了方便大家理解，讲解的过程中忽略了一些与主流程关联不大的细节，最后给大家补充一下，感兴趣的同学可以继续深入学习:

- 当插件参数中开启了`modernPolyfills`选项时，Vite 也会自动对 Modern 模式的产物进行 Polyfill 收集，并单独打包成`polyfills-modern.js`的 chunk，原理和 Legacy 模式下处理 Polyfill 一样。
- Sarari 10.1 版本不支持 `nomodule`，为此需要单独引入一些补丁代码，[点击查看](https://link.juejin.cn/?target=https%3A%2F%2Fgist.github.com%2Fsamthor%2F64b114e4a4f539915a95b91ffd340acc)。
- 部分低版本 Edge 浏览器虽然支持 type="module"，但不支持动态 import，为此也需要插入一些[补丁代码](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fvite%2Fpull%2F3885)，针对这种情况下降级使用 Legacy 模式的产物。









#### 统计编译、热更新各个阶段的耗时，看到分别被每个插件处理完后的结果（常用于开发调试插件）

vite-plugin-inspect 可以统计 开发阶段各个插件 编译的时间和编译结果，也可以在打包的时候开启 DEBUG 环境变量。

在开发调试插件的过程，我推荐大家在本地装上`vite-plugin-inspect`插件:

```ts
// vite.config.ts
import inspect from 'vite-plugin-inspect';

// 返回的配置
{
  plugins: [
    // 省略其它插件
    inspect()
  ]
}
```

这样当你再次启动项目时，会发现多出一个调试地址:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/606340bc8b9b4f81be0b0ac22516f838~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

你可以通过这个地址来查看项目中各个模块的编译结果：

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e972fc35eac4c168872317709707e5a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

点击特定的文件后，你可以看到这个模块经过各个插件处理后的中间结果，如下图所示:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d40c06d94c96412cbf9fc2dccf35d5f1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)





#### 配置mock

##### 在 `vite.config.ts` 中配置：

```ts
import mockPlugin from '@veno/vite-plugin-mock';
plugins: [
mockPlugin({
dir: 'mock',
enable: process.env.MOCK === 'true',
}),
],
```

##### 在`package.json`添加脚本:

`"mock": "MOCK=true vite --host"`

##### mock 目录：

请求的 path 就是 mock 目录下的文件路径



#### 雪碧图

vite-plugin-svg-icons





#### 开发环境使用http2

在 Vite 中，我们可以通过`vite-plugin-mkcert`在本地 Dev Server 上开启 HTTP2:

```css
pnpm i vite-plugin-mkcert -D
```

然后在 Vite 配置中进行使用:

```ts
// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import mkcert from "vite-plugin-mkcert";

export default defineConfig({
  plugins: [react(), mkcert()],
  server: {
    // https 选项需要开启
    https: true,
  },
});
```

插件的原理也比较简单，由于 HTTP2 依赖 TLS 握手，插件会帮你自动生成 TLS 证书，然后支持通过 HTTPS 的方式启动，而 Vite 会自动把 HTTPS 服务升级为 HTTP2。

> 其中有一个特例，即当你使用 Vite 的 proxy 配置时，Vite 会将 HTTP2 降级为 HTTPS，不过这个问题你可以通过[vite-plugin-proxy-middleware](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fwilliamyorkl%2Fvite-plugin-proxy-middleware)插件解决。



#### vite中使用模块联邦

社区中已经提供了一个比较成熟的 Vite 模块联邦方案: `vite-plugin-federation`，这个方案基于 Vite(或者 Rollup) 实现了完整的模块联邦能力。接下来，我们基于它来实现模块联邦应用。

首先初始化两个 Vue 的脚手架项目`host`和`remote`，然后分别安装`vite-plugin-federation`插件:

```ts
pnpm install @originjs/vite-plugin-federation -D
```

在配置文件中分别加入如下的配置:

```ts
// 远程模块配置
// remote/vite.config.ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import federation from "@originjs/vite-plugin-federation";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    vue(),
    // 模块联邦配置
    federation({
      name: "remote_app",
      filename: "remoteEntry.js",
      // 导出模块声明
      exposes: {
        "./Button": "./src/components/Button.js",
        "./App": "./src/App.vue",
        "./utils": "./src/utils.ts",
      },
      // 共享依赖声明
      shared: ["vue"],
    }),
  ],
  // 打包配置
  build: {
    target: "esnext",
  },
});

// 本地模块配置
// host/vite.config.ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue";
import federation from "@originjs/vite-plugin-federation";

export default defineConfig({
  plugins: [
    vue(),
    federation({
      // 远程模块声明
      remotes: {
        remote_app: "http://localhost:3001/assets/remoteEntry.js",
      },
      // 共享依赖声明
      shared: ["vue"],
    }),
  ],
  build: {
    target: "esnext",
  },
});
```

在如上的配置中，我们完成了远程模块的模块导出及远程模块在本地模块的注册，对于远程模块的具体实现，你可以参考小册的 Github 仓库，这里就不一一赘述了。接下来我们把关注点放在如何使用远程模块上面。

首先我们需要对远程模块进行打包，在 remote 路径下依赖执行:

```ts
// 打包产物
pnpm run build
// 模拟部署效果，一般会在生产环境将产物上传到 CDN 
npx vite preview --port=3001 --strictPort
```

然后我们在 `host`项目中使用远程模块:

```ts
<script setup lang="ts">
import HelloWorld from "./components/HelloWorld.vue";
import { defineAsyncComponent } from "vue";
// 导入远程模块
// 1. 组件
import RemoteApp from "remote_app/App";
// 2. 工具函数
import { add } from "remote_app/utils";
// 3. 异步组件
const AysncRemoteButton = defineAsyncComponent(
  () => import("remote_app/Button")
);
const data: number = add(1, 2);
</script>

<template>
  <div>
    <img alt="Vue logo" src="./assets/logo.png" />
    <HelloWorld />
    <RemoteApp />
    <AysncRemoteButton />
    <p>应用 2 工具函数计算结果: 1 + 2 = {{ data }}</p>
  </div>
</template>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>
```

启动项目后你可以看到如下的结果:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f5ca3b5434d4755abe67b0d66025e2d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

应用 2 的组件和工具函数逻辑已经在应用 1 中生效，也就是说，我们完成了远程模块在本地模块的运行时引入。

让我们来梳理一下整体的使用流程:

- 1. 远程模块通过`exposes` 注册导出的模块，本地模块通过 `remotes` 注册远程模块地址。
- 1. 远程模块进行构建，并部署到云端。
- 1. 本地通过`import '远程模块名称/xxx'`的方式来引入远程模块，实现运行时加载。

当然，还有几个要点需要给大家补充一下:

1. 在模块联邦中的配置中，`exposes` 和`remotes`参数其实并不冲突，也就是说一个模块既可以作为本地模块，又可以作为远程模块。
2. 由于 Vite 的插件机制与 Rollup 兼容，`vite-plugin-federation`方案在 Rollup 中也是完全可以使用的。









## Rollup

Rollup 默认不会打包 `node_modules` 中的第三方依赖。Rollup默认只处理 ES6 模块。

如果你想让 Rollup 能够处理 `node_modules` 中的第三方依赖，你需要使用 @rollup/plugin-node-resolve 插件。这个插件可以让 Rollup 理解 Node.js 的模块解析机制。

另外，如果你的第三方依赖是 CommonJS 模块，你还需要使用 @rollup/plugin-commonjs 插件来将 CommonJS 模块转换为 ES6 模块，因为 Rollup 只能处理 ES6 模块。





## 其它打包工具

- tsup: Esbuild 打包代码，Rollup 和 rollup-plugin-dts 打包 TS 类型
- unbuild: 原理同 tsup，另外包含 bundleless 模式



## 开发服务器

Dev Server 本质上是一个开发阶段使用的 HTTP Server，它主要包含如下的作用:

- 对资源进行编译，然后将编译产物返回给浏览器
- 实现模块热更新，在文件改动时能推送更新到浏览器
- 静态资源服务，比如支持访问图片等静态资源





# 移动端

### 单位

#### 写在 style 里的样式：

##### px --> vw

利用 postcss-px-to-viewport-vite-plugin 将 px 单位自动转为 vw
在 `vite.config.ts` 中配置：

```
import px2viewportPlugin from 'postcss-px-to-viewport-vite-plugin';
import autoprefixer from 'autoprefixer';
    css: {
        postcss: {
            plugins: [
                autoprefixer,
                px2viewportPlugin({
                    viewportWidth: 414, // 开发时根据414px的设计稿去写px的值
                    unitPrecision: 3, // 指定`px`转换为视窗单位值的小数位数（很多时候无法整除)
                    viewportUnit: 'vw',
                    selectorBlackList: ['.haspx'], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名
                    minPixelValue: 1, // 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值
                    fontViewportUnit: 'vw',
                    exclude: /node_modules/,
                    mediaQuery: true,
                }),
            ],
        },
    },
```



##### px --> rem

```js
import px2rem from 'postcss-pxtorem';
        css: {
            postcss: {
                plugins: [
                    autoprefixer(),
                    px2rem({
                        rootValue: 100,
                        propList: ['*'],
                    }),
                ],
            },
        },
```



#### 写在 ts 里的单位

借助 utils/mobile/unit.ts 里的 pxtorem 方法将 px 转换为 rem，如果是大屏幕则先使用 transViewValue 将 px 数值转为大屏下的 px 数值。
如果想保留 px 不被转化，则写成 PX 或 Px，然后添加注释//prettier-ignore 避免被 prettier 自动格式化。

```css
.foo {
  //prettier-ignore
  width: 1PX;
  //prettier-ignore
  height: 1Px;
}
```

### 大屏适配

控制页面最大 max-width：560px

### 字体

#### 字重

移动端可靠字重只有 400、700

只有 400 和 700 才有 normal 和 bold 这样的等价写法，其他值都必须写数字。且中文网站极少用到 normal 和 bold 之外的 font-weight 值，实在没有必要写数字。

由于用到 normal 和 bold 之外的 font-weight 值时，如果字体包不支持就会采用字重匹配规则，这就会跟预期效果有所偏差

- 「font-weight」不是为了告诉浏览器以多高的字重来「**绘制**」文字，而是告诉其在「font-family」匹配到的一个字体集合中如何继续「**匹配**」符合字重要求的字体。

- 通常情况下，一个特定的字体仅会包含少数的可用字重（实际效果还取决于字体包本身的支持情况）。若所指定的字重不存在直接匹配，则会通过字体匹配算法规则匹配使用邻近的可用字重 **。**

- bolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。





#### 裁剪字体

##### 场景释义

特殊字体：页面中非系统字体，页面不能直接显示的。当文案不可控，特殊字体过多的时候，需要通过裁剪来得到一个字体子集。

##### 字体分类

通常为中文汉字，以及数字两种。中文字体体积较大，且每次活动都不尽相同，需要特殊处理。数字一般从英文字体抽出，体积较小。对于常用数字字体 DIN，可以直接使用@pet/style.utils

##### **工具**



GUI：

[Fontmin App](https://github.com/ecomfe/fontmin-app)



推荐使用 [Fontmin](https://github.com/ecomfe/fontmin)。（其他工具：[font-spider](https://github.com/aui/font-spider)）

Fontmin的通常使用方式：可以在postdev以及postbuild阶段调用

以上为一段脚本示例：

build-font.mjs

```js
import Fontmin from 'fontmin';
import fs from 'fs';
const words = JSON.parse(fs.readFileSync('./src/config/custom-texts.json'));
const allText = Object.values(words).join();
const fontmin = new Fontmin()
    .src('font/HAN.ttf')
    .use(
        Fontmin.glyph({
            text: allText,
        }),
    )
    .use(Fontmin.ttf2woff())
    .dest('src/assets/font/custom');

fontmin.run(function (err) {
    console.log('\x1b[32m%s\x1b[0m', 'Now build fonts');
    if (err) {
        throw err;
    }
    console.log('\x1b[32m%s\x1b[0m', allText);
    console.log('\x1b[32m%s\x1b[0m', 'ALL DONE');
});
```



##### **字符集抽取**

对于S级大型活动，一般特殊字体的使用字符数较多，且不可控。一般通过直接抽取常用中文汉字的方式处理

这里提供一份22CNY字符集

```txt
啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱碱拣捡简俭剪减荐槛鉴践贱见键箭件健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利僳例俐痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃汀廷停亭庭艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座
0123456789加油，继续戳我！再戳快一点哦暴击 666今年暴富～哇
太棒了！哇哦，赞财星高照福气多多～太酷了快结束了，冲呀是个狠人第一轮红包雨即将来袭呦幼口禧
加油啊，继续点击！ 再点快一点哦~ 暴击666！ 今年暴富~ 哇哦，太棒了！ 哇哦，赞！
财星高照~ 福气多多~ 太酷啦！ 快结束了，冲呀！ 太厉害啦！' 山楂树下 王者荣耀：
【鲁班七号，杨玉环，廉颇，孙膑，裴擒虎】史诗皮肤 大闹天宫：
齐天大圣、二郎神、玉皇大帝、太白金星、托塔李天王、哪吒，大圣盲盒 葫芦娃：
大娃，一娃，二娃，三娃，四娃，五娃，六娃，七娃，葫芦娃盲盒
谷粒多，山楂树下，联通，上汽大众，京东，和平精英，家化，众安保险，花西子，茉 :
骰子
```



##### **剪裁字体引入**

通过 [@font-face](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face) 引用构建好的字符集

```
@font-face {
    font-family: FooBar;
    src: '@/your/fonts/foobar.ttf';
    font-weight: normal;
    font-style: normal;
    font-display: swap;
}

.g-font-han {
		font-family: FooBar, sans-serif;
}
```





##### **字符集管理**

如果是脚本构建，推荐将**构建产物**路径添加至 gitignore 文件，避免每次提交冲突



##### **相关组件**

在活动中，特殊字体一般出现于大标题中，所以通过调用[@pet/base.heading]组件，可以更好的统一管理特殊字体。**只需统一收口关注** g-font-han 这个类的 font-family 的定义。



##### **体验优化**

当首屏没有特殊字体调用（可能是弹窗内引用），可以提前通过隐藏字符触发特殊字体的调用，从而避免字符渲染的抖动。



##### **设计约定**

一次活动尽可能只使用一种特殊中文字体，对于用户名或者非文字受控场景，选用系统默认字体，避免使用特殊字体





#### 最小字体

移动端支持小于12px的字体，但最小到多少不知道。







### 设备兼容

在 `vite.config.ts` 中配置：

```
import legacy from '@vitejs/plugin-legacy';
plugins: [
legacy({
targets: ['iOS >= 10', 'Android >= 6'],
additionalLegacyPolyfills: ['regenerator-runtime/runtime'],
}),
],

```





### 适配ios16 中webview会被拖拽的问题

添加全局样式：

```css
 /*ios 16only*/
 @supports (-webkit-hyphens:none) and (overscroll-behavior:none){
 	html {
 		overscroll-behavior: none;
 	}
 	#app {
 		min-height: calc(100vh + 0.5px)
 	}
 }
```





### fastclick库

解决移动端点击延迟 300ms 的问题





## 离线包

https://juejin.cn/post/6844904031773523976

![image-20231230154037861](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-30-15-40-image-20231230154037861.png)





# <span id="gongchenghuagongju">工程化</span>工具

## 兼容性

### 旧版浏览器的语法兼容问题主要分两类

**语法降级问题**和 **Polyfill 缺失问题**。前者比如某些浏览器不支持箭头函数，需要将其转换为`function(){}`语法；而后者`Polyfill`本身可以翻译为`垫片`，也就是为浏览器提前注入一些 API 的实现代码，如`Object.entries`方法的实现，这样可以保证产物可以正常使用这些 API，防止报错。

### 底层工具链(babel里都集成了，所以这里就是将babel)

#### 工具概览

解决上述提到的两类语法兼容问题，主要需要用到两方面的工具，分别包括:

- **编译时工具**。代表工具有`@babel/preset-env`和`@babel/plugin-transform-runtime`。
- **运行时基础库**。代表库包括`core-js`和`regenerator-runtime`。

**编译时工具**的作用是在代码编译阶段进行<font color="red">**语法降级**及**添加 `polyfill` 代码的引用语句**</font>，如:

```ts
import "core-js/modules/es6.set.js"
```

而**运行时基础库**是根据 `ESMAScript`官方语言规范提供各种`Polyfill`实现代码，主要包括`core-js`和`regenerator-runtime`两个基础库，不过在 babel 中也会有一些上层的封装，包括：

- [@babel/polyfill](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-polyfill)

- [@babel/runtime](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-runtime)

- [@babel/runtime-corejs2](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-runtime-corejs2)

- [@babel/runtime-corejs3](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Fdocs%2Fen%2Fbabel-runtime-corejs3) 

  看似各种运行时库眼花缭乱，其实都是`core-js`和`regenerator-runtime`不同版本的封装罢了(`@babel/runtime`是个特例，不包含 core-js 的 Polyfill)。这类库是项目运行时必须要使用到的，因此一定要放到`package.json`中的`dependencies`中！

#### 实际使用

##### 初始化

接下来我们来通过代码实操的方式来学习这些工具，代码我也已经放到了[仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsanyuan0704%2Fjuejin-book-vite%2Ftree%2Fmain%2Fpolyfill%2Fbabel-test)中，你可以对照学习。

如果你没拉取仓库的代码，可以先按照如下的命令初始化项目:

```arduino
mkdir babel-test
npm init -y
```

然后安装一些必要的依赖:

```bash
pnpm i @babel/cli @babel/core @babel/preset-env
```

我解释一下各个依赖的作用:

- `@babel/cli`: 为 babel 官方的脚手架工具，很适合我们练习用。
- `@babel/core`: babel 核心编译库。
- `@babel/preset-env`: babel 的预设工具集，基本为 babel 必装的库。`@babel/preset-env` 的方案也存在一定局限性:
  - 如果使用新特性，往往是通过基础库(如 core-js)往全局环境添加 Polyfill，如果是开发应用没有任何问题，如果是开发第三方工具库，则很可能会对**全局空间造成污染**。
  - 很多工具函数的实现代码(如`_defineProperty`方法)，会在许多文件中重现出现，造成**文件体积冗余**。

接着新建 `src` 目录，在目录下增加`index.js`文件:

```ts
const func = async () => {
  console.log(12123)
}

Promise.resolve().finally();
```

##### 配置

###### 配置文件

接下来新建`.babelrc.json`即 babel 的配置文件，内容如下:

```ts
{
  "presets": [
    [
      "@babel/preset-env", 
      {
        // 指定兼容的浏览器版本
        "targets": {
          "ie": "11"
        },
        // 基础库 core-js 的版本，一般指定为最新的大版本
        "corejs": 3,
        // Polyfill 注入策略，后文详细介绍
        "useBuiltIns": "usage",
        // 不将 ES 模块语法转换为其他模块语法
        "modules": false
      }
    ]
  ]
}
```

######  `targets`和`browserslist`

我们可以通过 `targets` 参数指定要兼容的浏览器版本，你既可以填如上配置所示的一个对象:

```ts
{
  "targets": {
    "ie": "11"
  }
}
```

也可以用 [Browserslist](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fbrowserslist%2Fbrowserslist) 配置语法:

```ts
{ 
  // ie 不低于 11 版本，全球超过 0.5% 使用，且还在维护更新的浏览器
  "targets": "ie >= 11, > 0.5%, not dead"
}
```

Browserslist 是一个帮助我们设置目标浏览器的工具，不光是 Babel 用到，其他的编译工具如`postcss-preset-env`、`autoprefix`中都有所应用。对于`Browserslist`的配置内容，你既可以放到 Babel 这种特定工具当中，也可以在`package.json`中通过`browserslist`声明:

```ts
// package.json
{ 
  "browserslist": "ie >= 11"
}
```

或者通过`.browserslistrc`进行声明:

```ts
// .browserslistrc
ie >= 11
```

在实际的项目中，一般我们可以将使用下面这些**最佳实践集合**来描述不同的浏览器类型，减轻配置负担:

```ts
// 现代浏览器
last 2 versions and since 2018 and > 0.5%
// 兼容低版本 PC 浏览器
IE >= 11, > 0.5%, not dead
// 兼容低版本移动端浏览器
iOS >= 9, Android >= 4.4, last 2 versions, > 0.2%, not dead
```

对于这些配置对应的具体浏览器列表，大家可以去 [browserslist.dev](https://link.juejin.cn/?target=https%3A%2F%2Fbrowserslist.dev) 站点查看:



###### `useBuiltIns`

它决定了添加 Polyfill 策略，默认是 `false`，即不添加任何的 Polyfill。你可以手动将`useBuiltIns`配置为`entry`或者`usage`，接下来我们看看这两个配置究竟有什么区别。

首先你可以将这个字段配置为`entry`，需要注意的是，`entry`配置规定你必须在入口文件手动添加一行这样的代码:

```ts
// index.js 开头加上
import 'core-js';
```

接着在终端执行下面的命令进行 Babel 编译:

```bash
npx babel src --out-dir dist
```

产物输出在`dist`目录中，你可以去观察一下产物的代码:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f56b93f6e9884779b7197d2ad369034b~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

Babel 已经根据`目标浏览器`的配置为我们添加了大量的 Polyfill 代码，`index.js`文件简单的几行代码被编译成近 300 行。实际上，Babel 所做的事情就是将你的`import "core-js"`代码替换成了产物中的这些具体模块的导入代码。

但这个配置有一个问题，即无法做到按需导入，上面的产物代码其实有大部分的 Polyfill 的代码我们并没有用到。接下来我们试试`useBuiltIns: usage`这个按需导入的配置，改动配置后执行编译命令:

```ts
npx babel src --out-dir dist
```

同样可以看到产物输出在了`dist/index.js`中，内容如下所示:

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eecb694e85494faaa63dc00688787a09~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

> Polyfill 代码主要来自 `corejs` 和 `regenerator-runtime`，因此如果要运行起来，必须要装这两个库。

可以发现 Polyfill 的代码精简了许多，真正地实现了按需 Polyfill 导入。



###### 更优的 Polyfill 注入方案: transform-runtime

接下来要介绍的`transform-runtime`方案，就是为了解决`@babel/preset-env`的种种局限性。

> 需要提前说明的是，`transform-runtime`方案可以作为`@babel/preset-env`中`useBuiltIns`配置的替代品，也就是说，一旦使用`transform-runtime`方案，你应该把`useBuiltIns`属性设为 `false`。

接下来我们来尝试一下这个方案，首先安装必要的依赖:

```ts
pnpm i @babel/plugin-transform-runtime -D // 编译时工具，用来转换语法和添加 Polyfill
pnpm i @babel/runtime-corejs3 -S // 运行时基础库，封装了`core-js`、`regenerator-runtime`和各种语法转换用到的`工具函数`。
```

> core-js 有三种产物，分别是`core-js`、`core-js-pure`和`core-js-bundle`。第一种是全局 Polyfill 的做法，@babel/preset-env 就是用的这种产物；第二种不会把 Polyfill 注入到全局环境，可以按需引入；第三种是打包好的版本，包含所有的 Polyfill，不太常用。`@babel/runtime-corejs3` 使用的是第二种产物。

接着我们对`.babelrc.json`作如下的配置:

```json
{
  "plugins": [
    // 添加 transform-runtime 插件
    [
      "@babel/plugin-transform-runtime", 
      {
        "corejs": 3
      }
    ]
  ],
  "presets": [
    [
      "@babel/preset-env", 
      {
        "targets": {
          "ie": "11"
        },
        "corejs": 3,
        // 关闭 @babel/preset-env 默认的 Polyfill 注入
        "useBuiltIns": false,
        "modules": false
      }
    ]
  ]
}
```

执行终端命令:

```ts
npx babel src --out-dir dist
```

我们可以对比一下 `@babel/preset-env`下的产物结果:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc40d9a6401640058b96c4821e6ff8c1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

经过对比我们不难发现，`transform-runtime` 一方面能够让我们在代码中使用`非全局版本`的 Polyfill，这样就避免全局空间的污染，这也得益于 `core-js` 的 pure 版本产物特性；另一方面对于`asyncToGeneator`这类的工具函数，它也将其转换成了一段引入语句，不再将完整的实现放到文件中，节省了编译后文件的体积。

另外，`transform-runtime`方案引用的基础库也发生了变化，不再是直接引入`core-js`和`regenerator-runtime`，而是引入`@babel/runtime-corejs3`。





#### 三个阶段

##### 总览

![image-20230730152349973](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-07-30-15-23-image-20230730152349973.png)



##### parsing

解析成**AST** ( Abstract Syntax Tree)。AST 描述源代码语法的每个部分及其相互关系



##### Transformation

使用 babel-traverse 遍历 AST，并修改成新的 AST 。



##### Code Generation



### es-check语法版本进行扫描

可以借助es-check工具来扫描构建的代码是否符合开发人员预期。es-check是一个命令行工具，它可以按照开发人员的要求对指定文件的语法版本进行扫描。当扫描到不符合的文件时，它会给出对应的提示信息。开发人员可以使用npm安装es-check。









## 规范代码

### ESlint

#### 检查

`/* eslint-disable */`顶部加这行代码可以忽略整个文件的eslint检查。





#### 介绍

##### 1. parser - 解析器

ESLint 底层默认使用 [Espree](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Feslint%2Fespree)来进行 AST 解析，这个解析器目前已经基于 `Acron` 来实现，虽然说 `Acron` 目前能够解析绝大多数的 [ECMAScript 规范的语法](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Facornjs%2Facorn%2Ftree%2Fmaster%2Facorn)，但还是不支持 TypeScript ，因此需要引入其他的解析器完成 TS 的解析。

社区提供了`@typescript-eslint/parser`这个解决方案，专门为了 TypeScript 的解析而诞生，将 `TS` 代码转换为 `Espree` 能够识别的格式(即 [**Estree 格式**](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Festree%2Festree))，然后在 Eslint 下通过`Espree`进行格式检查， 以此兼容了 TypeScript 语法。

##### 2. parserOptions - 解析器选项

这个配置可以对上述的解析器进行能力定制，默认情况下 ESLint 支持 ES5 语法，你可以配置这个选项，具体内容如下:

- ecmaVersion: 这个配置和 `Acron` 的 [ecmaVersion](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Facornjs%2Facorn%2Ftree%2Fmaster%2Facorn) 是兼容的，可以配置 `ES + 数字`(如 ES6)或者`ES + 年份`(如 ES2015)，也可以直接配置为`latest`，启用最新的 ES 语法。
- sourceType: 默认为`script`，如果使用 ES Module 则应设置为`module`
- ecmaFeatures: 为一个对象，表示想使用的额外语言特性，如开启 `jsx`。

##### 3. rules - 具体代码规则

`rules` 配置即代表在 ESLint 中手动调整哪些代码规则，比如`禁止在 if 语句中使用赋值语句`这条规则可以像如下的方式配置:

```ts
// .eslintrc.js
module.exports = {
  // 其它配置省略
  rules: {
    // key 为规则名，value 配置内容
    "no-cond-assign": ["error", "always"]
  }
}
```

在 rules 对象中，`key` 一般为`规则名`，`value` 为具体的配置内容，在上述的例子中我们设置为一个数组，数组第一项为规则的 `ID`，第二项为`规则的配置`。

规则的`ID`说明如下：

- `off` 或 `0`: 表示关闭规则。
- `warn` 或 `1`: 表示开启规则，不过违背规则后只抛出 warning，而不会导致程序退出。
- `error` 或 `2`: 表示开启规则，不过违背规则后抛出 error，程序会退出。

具体的规则配置可能会不一样，有的是一个字符串，有的可以配置一个对象，你可以参考 [ESLint 官方文档](https://link.juejin.cn/?target=https%3A%2F%2Fcn.eslint.org%2Fdocs%2Frules%2F)。

当然，你也能直接将 `rules` 对象的 `value` 配置成 ID，如: `"no-cond-assign": "error"`。

##### 4. plugins

上面提到过 ESLint 的 parser 基于`Acorn`实现，不能直接解析 TypeScript，需要我们指定 parser 选项为`@typescript-eslint/parser`才能兼容 TS 的解析。同理，ESLint 本身也没有内置 TypeScript 的代码规则，这个时候 ESLint 的插件系统就派上用场了。我们需要通过添加 ESLint 插件来增加一些特定的规则，比如添加`@typescript-eslint/eslint-plugin` 来拓展一些关于 TS 代码的规则，如下代码所示:

```js
// .eslintrc.js
module.exports = {
  // 添加 TS 规则，可省略`eslint-plugin`
  plugins: ['@typescript-eslint']
}
```

值得注意的是，添加插件后只是拓展了 ESLint 本身的规则集，但 ESLint 默认并**没有开启**这些规则的校验！如果要开启或者调整这些规则，你需要在 rules 中进行配置，如:

```js
// .eslintrc.js
module.exports = {
  // 开启一些 TS 规则
  rules: {
    '@typescript-eslint/ban-ts-comment': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
  }
}
```

##### 5. extends - 继承配置

extends 相当于`继承`另外一份 ESLint 配置，可以配置为一个字符串，也可以配置成一个字符串数组。主要分如下 3 种情况:

1. 从 ESLint 本身继承；
2. 从类似 `eslint-config-xxx` 的 npm 包继承；
3. 从 ESLint 插件继承。

```ts
// .eslintrc.js
module.exports = {
   "extends": [
     // 第1种情况 
     "eslint:recommended",
     // 第2种情况，一般配置的时候可以省略 `eslint-config`
     "standard"
     // 第3种情况，可以省略包名中的 `eslint-plugin`
     // 格式一般为: `plugin:${pluginName}/${configName}`
     "plugin:react/recommended"
     "plugin:@typescript-eslint/recommended",
   ]
}
```

有了 extends 的配置，对于之前所说的 ESLint 插件中的繁多配置，我们就**不需要手动一一开启**了，通过 extends 字段即可自动开启插件中的推荐规则:

```js
extends: ["plugin:@typescript-eslint/recommended"]
```

##### 6. env 和 globals

这两个配置分别表示`运行环境`和`全局变量`，在指定的运行环境中会预设一些全局变量，比如:

```js
// .eslint.js
module.export = {
  "env": {
    "browser": "true",
    "node": "true"
  }
}
```

指定上述的 `env` 配置后便会启用浏览器和 Node.js 环境，这两个环境中的一些全局变量(如 `window`、`global` 等)会同时启用。

有些全局变量是业务代码引入的第三方库所声明，这里就需要在`globals`配置中声明全局变量了。每个全局变量的配置值有 3 种情况:

1. `"writable"`或者 `true`，表示变量可重写；
2. `"readonly"`或者`false`，表示变量不可重写；
3. `"off"`，表示禁用该全局变量。

那`jquery`举例，我们可以在配置文件中声明如下:

```js
// .eslintrc.js
module.exports = {
  "globals": {
    // 不可重写
    "$": false, 
    "jQuery": false 
  }
}
```



#### 配置

这部分推荐 antfu/config 这个工具，或者直接使用 @umji/fabric 这类包，可以快速完成 eslint 配置。

接下来我们来利用 ESLint 官方的 cli 在现有的脚手架项目中进行初始化操作，首先我们需要安装 ESLint:

```bash
pnpm i eslint -D
```

接着执行 ESLint 的初始化命令，并进行如下的命令行交互:

```ts
npx eslint --init
```

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c71cb725150d4e5c9d46539916047ef1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

接着 ESLint 会帮我们自动生成`.eslintrc.js`配置文件。需要注意的是，在上述初始化流程中我们并没有用 npm 安装依赖，需要进行手动安装:

```bash
pnpm i eslint-plugin-vue@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D -w
```





`.eslintignore`

```
node_modules
offline
dist
*.mjs
engine-strict = true
```







#### 原理

#####  eslint 的实现原理简单概述

- 首先 这是一个循环的过程，上限是10次，默认修复 10 次还没修复完就终止。

  ![image-20230920162938584](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-20-16-29-image-20230920162938584.png)

- 每次循环都调用` verify`对传入的文本进行 lint，这里会对文本做 parse，产生 AST，然后调用各种 rule 来检查AST，返回的结果里（就是 problem 数组）包含了错误的信息和如何修复（具体就是把 range 范围的字符串替换成 text）。

- 然后再调用 `applyFixes(problem)` 执行 fix 的修复。它会有个标记变量，默认为 false，修复完设置为 true。（具体修复的实现就是个字符串替换）。



为什么会有remainingMessages（即剩下的错误）和 循环多次来修复 ：

1. 有的 problem 本身不支持 fix，没有 fix，那自然要把问题留下来；
2. 还有一个原因是两个 fix 冲突了：比如上一个 fix 修复完之后，最新的位置是 10，而下一个 fix 要求从 9 开始替换文本，那自然就不行了。所以这条 fix 就被留了下来。然后就要下一次循环再修复。











### prettier

#### eslint与 Prettier 强强联合

虽然 ESLint 本身具备自动格式化代码的功能(`eslint --fix`)，但术业有专攻，ESLint 的主要优势在于`代码的风格检查并给出提示`，而在代码格式化这一块 Prettier 做的更加专业，因此我们经常将 ESLint 结合 Prettier 一起使用。

首先我们来安装一下 Prettier:

```ts
pnpm i prettier -D
```

在项目根目录新建`.prettierrc.js`配置文件，填写如下的配置内容:

```js
// .prettierrc.js
module.exports = {
  printWidth: 80, //一行的字符数，如果超过会进行换行，默认为80
  tabWidth: 2, // 一个 tab 代表几个空格数，默认为 2 个
  useTabs: false, //是否使用 tab 进行缩进，默认为false，表示用空格进行缩减
  singleQuote: true, // 字符串是否使用单引号，默认为 false，使用双引号
  semi: true, // 行尾是否使用分号，默认为true
  trailingComma: "none", // 是否使用尾逗号
  bracketSpacing: true // 对象大括号直接是否有空格，默认为 true，效果：{ a: 1 }
};
```

接下来我们将`Prettier`集成到现有的`ESLint`工具中，首先安装两个工具包:

```js
pnpm i eslint-config-prettier eslint-plugin-prettier -D
```

其中`eslint-config-prettier`用来覆盖 ESLint 本身的规则配置，而`eslint-plugin-prettier`则是用于让 Prettier 来接管`eslint --fix`即修复代码的能力。

在 `.eslintrc.js` 配置文件中接入 prettier 的相关工具链，最终的配置代码如下所示，你可以直接粘贴过去:

```js
module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true
  },
  extends: [
    'eslint:recommended',
    'plugin:vue/vue3-essential',
    'plugin:@typescript-eslint/recommended',
    // 1. 接入 prettier 的规则
    'prettier',
    'plugin:prettier/recommended'
  ],
  globals: {
    defineOptions: true
  },
  parser: 'vue-eslint-parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module',
    parser: '@typescript-eslint/parser'
  },
  plugins: ['vue', '@typescript-eslint'],
  rules: {
    // 2. 开启 prettier 自动修复的功能
    'prettier/prettier': 'error',
    '@typescript-eslint/ban-ts-comment': 'off',
    'vue/multi-word-component-names': 'off'
  }
};

```

OK，现在我们回到项目中来见证一下`ESLint + Prettier`强强联合的威力，在 `package.json` 中定义一个脚本:

```json
{
  "scripts": {
    // 省略已有 script
    "lint:script": "eslint --ext .js,.jsx,.ts,.tsx --fix --quiet ./",
  }
}
```

接下来在命令行终端执行:

```js
pnpm run lint:script
```

这样我们就完成了 `ESLint 的规则检查`以及 `Prettier 的自动修复`。



#### `.prettierignore`

```
## OS
.DS_Store
.idea
.editorconfig
package-lock.json
.npmrc

# Ignored suffix
*.log
*.md
*.svg
*.png
*ignore

## Local
node_modules
.husky

## Built-files
.cache
dist
```

#### 忽略某行

添加注释：

`//prettier-ignore`



### 保存自动格式化

我们可以在`VSCode`中安装`ESLint`和`Prettier`这两个插件，并且在设置区中开启`Format On Save`:

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230215222418228.png" alt="image-20230215222418228" style="zoom:50%;" />

接下来在你按`Ctrl + S`保存代码的时候，Prettier 便会自动帮忙修复代码格式。









### 样式规范工具: Stylelint

#### 使用

> Stylelint，一个强大的现代化样式 Lint 工具，用来帮助你避免语法错误和统一代码风格。

Stylelint 主要专注于样式代码的规范检查，内置了 **170 多个 CSS 书写规则**，支持 **CSS 预处理器**(如 Sass、Less)，提供**插件化机制**以供开发者扩展规则。与 ESLint 类似，在规范检查方面，Stylelint 已经做的足够专业，而在代码格式化方面，我们仍然需要结合 Prettier 一起来使用。

首先让我们来安装 Stylelint 以及相应的工具套件：

```ts
pnpm i stylelint stylelint-prettier stylelint-config-prettier stylelint-config-recess-order stylelint-config-standard stylelint-config-standard-scss -D
```

然后，我们在 Stylelint 的配置文件`.stylelintrc.js`中一一使用这些工具套件:

```js
// .stylelintrc.js
module.exports = {
  // 注册 stylelint 的 prettier 插件
  plugins: ['stylelint-prettier'],
  // 继承一系列规则集合
  extends: [
    // standard 规则集合
    'stylelint-config-standard',
    // standard 规则集合的 scss 版本
    'stylelint-config-standard-scss',
    // 样式属性顺序规则
    'stylelint-config-recess-order',
    // 接入 Prettier 规则
    'stylelint-config-prettier',
    'stylelint-prettier/recommended'
  ],
  // 配置 rules
  rules: {
    // 开启 Prettier 自动格式化功能
    'prettier/prettier': true
  }
};
```

#### rules配置 

Stylelint 中rules 会有三种配置方式:

- `null`，表示关闭规则。
- 一个简单值(如 true，字符串，根据不同规则有所不同)，表示开启规则，但并不做过多的定制。
- 一个数组，包含两个元素，即`[简单值，自定义配置]`，第一个元素通常为一个简单值，第二个元素用来进行更精细化的规则配置。



#### `scripts`配置

 `package.json` 中，增加如下的 `scripts` 配置:

```json
{
  "scripts": {
    // 整合 lint 命令
    "lint": "npm run lint:script && npm run lint:style",
    // stylelint 命令
    "lint:style": "stylelint --fix \"src/**/*.{css,scss}\""
  }
}
```

执行`pnpm run lint:style`即可完成样式代码的规范检查和自动格式化。当然，你也可以在 VSCode 中安装`Stylelint`插件，这样能够在开发阶段即时感知到代码格式问题，提前进行修复。



#### 在 Vite 中集成 Stylelint

社区中提供了 Stylelint 的 Vite 插件。我们来安装一下这个插件:

```bash
# Vite 2.x
pnpm i @amatlash/vite-plugin-stylelint -D

# Vite 3.x 及以后的版本
pnpm i vite-plugin-stylelint -D
```

然后在 Vite 配置文件中添加如下的内容:

```ts
import viteStylelint from '@amatlash/vite-plugin-stylelint';
// 注意: Vite 3.x 以及以后的版本需要引入 vite-plugin-stylelint

// 具体配置
{
  plugins: [
    // 省略其它插件
    viteStylelint({
      // 对某些文件排除检查
      exclude: /windicss|node_modules/
    }),
  ]
}
```

接下来，你就可以在命令行界面看到对应的 Stylelint 提示了:

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e0957eaa8d1444f98a80173502f2395~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)





## Husky + lint-staged 的 Git 提交工作流集成

husky还是有点重量，一般没有复杂需求可以就用simple-git-hooks之类的。

### 提交前的代码 Lint 检查

#### Husky

我们可以在代码提交的时候进行卡点检查，也就是拦截 `git commit` 命令，进行代码格式检查，只有确保通过格式检查才允许正常提交代码。社区中已经有了对应的工具——`Husky`来完成这件事情，让我们来安装一下这个工具:

```ts
pnpm i husky -D
```

1. 初始化 Husky: `npx husky install`，并将 `husky install`作为项目启动前脚本，如:

```json
{
  "scripts": {
    // 会在安装 npm 依赖后自动执行
    "prepare": "husky install"
  }
}
```

2. 添加 Husky 钩子，在终端执行如下命令:

```ts
npx husky add .husky/pre-commit "npm run lint"
```

接着你将会在项目根目录的`.husky`目录中看到名为`pre-commit`的文件，里面包含了 `git commit`前要执行的脚本。现在，当你执行 `git commit` 的时候，会首先执行 `npm run lint`脚本，通过 Lint 检查后才会正式提交代码记录。





#### lint-staged

刚才我们直接在 Husky 的钩子中执行 `npm run lint`，这会产生一个额外的问题: Husky 中每次执行`npm run lint`都对仓库中的代码进行全量检查，也就是说，即使某些文件并没有改动，也会走一次 Lint 检查。

而`lint-staged`就是用来解决上述全量扫描问题的，只对存入`暂存区`的文件进行 Lint 检查。首先，让我们安装一下对应的 npm 包:

```ts
pnpm i -D lint-staged
```

配置`.lintstagedrc.mjs`

```
export default {
    '**/*.{ts,vue}': ['prettier --write', 'eslint --cache --fix'],
    '**/*.{js,mjs,css,less,scss,json,md}': 'prettier --write',
};
```





接下来我们需要在 Husky 中应用`lint-stage`，回到`.husky/pre-commit`脚本中，将原来的`npm run lint`换成如下脚本:

```ts
npx --no -- lint-staged
```

如此一来，我们便实现了提交代码时的`增量 Lint 检查`。







### 提交时的 commit 信息规范

首先我们来安装一下需要的工具库，执行如下的命令:

```bash
pnpm i commitlint @commitlint/cli @commitlint/config-conventional -D
```

接下来新建`.commitlintrc.js`：

```ts
// .commitlintrc.js
module.exports = {
  extends: ["@commitlint/config-conventional"]
};
```

一般我们直接使用`@commitlint/config-conventional`规范集就可以了，它所规定的 commit 信息一般由两个部分: `type` 和 `subject` 组成，结构如下:

```js
// type 指提交的类型
// subject 指提交的摘要信息
<type>: <subject>
```

常用的 `type` 值包括如下:

- `feat`: 添加新功能。
- `fix`: 修复 Bug。
- `chore`: 一些不影响功能的更改。
- `docs`: 专指文档的修改。
- `perf`: 性能方面的优化。
- `refactor`: 代码重构。
- `test`: 添加一些测试代码等等。

接下来我们将`commitlint`的功能集成到 Husky 的钩子当中，在终端执行如下命令即可:

```ts
npx husky add .husky/commit-msg "npx --no-install commitlint -e $HUSKY_GIT_PARAMS"
```

你可以发现在`.husky`目录下多出了`commit-msg`脚本文件，表示`commitlint`命令已经成功接入到 husky 的钩子当中。现在我们可以尝试对代码进行提交，假如输入一个错误的 commit 信息，commitlint 会自动抛出错误并退出:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0380e4bb149540649fc8b5f7f8e71c6e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

至此，我们便完成了 Git 提交信息的卡点扫描和规范检查。



### 引入 [git flow](https://link.juejin.cn/?target=https%3A%2F%2Fwww.atlassian.com%2Fgit%2Ftutorials%2Fcomparing-workflows%2Fgitflow-workflow)，管理`git`分支。



### 提交代码时压缩图片

#### 步骤

安装@automan/kia：`pnpm i @automan/kia -D`

在`.husky`目录下添加:

```sh
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"
pnpm exec kia pre-commit
```

#### 原理

直接在node_modules中看@automan/kia源码tinypng.ts

核心代码：

```ts
import { readFileSync, createWriteStream, unlinkSync, renameSync } from 'node:fs';
import axios from 'axios';
import { getSize } from '../lib/util.js';

const TINYIMG_URL = ['tinyjpg.com', 'tinypng.com'];

function randomIp() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * 256))
        .join('.');
}

function randomTiny() {
    return TINYIMG_URL[Math.round(Math.random())]!;
}

const UA_LIST = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0',
    'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_5_7;en-us) AppleWebKit/530.17 (KHTML, like Gecko) Version/4.0 Safari/530.17',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.49 Safari/537.36',
];

function randomUA() {
    return UA_LIST[Math.floor(UA_LIST.length * Math.random())]!;
}

type TinyResponse = {
    input: {
        size: number;
        type: 'image/png' | 'image/jpg';
    };
    output: {
        size: number;
        type: 'image/png' | 'image/jpg';
        width: number;
        height: number;
        ratio: number;
        url: string;
    };
};

// const PROXY_INFO = {
//     host: 'oversea-squid4.sgp.txyun',
//     port: 11080,
// };

async function uploadImage(data: Buffer) {
    const res = await axios({
        timeout: Math.max(10000, data.length / 10), // 设网速 10k/s
        method: 'post',
        url: `https://${randomTiny()}/backend/opt/shrink`,
        data,
        headers: {
            'Cache-Control': 'no-cache',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Postman-Token': `${Date.now()}`,
            'User-Agent': randomUA(),
            'X-Forwarded-For': randomIp(),
        },
    });
    return res.data as TinyResponse;
}

function downloadImage(url: string, filePath: string) {
    const CancelToken = axios.CancelToken;
    const source = CancelToken.source();

    return new Promise((resolve, reject) => {
        const out = createWriteStream(filePath, {
            emitClose: true,
        });

        let t: NodeJS.Timeout;
        out.on('close', () => {
            t && clearTimeout(t);
            resolve(1);
        });
        out.on('error', () => {
            t && clearTimeout(t);
            reject(new Error('Write error'));
        });
        axios({
            timeout: 20000, // 20s
            method: 'get',
            url,
            cancelToken: source.token,
            responseType: 'stream',
            // proxy: PROXY_INFO,
        }).then((response) => {
            t = setTimeout(() => {
                out.end();
                source.cancel('download timeout cancel req');
                reject(new Error('download timeout'));
            }, 60000); // 1min
            response.data.pipe(out);
        }).catch(reject);
    });
}

async function compressByTiny(fileName: string) {
    const file = readFileSync(fileName);
    const tempFile = `${fileName}.temp`;

    try {
        // console.log(`+开始压缩[${info.added}/${info.total}]: '${shortName}'`);
        const res = await uploadImage(file);
        await downloadImage(res.output.url, tempFile);
        unlinkSync(fileName);
        renameSync(tempFile, fileName);

        console.log(`图片 "${fileName}" 压缩完毕，压缩前：${getSize(res.input.size)}，压缩后：${getSize(res.output.size)}`);

    } catch (err) {
        console.error(`压缩失败: '${fileName}'`);
        console.error(err);
        unlinkSync(tempFile);
    }
}

function createTinyCompressPool({
    limit,
    retry,
} = {
    limit: 5,
    retry: 3,
}) {
    const queue: Array<{
        resolve: (value: unknown) => void;
        reject: (reason?: any) => void;
        fileName: string;
        retryCount: number;
    }> = [];
    let count = 0;

    function doCompress() {
        if (count > limit) {
            return;
        }
        const item = queue.shift();
        if (!item) {
            return;
        }
        count++;
        compressByTiny(item.fileName).then(v => {
            item.resolve(v);
            count--;
            doCompress();
        }).catch(e => {
            console.error(e);
            item.retryCount++;
            if (item.retryCount < retry) {
                console.error(`图片 ${item.fileName} 重试第${item.retryCount}次`);
                queue.push(item);
            } else {
                item.reject(e);
            }
            count--;
            doCompress();
        });
    }

    return (fileName: string) => {
        return new Promise((resolve, reject) => {
            queue.push({
                resolve,
                reject,
                fileName,
                retryCount: 0,
            });
            doCompress();
        });
    }
}

export const tinyCompress = createTinyCompressPool();
```





### 利用cli写commit

安装` pnpm i commitizen cz-conventional-changelog -w -D`

配置文件`.czrc`

```
{
    "path": "cz-conventional-changelog"
}
```

配置`package.json`脚本：

```
  "scripts": {
    ......
    "commit": "cz"
  },
```



### 检查commit的文本

安装commitlint

配置`.commitlintrc.js`

```
module.exports = {
  extends: ['@commitlint/config-conventional']
};
```







### 忽略提交一些文件

`.gitignore`

```
# local env files
.env.local
.env.*.local

#util files
dist/
apps/*/dist/
tmp/
*.tsbuildinfo
.npm
.eslintcache
.volarrc

# Log files
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Editor directories and files
**/.DS_Store
**/**/.DS_Store
.DS_Store
.ideagit rm -r --cached 
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
node_modules
.idea

```















## 分支管理

![image-20230428155430562](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-28-15-54-image-20230428155430562.png)

## css

#### class命名规范

BEM：Block__Element-Modifier 	示例： `header-container___top_container-actived`

- B：header-container，如果为多个单词，中间用-分割
- E：top_container，如果为多个单词，中间用_分割
- M：actived，状态通常是单个单词，不需要再被分割

#### reset.css

```css
html,
body {
  margin: 0 auto;
  padding: 0;
  height: 100%;
  width: 100%;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-font-smoothing: antialiased;
  color: #222;
  line-height: normal;
}

body {
  font-size: 14px;
  font-family: 'PingFang SC', system-ui, -apple-system, Roboto, 'Helvetica Neue',
    'Noto Sans', 'Liberation Sans', Arial, 'Apple Color Emoji', 'Segoe UI Emoji',
    'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
}

#app {
  min-height: 100%;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  margin: 0;
  padding: 0;
  font-weight: 700;
}

ul,
ol {
  list-style: none;
  padding: 0;
  margin: 0;
}

button {
  background: transparent;
  border: none;
  padding: 0;
}

a {
  text-decoration: none;
}
```



## sourceMap

### 介绍

**sourcemap 是关联编译后的代码和源码的，通过一个个行列号的映射。**

比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个 mapping。



### sourceMap原理

sourcemap 的格式如下：

```javascript
{
　　　　version : 3,
　　　　file: "out.js",
　　　　sourceRoot : "",
　　　　sources: ["foo.js", "bar.js"],
　　　　names: ["a", "b"],
　　　　mappings: "AAgBC,SAAQ,CAAEA;AAAEA",
      sourcesContent: ['const a = 1; console.log(a)', 'const b = 2; console.log(b)']
}
```

- version：sourcemap 的版本，一般为 3
- file：编译后的文件名
- sourceRoot：源码根目录
- names：转换前的变量名
- sources：源码文件名
- sourcesContent：每个 sources 对应的源码的内容
- mappings：一个个位置映射

为什么 sources 可以有多个呢？

因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。

重点是 mappings 部分：

mappings 部分是通过分号`;` 和逗号 `,` 分隔的：

```vbnet
mappings:"AAAAA,BBBBB;CCCCC"
```

一个分号就代表一行，这样就免去了行的映射。

然后每一行可能有多个位置的映射，用 `,` 分隔。

那具体的每一个 mapping 都是啥呢？

比如 AAAAA 一共五位，分别有不同的含义：

- 转换后代码的第几列（行数通过分号 ; 来确定）
- 转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引
- 转换前的源码的第几行
- 转换前的源码的第几列
- 转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引

然后经过编码之后，就成了 AAAAA 这种，这种编码方式叫做 VLQ 编码。

sourcemap 的格式还是很容易理解的，就是一一映射编译后代码的位置和源码的位置。

各种调试工具一般都支持 sourcemap 的解析，只要在文件末尾加上这样一行：

```javascript
//# sourceMappingURL=/path/to/source.js.map
```

运行时就会关联到源码：

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35c2ccc72c774d0c8b8cf7e65ce2ed03~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)











### 作用

- 调试的时候会使用 sourcemap，这样可以直接在源码打断点调试。

- 线上报错的时候会使用 sourcemap 来映射到源码，这种情况一般都是单独上传 sourcemap 到错误收集平台。比如 sentry 就提供了一个 [@sentry/webpack-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F@sentry%2Fwebpack-plugin) 支持在打包完成后把 sourcemap 自动上传到 sentry 后台，然后把本地 sourcemap 删掉。还提供了 [@sentry/cli](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F@sentry%2Fcli) 让用户可以手动上传。

- 生成的类型也可以通过 sourcemap 关联到对应的源码中的定义。

  sourcemap 只是位置的映射，可以用在任何代码上，比如 JS、TS、CSS 等，而且 TS 的类型也支持 sourcemap：指定了 declaration 会生成 d.ts 的声明文件，还可以指定 declarationMap 来生成 sourcemap：

  <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-18-20-09-image-20230918200859952.png" alt="image-20230918200859952" style="zoom:50%;" />

  这样在 VSCode 里我们就可以直接点击某个类型来跳转到源码里对应的地方了。

  ![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65482a375f1348299c033cb3141b0330~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)







### sourcemap 的生成



编译工具在生成代码的时候也会生成 sourcemap：

![image-20230918201257987](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-18-20-12-image-20230918201257987.png)



#### 生成原理

通过 [astexplorer.net](https://link.juejin.cn/?target=https%3A%2F%2Fastexplorer.net%2F%23%2Fgist%2F19042bfa06784d0e1b2dcb2ecd3559d5%2F50898c658d8129dbe520cc515af169331082036b) 可以看到，AST 中保留了源码中的位置，这是 parser 在 parse 源码的时候记录的。

![image-20230918201340016](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-18-20-13-image-20230918201340016.png)

然后进行 AST 的各种转换之后会打印成目标代码，打印的时候是一行行一列列的拼接字符串，这时候就有了目标代码中的位置。

![image-20230918201448204](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-18-20-14-image-20230918201448204.png)

两者一映射就是mappings了。









SourceMap 的加载和解析完全是前端行为（Devtools，VSCode Debugger等），后端并不涉及到任何 SourceMap 的处理。

这样的设计是因为考虑到：源码的调试和断点就是前端行为，后端只是提供了运行时暂停和状态暴露的能力。如果后端来解析，会影响代码运行时的执行效率。而且前端处理能更自由，不同 Debugger 工具可能对 SourceMap 进行再映射。比如前面提到的 VSCode Debugger 在调试时，如果映射的路径不在项目中就无法编辑，就可以通过 `sourceMapPathOverrides` 等配置再重新映射。

**正因为前端负责 SourceMap 的解析，所以我们打的断点在 SourceMap 解析完成之前是没法告诉后端的**。所以如果 SourceMap 加载比较慢，可能后端代码已经执行完了，前端才将断点信息传递过去，就会出现打了断点但是无效的情况。在 VSCode Debugger 中打断点提示无效也大概是这个原因，没有完成 SourceMap 的解析，就无法正确映射。

![image-20240106165502779](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-06-16-55-image-20240106165502779.png)







####  [source-map](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map) 这个包

当然 sourcemap 有对应的格式和编码，自己生成还是挺麻烦的，我们会用 [source-map](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map) 这个包：

[source-map](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map) 可以用于生成和解析 sourcemap，它暴露了 SourceMapConsumer、SourceMapGenerator、SourceNode 3个类，分别用于消费 sourcemap、生成 sourcemap、创建源码节点。

生成 sourcemap 的流程是：

1. 创建一个 SourceMapGenerator 对象
2. 通过 addMapping 方法添加一个映射
3. 通过 toString 转为 sourcemap 字符串

```javascript
const { SourceMapGenerator } = require('source-map');

const map = new SourceMapGenerator({
    file: "source-mapped.js"
});
  
map.addMapping({
    generated: {
        line: 10,
        column: 35
    },
    source: "foo.js",
    original: {
        line: 33,
        column: 2
    },
    name: "christopher"
});
  
console.log(map.toString());
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2c39a2c3f004bfcaa12f78a236bba63~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

消费 sourcemap 用 SourceMapConsumer 的 api。

可以调用 originalPositionFor 和 generatedPositionFor 分别用目标代码位置查源码位置和用源码位置查目标代码位置

还可以通过 eachMapping 遍历所有 mapping，对每个进行处理。

```javascript
const { SourceMapConsumer } = require('source-map');

const rawSourceMap = {
    version: 3,
    file: "min.js",
    names: ["bar", "baz", "n"],
    sources: ["one.js", "two.js"],
    sourceRoot: "http://example.com/www/js/",
    mappings: "CAAC,IAAI,IAAM,SAAUA,GAClB,OAAOC,IAAID;CCDb,IAAI,IAAM,SAAUE,GAClB,OAAOA"
};

(async function() {
    await SourceMapConsumer.with(rawSourceMap, null, consumer => {
        // 目标代码位置查询源码位置
        consumer.originalPositionFor({
            line: 2,
            column: 28
        })
        // { source: 'http://example.com/www/js/two.js',
        //   line: 2,
        //   column: 10,
        //   name: 'n' }
    
        // 源码位置查询目标代码位置
        consumer.generatedPositionFor({
            source: "http://example.com/www/js/two.js",
            line: 2,
            column: 10
        })
        // { line: 2, column: 28 }
    
        // 遍历 mapping
        consumer.eachMapping(function(m) {
            console.log(m);
        });    
    });
})();
```

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57ec2f8d61c4a70b4936a10f133eef7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

知道了位置从哪里来，知道了怎么用 source-map 的包生成 sourcemap，那就知道了平时我们用的 sourcemap 是怎么来的了。

我们用到的 webpack、babel 等等工具的 sourcemap 的生成和消费都是用的 source-map 这个包，大家也可以把[小册仓库的代码](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FQuarkGluonPlasma%2Ffe-debug-exercize)下下来跑跑试试。

更详细的介绍可以看 source-map 这个包的[文档](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fsource-map%23consuming-a-source-map)。





## tree-shaking

干掉dead code，即永远不会执行的代码，比如：

```js
if(false){
	console.log('你好')
}
```



想要实现 Tree-Shaking，必须满足一个条件，即模块必须是 ESM（ES Module），因为 Tree-Shaking 依赖 ESM 的静态结构。



### 副作用

如果一个函数调用会产生副作用，那么就不能将其移除。<mark>副作用就是，当调用函数的时候会对外部产生影响</mark>，例如修改了全局变量。比如只是读取对象的值也可能产生副作用，如果obj 对象是一个通过 Proxy 创建的代理对象，那么当我们读取对象属性时，就会触发代理对象的 get 夹子（trap），在 get 夹子中是可能产生副作用的，例如我们在get 夹子中修改了某个全局变量。而到底会不会产生副作用，只有代码真正运行的时候才能知道，<mark>JavaScript 本身是动态语言，因此想要静态地分析哪些代码是dead code 很有难度</mark>。所以像 rollup.js 这类工具都会提供一个机制，让我们能明确地告诉 rollup.js：“放心吧，这段代码不会产生副作用，你可以移除它。”具体怎么做呢？如以下代码所示：

```js
import {foo} from './utils'
/*#__PURE__*/ foo()
```

注意注释代码 /*#__PURE__*/，其作用就是告诉 rollup.js，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking。<mark>通常产生副作用的代码都是模块内函数的顶级调用。</mark>什么是顶级调用呢？如以下代码所示：

```js
 foo() // 顶级调用
 function bar() {
   foo() // 函数内调用
 }
```

可以看到，对于顶级调用来说，是可能产生副作用的；但对于函数内调用来说，只要函数 bar 没有被调用，那么 foo 函数的调用自然不会产生副作用。因此，在Vue.js 3 的源码中，基本都是在一些顶级调用的函数上使用 /*#__PURE__*/ 注释。当然，该注释不仅仅作用于函数，它可以应用于任何语句上。该注释也不是只有 rollup.js 才能识别，webpack 以及压缩工具（如 terser）都能识别它。





## 压缩

### 代码压缩原理

“代码压缩”最关键的问题是：如何用“**更精简**”的代码表达“**同一套**”程序逻辑？这并不是什么黑魔法，底层逻辑简单的甚至有点粗暴，拆开来看：

“**更精简**”意味着可以适当 —— 甚至完全牺牲可读性、语义、优雅度而力求用最少字符数的方式书写代码。比如说 `const name = 'tecvan';`，这个看起来非常简单的赋值语句就有不少可以精简的字符：

1. 变量名 `name` 语义很明确，大多数“人”看到就基本明白是干什么用的，但这对计算机并没有什么意义，我们完全可以将 `name` 修改为 `a` —— 从 4 个字符精简为 1 个字符，但仍保持改动前后逻辑、功能效果完全一致；
2. 赋值操作符 `=` 前后都有空格，这种格式对阅读代码的“人”很友好，视觉效果非常舒适、整齐，但对计算机而言同样毫无意义，我们可以将这前后两个空格删掉 —— 精简了两个字符；
3. 虽然 `const` 与 `let` 关键词的功能不同，但特定情况下我们同样能牺牲一部分功能性，用 `let` 替换 `const`，从 5 个字符精简为 1 个字符。

经过上面三个步骤之后，代码从 `const name = 'tecvan';` —— 22 个字符，精简为 `let a='tecvan';` —— 18 个字符，往大了说是节省了 **18%** 的代码体积。其它语言的代码压缩规则也基本都是按照上面这种套路实现的。

其次，“**同一套**”意味着修改前后必须保持一致的代码逻辑、执行流程、功能效果等，例如：

```js
const a = 1;
const b = 2;
const c = a + b;
```

代码中，`a/b` 都是字面量常量，那么整段代码完全可以精简为 `const c = 3` ，省略掉 `a/b` 变量的声明语句，前后还能保持功能完全一致。

为了应对这两个挑战，很自然的我们可以先将字符串形态的代码转换为结构化、容易分析处理的 AST（抽象语法树）形态，之后在 AST 上应用上面的规则做各种语法、语义、逻辑推理与简化替换，最后按精简过的 AST 生成结果代码。

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa9c68ef6c6e47918bd6bde4a529513e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



## 测试

### 单元测试

将测试用例的不同组织方式称为测试风格，主要有TDD（测试驱动开发）和BDD（行为驱动开发）两种

❑ 关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例；BDD关注整体行为是否符合预期，适合自顶向下的设计方式。

❑ 表达方式不同。TDD的表述方式偏向于功能说明书的风格；BDD的表述方式更接近于自然语言的习惯。

### 代码覆盖率(测试覆盖率)

通过计算 测试过程中 被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。







## 图片

### 图片格式

#### （1）**BMP**

- 是***无损的***、既支持索引色也支持直接色的点阵图。
- 这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。

#### （2）**GIF**

- 是***无损的***、采用索引色的点阵图。采用LZW压缩算法进行编码。

- ***文件小，是GIF格式的优点***，

- 同时，GIF格式还具有***支持动画以及透明***的优点。

- 但是GIF格式仅支持8bit的索引色

- 所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。

- 适合动画、可以动的图标。支持纯透明但不支持半透明，不适合色彩丰富的图片。

  埋点信息通常也会使用gif发送，因为1x1的gif图发送的网络请求比普通的get请求要小一些。

#### （4）**PNG-8**

- 是***无损的***、使用索引色的点阵图。
- PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。
- PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则必是PNG-8。
- PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。
- 适合纯色、透明、图标，支持纯透明和半透明。不适合色彩丰富图片，因为无损储存会导致储存体积大于jpeg

#### （5）**PNG-24**

- 是***无损的***、使用直接色的点阵图。
- PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。
- PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0-255),G(0-255),B(0-255)，可以表达256乘以256乘以256=16777216种颜色的图片

`PNG 32`：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0~~255),G(0~~255),B(0~~255),A(0~~255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色




#### （6）**SVG**

- 是***无损的***矢量图。
- SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。
- 矢量格式，SVG的文件体积更小，因为它不同于GIF、PNG这些像素化的图片或者其他基于光栅的图片格式。但渲染成本过高，适合小且色彩单一的图标。
- [详情可见文章](https://css-tricks.com/using-svg/)



#### （3）**JPEG**

- 是***有损的***、采用直接色的点阵图。
- JPEG的图片的优点是采用了直接色，得益于***更丰富的色彩***，JPEG非常适合用来存储照片，
- 与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊
- 直接色的选用，又会导致图片文件较GIF更大。
- 适合色彩丰富的图、Banner图。不适合：图形文字、图标、不支持透明度。



#### （7）**WebP**

- #### 是谷歌开发的一种新图片格式

- WebP是同时支持***有损和无损***压缩的、使用直接色的点阵图。

- 从名字就可以看出来它是为Web而生的，相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。

- 目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。

- 在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；

- 在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；

- WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。

- 支持纯透明和半透明，可以保证图片质量和较小的体积，适合Chrome和移动端浏览器。不适合其他浏览器。



下面是对比 AVIF、WebP、PNG 和 JPG 四种图像格式的优缺点：

1. **AVIF (AV1 Image File Format)**:
   - 优点：
     - 最新的图像格式，具有出色的压缩性能，可以提供更小的文件大小。
     - 支持高质量图像压缩，能够保留更多细节和颜色信息。
     - 支持高级功能，如动画、透明度和多帧图像。
   - 缺点：
     - 兼容性较差：目前仅有一些现代浏览器和图像编辑软件支持 AVIF 格式。
     - 编码和解码速度相对较慢，可能需要更多的计算资源。

2. **WebP**:
   - 优点：
     - 提供良好的图像压缩性能，通常比 JPEG 和 PNG 格式更小。
     - 支持有损和无损压缩，具有可调节的压缩质量。
     - 支持透明度和动画。
     - 在现代浏览器中有很好的兼容性。
   - 缺点：
     - 兼容性有限：在一些旧版本的浏览器和图像编辑软件中可能不支持 WebP 格式。

3. **PNG**:
   - 优点：
     - 无损压缩，保留图像质量和细节。
     - 支持透明度，可以创建带有透明背景的图像。
     - 支持索引色彩模式，适用于简单的图形和图标。
     - 在各种浏览器和图像编辑软件中广泛支持。
   - 缺点：
     - 文件大小通常比其他格式（如 JPEG）更大，尤其是对于照片和复杂图像。
     - 不适合存储高分辨率的照片。

4. **JPG (JPEG)**:
   - 优点：
     - 压缩后的文件通常较小，适合存储照片和复杂图像。
     - 在各种浏览器和图像编辑软件中广泛支持。
     - 可以调节压缩质量，权衡图像质量和文件大小。
   - 缺点：
     - 有损压缩，会损失一些图像细节和质量。
     - 不支持透明度。
     - 对于一些图像，压缩后可能出现压缩伪影和失真。

综上所述，选择图像格式应根据具体需求和使用场景。AVIF 和 WebP 提供更好的压缩性能和图像质量，但兼容性可能有限。比如增长的方案就是把图片转成avif和webp最后用png兜底。





### **图片使用规范**

#### 各种图片（用于cny大型项目）

| 类型       | 倍数                           | 尺寸                               | 处理方式                                        |
| ---------- | ------------------------------ | ---------------------------------- | ----------------------------------------------- |
| 小图片     | 2倍(828)                       | 414 * 414 以下(不超过半屏)         | 有透明部分用png无透明部分用jpg单张图不超过100kb |
| 大图片     | 低端机 1倍(414)高端机 2倍(828) | 超过半屏宽度的图片，如背景、海报等 | 有透明部分用png无透明部分用jpg单张图不超过200kb |
| apng       | 1倍(414)                       | 帧数不超过10                       | 总大小不超过300kb                               |
| 商业化logo |                                |                                    | 公共CDN地址                                     |
| icons      | 2倍(828)                       | 100 * 100以下                      | 使用雪碧图                                      |

所有图片资源按上图要求分类，以除夕主会场为例，在apps/eve/src/modules/main/assets目录下：

1. icons - 存放雪碧图icon合集，使用方式见“自动生成雪碧图”部分；
2. pics - 存放大/小图片，直接使用，统一使用二倍图；
3. apng - 存放apng动图，直接使用；
4. svg - 存放svg文件，直接使用；



#### 不要写死链接

图片等资源链接写死，无法进行CDN容灾处理。链接写死，替换链接需要发版，灵活性较差。

**图片资源**

如果是兜底图这种，建议放在项目内，用相对路径。

如果资源名希望不增加hash，可以放在publish目录下。



**链接配置**

建议统一走后端配置下发。

不要在代码中写死配置。



### avif和webp

|      | 支持 avif 的比例（安卓>=85，iOS >=16) | 不支持 avif, 支持 webp 的比例（安卓>=32, iOS >=14) | 都不支持 | 未知版本 | 总量     |
| ---- | ------------------------------------- | -------------------------------------------------- | -------- | -------- | -------- |
| 安卓 | 99.4%                                 | 0.5%                                               | 0.004%   | 0.006%   | 57375678 |
| iOS  | 12.73%                                | 80.75%                                             | 6.5%     | 0        | 930651   |





### 雪碧图

> HTTP2 的多路复用设计可以解决大量 HTTP 的请求导致的网络加载性能问题，因此雪碧图技术在 HTTP2 并没有明显的优化效果，这个技术更适合在传统的 HTTP 1.1 场景下使用(比如本地的 Dev Server)。

vite中：vite-plugin-svg-icons





### 图片预加载

```vue
<script setup>
  // 在vue的setup里就把图片先加载进来，而不是等页面渲染再去请求图片
preloadImage([LeftSelected, RightSelected, LeftShortSelected, RightShortSelected, MiddleSelected]);  
function preloadImage(images: Array<string>) {
    images.forEach((imgSrc) => {
        const img = new Image();
        img.src = imgSrc;
    });
}
</script>
```



base.utils/Preload.ts

```typescript
// TODO：拆分该文件

/** 加载图片配置 */
import { invoke } from '@yoda/bridge';
import type { PictureOption, SourceOption, ImgOption } from '@kwai-explore/picture.vue/types';
import { assertNotNil } from '../../core/asserts';
import { sleep } from '../../core/helper';

declare global {
    interface Window {
        ENV_INFO?: {
            /**
             * 是否高崩溃机型
             */
            islp?: boolean;
            icfo?: boolean;
            // 跨机房
            azprefix?: string;
        };
    }
}

/**
 * @description TS类型：图片加载配置
 */
export type LoadImageOptions = {
    /** 图片是否跨域请求，默认 true */
    crossOrigin?: boolean;
};

/**
 * @description TS类型：通用配置
 */
export type LoadCommonOptions = {
    /** 超时时间 */
    timeout?: number;
    /** 低端机是否加载 */
    lpDisable?: boolean;
};

/**
 * @description TS类型：LoadCommonOptions和LoadImageOptions的联合类型
 */
export type Options = LoadCommonOptions & LoadImageOptions;

/**
 * @description TS类型：加载结果
 */
export type LoadResult = boolean | undefined;
/**
 * @description TS类型：结果
 */
export type Result = {
    success: LoadResult;
    source: string;
};
type PromiseLoadRes = Promise<LoadResult>;
type PromiseRes = Promise<Result>;

/**
 * @description 预加载资源的结果
 * {@link preloadSource}
 */
export type LoadSourceResult = Promise<{
    done: boolean;
    detail: Result[];
}>;

type SourceLoader = (url: string, options?: Options) => PromiseLoadRes;

const imageTypes = ['jpg', 'jpeg', 'png', 'gif', 'svg', 'webp', 'pjpeg', 'apng'];
const audioTypes = ['mp3', 'wav'];

const sourceCache: Record<string, PromiseLoadRes> = {};
const sources: {
    type: 'image' | 'video' | 'audio' | 'model' | 'magic';
    includes: string[];
    loader: SourceLoader;
}[] = [
    {
        type: 'image',
        includes: imageTypes,
        loader: async (url, options = {}) => {
            if (!sourceCache[url]) {
                sourceCache[url] = (() =>
                    new Promise((resolve) => {
                        const { crossOrigin = true, timeout } = options;
                        console.log('image source:', url);
                        const img = new Image();
                        if (crossOrigin) {
                            img.crossOrigin = 'anonymous';
                        }

                        img.onload = () => {
                            resolve(true);
                        };
                        img.onerror = () => {
                            resolve(false);
                        };

                        img.src = url;
                        if (timeout !== undefined) {
                            sleep(timeout).then(() => {
                                resolve(false);
                            });
                        }
                    }))();
            }
            return sourceCache[url];
        },
    },
    {
        type: 'audio',
        includes: audioTypes,
        loader: async (url, options) => {
            if (!sourceCache[url]) {
                sourceCache[url] = (() =>
                    new Promise((resolve) => {
                        fetch(url)
                            .then(() => {
                                resolve(true);
                            })
                            .catch(() => {
                                resolve(false);
                            });

                        if (options?.timeout !== undefined) {
                            sleep(options?.timeout).then(() => {
                                resolve(false);
                            });
                        }
                    }))();
            }

            return sourceCache[url];
        },
    },
    {
        type: 'model',
        includes: ['glb', 'gltf'],
        loader: async (url, options) => {
            if (!sourceCache[url]) {
                sourceCache[url] = (() =>
                    new Promise((resolve) => {
                        fetch(url)
                            .then(() => {
                                resolve(true);
                            })
                            .catch(() => {
                                resolve(false);
                            });

                        if (options?.timeout !== undefined) {
                            sleep(options?.timeout).then(() => {
                                resolve(false);
                            });
                        }
                    }))();
            }

            return sourceCache[url];
        },
    },
    {
        // 魔表类型
        type: 'magic',
        includes: ['magic'],
        loader: async (url, options = {}) => {
            if (!sourceCache[url]) {
                sourceCache[url] = (() =>
                    new Promise((resolve) => {
                        const magicFaceID = Number(url.replace('.magic', ''));
                        if (Number.isNaN(magicFaceID)) {
                            resolve(false);
                        }

                        invoke('post.preloadMagicFace', { magicFaceID })
                            .then(() => {
                                resolve(true);
                            })
                            .catch(() => {
                                resolve(false);
                            });

                        if (options?.timeout !== undefined) {
                            sleep(options?.timeout).then(() => {
                                resolve(false);
                            });
                        }
                    }))();
            }
            return sourceCache[url];
        },
    },
    {
        type: 'video',
        includes: ['mp4'],
        loader: async (url, options) => {
            if (!sourceCache[url]) {
                sourceCache[url] = (() =>
                    new Promise((resolve) => {
                        fetch(url)
                            .then(() => {
                                resolve(true);
                            })
                            .catch(() => {
                                resolve(false);
                            });

                        if (options?.timeout !== undefined) {
                            sleep(options?.timeout).then(() => {
                                resolve(false);
                            });
                        }
                    }))();
            }

            return sourceCache[url];
        },
    },
];

const loadSourceByType = (sourceUrl: string, options?: Options): PromiseRes => {
    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve) => {
        const tailName = sourceUrl.split('.').pop() ?? '';
        if (!Boolean(tailName)) {
            resolve({
                success: false,
                source: sourceUrl,
            });
            return;
        }

        try {
            const loader = sources.find((item) => item.includes.includes(tailName))?.loader;
            if (loader) {
                resolve({
                    success: await loader(sourceUrl, options),
                    source: sourceUrl,
                });
                return;
            }

            resolve({
                success: undefined,
                source: sourceUrl,
            });
        } catch (error) {
            console.log('load error:', error);
            resolve({
                success: false,
                source: sourceUrl,
            });
            return;
        }
    });
};

type PreloadSource = (sourceUrl: string[] | string, options?: Options) => LoadSourceResult;

/**
 * @description 预加载资源
 * @param sourceUrl 资源URL
 * @param options 配置参数，见{@link Options}
 * @returns
 */
export const preloadSource: PreloadSource = (sourceUrl, options = {}) => {
    const { lpDisable = false } = options;
    if (lpDisable && Boolean(window.ENV_INFO?.islp)) {
        return Promise.resolve({
            done: true,
            detail: [],
        });
    }

    if (!Array.isArray(sourceUrl)) {
        return preloadSource([sourceUrl], options);
    }

    // eslint-disable-next-line no-async-promise-executor
    return new Promise(async (resolve) => {
        if (sourceUrl.length === 0) {
            resolve({
                done: true,
                detail: [],
            });
            return;
        }

        const result = await Promise.all(sourceUrl.map((source) => loadSourceByType(source, options)));

        resolve({
            done: true,
            detail: result,
        });
    });
};

/**
 * @description 预加载图片
 * @param src 图片配置，见 @kwai-explore/picture.vue/types
 */
export function preloadPicture(src: PictureOption) {
    let sourcesData: SourceOption[];
    let imgData: ImgOption;
    if ('fallback' in src) {
        imgData = src.fallback;
        sourcesData = Object.entries(src.sources).map(([key, val]) => {
            return {
                type: `image/${key}`,
                srcset: val[0]?.src!,
            };
        });
    } else {
        sourcesData = src.slice(0, -1) as SourceOption[];
        imgData = src.at(-1) as ImgOption;
    }

    assertNotNil(imgData);

    const picture = document.createElement('picture');

    for (const sourceData of sourcesData) {
        const source = document.createElement('source');
        Object.entries(sourceData).forEach(([key, value]) => {
            // @ts-expect-error
            source[key] = value;
        });
        picture.appendChild(source);
    }

    const img = document.createElement('img');
    img.alt = '';
    picture.appendChild(img);
    img.src = imgData.src; // 这样就会发起请求了
}
```









## 模块共享

### 简介

对于一个互联网产品来说，一般会有不同的细分应用，比如`腾讯文档`可以分为`word`、`excel`、`ppt`等等品类，`抖音 PC 站点`可以分为`短视频站点`、`直播站点`、`搜索站点`等子站点，而每个子站又彼此独立，可能由不同的开发团队进行单独的开发和维护，会经常遇到一些模块共享的问题，也就是说不同应用中总会有一些共享的代码，比如公共组件、公共工具函数、公共第三方依赖等等。对于这些共享的代码，除了通过简单的复制粘贴，还有没有更好的复用手段？





### 旧方案

#### 1. 发布 npm 包

发布 npm 包是一种常见的复用模块的做法，我们可以将一些公用的代码封装为一个 npm 包，具体的发布更新流程是这样的:

1. 公共库 lib1 改动，发布到 npm；
2. 所有的应用安装新的依赖，并进行联调。 ![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5196f352c9124076a9f446cec686fb65~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

封装 npm 包可以解决模块复用的问题，但它本身又引入了新的问题:

1. **开发效率问题**。每次改动都需要发版，并所有相关的应用安装新依赖，流程比较复杂。
2. **项目构建问题**。引入了公共库之后，公共库的代码都需要打包到项目最后的产物后，导致产物体积偏大，构建速度相对较慢。

因此，这种方案并不能作为最终方案，只是暂时用来解决问题的无奈之举。

#### 2. Git Submodule

通过 `git submodule` 的方式，我们可以将代码封装成一个公共的 Git 仓库，然后复用到不同的应用中，但也需要经历如下的步骤：

1. 公共库 lib1 改动，提交到 Git 远程仓库；
2. 所有的应用通过`git submodule`命令更新子仓库代码，并进行联调。

你可以看到，整体的流程其实跟发 npm 包相差无几，仍然存在 npm 包方案所存在的各种问题。

#### 3. 依赖外部化(external)+ CDN 引入

在上一节中我们提到了`external`的概念，即对于某些第三方依赖我们并不需要让其参与构建，而是使用某一份公用的代码。按照这个思路，我们可以在构建引擎中对某些依赖声明`external`，然后在 HTML 中加入依赖的 CDN 地址:

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/src/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite App</title>
  </head>
  <body>
    <div id="root"></div>
    <!-- 从 CDN 上引入第三方依赖的代码 -->
    <script src="https://cdn.jsdelivr.net/npm/react@17.0.2/index.min.js"><script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@17.0.2/index.min.js"><script>
  </body>
</html>
```

如上面的例子所示，我们可以对`react`和`react-dom`使用 CDN 的方式引入，一般使用`UMD`格式产物，这样不同的项目间就可以通过`window.React`来使用同一份依赖的代码了，从而达到模块复用的效果。不过在实际的使用场景，这种方案的局限性也很突出:

1. **兼容性问题**。并不是所有的依赖都有 UMD 格式的产物，因此这种方案不能覆盖所有的第三方 npm 包。
2. **依赖顺序问题**。我们通常需要考虑间接依赖的问题，如对于 antd 组件库，它本身也依赖了 react 和 moment，那么`react`和`moment` 也需要 `external`，并且在 HTML 中引用这些包，同时也要**严格保证**引用的顺序，比如说`moment`如果放在了`antd`后面，代码可能无法运行。而第三方包背后的间接依赖数量一般很庞大，如果逐个处理，对于开发者来说简直就是噩梦。
3. **产物体积问题**。由于依赖包被声明`external`之后，应用在引用其 CDN 地址时，会全量引用依赖的代码，这种情况下就没有办法通过 Tree Shaking 来去除无用代码了，会导致应用的性能有所下降。

#### 4. Monorepo

作为一种新的项目管理方式，Monorepo 也可以很好地解决模块复用的问题。在 Monorepo 架构下，多个项目可以放在同一个 Git 仓库中，各个互相依赖的子项目通过软链的方式进行调试，代码复用显得非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca9fdeedc8ec45e8bdb977f8b924e16e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

不得不承认，对于应用间模块复用的问题，Monorepo 是一种非常优秀的解决方案，但与此同时，它也给团队带来了一些挑战:

1. **所有的应用代码必须放到同一个仓库**。如果是旧有项目，并且每个应用使用一个 Git 仓库的情况，那么使用 Monorepo 之后项目架构调整会比较大，也就是说改造成本会相对比较高。
2. Monorepo 本身也存在一些天然的局限性，如项目数量多起来之后依赖安装时间会很久、项目整体构建时间会变长等等，我们也需要去解决这些局限性所带来的的开发效率问题。而这项工作一般需要投入专业的人去解决，如果没有足够的人员投入或者基建的保证，Monorepo 可能并不是一个很好的选择。
3. **项目构建问题**。跟 `发 npm 包`的方案一样，所有的公共代码都需要进入项目的构建流程中，产物体积还是会偏大。



### 新方案：Module Federation（模块联邦）

#### MF 核心概念

模块联邦中主要有两种模块: `本地模块`和`远程模块`。

本地模块即为普通模块，是当前构建流程中的一部分，而远程模块不属于当前构建流程，在本地模块的运行时进行导入，同时本地模块和远程模块可以共享某些依赖的代码，如下图所示:

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a612a1b0f394d3fbf2cf2afe9bb0d70~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)在模块联邦中，每个模块既可以是`本地模块`，导入其它的`远程模块`，又可以作为远程模块，被其他的模块导入。如下面这个例子所示:

如图，其中 A 模块既可以作为本地模块导入 B，又可以作为远程模块被 C 导入。

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13c0775cc53e48e4ad34400d63c4033e~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



以上就是模块联邦的主要设计原理，现在我们来好好分析一下这种设计究竟有哪些优势:

1. **实现任意粒度的模块共享**。这里所指的模块粒度可大可小，包括第三方 npm 依赖、业务组件、工具函数，甚至可以是整个前端应用！而整个前端应用能够共享产物，代表着各个应用单独开发、测试、部署，这也是一种`微前端`的实现。
2. **优化构建产物体积**。远程模块可以从本地模块运行时被拉取，而不用参与本地模块的构建，可以加速构建过程，同时也能减小构建产物。
3. **运行时按需加载**。远程模块导入的粒度可以很小，如果你只想使用 app1 模块的`add`函数，只需要在 app1 的构建配置中导出这个函数，然后在本地模块中按照诸如`import('app1/add')`的方式导入即可，这样就很好地实现了模块按需加载。
4. **第三方依赖共享**。通过模块联邦中的共享依赖机制，我们可以很方便地实现在模块间公用依赖代码，从而避免以往的`external + CDN 引入`方案的各种问题。



#### MF 实现原理

从以上示例中大家可以看到，Module Federation 使用比较简单，对已有项目来说改造成本并不大。那么，这么强大而易用的特性是如何在 Vite 中得以实现的呢？接下来，我们来深入探究一下 MF 背后的实现原理，分析`vite-plugin-federation`这个插件背后究竟做了些什么。

总体而言，实现模块联邦有三大主要的要素:

1. `Host`模块: 即本地模块，用来消费远程模块。
2. `Remote`模块: 即远程模块，用来生产一些模块，并暴露`运行时容器`供本地模块消费。
3. `Shared`依赖: 即共享依赖，用来在本地模块和远程模块中实现第三方依赖的共享。

首先，我们来看看本地模块是如何消费远程模块的。之前，我们在本地模块中写过这样的引入语句:

```ts
import RemoteApp from "remote_app/App";
```

我们来看看 Vite 将这段代码编译成了什么样子:

```ts
// 为了方便阅读，以下部分方法的函数名进行了简化
// 远程模块表
const remotesMap = {
  'remote_app':{url:'http://localhost:3001/assets/remoteEntry.js',format:'esm',from:'vite'},
  'shared':{url:'vue',format:'esm',from:'vite'}
};

async function ensure() {
  const remote = remoteMap[remoteId];
  // 做一些初始化逻辑，暂时忽略
  // 返回的是运行时容器
}

async function getRemote(remoteName, componentName) {
  return ensure(remoteName)
    // 从运行时容器里面获取远程模块
    .then(remote => remote.get(componentName))
    .then(factory => factory());
}

// import 语句被编译成了这样
// tip: es2020 产物语法已经支持顶层 await
const __remote_appApp = await getRemote("remote_app" , "./App");
```

除了 import 语句被编译之外，在代码中还添加了`remoteMap`和一些工具函数，它们的目的很简单，就是通过访问远端的**运行时容器**来拉取对应名称的模块。

而运行时容器其实就是指远程模块打包产物`remoteEntry.js`的导出对象，我们来看看它的逻辑是怎样的:

```ts
// remoteEntry.js
const moduleMap = {
  "./Button": () => {
    return import('./__federation_expose_Button.js').then(module => () => module)
  },
  "./App": () => {
    dynamicLoadingCss('./__federation_expose_App.css');
    return import('./__federation_expose_App.js').then(module => () => module);
  },
  './utils': () => {
    return import('./__federation_expose_Utils.js').then(module => () => module);
  }
};

// 加载 css
const dynamicLoadingCss = (cssFilePath) => {
  const metaUrl = import.meta.url;
  if (typeof metaUrl == 'undefined') {
    console.warn('The remote style takes effect only when the build.target option in the vite.config.ts file is higher than that of "es2020".');
    return
  }
  const curUrl = metaUrl.substring(0, metaUrl.lastIndexOf('remoteEntry.js'));
  const element = document.head.appendChild(document.createElement('link'));
  element.href = curUrl + cssFilePath;
  element.rel = 'stylesheet';
};

// 关键方法，暴露模块
const get =(module) => {
  return moduleMap[module]();
};

const init = () => {
  // 初始化逻辑，用于共享模块，暂时省略
}

export { dynamicLoadingCss, get, init }
```

从运行时容器的代码中我们可以得出一些关键的信息:

- 1. `moduleMap`用来记录导出模块的信息，所有在`exposes`参数中声明的模块都会打包成单独的文件，然后通过 `dynamic import` 进行导入。
- 1. 容器导出了十分关键的`get`方法，让本地模块能够通过调用这个方法来访问到该远程模块。

至此，我们就梳理清楚了远程模块的`运行时容器`与本地模块的交互流程，如下图所示

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0091bec4ab12419085316153d7d1a6fb~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

接下来，我们继续分析共享依赖的实现。拿之前的示例项目来说，本地模块设置了`shared: ['vue']`参数之后，当它执行远程模块代码的时候，一旦遇到了引入`vue`的情况，会优先使用本地的 `vue`，而不是远端模块中的`vue`。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e800a628da434dff9c57ca9cf172fd97~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)

让我们把焦点放到容器初始化的逻辑中，回到本地模块编译后的`ensure`函数逻辑:

```ts
// host

// 下面是共享依赖表。每个共享依赖都会单独打包
const shareScope = {
  'vue':{'3.2.31':{get:()=>get('./__federation_shared_vue.js'), loaded:1}}
};
async function ensure(remoteId) {
  const remote = remotesMap[remoteId];
  if (remote.inited) {
    return new Promise(resolve => {
        if (!remote.inited) {
          remote.lib = window[remoteId];
          remote.lib.init(shareScope);
          remote.inited = true;
        }
        resolve(remote.lib);
    });
  }
}
```

可以发现，`ensure`函数的主要逻辑是将共享依赖信息传递给远程模块的运行时容器，并进行容器的初始化。接下来我们进入容器初始化的逻辑`init`中:

```ts
const init =(shareScope) => {
  globalThis.__federation_shared__= globalThis.__federation_shared__|| {};
  // 下面的逻辑大家不用深究，作用很简单，就是将本地模块的`共享模块表`绑定到远程模块的全局 window 对象上
  Object.entries(shareScope).forEach(([key, value]) => {
    const versionKey = Object.keys(value)[0];
    const versionValue = Object.values(value)[0];
    const scope = versionValue.scope || 'default';
    globalThis.__federation_shared__[scope] = globalThis.__federation_shared__[scope] || {};
    const shared= globalThis.__federation_shared__[scope];
    (shared[key] = shared[key]||{})[versionKey] = versionValue;
  });
};
```

当本地模块的`共享依赖表`能够在远程模块访问时，远程模块内也就能够使用本地模块的依赖(如 `vue`)了。现在我们来看看远程模块中对于`import { h } from 'vue'`这种引入代码被转换成了什么样子:

```ts
// __federation_expose_Button.js
import {importShared} from './__federation_fn_import.js'
const { h } = await importShared('vue')
```

不难看到，第三方依赖模块的处理逻辑都集中到了 `importShared` 函数，让我们来一探究竟:

```ts
// __federation_fn_import.js
const moduleMap= {
  'vue': {
     get:()=>()=>__federation_import('./__federation_shared_vue.js'),
     import:true
   }
};
// 第三方模块缓存
const moduleCache = Object.create(null);
async function importShared(name,shareScope = 'default') {
  return moduleCache[name] ? 
    new Promise((r) => r(moduleCache[name])) : 
    getProviderSharedModule(name, shareScope);
}

async function getProviderSharedModule(name, shareScope) {
  // 从 window 对象中寻找第三方包的包名，如果发现有挂载，则获取本地模块的依赖
  if (xxx) {
    return await getHostDep();
  } else {
    return getConsumerSharedModule(name); 
  }
}

async function getConsumerSharedModule(name , shareScope) {
  if (moduleMap[name]?.import) {
    const module = (await moduleMap[name].get())();
    moduleCache[name] = module;
    return module;
  } else {
    console.error(`consumer config import=false,so cant use callback shared module`);
  }
}
```

由于远程模块运行时容器初始化时已经挂载了共享依赖的信息，远程模块内部可以很方便的感知到当前的依赖是不是共享依赖，如果是共享依赖则使用本地模块的依赖代码，否则使用远程模块自身的依赖产物代码。最后我画了一张流程图，你可以参考学习:

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0f8d0e3158264c45bfd25dd205d65fd0~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)



## 生成文档

### jsDoc

感觉比较适合写node的时候用

**JSDoc 的应用场景：**

1. **纯 JavaScript 项目：** JSDoc 最早是为 JavaScript 开发的，因此对于纯 JavaScript 项目是一个很好的选择。您可以使用 JSDoc 来为 JavaScript 代码添加类型注释和文档注释。
2. **文档生成：** JSDoc 可以生成详细的代码文档，这对于维护大型项目和与团队共享代码非常有用。您可以使用工具如 JSDoc 或使用集成了 JSDoc 的构建工具（如 Node.js 中的 `jsdoc` 包）来生成代码文档。
3. **类型注释：** 虽然 JSDoc 不会执行类型检查，但它可以为代码提供类型注释，以便其他开发者可以更容易地理解代码的含义。这在没有 TypeScript 的项目中特别有用。
4. **IDE 支持：** 大多数主流的集成开发环境（IDE）对 JSDoc 有很好的支持，可以提供代码补全、跳转到定义、查找引用等功能。



### vitepress

#### 目录结构

.vitepress/config.js 配置工具栏、导航栏等

index.md为网站进来的首页



### `TypeDoc`

`TypeDoc` 是一个可将 TypeScript 项目的源代码转换为 HTML 文档的工具，它能自动提取源代码中的注释、类型、类、接口等信息，生成易于阅读且友好的文档。`TypeDoc` 可将一个 TypeScript 项目的结构及其简要说明输出到一个 HTML 文档中，这有助于开发者更轻松地了解并使用项目所提供的 API。

以下是安装和使用 TypeDoc 的方法：

1. 安装 TypeDoc（假设您已经安装了 TypeScript）：

```bash
npm install --save-dev typedoc
```

2. 为您的 TypeScript 源代码添加 TypeDoc 注释：

```typescript
/**
 * 对这个类的描述
 */
class MyClass {
  private readonly _prop: string;
  
  /**
   * MyClass 构造函数
   * @param prop - 对这个参数的描述
   */
  constructor(prop: string) {
    this._prop = prop;
  }

  /**
   * 获取 prop 属性的值
   * @returns 这个方法返回什么内容
   */
  get prop(): string {
    return this._prop;
  }
}
```

在这个例子中，我们使用 `/** */` 形式的注释，并在里面加入了简短的描述、标签（如 `@param`、`@returns` 等）以提供更多信息。TypeDoc 会自动读取这些注释并将其添加到生成的文档中。

3. 配置并运行 TypeDoc：

在您的 `package.json` 文件中，可以添加一个新的 npm 脚本以运行 TypeDoc。以下是一个简单的示例：

```json
{
  "scripts": {
    "docs": "typedoc --out docs src"
  }
}
```

此脚本会告诉 TypeDoc 从 `src` 目录读取源代码，并将生成的 HTML 文档输出到名为 `docs` 的文件夹。您可以通过运行 `npm run docs` 生成文档。

如果您需要详细配置 TypeDoc，可以创建一个 `typedoc.json` 配置文件，并在其中包含所需的选项，然后在您的 `package.json` 脚本中指定配置文件，如：

```json
{
  "scripts": {
    "docs": "typedoc --options typedoc.json"
  }
}
```

了解更多关于 TypeDoc 的信息，请参考官方文档：[TypeDoc 官方文档](https://typedoc.org/guides/installation/)。



## mock

可以用这个库：https://github.com/mswjs/msw

开发人员对于数据mock的诉求大致可以分为以下三类。

• 开发无侵入：通过拦截XMLHttpRequest或者代理HTTP请求，返回模拟的响应数据。

• 多数据类型模拟：支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等数据，通过返回随机数据，来模拟各种场景。

• 多场景模拟：可以自定义接口返回时间、异常HTTP响应等，来测试前端对接口异常的边界场景处理情况。

常见的接口mock方案主要分为工具和平台两种，下面分别以Mock.js和YApi为代表进行讲解。Mock.js属于工具类接口mock方案，它的原理是通过拦截XMLHttpRequest请求来实现数据mock，通过该方式进行的mock不会发起真实的请求。因为它会代理XMLHttpRequest请求，直接在函数的执行层面劫持并返回，所以在浏览器开发人员工具的Network中不能查看到对应的请求。如果是fetch则使用mockjs-fetch。



## 修改环境变量（即process.env）

```
$ yarn add cross-env
```

![image-20230310105233872](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230310105233872.png)









# CLI

## CLI 与 脚手架的概念

在软件开发中，脚手架就是帮助开发过程的工具和环境配置的集合。简单来说，目前组件库的状态就是一个脚手架。虽然只有一个组件，但是为组件库的环境配置和工具已经整合完成了。

其次说一下 CLI 工具是什么。 CLI 是英文 command-line interface 的简写，翻译为命令行界面。也就是只在用户提示符下键入可执行命令的界面。通常脚手架程序会通过 CLI 的形式封装，这样做更加符合程序员的习惯。所以目前看到的大多数脚手架都是以 CLI 工具的形式封装的。久而久之，大家也就比较习惯将 CLI 与脚手架混为在一起了。



## 开发项目脚手架

### 概念

这次我们要开发的脚手架 create-smarty-app ，功能是可以快速创建一个使用 Smarty-UI 开发的项目模版。也就是说，假设你想使用 smarty-ui 开发项目，可以直接使用脚手架创建一个空的项目，里面包含的 vite + vue3 + smarty-ui 组件。直接开发逻辑就好了。

对于一个组件库来讲，脚手架一般分为两种：

- Create-smarty-ui-app : 创建使用 Smarty-UI 组件库的程序的脚手架；
- Create-xxx-ui ： 创建和 Smarty-UI 类似的组件库的脚手架，也就是复用我们上面的架构。

一般一个脚手架项目会有两部分组成：

- Template 项目： 项目的模版；
- CLI 工具项目： 提供命令行界面用于克隆项目，生成代码、自动配置、运行调试、发布等功能。



### 创建模版项目

这一步，主要就是创建一个程序的模版。其实就是从零搭建一个Vue3 + Vite 环境并且引入 Smarty-UI。

首先，选择使用 vite-cli 工具直接搭建项目。

- Vite 启动；
- 使用 Javascript 语言；
- 全局引入 Samrty-UI。

这个过程其实就是使用 Vite 脚手架工具搭建一个 vue3 项目，然后引入 smarty-ui 组件。

这个模版工程搭建也可以根据喜好加入一下个性化的代码。

### 创建CLI 项目

有了模版项目，接下来需要创建脚手架。

脚手架主要的运行过程如下。

- 提供命令行界面：
  - 选择代码模版 ；
  - 填写项目名称。
- 克隆模版项目；
- 根据项目名称及其他配置生成代码。

这一步的目的主要是搭建一个基础的 CLI 环境。也就是可以用一个全局命令调用到 CLI 工具的 JS 程序。 CLI 工具是可以在全局执行的程序。也就是说，将 npm 软件包中的一个 JS 文件注册到全局。

#### 基本原理演示

比如： 全局安装 vue-cli。

```Bash
sudo npm i @vue/cli -g
```

以 Mac 为例。npm 首先会把软件包下载到 /lib/node_modules/@vue/cli 目录下。然后 npm 会根据 @vue/cli 软件包中 package.json 的 bin 字段中的配置，将 bin/vue.js 文件软连接到 /usr/local/bin 中去。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76d520f05b24769849f6b2fec3de525~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

你可以使用 ls -l 查看一下：

```Bash
ls -l /usr/local/bin
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d6b156dc9c0498dbd515740ccfc0d9d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

这个时候你就可以全局执行 vue 这个命令了。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/380195e38d394cc5863b5255e2685175~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



#### 初始化CLI工具

需要提供一种调试CLI工具的方法。解决的办法就是使用 npm link 来模拟这个软连接过程。也就是说 npm link 就是在模拟全局安装。

首先创建项目。主目录下创建 cli 项目并初始化。

```Bash
pnpm init
```

在 cli/bin 中添加一个 index.js 作为文件的入口。

```js
#!/usr/bin/env node
console.log('create-victorui ....')
```

这里面第一行 #!/usr/bin/env node 的功能是：这个 index.js 程序不是常规的使用 node xxx 命令执行，而是需要通过 source xxx 或 ./xxx 来执行。也就是像一个 shell 脚本一样执行。这时候就出现了一个问题，一个 JS 代码是不能够直接以这种形式执行的。那么这个时候就需要上述语句来声明解释器类型。也就是说，执行该代码需要使用 node 当做解释器辅助。

在 package.json 中添加一个 bin 属性，声明注册一个叫 create-victorui 的可执行文件。并且将 type 设置为 module 。这么做的目的是在 Node 环境中使用 esm 模块规范。

```JSON
{
  .......
  "type": "module",
  "bin": {
    "create-victorui": "./bin/index.js"
  }
}

```

脚本编写虽然也可以使用 Typescript 。为了方便，这次我们使用 JS 编写。

运行 npm link 模拟全局安装的效果。

```Bash
# 在 cli 目录下
sudo npm link
```

这个时候可以在任何一个目录下执行命令。

```Bash
create-victorui
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c29d180efb6400fae5657227ccef7a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

日志正确输出，标志着 CLI 工具框架初始化完毕。

#### 创建命令行界面

命令行界面的意义在于可以让用户定制自己需要的程序。

首先打印一个欢迎界面，这个功能是使用 clear、chalk-animation 与 figlet 合作完成。

- Clear 清除屏幕；
- Figlet 提供炫酷的文字效果；
- Chalk-animation 提供命令行动画与渐变颜色。

安装 `pnpm add figlet@"1.5.2" clear@"0.1.0" chalk-animation@"2.0.2" `

然后是命令行选项，这个使用 inquirer 这个库完成。它会根据配置显示界面并把结果返回为 json。后面通过返回结果动态 import 导入需要的模块，这样就实现了根据选项运行不同的初始化模块。

安装 `pnpm i chalk@"5.0.1" inquirer@"9.1.0"`

```js
#!/usr/bin/env node

import { promisify } from "util";
import figlet from "figlet";
import clear from "clear";
import chalk from "chalk";
import inquirer from "inquirer";
import chalkAnimation from "chalk-animation";

const log = (content) => console.log(chalk.green(content));
const opt = {
  "SmartyUI应用模版(Vite)": "smarty-ui-vite",
  SmartyAdmin模版: "admin",
  组件库脚手架: "uitemplate",
  组件库文档网站: "uitemplate",
  退出: "quit",
};

const question = [
  {
    type: "rawlist" /* 选择框 */,
    message: "请选择要创建的项目？",
    name: "operation",
    choices: Object.keys(opt),
  },
];

// 打印欢迎画面
clear();
const logo = figlet.textSync("Smarty UI!", {
  // font: "Ghost",
  horizontalLayout: "default",
  verticalLayout: "default",
  width: 80,
  whitespaceBreak: true,
});

const rainbow = chalkAnimation.rainbow(logo);
setTimeout(() => {
  rainbow.stop(); // Animation stops
  query();
}, 500);


async function query() {
  const answer = await inquirer.prompt(question);

  if (answer.operation === "退出") return;

  const { default: op } = await import(
    `../lib/operations/${opt[answer.operation]}.js`
  );
  await op();
}
```

#### 克隆项目模版

项目的主体一般都是通过从 Github 直接拉取的形式。只有少部分需要修改的代码使用代码模版生成的方式实现。

首先使用 download-git-repo 这个库完成克隆。 克隆是一个漫长的异步执行过程，可能会持续数秒到几分钟。这个时候为了优化用户体验，不要让用户认为程序死掉了，就需要一个进度条表示一直在加载。

首先编写一个进度条和 git 下载结合的 clone 函数。

```Bash
pnpm add ora@"6.1.2" download-git-repo@"3.0.2"
```

>  cli/lib/utils/clone.js

```JavaScript
import { promisify } from "util";
import download from "download-git-repo";
import ora from "ora";
export default async (repo, desc) => {
  const process = ora(`下载.....${repo}`);
  process.start();
  await promisify(download)(repo, desc);
  process.succeed();
};
```

然后编写克隆过程，这个里面还需要一点交互问一下它的项目名称。和上面功能相似我就不讲了。另外为了让日志有颜色，使用了 chalk 包。

> cli/lib/operations/victor-ui-vite.js

```JavaScript
import clone from "../utils/clone.js";
import inquirer from "inquirer";
import { resolve } from "path";
import fs from "fs";

import chalk from "chalk";
const log = (...args) => console.log(chalk.green(...args));

import handlebars from "handlebars";

export default async () => {
  const { name } = await inquirer.prompt([
    {
      type: "input" /* 选择框 */,
      message: "请输入项目的名称？",
      name: "name",
    },
  ]);

  log("🚌 创建项目:" + name);
  
  log(`
👌 安装完成：
To get Start:
===========================
cd ${name}
npm i
npm run dev
===========================
            `);
};
```



#### 模版生成代码（还没）

除了模版库中的代码，还有一些代码需要自动生成。比如： 你希望项目名显示在页面中，又比如你希望根据配置决定加载什么样的 vue 插件。 这相当于动态的拼装代码，这个过程其实和前端使用一个模版库渲染 html 并没有什么区别。这个时候可以选择一个模版库完成，常用的是 handlebars 这个库。

具体到本程序，只有一个最简单的代码需要模版生成。package.json 中的项目名改写为包名。

首先在github中创建一个模版项目 victor-ui-app-js-template ，并且项目中创建一个 template 文件夹。然后创建一个 package.json 模版。这个模版和 package.json 几乎一样，只是将 name 属性的值变成了表达式。

> template/package.hbs.json

```JSON
{
  "name": "{{ name }}",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "smarty-ui-vite": "^0.1.4",
    "vue": "^3.2.37"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^3.0.3",
    "vite": "^3.0.7"
  }
}
```

下面就在 CLI 工具中编写通过 template 生成 package.json 的代码。

```JavaScript
import clone from "../utils/clone.js";
import inquirer from "inquirer";
import { resolve } from "path";
import fs from "fs";

import chalk from "chalk";
const log = (...args) => console.log(chalk.green(...args));

import handlebars from "handlebars";

export default async () => {
  const { name } = await inquirer.prompt([
    {
      type: "input" /* 选择框 */,
      message: "请输入项目的名称？",
      name: "name",
    },
  ]);

  log("🚌 创建项目:" + name);

  // 从github克隆项目到指定文件夹
  await clone("github:smarty-team/smarty-ui-app-js-template", name);

  // 生成路由定义
  compile(
    {
      name,
    },
    `./${name}/package.json`,
    `./${name}/template/package.hbs.json`
  );

  log(`
👌 安装完成：
To get Start:
===========================
cd ${name}
npm i
npm run dev
===========================
            `);
};


/**
 * 编译模板文件
 * @param meta 数据定义
 * @param filePath 目标文件路径
 * @param templatePath 模板文件路径
 */
function compile(meta, filePath, templatePath) {
  if (fs.existsSync(templatePath)) {
    const content = fs.readFileSync(templatePath).toString();
    const result = handlebars.compile(content)(meta);
    fs.writeFileSync(filePath, result);
    log(`📚 ${filePath} 修改成功`);
  } else {
    log(`❌ ${filePath} 修改失败`);
  }
}
```

### 上传 Npm 仓库（还没）

最后一步是上传 npm 仓库。这个步骤还是需要使用 Github Action 完成。这一步前面已经讲过，不再赘述。

> .github/workflows/publish-smarty-ui-vite.yml

```YAML
name: Publish Smarty-ui-vite To Npm

on:
  push:
    branches: [publish-smarty-ui-vite]

jobs:
  publish:
    runs-on: ubuntu-latest

    name: "publish npm"

    environment: npm

    steps:
      - uses: actions/checkout@master
      - uses: pnpm/action-setup@v2.1.0
        with:
          version: 6.31.0
      - name: Install modules
        run: pnpm install
      - name: Build
        run: cd packages/smarty-ui-vite && npm run build
      - name: "Publish to the npm registry"
        uses: primer/publish@3.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_AUTH_TOKEN: ${{ secrets.NPM_AUTH_TOKEN }} # 跟前面步骤中的 NPM_AUTH_TOKEN 保持一致
        with:
          default_branch: "publish-smarty-ui-vite"
          dir: "packages/smarty-ui-vite/dist"
```





## 使支持 create

这个属于一种约定。大家了解一下就可以了。

[docs.npmjs.com/cli/v8/comm…](https://link.juejin.cn/?target=https%3A%2F%2Fdocs.npmjs.com%2Fcli%2Fv8%2Fcommands%2Fnpm-init)

以 smarty-ui 的 cli 为例，你只需要将软件包名称命名为 create-smarty-app，这样就可以通过。

```Bash
npm init smarty-app

# 也可以使用 执行的两者的功能是一致的。
npm create smarty-app
```



## 用现成的开发脚手架

根据 [Vite 官方文档 ](https://link.juejin.cn/?target=https%3A%2F%2Fvitejs.dev%2Fguide%2F%23scaffolding-your-first-vite-project)，Vite 的脚手架目前分为官方脚手架和第三方脚手架。

第三方脚手架全部使用 degit 安装。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dec9fc92bc2a47589999a28c0a7eb26a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

degit 是一个简洁版的脚手架工具。它的特点是可以只需要创建项目模版而无需自己编写脚手架 CLI。 只需要使用 degit 就可以克隆模版项目创建自己的项目了。

[github.com/Rich-Harris…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FRich-Harris%2Fdegit)

首先全局安装 degit。

```Bash
sudo npm install -g degit
```

下面测试一下我们项目是否可以这样使用， 根据规则 degit 的后面参数应该是模版软件的 github 地址。所以我们按照描述运行。

```Bash
degit smarty-team/smarty-ui-app-js-template my-app
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/224cbae7e1db43158f5aee6a6895679a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

经过测试，这个软件是可以创建的，只是没有自己 cli 的加持。连 package.json 中的软件包名字都没有改。不过假设你的模版比较简单，只是为了克隆项目也可以使用这个软件。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b9092c78703478689996f21459fbe25~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

第三方脚手架全部汇总在 awesome-vite 的网站上，如果后期希望推广你的组件库，可以考虑给这个项目 PR。

[github.com/vitejs/awes…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fvitejs%2Fawesome-vite%23templates)



## 实现一个cli

#### 实现cli常用的一些库

- Commander: 参数解析 .。 默认内置了 -h 和 --help 参数。https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md
- Yards:参数解析。
- CAC：参数解析，新兴轻量。
- inquirer: 实现命令行里的选择功能
- chalk：使控制台五颜六色
- ini： 配置文件ini格式解析器和序列化器。
- ora： 命令行loading
- https://github.com/google/zx: 在js文件中写 shell脚本
- https://www.npmjs.com/package/download-git-repo：Download and extract(提取物) a git repository (GitHub, GitLab, Bitbucket) from node.
- 打印表格console-table-printer
- 展示更小的时间：microtime



##### Create-vue:

**minimist**： 替代 Commander

prompts ： https://www.npmjs.com/package/prompts 替代 inquirer

kolorist：替代 chalk

npm-run-all2: https://www.npmjs.com/package/npm-run-all2

ejs ： 模版引擎，用来动态在文件里加上一些代码。

renovate: https://www.mend.io/renovate/

#### 我的实现过程

在`package.json`中配置好 bin：

```json
  "bin":{
    "dyc":"./bin/index.js",
    "create-dyc":"./bin/index.js"
  },
```



然后在项目目录中执行`pnpm link --global`  相当于 把这项目安装到全局下，这样就能直接在全局下运行比如 `dyc` or `create-dyc`。

注意如果命令对应的文件变了，比如变成：`"dyc": "./bin/hhh/index.js"` ，那就要重新`pnpm link --global`。到那时文件内容变了是没关系的，他还是能找到这个文件，然后执行文件内容。 





# IDE

## 云端ide

1.github.dev+你的仓库名，如https://github.dev/xieguanglei/caculator-app
2.stackblitz.com/github+你的仓库名，如https://stackblitz.com/github/xieguanglei/caculator-app

**Dev environments** In your **web app**： https://webcontainers.io/

## vscode

### 遇到的error

code helper(plugin)一直占用百分之九十多的cpu，应该是某个插件导致的问题。可以vscode 插件->右上角... -> Start Extension Bisect （开始扩展二等分）进行排查是哪个插件导致的问题，或者直接关闭所有插件之后看是不是没有那么高占用了，然后关掉一个可能出问题的插件进行一个个排查。（比如我就遇到过Codeium这个插件占用百分之九十多的问题，我tm直接把他禁用）



### 文件搜索

```
VS Code的搜索文件过滤功能使用的是glob模式匹配语法。glob模式是一种简化的正则表达式，主要用于文件名匹配。以下是一些基本的glob模式规则：

* 匹配任何数量的任何字符，但不包括/。例如，*.js匹配所有js文件。
** 匹配任何数量的任何字符，包括/。例如，**/*.js匹配所有目录下的js文件。
? 匹配任何单个字符，但不包括/。例如，?.js匹配a.js，但不匹配ab.js。
{} 匹配大括号内的任何一个模式。例如，{*.js,*.ts}匹配所有js和ts文件。
[] 匹配方括号内的任何一个字符。例如，[abc].js匹配a.js，b.js和c.js。
! 排除匹配的文件。例如，!*.js排除所有js文件。

你可以在VS Code的搜索框中输入glob模式来过滤搜索结果。例如，你可以输入**/*.js来搜索所有js文件，或者输入!**/node_modules/**来排除node_modules目录。
需要注意的是，VS Code的glob模式匹配是大小写敏感的，除非你开启了"Search: Ignore Case"设置。
```



### snippet

#### 入口

点击【F1】，然后输入snippet。

 snippets 一共三种范围：

![image-20230916133643055](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-09-16-13-36-image-20230916133643055.png)

如果是项目级别的会在 .vscode目录下多出一个 xx.code-snippets 的文件

#### 使用

语法官网：https://code.visualstudio.com/docs/editor/userdefinedsnippets



##### 好用的网站

<mark>https://snippet-generator.app/  这个网站能帮你快速生成snippet</mark>



##### 属性



###### scope

可以通过scope指定语言,不指定的所有语言都生效

```json
"Print to console": {
    "scope": "javascript,typescript",
 }
```



###### prefix

prefix是触发的前缀,可以指定多个

```json
"Print to console": {
...
    "prefix": ["log", "console"]
 }
```



###### body

body 是插入到编辑器中的内容

```json
"Print to console": {
...
    "body": [
            "console.log();"
    ],
 }
```



###### description是描述

```json
"Print to console": {
...
    "description": "Log output to console"
 }
```







##### $ 的作用

###### 指定光标

`$1`、`$2`等用来指定光标的位置, 并且可以指定多个光标位置，通过tab切换光标位置

```json
 "Print to console": {
...
            "body": [
                    "console.log('$1');",
                    "$2"
            ],
...
    }
```

![llsTestYanshi.gif](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d7d3b4e78d2474695c25bf821b6d604~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)



###### 给光标位置添加默认值

`:[placeholder]`可以给光标位置添加默认值

```json
"Print to console": {
...
            "body": [
                    "console.log(${1:Hello});",
            ],
...
    }
```

![llsTestYanshi2.gif](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0ead84b8b6849b6afffc54fb9365647~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)



###### 提供多个值来选择

```bash
"Print to console": {
...
            "body": [
                    "你好${1|光光,东东|}"
            ],
...
    }
```



###### 取变量

所有可用变量可以在 [VSCode 文档](https://link.juejin.cn/?target=https%3A%2F%2Fcode.visualstudio.com%2Fdocs%2Feditor%2Fuserdefinedsnippets%23_variables)里看到。

提供了一些变量可以取：

```bash
"当前文件： $TM_FILENAME",
"当前日期： $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE"
```

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e6f26da95114b66a1eb96347ccf4ab6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)



###### 对变量做正则替换

```bash
"${TM_FILENAME/(.*)\\.[a-z]+/${1:/upcase}/i}"
```

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a05e4333aeda48829cc791377217049b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)



#### 如果要snippets里包含$

在$的前面加`\\`：`\\$`





### 常用配置

`.editorconfig`

```
[*.{js,jsx,ts,tsx,vue,json}]
indent_style = space
indent_size = 4
end_of_line = lf
trim_trailing_whitespace = true
insert_final_newline = true
max_line_length = 100
```











# AST

## 可视化ast树

https://astexplorer.net/

## 利用babel

### 这个网站可视化babel转成的ast树

https://lihautan.com/babel-ast-explorer/#?eyJiYWJlbFNldHRpbmdzIjp7InZlcnNpb24iOiI3LjYuMCJ9LCJ0cmVlU2V0dGluZ3MiOnsiaGlkZUVtcHR5Ijp0cnVlLCJoaWRlTG9jYXRpb24iOnRydWUsImhpZGVUeXBlIjp0cnVlLCJoaWRlQ29tbWVudHMiOnRydWV9LCJjb2RlIjoiIn0=





### 看babel的效果

babel 解析成ast树：https://lihautan.com/babel-ast-explorer/#?eyJiYWJlbFNldHRpbmdzIjp7InZlcnNpb24iOiI3LjYuMCJ9LCJ0cmVlU2V0dGluZ3MiOnsiaGlkZUVtcHR5IjpmYWxzZSwiaGlkZUxvY2F0aW9uIjpmYWxzZSwiaGlkZVR5cGUiOmZhbHNlLCJoaWRlQ29tbWVudHMiOmZhbHNlfSwiY29kZSI6IiJ9

Babel 提供了一个在线版的 REPL 页面，读者可在 [babeljs.io/repl](https://link.juejin.cn/?target=https%3A%2F%2Fbabeljs.io%2Frepl) 实时体验功能效果。



### 导入

使用esm的方式导入使用@babel/traverse时这样去导入（官方文档坑之）：

```ts
import _traverse from "@babel/traverse";
const traverse = _traverse.default;
```





### 所需依赖

```tsx
import { parse } from '@babel/parser';
import * as t from '@babel/types';
import _traverse from '@babel/traverse';
import _generate from '@babel/generator';
```



### 使用

```tsx
const ast = parse(code, {
  sourceType: 'module',
  plugins: ['typescript', 'jsx'] // 若要处理 TypeScript或jsx 代码，请启用插件
});
traverse(ast,{
	CallExpression(path){}, //path.node就是CallExpression这个节点
})
```















# 框架

## MV*框架

### 为什么要用MV*框架

因为包含了这些东西

◎ 模板引擎，动态生成、创建页面。

◎ 双向绑定，实时修改数据。

◎ 前端路由，路由变化映射到对应的逻辑上。

……正是这些特性组成了一个前端框架

前端MV*框架的原理就是通过观察和订阅来进行联动操作，以自动触发各种逻辑函数



### MVVM

#### vue3

ViewModel 层做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。

Vue 没有完全遵循 MVVM 思想，因为严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 提供了$refs 这个属性，让 Model 可以直接操作 View



#### MVVM、MVC的区别

MVC 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。



**（1）MVC**

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/else/image-20230313212708681.png" alt="image-20230313212708681" style="zoom:50%;" />

React采用的是MVC。“单向驱动”。如果要实现双向驱动得自己写代码。

MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603814137582-5a9aa62f-0045-4272-bef0-447dedb25596.png)

（2）MVVM

Vue采用的是MVVM。“双向驱动”。

MVVM 分为 Model、View、ViewModel：

- Model代表数据模型，数据和业务逻辑都在Model层中定义；
- View代表UI视图，负责数据的展示；
- ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；

Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定(就是v-model)的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。

这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603814104939-8c8ac923-735d-4476-937a-cb1f795ffe84.png)







#### **MVVM**的优缺点

优点: 

- 分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的"View"上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 
- 提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 
- ⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放 



缺点: 

- Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 
- ⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 
- 对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。







### MV*框架组成



#### 模版引擎

《前端架构：从入门到微前端》

前端模板引擎分为两种，基于字符串的模板引擎和基于JavaScript的模板引擎。两种不同类型的模板引擎，各有各的优势。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

基于字符串的模板引擎在更新DOM的时候会更新所有DOM节点，这时浏览器需要重新渲染所有的节点。当我们拥有大量的HTML元素或DOM操作时，如果每次都刷新整个DOM节点，显然是不合适的。这时，我们就需要更高级一点的方案。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuMjUgOC44MzkxOUM2LjI0OTUxIDYuMzM5MTkgOC4yNzM4MSA1LjAyOTY2IDEwLjA1OTUgNS4wMjk2NkMxMS44NDUyIDUuMDI5NjYgMTMuNjMxIDYuNjk2MzMgMTMuNjMxIDguMTI0OUMxMy42MzEgOC40MzQ3MyAxMy42NzkzIDguOTYyMjkgMTMuNzc2MSA5LjcwNzU2QzEzLjgyNzQgMTAuMTAzIDEzLjU5MTUgMTAuNDc5MyAxMy4yMTMyIDEwLjYwNTRMMTIuNzk3NiAxMC43NDM5VjEwLjkwNjhDMTIuNzk3NiAxMi4wNjY5IDExLjk5OTUgMTMuMDc0NiAxMC44NzAyIDEzLjM0MDNMMTAuNzczOCAxMy4zNjNWMTQuNTUzNUM5LjA3NDEzIDE0LjY3MTMgNy44ODM2NSAxNC4yNzQ1IDcuMjAyMzggMTMuMzYzQzcuMjAyMzggMTIuMTEyIDYuODg0OTIgMTAuNjA0MSA2LjI1IDguODM5MTlaTTkuNTIzODEgMTIuMzczTDEwLjU4MzkgMTIuMTIzNUMxMS4xNDg2IDExLjk5MDcgMTEuNTQ3NiAxMS40ODY4IDExLjU0NzYgMTAuOTA2OFY5Ljg0M0wxMi40OTM3IDkuNTI3NjRDMTIuNDE4OCA4LjkwNzM2IDEyLjM4MSA4LjQ0NjcgMTIuMzgxIDguMTI0OUMxMi4zODEgNy4zODE5NCAxMS4xNDA5IDYuMjc5NjYgMTAuMDU5NSA2LjI3OTY2QzguNzI0OSA2LjI3OTY2IDcuNjAwOTMgNy4yMTUyNSA3LjUwNjQzIDguNjQyMzVDOC4wNTcxOSAxMC4yMTk1IDguMzcwMjYgMTEuNjIyMiA4LjQzODI1IDEyLjg1ODlDOC42OTU5NCAxMy4wNjk0IDkuMDUyMDIgMTMuMjEzNCA5LjUyMzgxIDEzLjI4MDhWMTIuMzczWk0xMS45NjI0IDE0LjI3MDZDMTEuOTkyNSAxNC42MTQ1IDEyLjI5NTcgMTQuODY4OSAxMi42Mzk1IDE0LjgzODhDMTMuOTAwNCAxNC43Mjg1IDE0LjgzMyAxMy42MTY5IDE0LjcyMjcgMTIuMzU2MUMxNC42OTI3IDEyLjAxMjIgMTQuMzg5NSAxMS43NTc5IDE0LjA0NTYgMTEuNzg3OUMxMy43MDE4IDExLjgxOCAxMy40NDc0IDEyLjEyMTIgMTMuNDc3NSAxMi40NjVDMTMuNTI3NiAxMy4wMzgxIDEzLjEwMzcgMTMuNTQzNCAxMi41MzA2IDEzLjU5MzVDMTIuMTg2NyAxMy42MjM2IDExLjkzMjMgMTMuOTI2OCAxMS45NjI0IDE0LjI3MDZaIiBmaWxsPSIjOTlBMEFBIi8+Cjwvc3ZnPgo=)



基于JavaScript的模板引擎设计（dyc：这一章都值得看）

 



在多页面应用中使用基于JavaScript模板引擎的情况并不常见。对于一些复杂的、拥有大量的DOM操作的组件，如表格组件，则更需要这种类XML的组件，以提高性能。（dyc：简单页面用字符串替换的效率是否更高，看前面那一章字符串替换的做法）



#### 双向绑定

双向绑定，即双向数据绑定，它是指视图（View）的变化能实时地让数据模型（Model）发生变化，而数据的变化也能实时更新到视图层。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

双向绑定有几种不同的实现方式：◎ 手动绑定。即两个单身绑定的结合，通过手动set和get数据来触发UI或数据变化。◎ 脏检查机制。即在发生指定的事件（如HTTP请求、DOM事件）时，遍历数据相应的元素，然后进行数据比较，对变化的数据进行操作。◎ 数据劫持。即通过hack的方式（Object.defineProperty()）对数据的setter和getter进行劫持。在数据变化时，通知相应的数据订阅者，以触发相应的监听回调。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

使用浏览器访问网页时，如果网页URL中带有Hash，页面就会被定位到id（或name）与Hash值一样的元素的位置。





## 框架选型

选定一个前端框架时，我们还要考虑的因素有：

◎ 框架是否能满足大部分应用的需求？如果不能，那么需要使用哪个框架？

◎ 框架是否有丰富的组件库？如果没有，我们的团队和组织是否有独立开发的能力？

◎ 框架的社区支持怎样？在遇到问题时能否快速方便地找到人解答？

◎ 框架的替换成本如何？假如我们的新项目将使用B框架，那么我们还需要额外学习什么内容？每个问题都不是一个简单、独立的问题，它们都值得我们深入地探索一番。6.4.1 选型考虑因素如果旧的框架逐渐被淘汰，那么就需要选择一个新的框架，以便帮助大家平衡地过渡。这时如果你也成为一个前端的技术负责人，那么需要评估哪个框架更适合我们。恐怕不是一句话或者几句话就能解决这个问题的，我们需要组织讨论会，进行各种框架的对比分享等。待讨论的事项如下：

◎ 团队成员能否快速掌握该框架。框架拥有自己的设计思想，它可能有更适合的用户群。如Angular其总体的架构思想依赖注入、强类型等，更适合那些有后端经验的开发者。如Vue框架更容易上手，适合初学者进行Web开发。而对于一个没有经验的新手，直接使用Angular框架，则需要较长的学习时间。

◎ 框架的生态是否丰富？是否拥有我们所需要的功能组件？技术选型要考虑的一个因素是生态系统，即是否有对应的可选择的组件、库是否足够丰富。多数时候不同的框架之间都可以找到一些相似的组件，但有些时候一些复杂的交互组件，可能没有相对应的框架实现。一旦业务上对这类组件的需求比较大，那么我们可能就只能放弃某个框架，同时考虑消耗的成本。

◎ 不同框架对于不同浏览器的支持程度如何？由于实现机制的不同，框架会对浏览器有一定的要求。这部分内部，我们会在随后的章节里，进一步展开讨论。

◎ 框架的后期维护成本和难度怎样？项目的维护难度与其花费的时间和代码量是成正比的，即时间越长、代码量越大，维护成本也就越高。越是大型的项目，到后期也就越难维护；而小型的项目，则不存在这样的问题。因此在选择框架的时候，可以考虑项目的规模，越有可能变大的项目，选择一个大而全的框架，往往会更容易维护。

◎ 是否能以最小的代价迁移现有的应用？当我们选定A框架时，往往后面编写的代码都难以迁移到B框架。比如我们使用React编写的组件，无法直接在Angular或者Vue中使用。尽管随着Web Components技术的发展，跨框架使用变得越来越有希望，但是这也意味着我们需要做大量的适配。随着时间的流逝，A框架在未来不一定适合我们，可能B框架更适合现在的我们，那么我们可能会踏入原来的坑中，继续探索B的可能性。此外，还有一个场景是，当一个框架的API不断变化并且向下不兼容的时候，就会带来额外的维护成本。一个典型的例子就是React Native，在笔者使用React Native开发一个应用的过程中，中途更新了版本，由于API的变更影响了第三方组件，并且额外带来几天时间的升级成本。在这个应用的生命周期里，我们还需要不断地追随这部分变化。



















# 跨端(半Native半Web混合开发模式)

## 为什么需要跨端

开发成本低：生态庞大、效率高、多端通用，能接得住时限很短的任务，开发APP需要两种语言和两拨开发者来做成本较高

一致性的体验：运行在web、安卓、ios都一样的UI（安卓原生和ios原生的ui风格会不一样）

热更新

移动设备性能提升了使得跨端比不上纯原生的性能差异能缩小。





## 跨端的一些通用原理

### JSBridge实现原理

JSBridge是一种通用的交互理念，多种设计方式都可以实现，思路也不尽相同。
**js调用native**
● 请求拦截假跳转
● 弹窗拦截
● JS上下文注入API

**native调用js**
● 直接执行js代码

#### 3.1 js调用native

##### 3.1.1 请求拦截假跳转

webview发送请求都会经过客户端的请求发送模块，客户端可以在请求发送出去拦截，H5发出一条URI schema假跳转的请求，其跳转目的地是一个非法不存在的地址，和客户端约定好这个schema协议，客户端拦截请求进行分析，如果符合约定的协议就停止跳转调用native的方法，其他的当作真的请求发送出去。拦截下来的url不会导致webview继续跳转，因此用户完全没有感知。我们可以利用这个条件，定义一些scheme规则，客户端读取伪协议域名的部分作为通信识别，比如抖音的某些schema协议**bytedance://** , **snssdk1128://**, **aweme://** 可与正常协议做区分，读取路径作为指令识别，读取参数作为数据，并根据约定调用对应的native原生代码。

```JavaScript
// 协议格式。 协议://域名/路径?参数
https://www.baidu.com/s?params=123 真跳转
// 抖音跳转
aweme://profile/?douyin_id=88 假跳转
snssdk1128://profile/?douyin_id=88 假跳转

aweme // 用作协议，用作拦截的方式
profile // 约定调用客户端的方法名，告诉客户端我要打开抖音个人主页
params // 表示调用客户端方法要传递的参数，id为88的这个人的主页
```

js发起跳转的三种方式

a标签直接跳转

```JavaScript
<a href="aweme://profile/?douyin_id=88"></a>
```

location.href

```JavaScript
location.href = "aweme://profile/?douyin_id=88";
```

iframe跳转：在JS中创建一个iframe，插入DOM中进行跳转

```JavaScript
$('body').append('<iframe src="' + 'aweme://profile/?douyin_id=88' + ' " style="display: none;"'></iframe>)
```

**代表产品：**
抖音的JSB采用的就是请求拦截假跳转的方式。
**优点：**
兼容性好，这是所有JS调用Native的通信方式里，唯一同时支持安卓webview/苹果UIWebview/WKWebview的通信方式。
**缺点：**
webview会把调用封装为请求，时延达到200ms-400ms。
跳转的url存在长度限制。

##### 3.1.2 弹窗拦截

js 调用弹窗时一般有 alert/confirm/prompt 三种弹窗，这三种弹窗对应客户端都会有方法实现，可以直接做拦截。

```JavaScript
var actionInfo = {
    type: 'aweme',
    action: 'profile',
    params:{
        "id":88,
    }
}

prompt(JSON.stringify([actionInfo]))
```

这种方式比请求拦截好的地方是可以支持同步调用了。但是 iOS 中有两种 UIWebView 和 WKWebView，前者在 webView 中屏蔽的弹窗的功能。会有很多兼容性问题。

##### 3.1.3 JS上下文注入API

js引擎是js和native都能访问到的共同区域。在打开webview之后，往js的上下文(window)注入对象或方法，供js进行调用能直接执行相应的Native代码逻辑。

```Objective-C
// iOS JavaScriptCore 注入（UIWebView）
// 获取 WebView 中 JS上下文
JSContext *context = [webview valueForKeyPath:@"documentView.webView.mainFrame.javaScriptContext"];
//注入 callNative 函数方法
context[@"openProfile"] = ^( JSValue * params )
{
    // 解析参数找到对应的方法进行处理
    NSInvocation *invocation = [执行方法]
}


// android webView 注入
// 通过 addJavascriptInterface 将对象映射到 JS 对象
mWebView.addJavascriptInterface(new JavaScriptBridge(), "openProfile");
openProfile({
    action: 'openProfile',
    params:{
        id: '888'
    }
});
```

![file](https://static.yximgs.com/udata/pkg/EE-KSTACK/25e9a063afa8ed751d9647e86906f4d1.png)

**代表产品：**
微信公众号
**优点：**
同步，回调速度比较快，更接近写代码方式
**缺点：**
低版本IOS系统不支持此方式，安卓4.2之前，注入javascript接口的方式是addJavascriptInterface，存在安全漏洞，4.2之后引入Javascriptinterface新方法做替代，存在兼容性问题。

#### 3.2 native调用JS：

使用evaluatingJavaScript执行JS代码
相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，Native想要调用JS的时候，可以把数据与调用的JS函数，通过字符串拼接成JS代码，交给WebView进行执行，直接调用相应的 API 即可执行拼接 JavaScript 字符串。
aweme://profile?douyin_id=233&callback_id=dy20180724；
类似JSONP的逻辑，js会提供一个方法等待客户端调用。

```JavaScript
window.nativeCallBackMap = {};

function nativeCallJs(data) {
    let data = JSON.parse(data);
  let callback = window.nativeCallbackMap[data['callbackId'];
  callback(data['resData']);
}
NSString *resDataString = [self _serializeMessageData:data];
NSString* javascriptCommand = [NSString stringWithFormat:@"nativeCallJs('%@');", resDataString];
[self.webView evaluateJavaScript:javascriptCommand completionHandler:nil];

// 'nativeCallJs({callbackId: xxx, resData: xxx})'
```

这段代码只是用来拼接出字符串
再用evaluatingJavaScript或loadUrl对js代码进行执行，即完成了native对js方法的调用

● hybrid应用优点：首先具有所有 webView 所有的优点，解决了单纯 webView 的交互功能受限，能调用原生接口完成需求
● 缺点：也无法避免 webView 所带来的性能问题，打开白屏时间长，用户体验较差，等问题，也存在受限与浏览器，及重复打开需要重复加载等问题所有新需要客户端提供的功能都需要客户端发版。



## 跨端方案



### 有哪些

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-11-54-image-20230429115447702.png" alt="image-20230429115447702" style="zoom:50%;" />







### webview

#### 介绍

就是个移动端中用于加载网页的控件。大多数混合框架都是基于webview的二次开发：比如ionic、cordova。Android和iOS平台都有内置的WebView组件可供使用，也可以使用第三方库实现WebView。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-12-09-image-20230429120945253.png" alt="image-20230429120945253" style="zoom:50%;" />





#### webview使用原生能力

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-12-04-image-20230429120450138.png" alt="image-20230429120450138" style="zoom:50%;" />

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-12-13-image-20230429121329358.png" alt="image-20230429121329358" style="zoom:50%;" />





### 小程序

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-12-17-image-20230429121719760.png" alt="image-20230429121719760" style="zoom:50%;" />



### 用js去写原生

#### RN/weex

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-12-19-image-20230429121905029.png" alt="image-20230429121905029" style="zoom:50%;" />

React Native 和使用 WebView 的区别：

1. **性能和原生体验**：React Native 使用原生组件来渲染用户界面，因此具有更好的性能和原生体验。相比之下，WebView 是一个嵌入式的浏览器视图，它在应用内部加载和显示 Web 内容，但性能可能不如原生组件。





#### 其它方案

高赞的：https://github.com/expo





### Flutter

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-29-12-25-image-20230429122558374.png" alt="image-20230429122558374" style="zoom:50%;" />





# 音视频

## 音频

浏览器会拦截自动播放行为，安卓内置webview没有这个限制，直接可以播不用等第一次。[详情见这里](https://developer.mozilla.org/zh-CN/docs/Web/Media/Autoplay_guide)

这篇资料还没看：https://zhuanlan.zhihu.com/p/401204241

### 简单的播放音频Audio

```html
<audio autoplay src="path/to/music.mp3"></audio>
```

或者：

```js
const audio = new Audio();
audio.autoplay = true;
audio.src = 'path/to/music.mp3';
```

这种方式播放的音频，只能控制播放、暂停等等一些简单的操作。



### 更「高级」AudioContext

#### 介绍

想要控制音频更「高级」的属性，比如声道的合并与分割、混响、音调、声相控制和音频振幅压缩等等，这就基于 `AudioContext`。我们以最简单的栗子来了解一下 `AudioContext` 的用法：

```js
const URL = 'path/to/music.mp3';
const audioContext = new AudioContext();
const playAudio = function (buffer) {
   const source = audioContext.createBufferSource();
   source.buffer = buffer;
   source.connect(audioContext.destination);
   source.start();
};
const getBuffer = function (url) {
   const request = new XMLHttpRequest();
   return new Promise((resolve, reject) => {
request.open('GET', url, true);
       request.responseType = 'arraybuffer';
       request.onload = () => {
           audioContext.decodeAudioData(request.response, buffer => buffer ? resolve(buffer) : reject('decoding error'));
       };
       request.onerror = error => reject(error);
       request.send();
   });
};
const buffer = await getBuffer(URL);
buffer && playAudio(buffer);
```

代码无非就做了三件事：

- 通过 `ajax` 把音频数据请求下来；
- 通过 `audioContext.decodeAudioData()` 方法把音频数据转换成我们所需要的 `buffer` 格式；
- 通过 `playAudio()` 方法把音频播放出来。

这里需要重点讲一下 `playAudio` 这个函数，我提取出了三个关键点：

- `source`
- `connect`
- `destination`

你可以试着以这种方式来理解这三个关键点：首先我们通过 `audioContext.createBufferSource()` 方法创建了一个「容器」 `source` 并装入接收进来的「水」 `buffer`；其次通过「管道」 `connect` 把它和「出口」 `destination` 连接起来；最终「出口」 `destination` 「流」出来的就是我们所听到的音频了。



#### 音频节点(`AudioNode`)

可以把它理解为是通过「管道」 `connect` 连接在「容器」`source` 和「出口」 `destination` 之间一系列的音频「处理器」。`AudioContext` 提供了许多「处理器」用来处理音频，比如音量「处理器」 `GainNode`、延时「处理器」 `DelayNode` 或声道合并「处理器」 `ChannelMergerNode` 等等。

前面所提到的「管道」 `connect`，「容器」 `source`  也是一种音频节点 `AudioNode` 。



举例：GainNode

音频处理是通过一个个「处理器」来处理的，那么在实际应用中怎么把我们想要的「处理器」装上去呢？

```js
const source = audioContext.createBufferSource();
const gainNode = audioContext.createGain();
const buffer = await getBuffer(URL);

source.buffer = buffer;
source.connect(gainNode);
gainNode.connect(source.destination);

const updateVolume = volume => gainNode.gain.value = volume;
```

可以发现和上面提到的 `playAudio` 方法很像，区别只是 `source` 不直接 connect 到 `source.destination`，而是先 connect 到 `gainNode`，然后再通过 `gainNode` connect 到 `source.destination`。这样其实就把「音量处理器」装载上去了，此时我们通过更新 `gainNode.gain.value` 的值（`0 - 1` 之间）就可以控制音量的大小了。



多个音频节点 `connect` 到一起就形成了 **音频导向图（Audio Routing Graph）**：

![image-20231216134103480](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-16-13-41-image-20231216134103480.png)





#### 多个音频源

 `AudioContext` 中可以同时使用多个「处理器」去处理一个音频源，在 `AudioContext` 中可以有多个音频处理通道，它们之间互不影响：

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-16-13-37-image-20231216133729904.png" alt="image-20231216133729904" style="zoom:25%;" />



```js
const sourceOne = audioContext.createBufferSource();
const sourceTwo = audioContext.createBufferSource();
const gainNodeOne = audioContext.createGain();
const gainNodeTwo = audioContext.createGain();

sourceOne.connect(gainNodeOne);
sourceTwo.connect(gainNodeTwo);
gainNodeOne.connect(audioContext.destination);
gainNodeTwo.connect(audioContext.destination);
```



#### 模块化(`Modular`)

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-16-13-39-image-20231216133907592.png" alt="image-20231216133907592" style="zoom:25%;" />

通过前面 **音频节点** 的介绍，相信你们已经感受到了 Web Audio 的模块化设计了，它提供了一种非常方便的方式来为音频装上(`connect`)不同的「处理器」 `AudioNode`。不仅一个音频源可以使用多个「处理器」，而多个音频源也可以合并为一个「输出」 `destination`。

得益于 Web Audio 的模块化设计，除了上面提到的模块（`AudioNode`），它还提供了非常多的可配置的、高阶的、开箱即用的模块。所以通过使用这些模块，我们完全可以创建出功能丰富的音频处理应用。







### 区别

**`Audio`:**

- 简单的音频播放器；
- 「单线程」的音频；

**Web Audio:**

- 音频合成；
- 可以做音频的各种处理；
- 游戏或可交互应用中的环绕音效；
- 可视化音频等等等等。





## 视频

快手的用法 见 增长md。

这个库比较出名？https://github.com/videojs/video.js

H.265，也被称为HEVC（High Efficiency Video Coding），是一种高效的视频压缩标准，它的主要优势在于提供相同的视频质量的情况下，相比于H.264可以提供大约两倍的数据压缩比。然而，由于H.265的解码需要更高的计算能力，因此并非所有的设备或浏览器都支持H.265的解码。

`@ks/player/src/wrapped-video/video.ts`的`useH265Play`方法中，当检测到视频是H.265编码时，会使用canvas来播放视频。这是因为canvas提供了更多的控制权和灵活性，可以通过JavaScript来操作canvas，包括绘制图像、创建动画等。在这里，canvas被用来绘制H.265视频的每一帧。而video标签虽然可以用来播放视频，但是它的功能相对有限，主要依赖于浏览器的内置功能。如果浏览器不支持H.265，那么video标签就无法播放H.265视频。而canvas配合JavaScript就可以实现更多的功能，包括播放那些浏览器本身不支持的视频格式。







# 富文本

快手大佬推荐的：

meta公司：https://github.com/facebook/lexical  、快手内网搜：**Lexical设计理念和在CMS应用**

star最多：https://docs.slatejs.org/

猿辅导用来搞在线文档：https://prosemirror.net/

https://tiptap.dev/installation







# 微前端

解决遗留系统，才是人们采用微前端方案最重要的原因。既然应用可以使用，就不花太多的力气重写，而是直接整合到新的应用中去。不重写原有系统。







# 开发时用的工具

## 部署静态资源

有个npm库：serve

可以将目录部署到3000端口让你通过http协议访问。



## 页面相关

点击页面元素打开IDE源码的开源提效工具：https://juejin.cn/post/7326002010084311079#heading-10





## 网络相关

### 请求这个网址会返回json数据（可用于测试请求）

https://jsonplaceholder.typicode.com/todos/2





## 敲代码

用这个插件可以加强console.log的体验 https://www.npmjs.com/package/babel-plugin-enhance-log 或 https://github.com/unjs/consola







## css

### 统计css代码体积

网址：bytesizematters.com



### 可视化贝塞尔曲线

网址：https://cubic-bezier.com/



css可以做很多事情：https://github.com/you-dont-need?q=&type=all&language=&sort=stargazers



### 背景图案

svg实现：https://philiprogers.com/svgpatterns/#subtledots

渐变实现：lea.verou.me/css3patterns



## 滚动

https://github.com/ustbhuangyi/better-scroll



