# 服务器







## 前后端数据通信

### RESTful API 

#### 简介

`REST`的全称是`Representational state transfer`。中文含义为表现层状态转化。它描述了一个系统如何与另一个交流。具体如下:

- Representational: 数据的表现形式(JSON、XML...)
- state: 当前状态或者数据
- transfer: 数据传输

符合REST规范的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源，并表现在URL上。

<font color="red">RESTful与MVC设计并不冲突，而且是更好的改进。相比MVC, RESTful只是将HTTP请求方法也加入了路由的过程，以及在URL路径上体现得更资源化（即url路径上不再出现操作的词汇如`add`、`delete`）。</font>

`REST` 一般通过 Http 方法`GET`, `DELETE`, `POST` 和 `PUT`等 来操作资源。

Query和Params可以结合使用。例如，在RESTful API中，Query通常用于过滤、排序和分页等操作，而Params则用于传递实际的数据。



#### 六个约束:

- 客户-服务器(Client-Server)

  关注点分离。服务端专注数据存储，提升了简单性，前端专注用户界面，提升了可移植性。

- 无状态(Stateless)

  所有用户会话信息都保存在客户端。每次请求必须包括所有信息，不能依赖上下文信息。服务端不用保存会话信息，提升了简单性、可靠性、可见性。

- 缓存(Cache)

  所有服务端响应都要被标为可缓存或不可缓存，减少前后端交互，提升了性能。

- 统一接口(Uniform Interface)

  接口设计尽可能统一通用，提升了简单性、可见性。接口与实现解耦，使前后端可以独立开发迭代。

- 分层系统(Layered System)

- 按需代码(Code-On-Demand)

#### 行业内的最佳实践

##### `请求设计规范`

- `URI 使用名词`，尽量使用复数，如/users
- URI 使用`嵌套`表示`关联关系`，如/users/123/repos/234
- 使用`正确的 HTTP 方法`，如 GET/POST/PUT/DELETE

##### `响应设计规范`

- `查询`
- `分页`
- `字段过滤`

如果记录数量很多，服务器不可能都将它们返回给用户。API 应该提供参数，过滤返回结果。下面是一些常见的参数（包括上面的查询、分页以及字段过滤）：

```ini
?limit=10：指定返回记录的数量
?offset=10：指定返回记录的开始位置。
?page=2&per_page=100：指定第几页，以及每页的记录数。
?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。
?animal_type_id=1：指定筛选条件
```

- `状态码`
- `错误处理`

就像 HTML 的出错页面向访问者展示了有用的错误消息一样，API 也应该用之前清晰易读的格式来提供有用的错误消息。

比如对于常见的提交表单，当遇到如下错误信息时：

```json
{
    "error": "Invalid payoad.",
    "detail": {
        "surname": "This field is required."
    }
}
```

接口调用者很快就能定位到错误原因。

##### `安全`

- `HTTPS`
- `鉴权`

RESTful API 应该是无状态。这意味着对请求的认证不应该基于`cookie`或者`session`。相反，每个请求应该带有一些认证凭证。

- `限流`

为了避免请求泛滥，给 API 设置`速度限制`很重要。为此 `RFC 6585` 引入了 HTTP 状态码`429（too many requests）`。加入速度设置之后，应该给予用户提示。











对于前端来说，后端主要是提供 http 接口来传输数据，而这种数据传输的方式主要有 5 种：

- url param
- query
- form-urlencoded
- form-data
- json

###  url param

我们可以把参数写在 url 中，比如：

```arduino
http://guang.zxg/person/1111
```

这里的 1111 就是路径中的参数（url param），服务端框架或者单页应用的路由都支持从 url 中取出参数。

### query

通过 url 中 ？后面的用 & 分隔的字符串传递数据。比如：

```ini
http://guang.zxg/person?name=guang&age=20
```

这里的 name 和 age 就是 query 传递的数据。

其中非英文的字符和一些特殊字符要经过编码，可以使用 encodeURIComponent 的 api 来编码：

```javascript
const query = "?name=" + encodeURIComponent('光') + "&age=20"

// ?name=%E5%85%89&age=20
```

或者使用封装了一层的 query-string 库来处理。

```javascript
const queryString = require('query-string');

queryString.stringify({
  name: '光',
  age: 20
});

// ?name=%E5%85%89&age=20
```

### form-urlencoded

直接用 form 表单提交数据就是这种，它和 query 字符串的方式的区别只是放在了 body 里，然后指定下 content-type 是 `application/x-www-form-urlencoded`。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-25-n5veKa.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-25-n5veKa.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-25-n5veKa.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-25-n5veKa.webp" loading="lazy"/>
  </picture>

因为内容也是 query 字符串，所以也要用 encodeURIComponent 的 api 或者 query-string 库处理下。

这种格式也很容易理解，get 是把数据拼成 query 字符串放在 url 后面，于是表单的 post 提交方式的时候就直接用相同的方式把数据放在了 body 里。

通过 & 分隔的 form-urlencoded 的方式需要对内容做 url encode，如果传递大量的数据，比如上传文件的时候就不是很合适了，因为文件 encode 一遍的话太慢了，这时候就可以用 form-data。

### form-data

fetch提交formdata时候不需要指定content-type。

form data 不再是通过 & 分隔数据，而是用 --------- + 一串数字做为 boundary 分隔符。因为不是 url 的方式了，自然也不用再做 url encode。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wl0xnq.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wl0xnq.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wl0xnq.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wl0xnq.webp" loading="lazy"/>
  </picture>

form-data 需要指定 content type 为 `multipart/form-data`，然后指定 boundary 也就是分割线。

body 里面就是用 boundary 分隔符分割的内容。

很明显，这种方式适合传输文件，而且可以传输多个文件。

但是毕竟多了一些只是用来分隔的 boundary，所以请求体会增大。

### json

form-urlencoded 需要对内容做 url encode，而 form data 则需要加很长的 boundary，两种方式都有一些缺点。如果只是传输 json 数据的话，不需要用这两种。

可以直接指定content type 为 application/json 就行：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UJDtcB.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UJDtcB.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UJDtcB.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UJDtcB.webp" loading="lazy"/>
  </picture>





### GraphQL

#### 介绍

restful 风格的 web 接口返回什么信息是服务端那边决定的，客户端只是传一下参数。

而不同场景下需要的数据不同，这时候可能就得新开发一个接口。特别是在版本更新的时候，接口会有所变动。这样就很容易导致一大堆类似的接口。

facebook 当时也遇到了这个问题，于是他们创造了一种新的接口实现方案：GraphQL。用了 GraphQL 之后，返回什么数据不再是服务端说了算，而是客户端自己决定。服务端只需要提供一个接口，客户端通过这个接口就可以取任意格式的数据，实现 CRUD。

GraphQL 全称是 graph query language，就是从这个对象的 graph 中查询数据的。

比如想查询所有的学生，就可以这样：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4EWUbe.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4EWUbe.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4EWUbe.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4EWUbe.webp" loading="lazy"/>
  </picture>

想再查询他们的年龄，就可以这样：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ZNUvkE.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ZNUvkE.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ZNUvkE.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ZNUvkE.webp" loading="lazy"/>
  </picture>

想查询老师的名字和他教的学生，就可以这样：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-X1iE5P.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-X1iE5P.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-X1iE5P.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-X1iE5P.webp" loading="lazy"/>
  </picture>

而这些都是在一个 http 接口里完成的！**一个 http 接口就能实现所有的 CRUD！**



#### 实现

##### 服务端实现GraphQL接口

那这么强大的 GraphQL 是怎么实现的呢？

我们先写个 demo 快速入门一下：

facebook 提供了 graphql 的 npm 包，但那个封装的不够好，一般我们会用基于 graphql 包的 @apollo/server 和 @apollo/client 的包来实现 graphql。



安装用到的包：

```bash
npm install @apollo/server
```

然后在 index.js 写一下这段代码：

```javascript
javascript
复制代码import { ApolloServer } from '@apollo/server';

const typeDefs = `
  type Student {
    id: String,
    name: String,
    sex: Boolean
    age: Int
  }

  type Teacher {
    id: String,
    name: String,
    age: Int,
    subject: [String],
    students: [Student]
  }

  type Query {
    students: [Student],
    teachers: [Teacher],
  }

  schema {
    query: Query
  }
`;
```

定义了一个 Student 的对象类型，有 id、name、sex、age 这几个字段。

又定义了一个 Teacher 的对象类型，有 id、name、age、subject、students 这几个字段。students 字段是他教的学生的信息。

然后定义了查询的入口，可以查 students 和 teachers 的信息。

这样就是一个 schema。

对象类型和对象类型之间有关联关系，老师关联了学生、学生也可以关联老师，关联来关联去这不就是一个图么，也就是 graph。



现在我们声明的只是对象类型的关系，还要知道这些类型的具体数据，取数据的这部分叫做 resolver。

```javascript
javascript
复制代码const students = [
    {
      id: '1',
      name: async () => {
        await '取数据';
        return '光光'
      },
      sex: true,
      age: 12
    },
    {
      id: '2',
      name:'东东',
      sex: true,
      age: 13
    },
    {
      id: '3',
      name:'小红',
      sex: false,
      age: 11
    },
];

const teachers = [
  {
    id: '1',
    name: '神光',
    sex: true,
    subject: ['体育', '数学'],
    age: 28,
    students: students
  }
]

const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers
    }
};
```

resolver 是取对象类型对应的数据的，每个字段都可以写一个 async 函数，里面执行 sql、访问接口等都可以，最终返回取到的数据。

当然，直接写具体的数据也是可以的。

这样有了 schema 类型定义，有了取数据的 resovler，就可以跑起 graphql 服务了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Urmj7f.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Urmj7f.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Urmj7f.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Urmj7f.webp" loading="lazy"/>
  </picture>

也就是这样：

```javascript
import { startStandaloneServer } from '@apollo/server/standalone' 

const server = new ApolloServer({
    typeDefs,
    resolvers,
});
  
const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
});
  
console.log(`🚀  Server ready at: ${url}`);
```

传入 schema 类型定义和取数据的 resolver，就可以用 node 把服务跑起来。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-67XZQm.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-67XZQm.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-67XZQm.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-67XZQm.webp" loading="lazy"/>
  </picture>



跑起来之后，浏览器访问一下：

就可以看到这样的 sandbox，这里可以执行 graphql 的查询：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wykh6y.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wykh6y.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wykh6y.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wykh6y.webp" loading="lazy"/>
  </picture>

（graphql 接口是监听 POST 请求的，用 get 请求这个 url 才会跑这个调试的工具）

我查询所有学生的 id、name、age 就可以这样：

```graphql
query Query {
    students {
        name,
        id
    }
}
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-95l1Yl.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-95l1Yl.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-95l1Yl.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-95l1Yl.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-cyTIoU.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-cyTIoU.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-cyTIoU.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-cyTIoU.webp" loading="lazy"/>
  </picture>

这里 “光光” 那个学生是异步取的数据，resolver 会执行对应的异步函数，拿到最终数据：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-o36Ipi.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-o36Ipi.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-o36Ipi.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-o36Ipi.webp" loading="lazy"/>
  </picture>

取老师的信息就可以这样：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UTVIaQ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UTVIaQ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UTVIaQ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-UTVIaQ.webp" loading="lazy"/>
  </picture>



##### 客户端实现请求GraphQL

###### 查

当然，我们这里是在 sandbox 里测的，用 @apollo/client 包也很简单。

比如 react 的 graphql 客户端是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-rw6Jpg.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-rw6Jpg.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-rw6Jpg.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-rw6Jpg.webp" loading="lazy"/>
  </picture>

一个 gql 的 api 来写查询语言，一个 useQuery 的 api 来执行查询。

我们之后还是直接在 sandbox 里测试。

有的同学可能会说，如果我想查询某个名字的老师的信息呢？

怎么传参数？

graphql 当然是支持的，这样写：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-AaFzlb.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-AaFzlb.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-AaFzlb.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-AaFzlb.webp" loading="lazy"/>
  </picture>

```ini
ini
复制代码type Query {
    students: [Student],
    teachers: [Teacher],
    studentsbyTeacherName(name: String!): [Student]
}
```

新加一个 query 入口，声明一个 name 的参数。（这里 String 后的 ! 代表不能为空）

然后它对应的 resolver 就是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-aQrJD9.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-aQrJD9.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-aQrJD9.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-aQrJD9.webp" loading="lazy"/>
  </picture>

```javascript
javascript
复制代码const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers,
      studentsbyTeacherName: async (...args) => {
        console.log(args);

        await '执行了一个异步查询'
        return students
      }
    }
};
```

studentsbyTeacherName 字段的 resolver 是一个异步函数，里面执行了查询，然后返回了查到的学生信息。

我们打印下参数看看传过来的是什么。

有参数的查询是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HPouIt.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HPouIt.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HPouIt.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HPouIt.webp" loading="lazy"/>
  </picture>

传入老师的 name 参数为 111，返回查到的学生的 id、name 信息。

可以看到返回的就是查询到的结果。

而服务端的 resolver 接收到的参数是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-J8SorR.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-J8SorR.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-J8SorR.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-J8SorR.webp" loading="lazy"/>
  </picture>

其余的几个参数不用管，只要知道第二个参数就是客户端传过来的查询参数就好了。

这样我们就可以根据这个 name 参数实现异步的查询，然后返回数据。



###### 增删改

其实看到上面的有参数的查询应该就能想到了，其实写起来差不多。

在 schema 里添加这样一段类型定义：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ATcBR6.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ATcBR6.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ATcBR6.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ATcBR6.webp" loading="lazy"/>
  </picture>

```grqphql
grqphql
复制代码type Res {
    success: Boolean
    id: String
}

type Mutation {
    addStudent(name:String! age:Int! sex:Boolean!): Res

    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res

    deleteStudent(id: String!): Res
}

schema {
    mutation: Mutation
    query: Query
}
```

和有参数的查询差不多，只不过这部分增删改的类型要定义在 mutation 部分。

然后 resolver 也要有对应的实现：

```javascript
javascript
复制代码async function addStudent (_, { name, age, sex }) {
    students.push({
        id: '一个随机 id',
        name,
        age,
        sex
    });
    return {
      success: true,
      id: 'xxx'
    }
}

async function updateStudent (_, { id, name, age, sex }) {

    return {
      success: true,
      id: 'xxx'
    }
}

async function deleteStudent (_, { id }) {
    return {
      success: true,
      id: 'xxx'
    }
}
  
const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers,
      studentsbyTeacherName: async (...args) => {
        console.log(args);

        await '执行了一个异步查询'
        return students
      }
    },
    Mutation: {
        addStudent: addStudent,
        updateStudent: updateStudent,
        deleteStudent: deleteStudent
    }
};
```

和 query 部分差不多，只不过这里实现的是增删改。

我只对 addStudent 做了实现。

我们测试下：

执行 addStudent，添加一个学生：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pVxKpn.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pVxKpn.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pVxKpn.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pVxKpn.webp" loading="lazy"/>
  </picture>

然后再次查询所有的学生：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-P9cNsZ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-P9cNsZ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-P9cNsZ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-P9cNsZ.webp" loading="lazy"/>
  </picture>

就可以查到刚来的小刚同学。

这样，我们就可以在一个 graphql 的 POST 接口里完成所有的 CRUD！

全部代码如下，大家可以跑一跑（注意要在 package.json 里加个 type: "module"）

```javascript
javascript
复制代码import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone' 

const typeDefs = `
  type Student {
    id: String,
    name: String,
    sex: Boolean
    age: Int
  }

  type Teacher {
    id: String,
    name: String,
    age: Int,
    subject: [String],
    students: [Student]
  }

  type Query {
    students: [Student],
    teachers: [Teacher],
    studentsbyTeacherName(name: String!): [Student]
  }

  type Res {
    success: Boolean
    id: String
  }

  type Mutation {
    addStudent(name:String! age:Int! sex:Boolean!): Res

    updateStudent(id: String! name:String! age:Int! sex:Boolean!): Res

    deleteStudent(id: String!): Res
  }

  schema {
    mutation: Mutation
    query: Query
  }
`;

const students = [
    {
      id: '1',
      name: async () => {
        await '取数据';
        return '光光'
      },
      sex: true,
      age: 12
    },
    {
      id: '2',
      name:'东东',
      sex: true,
      age: 13
    },
    {
      id: '3',
      name:'小红',
      sex: false,
      age: 11
    },
];

const teachers = [
  {
    id: '1',
    name: '神光',
    sex: true,
    subject: ['体育', '数学'],
    age: 28,
    students: students
  }
]

async function addStudent (_, { name, age, sex }) {
    students.push({
        id: '一个随机 id',
        name,
        age,
        sex
    });
    return {
      success: true,
      id: 'xxx'
    }
}

async function updateStudent (_, { id, name, age, sex }) {

    return {
      success: true,
      id: 'xxx'
    }
}

async function deleteStudent (_, { id }) {
    return {
      success: true,
      id: 'xxx'
    }
}
  
const resolvers = {
    Query: {
      students: () => students,
      teachers: () => teachers,
      studentsbyTeacherName: async (...args) => {
        console.log(args);

        await '执行了一个异步查询'
        return students
      }
    },
    Mutation: {
        addStudent: addStudent,
        updateStudent: updateStudent,
        deleteStudent: deleteStudent
    }
};

const server = new ApolloServer({
    typeDefs,
    resolvers,
});
  
const { url } = await startStandaloneServer(server, {
    listen: { port: 4000 },
});
  
console.log(`🚀  Server ready at: ${url}`);
```





#### 原理

graphql 是怎么实现的呢？

回顾整个流程，我们发现涉及到两种 DSL（领域特定语言），一个是 schema 定义的 DSL，一个是查询的 DSL。

服务端通过 schema 定义的 DSL 来声明 graph 图，通过 resolver 来接受参数，执行查询和增删改。

客户端通过查询的 DSL 来定义如何查询和如何增删改，再发给服务端来解析执行。

通过这种 DSL 实现了动态的查询。

确实很方便很灵活，但也有缺点，就是 parse DSL 为 AST 性能肯定是不如 restful 那种直接执行增删改查高的。









## 什么是正向代理和反向代理

一句话说明：正向代理就是代理客户端的请求，在一个面向客户端的位置。反向代理就是将客户端的请求分发到不同的服务器，在一个面向服务端的位置。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tkWebk.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tkWebk.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tkWebk.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tkWebk.webp" loading="lazy"/>
  </picture>

### 正向代理

是指客户端通过代理服务器发送请求到目标服务器。客户端向代理服务器发送请求，代理服务器再将请求转发给目标服务器，并将服务器的响应返回给客户端。正向代理可以隐藏客户端的真实IP地址，提供匿名访问和访问控制等功能。它常用于跨越防火墙访问互联网、访问被封禁的网站等情况。

### 反向代理

是指客户端发送请求到代理服务器，代理服务器再将请求转发给后端的多个服务器中的一个或多个，并将后端服务器的响应返回给客户端。客户端并不直接访问后端服务器，而是通过反向代理服务器来获取服务。反向代理可以实现负载均衡、高可用性和安全性等功能。它常用于网站的高并发访问、保护后端服务器、提供缓存和SSL终止等功能。









## Nginx

### 什么是Nginx

Nginx是一个开源的高性能HTTP和反向代理服务器。

Nginx采用事件驱动的异步架构，能够处理大量并发连接而不会消耗过多的系统资源。它的处理能力比传统的Web服务器更高，在高并发负载下表现出色。

Nginx支持丰富的模块化扩展，可以通过添加第三方模块来提供额外的功能，如gzip压缩、SSL/TLS加密、缓存控制等。

### Nginx应用场景

1. 反向代理+负载均衡：Nginx可以作为反向代理服务器，实现负载均衡。请求发给 nginx，由它转发给应用服务器，这一层也可以叫做网关。

   <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-37-image-20240206113739483.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-37-image-20240206113739483.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-37-image-20240206113739483.png" alt="image-20240206113739483" style="zoom:75%;" loading="lazy"/>
  </picture>

2. 静态文件服务。 为什么需要做动静分离呢？

   先来以淘宝为例分析看看：
    当浏览器输入`www.taobao.com`访问淘宝首页时，打开开发者调试工具可以很明显的看到，首页加载会出现`100+`的请求数，如果这些请求都来到部署`WEB`服务的机器处理，那则代表着一个客户端请求淘宝首页，就会对后端服务器造成`100+`的并发请求。

   大部分资源是静态的，且这些资源大概率情况下长时间也不会出现变动，那为何还要让这些请求到后端再处理呢？所以**做了动静分离之后，至少能够让后端服务减少一半以上的并发量。** 

   

   

### 如何处理请求

Nginx处理请求的基本流程如下：

1. 接收请求：Nginx作为服务器软件监听指定的端口，接收客户端发来的请求。
2. 解析请求：Nginx解析请求的内容，包括请求方法（GET、POST等）、URL、头部信息等。
3. 配置匹配：Nginx根据配置文件中的规则和匹配条件，决定如何处理该请求。配置文件定义了虚拟主机、反向代理、负载均衡、缓存等特定的处理方式。
4. 处理请求：Nginx根据配置的处理方式，可能会进行以下操作：
   - 静态文件服务：如果请求的是静态资源文件，如HTML、CSS、JavaScript、图片等，Nginx可以直接返回文件内容，不必经过后端应用程序。
   - 反向代理：如果配置了反向代理，Nginx将请求转发给后端的应用服务器，然后将其响应返回给客户端。这样可以提供负载均衡、高可用性和缓存等功能。
   - 缓存：如果启用了缓存，Nginx可以缓存一些静态或动态内容的响应，在后续相同的请求中直接返回缓存的响应，减少后端负载并提高响应速度。
   - URL重写：Nginx可以根据配置的规则对URL进行重写，将请求从一个URL重定向到另一个URL或进行转换。
   - SSL/TLS加密：如果启用了SSL/TLS，Nginx可以负责加密和解密HTTPS请求和响应。
   - 访问控制：Nginx可以根据配置的规则对请求进行访问控制，例如限制IP访问、进行身份认证等。
5. 响应结果：Nginx根据处理结果生成响应报文，包括状态码、头部信息和响应内容。然后将响应发送给客户端。









### 使用

#### Nginx环境搭建

❶首先创建`Nginx`的目录并进入：

```shell
[root@localhost]# mkdir /soft && mkdir /soft/nginx/
[root@localhost]# cd /soft/nginx/
```

❷下载`Nginx`的安装包，可以通过`FTP`工具上传离线环境包，也可通过`wget`命令在线获取安装包：

```shell
[root@localhost]# wget https://nginx.org/download/nginx-1.21.6.tar.gz
```

没有`wget`命令的可通过`yum`命令安装：

```shell
shell
复制代码[root@localhost]# yum -y install wget
```

❸解压`Nginx`的压缩包：

```shell
shell
复制代码[root@localhost]# tar -xvzf nginx-1.21.6.tar.gz
```

❹下载并安装`Nginx`所需的依赖库和包：

```shell
shell
复制代码[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ gcc-c++
[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ pcre pcre-devel4
[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ zlib zlib-devel
[root@localhost]# yum install --downloadonly --downloaddir=/soft/nginx/ openssl openssl-devel
```

也可以通过`yum`命令一键下载（推荐上面方式）：

```shell
shell
复制代码[root@localhost]# yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel
```

执行完成后，然后`ls`查看目录文件，会看一大堆依赖：
 <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-hJJgUl.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-hJJgUl.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-hJJgUl.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-hJJgUl.webp" loading="lazy"/>
  </picture>
 紧接着通过`rpm`命令依次将依赖包一个个构建，或者通过如下指令一键安装所有依赖包：

```shell
shell
复制代码[root@localhost]# rpm -ivh --nodeps *.rpm
```

❺进入解压后的`nginx`目录，然后执行`Nginx`的配置脚本，为后续的安装提前配置好环境，默认位于`/usr/local/nginx/`目录下（可自定义目录）：

```shell
shell
复制代码[root@localhost]# cd nginx-1.21.6
[root@localhost]# ./configure --prefix=/soft/nginx/
```

❻编译并安装`Nginx`：

```shell
shell
复制代码[root@localhost]# make && make install
```

❼最后回到前面的`/soft/nginx/`目录，输入`ls`即可看见安装`nginx`完成后生成的文件。

❽修改安装后生成的`conf`目录下的`nginx.conf`配置文件：

```shell
shell
复制代码[root@localhost]# vi conf/nginx.conf
    修改端口号：listen    80;
	修改IP地址：server_name  你当前机器的本地IP(线上配置域名);
```

❾制定配置文件并启动`Nginx`：

```shell
shell
复制代码[root@localhost]# sbin/nginx -c conf/nginx.conf
[root@localhost]# ps aux | grep nginx
```

`Nginx`其他操作命令：

```shell
shell
复制代码sbin/nginx -t -c conf/nginx.conf # 检测配置文件是否正常
sbin/nginx -s reload -c conf/nginx.conf # 修改配置后平滑重启
sbin/nginx -s quit # 优雅关闭Nginx，会在执行完当前的任务后再退出
sbin/nginx -s stop # 强制终止Nginx，不管当前是否有任务在执行
```

❿开放`80`端口，并更新防火墙：

```shell
shell
复制代码[root@localhost]# firewall-cmd --zone=public --add-port=80/tcp --permanent
[root@localhost]# firewall-cmd --reload
[root@localhost]# firewall-cmd --zone=public --list-ports
```

⓫在`Windows/Mac`的浏览器中，直接输入刚刚配置的`IP`地址访问`Nginx`：
 <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-w2ADll.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-w2ADll.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-w2ADll.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-w2ADll.webp" loading="lazy"/>
  </picture>
 最终看到如上的`Nginx`欢迎界面，代表`Nginx`安装完成。



#### nginx 启动和关闭

```bash
进入目录：/usr/local/nginx/sbin
启动命令：./nginx
重启命令：nginx -s reload
快速关闭命令：./nginx -s stop
有序地停止，需要进程完成当前工作后再停止：./nginx -s quit
直接杀死nginx进程：killall nginx
```

#### 目录结构

```csharp
[root@localhost ~]# tree /usr/local/nginx
/usr/local/nginx

├── client_body_temp                 # POST 大文件暂存目录
├── conf                             # Nginx所有配置文件的目录
│   ├── fastcgi.conf                 # fastcgi相关参数的配置文件
│   ├── fastcgi.conf.default         # fastcgi.conf的原始备份文件
│   ├── fastcgi_params               # fastcgi的参数文件
│   ├── fastcgi_params.default      
│   ├── koi-utf
│   ├── koi-win
│   ├── mime.types                   # 媒体类型
│   ├── mime.types.default
│   ├── nginx.conf                   #这是Nginx默认的主配置文件，日常使用和修改的文件
│   ├── nginx.conf.default
│   ├── scgi_params                 # scgi相关参数文件
│   ├── scgi_params.default  
│   ├── uwsgi_params                 # uwsgi相关参数文件
│   ├── uwsgi_params.default
│   └── win-utf
├── fastcgi_temp                     # fastcgi临时数据目录
├── html                             # Nginx默认站点目录
│   ├── 50x.html                     # 错误页面优雅替代显示文件，例如出现502错误时会调用此页面
│   └── index.html                   # 默认的首页文件
├── logs                             # Nginx日志目录
│   ├── access.log                   # 访问日志文件
│   ├── error.log                   # 错误日志文件
│   └── nginx.pid                   # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件
├── proxy_temp                       # 临时目录
├── sbin                             # Nginx 可执行文件目录
│   └── nginx                       # Nginx 二进制可执行程序
├── scgi_temp                       # 临时目录
└── uwsgi_temp                       # 临时目录
```

#### 配置文件nginx.conf

只要放到 /usr/share/nginx/html 下的文件，都可以通过被访问到。这是因为 nginx 的默认配置。我们看下 nginx 配置文件，也就是 /etc/nginx/nginx.conf。

nginx.conf 叫做主配置文件，里面一般做一些全局的配置，比如错误日志的目录等等。可以看到 http 下面有个 include 引入了 /etc/nginx/conf.d/*.conf 的配置。一般具体的路由配置都是在这些子配置文件里。目录 conf.d 是 configuration directory 的意思。

```ini
# 启动进程,通常设置成和cpu的数量相等
worker_processes  1;

# 全局错误日志定义类型，[debug | info | notice | warn | error | crit]
error_log  logs/error.log;
error_log  logs/error.log  notice;
error_log  logs/error.log  info;

# 进程pid文件
pid        /var/run/nginx.pid;

# 工作模式及连接数上限
events {
    # 仅用于linux2.6以上内核,可以大大提高nginx的性能
    use   epoll;

    # 单个后台worker process进程的最大并发链接数
    worker_connections  1024;

    # 客户端请求头部的缓冲区大小
    client_header_buffer_size 4k;

    # keepalive 超时时间
    keepalive_timeout 60;

    # 告诉nginx收到一个新连接通知后接受尽可能多的连接
    # multi_accept on;
}

# 设定http服务器，利用它的反向代理功能提供负载均衡支持
http {
    # 文件扩展名与文件类型映射表义
    include       /etc/nginx/mime.types;

    # 默认文件类型
    default_type  application/octet-stream;

    # 默认编码
    charset utf-8;

    # 服务器名字的hash表大小
    server_names_hash_bucket_size 128;

    # 客户端请求头部的缓冲区大小
    client_header_buffer_size 32k;

    # 客户请求头缓冲大小
    large_client_header_buffers 4 64k;

    # 设定通过nginx上传文件的大小
    client_max_body_size 8m;

    # 开启目录列表访问，合适下载服务器，默认关闭。
    autoindex on;

    # sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用，
    # 必须设为 on,如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I/O处理速度
    sendfile        on;

    # 此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用
    #tcp_nopush     on;

    # 连接超时时间（单秒为秒）
    keepalive_timeout  65;


    # gzip模块设置
    gzip on;               #开启gzip压缩输出
    gzip_min_length 1k;    #最小压缩文件大小
    gzip_buffers 4 16k;    #压缩缓冲区
    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）
    gzip_comp_level 2;     #压缩等级
    gzip_types text/plain application/x-javascript text/css application/xml;
    gzip_vary on;

    # 开启限制IP连接数的时候需要使用
    #limit_zone crawler $binary_remote_addr 10m;

    # 指定虚拟主机的配置文件，方便管理
    include /etc/nginx/conf.d/*.conf;


    # 负载均衡配置
    upstream aaa {
        # 请见上文中的五种配置
    }


   # 虚拟主机的配置
    server {

        # 监听端口
        listen 80;

        # 域名可以有多个，用空格隔开
        server_name www.aaa.com aaa.com;

        # 默认入口文件名称
        index index.html index.htm index.php;
        root /data/www/sk;

        # 图片缓存时间设置
        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)${
            expires 10d;
        }

        #JS和CSS缓存时间设置
        location ~ .*.(js|css)?${
            expires 1h;
        }

        # 日志格式设定
        #$remote_addr与 $http_x_forwarded_for用以记录客户端的ip地址；
        #$remote_user：用来记录客户端用户名称；
        #$time_local：用来记录访问时间与时区；
        #$request：用来记录请求的url与http协议；
        #$status：用来记录请求状态；成功是200，
        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；
        #$http_referer：用来记录从那个页面链接访问过来的；
        log_format access '$remote_addr - $remote_user [$time_local] "$request" '
        '$status $body_bytes_sent "$http_referer" '
        '"$http_user_agent" $http_x_forwarded_for';

        # 定义本虚拟主机的访问日志
        access_log  /usr/local/nginx/logs/host.access.log  main;
        access_log  /usr/local/nginx/logs/host.access.404.log  log404;

        # 对具体路由进行反向代理
        location /connect-controller {

            proxy_pass http://127.0.0.1:88;
            proxy_redirect off;
            proxy_set_header X-Real-IP $remote_addr;

            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $host;

            # 允许客户端请求的最大单文件字节数
            client_max_body_size 10m;

            # 缓冲区代理缓冲用户端请求的最大字节数，
            client_body_buffer_size 128k;

            # 表示使nginx阻止HTTP应答代码为400或者更高的应答。
            proxy_intercept_errors on;

            # nginx跟后端服务器连接超时时间(代理连接超时)
            proxy_connect_timeout 90;

            # 后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据
            proxy_send_timeout 90;

            # 连接成功后，后端服务器响应的超时时间
            proxy_read_timeout 90;

            # 设置代理服务器（nginx）保存用户头信息的缓冲区大小
            proxy_buffer_size 4k;

            # 设置用于读取应答的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k
            proxy_buffers 4 32k;

            # 高负荷下缓冲大小（proxy_buffers*2）
            proxy_busy_buffers_size 64k;

            # 设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长
            # 设定缓存文件夹大小，大于这个值，将从upstream服务器传
            proxy_temp_file_write_size 64k;
        }

        # 动静分离反向代理配置（多路由指向不同的服务端或界面）
        location ~ .(jsp|jspx|do)?$ {
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass http://127.0.0.1:8080;
        }
    }
}
```



#### 虚拟主机

虚拟主机就是可以用一台 nginx 服务器来为多个域名和端口的提供服务。只要多加几个 server 配置就可以。

这里面就配置了 localhost:80 的虚拟主机下的所有路由。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-34-9b0c567876af4ce8862b20c213d31613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-34-9b0c567876af4ce8862b20c213d31613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-34-9b0c567876af4ce8862b20c213d31613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-34-9b0c567876af4ce8862b20c213d31613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" loading="lazy"/>
  </picture>





#### location

location指令的作用就是根据用户请求的URI来执行不同的应用

##### 语法

###### 写法

```css
location [ = | ~ | ~* | ^~ ] uri {...}
```

- `[ = | ~ | ~* | ^~ ]`：匹配的标识
  - `~`与`~*`的区别是：`~`区分大小写，`~*`不区分大小写
  - `^~`：进行常规字符串匹配后，不做正则表达式的检查
- `uri`：匹配的网站地址
- `{...}`：匹配uri后要执行的配置段



###### 一共 4 种匹配：

location = /aaa 是精确匹配 /aaa 的路由。

location /bbb 是前缀匹配 /bbb 的路由。

location ~ /ccc.*.html 是正则匹配。可以再加个 * 表示不区分大小写 location ~* /ccc.*.html

location ^~ /ddd 是前缀匹配，但是优先级更高。

这 4 种语法的优先级是这样的：

**精确匹配（=） > 高优先级前缀匹配（^~） > 正则匹配（～ ~\*） > 普通前缀匹配**





###### root 和 alias 区别

**root 和 alias 的区别就是拼接路径时是否包含匹配条件的路径。**

比如这样的两个配置：

```bash
location /222 {
    alias /dddd;
}

location /222 {
    root /dddd;
}
```

同样是 /222/xxx/yyy.html，如果是用 root 的配置，会把整个 uri 作为路径拼接在后面。也就是会查找 /dddd/222/xxx/yyy.html 文件。

如果是 alias 配置，它会去掉 /222。也就是会查找 /dddd/xxx/yyy.html 文件。





##### 举例

```ini
location = / {
    [ configuration A ]
}
location / {
    [ configuration B ]
}
location /sk/ {
    [ configuration C ]
}
location ^~ /img/ {
    [ configuration D ]
}
location ~* .(gif|jpg|jpeg)$ {
    [ configuration E ]
}
```

- `= /` 请求 `/` 精准匹配A，不再往下查找
- `/` 请求`/index.html`匹配B。这是前缀匹配。首先查找匹配的前缀字符，找到最长匹配是配置B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置B。
- `/sk/` 请求`/sk/abc` 匹配C。首先找到最长匹配C，由于后面没有匹配的正则，所以使用最长匹配C。
- `~* .(gif|jpg|jpeg)$` 请求`/sk/logo.gif` 匹配E。首先进行前缀字符的查找，找到最长匹配项C，继续进行正则查找，找到匹配项E。因此使用E。
- `^~` 请求`/img/logo.gif`匹配D。首先进行前缀字符查找，找到最长匹配D。但是它使用了`^~`修饰符，不再进行下面的正则的匹配查找，因此使用D。

比如这个配置：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-04-a090ca1b6a184825870c24c92929dd53~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-04-a090ca1b6a184825870c24c92929dd53~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-04-a090ca1b6a184825870c24c92929dd53~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-11-04-a090ca1b6a184825870c24c92929dd53~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" loading="lazy"/>
  </picture>

它就配置了 / 下的所有路由，都是在 root 指定的目录查找。

所以 [http://localhost/aaa.html](https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%2Faaa.html) 就是从 /usr/share/nginx/html/aaa.html 找的。

##### 单页面应用刷新404问题

```bash
location / {
        try_files $uri $uri/ /index.html;
    }
```





















#### Nginx解决跨域问题



```shell
location / {
    # 允许跨域的请求，可以自定义变量$http_origin，*表示所有
    add_header 'Access-Control-Allow-Origin' *;
    # 允许携带cookie请求
    add_header 'Access-Control-Allow-Credentials' 'true';
    # 允许跨域请求的方法：GET,POST,OPTIONS,PUT
    add_header 'Access-Control-Allow-Methods' 'GET,POST,OPTIONS,PUT';
    # 允许请求时携带的头部信息，*表示所有
    add_header 'Access-Control-Allow-Headers' *;
    # 允许发送按段获取资源的请求
    add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range';
    # 一定要有！！！否则Post请求无法进行跨域！
    # 在发送Post跨域请求前，会以Options方式发送预检请求，服务器接受时才会正式请求
    if ($request_method = 'OPTIONS') {
        add_header 'Access-Control-Max-Age' 1728000;
        add_header 'Content-Type' 'text/plain; charset=utf-8';
        add_header 'Content-Length' 0;
        # 对于Options方式的请求返回204，表示接受跨域请求
        return 204;
    }
}
```

在`nginx.conf`文件加上如上配置后，跨域请求即可生效了。

> 但如果后端是采用分布式架构开发的，有时候RPC调用也需要解决跨域问题，不然也同样会出现无法跨域请求的异常，因此可以在你的后端项目中，通过继承`HandlerInterceptorAdapter`类、实现`WebMvcConfigurer`接口、添加`@CrossOrgin`注解的方式实现接口之间的跨域配置。







#### Nginx配置SSL证书

  随着越来越多的网站接入`HTTPS`，因此`Nginx`中仅配置`HTTP`还不够，往往还需要监听`443`端口的请求，`HTTPS`为了确保通信安全，所以服务端需配置对应的数字证书，当项目使用`Nginx`作为网关时，那么证书在`Nginx`中也需要配置，接下来简单聊一下关于`SSL`证书配置过程：

- ①先去CA机构或从云控制台中申请对应的`SSL`证书，审核通过后下载`Nginx`版本的证书。

- ②下载数字证书后，完整的文件总共有三个：

  ```
  .crt、.key、.pem
  ```

  ：

  - `.crt`：数字证书文件，`.crt`是`.pem`的拓展文件，因此有些人下载后可能没有。
  - `.key`：服务器的私钥文件，及非对称加密的私钥，用于解密公钥传输的数据。
  - `.pem`：`Base64-encoded`编码格式的源证书文本文件，可自行根需求修改拓展名。

- ③在`Nginx`目录下新建`certificate`目录，并将下载好的证书/私钥等文件上传至该目录。

- ④最后修改一下`nginx.conf`文件即可，如下：

```shell
# ----------HTTPS配置-----------
server {
    # 监听HTTPS默认的443端口
    listen 443;
    # 配置自己项目的域名
    server_name www.xxx.com;
    # 打开SSL加密传输
    ssl on;
    # 输入域名后，首页文件所在的目录
    root html;
    # 配置首页的文件名
    index index.html index.htm index.jsp index.ftl;
    # 配置自己下载的数字证书
    ssl_certificate  certificate/xxx.pem;
    # 配置自己下载的服务器私钥
    ssl_certificate_key certificate/xxx.key;
    # 停止通信时，加密会话的有效期，在该时间段内不需要重新交换密钥
    ssl_session_timeout 5m;
    # TLS握手时，服务器采用的密码套件
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    # 服务器支持的TLS版本
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    # 开启由服务器决定采用的密码套件
    ssl_prefer_server_ciphers on;

    location / {
        ....
    }
}

# ---------HTTP请求转HTTPS-------------
server {
    # 监听HTTP默认的80端口
    listen 80;
    # 如果80端口出现访问该域名的请求
    server_name www.xxx.com;
    # 将请求改写为HTTPS（这里写你配置了HTTPS的域名）
    rewrite ^(.*)$ https://www.xxx.com;
}
```

OK~，根据如上配置了`Nginx`后，你的网站即可通过`https://`的方式访问，并且当客户端使用`http://`的方式访问时，会自动将其改写为`HTTPS`请求。



#### Nginx的高可用

  线上如果采用单个节点的方式部署`Nginx`，难免会出现比如系统异常、程序宕机、服务器断电。由于`Nginx`作为整个系统的网关层接入外部流量，所以一旦`Nginx`宕机，最终就会导致整个系统不可用。

> 接下来则会通过`keepalived`的`VIP`机制，实现`Nginx`的高可用。`VIP`并不是只会员的意思，而是指`Virtual IP`，即虚拟`IP`。

`keepalived`在之前单体架构开发时，是一个用的较为频繁的高可用技术，比如`MySQL、Redis、MQ、Proxy、Tomcat`等各处都会通过`keepalived`提供的`VIP`机制，实现单节点应用的高可用。

##### Keepalived+重启脚本+双机热备搭建

①首先创建一个对应的目录并下载`keepalived`[安装包（提取码:s6aq）](https://link.juejin.cn?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1ssHGu2HlBd_Qph2aki9_6g%3Fpwd%3Ds6aq)到`Linux`中并解压：

```shell
shell
复制代码[root@localhost]# mkdir /soft/keepalived && cd /soft/keepalived
[root@localhost]# wget https://www.keepalived.org/software/keepalived-2.2.4.tar.gz
[root@localhost]# tar -zxvf keepalived-2.2.4.tar.gz
```

②进入解压后的`keepalived`目录并构建安装环境，然后编译并安装：

```shell
shell
复制代码[root@localhost]# cd keepalived-2.2.4
[root@localhost]# ./configure --prefix=/soft/keepalived/
[root@localhost]# make && make install
```

③进入安装目录的`/soft/keepalived/etc/keepalived/`并编辑配置文件：

```shell
shell
复制代码[root@localhost]# cd /soft/keepalived/etc/keepalived/
[root@localhost]# vi keepalived.conf
```

④编辑主机的`keepalived.conf`核心配置文件，如下：

```shell
shell
复制代码global_defs {
    # 自带的邮件提醒服务，建议用独立的监控或第三方SMTP，也可选择配置邮件发送。
    notification_email {
        root@localhost
    }
    notification_email_from root@localhost
    smtp_server localhost
    smtp_connect_timeout 30
    # 高可用集群主机身份标识(集群中主机身份标识名称不能重复，建议配置成本机IP)
	router_id 192.168.12.129 
}

# 定时运行的脚本文件配置
vrrp_script check_nginx_pid_restart {
    # 之前编写的nginx重启脚本的所在位置
	script "/soft/scripts/keepalived/check_nginx_pid_restart.sh" 
    # 每间隔3秒执行一次
	interval 3
    # 如果脚本中的条件成立，重启一次则权重-20
	weight -20
}

# 定义虚拟路由，VI_1为虚拟路由的标示符（可自定义名称）
vrrp_instance VI_1 {
    # 当前节点的身份标识：用来决定主从（MASTER为主机，BACKUP为从机）
	state MASTER
    # 绑定虚拟IP的网络接口，根据自己的机器的网卡配置
	interface ens33 
    # 虚拟路由的ID号，主从两个节点设置必须一样
	virtual_router_id 121
    # 填写本机IP
	mcast_src_ip 192.168.12.129
    # 节点权重优先级，主节点要比从节点优先级高
	priority 100
    # 优先级高的设置nopreempt，解决异常恢复后再次抢占造成的脑裂问题
	nopreempt
    # 组播信息发送间隔，两个节点设置必须一样，默认1s（类似于心跳检测）
	advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    # 将track_script块加入instance配置块
    track_script {
        # 执行Nginx监控的脚本
		check_nginx_pid_restart
    }

    virtual_ipaddress {
        # 虚拟IP(VIP)，也可扩展，可配置多个。
		192.168.12.111
    }
}
```

⑤克隆一台之前的虚拟机作为从（备）机，编辑从机的`keepalived.conf`文件，如下：

```shell
shell
复制代码global_defs {
    # 自带的邮件提醒服务，建议用独立的监控或第三方SMTP，也可选择配置邮件发送。
    notification_email {
        root@localhost
    }
    notification_email_from root@localhost
    smtp_server localhost
    smtp_connect_timeout 30
    # 高可用集群主机身份标识(集群中主机身份标识名称不能重复，建议配置成本机IP)
	router_id 192.168.12.130 
}

# 定时运行的脚本文件配置
vrrp_script check_nginx_pid_restart {
    # 之前编写的nginx重启脚本的所在位置
	script "/soft/scripts/keepalived/check_nginx_pid_restart.sh" 
    # 每间隔3秒执行一次
	interval 3
    # 如果脚本中的条件成立，重启一次则权重-20
	weight -20
}

# 定义虚拟路由，VI_1为虚拟路由的标示符（可自定义名称）
vrrp_instance VI_1 {
    # 当前节点的身份标识：用来决定主从（MASTER为主机，BACKUP为从机）
	state BACKUP
    # 绑定虚拟IP的网络接口，根据自己的机器的网卡配置
	interface ens33 
    # 虚拟路由的ID号，主从两个节点设置必须一样
	virtual_router_id 121
    # 填写本机IP
	mcast_src_ip 192.168.12.130
    # 节点权重优先级，主节点要比从节点优先级高
	priority 90
    # 优先级高的设置nopreempt，解决异常恢复后再次抢占造成的脑裂问题
	nopreempt
    # 组播信息发送间隔，两个节点设置必须一样，默认1s（类似于心跳检测）
	advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
    # 将track_script块加入instance配置块
    track_script {
        # 执行Nginx监控的脚本
		check_nginx_pid_restart
    }

    virtual_ipaddress {
        # 虚拟IP(VIP)，也可扩展，可配置多个。
		192.168.12.111
    }
}
```

⑥新建`scripts`目录并编写`Nginx`的重启脚本，`check_nginx_pid_restart.sh`：

```shell
shell
复制代码[root@localhost]# mkdir /soft/scripts /soft/scripts/keepalived
[root@localhost]# touch /soft/scripts/keepalived/check_nginx_pid_restart.sh
[root@localhost]# vi /soft/scripts/keepalived/check_nginx_pid_restart.sh

#!/bin/sh
# 通过ps指令查询后台的nginx进程数，并将其保存在变量nginx_number中
nginx_number=`ps -C nginx --no-header | wc -l`
# 判断后台是否还有Nginx进程在运行
if [ $nginx_number -eq 0 ];then
    # 如果后台查询不到`Nginx`进程存在，则执行重启指令
    /soft/nginx/sbin/nginx -c /soft/nginx/conf/nginx.conf
    # 重启后等待1s后，再次查询后台进程数
    sleep 1
    # 如果重启后依旧无法查询到nginx进程
    if [ `ps -C nginx --no-header | wc -l` -eq 0 ];then
        # 将keepalived主机下线，将虚拟IP漂移给从机，从机上线接管Nginx服务
        systemctl stop keepalived.service
    fi
fi
```

⑦编写的脚本文件需要更改编码格式，并赋予执行权限，否则可能执行失败：

```shell
shell
复制代码[root@localhost]# vi /soft/scripts/keepalived/check_nginx_pid_restart.sh

:set fileformat=unix # 在vi命令里面执行，修改编码格式
:set ff # 查看修改后的编码格式

[root@localhost]# chmod +x /soft/scripts/keepalived/check_nginx_pid_restart.sh
```

⑧由于安装`keepalived`时，是自定义的安装位置，因此需要拷贝一些文件到系统目录中：

```shell
shell
复制代码[root@localhost]# mkdir /etc/keepalived/
[root@localhost]# cp /soft/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/
[root@localhost]# cp /soft/keepalived/keepalived-2.2.4/keepalived/etc/init.d/keepalived /etc/init.d/
[root@localhost]# cp /soft/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
```

⑨将`keepalived`加入系统服务并设置开启自启动，然后测试启动是否正常：

```shell
shell
复制代码[root@localhost]# chkconfig keepalived on
[root@localhost]# systemctl daemon-reload
[root@localhost]# systemctl enable keepalived.service
[root@localhost]# systemctl start keepalived.service

其他命令：
systemctl disable keepalived.service # 禁止开机自动启动
systemctl restart keepalived.service # 重启keepalived
systemctl stop keepalived.service # 停止keepalived
tail -f /var/log/messages # 查看keepalived运行时日志
```

⑩最后测试一下`VIP`是否生效，通过查看本机是否成功挂载虚拟`IP`：

```shell
shell
复制代码[root@localhost]# ip addr
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-07F70H.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-07F70H.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-07F70H.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-07F70H.webp" loading="lazy"/>
  </picture>

> 从上图中可以明显看见虚拟`IP`已经成功挂载，但另外一台机器`192.168.12.130`并不会挂载这个虚拟`IP`，只有当主机下线后，作为从机的`192.168.12.130`才会上线，接替`VIP`。最后测试一下外网是否可以正常与`VIP`通信，即在`Windows`中直接`ping VIP`：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4kjdbk.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4kjdbk.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4kjdbk.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-4kjdbk.webp" loading="lazy"/>
  </picture>

外部通过`VIP`通信时，也可以正常`Ping`通，代表虚拟`IP`配置成功。

##### Nginx高可用性测试

  经过上述步骤后，`keepalived`的`VIP`机制已经搭建成功，在上个阶段中主要做了几件事：

- 一、为部署`Nginx`的机器挂载了`VIP`。
- 二、通过`keepalived`搭建了主从双机热备。
- 三、通过`keepalived`实现了`Nginx`宕机重启。

由于前面没有域名的原因，因此最初`server_name`配置的是当前机器的`IP`，所以需稍微更改一下`nginx.conf`的配置：

```shell
shell
复制代码sever{
    listen    80;
    # 这里从机器的本地IP改为虚拟IP
	server_name 192.168.12.111;
	# 如果这里配置的是域名，那么则将域名的映射配置改为虚拟IP
}
```

最后来实验一下效果： <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-6jGSiw.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-6jGSiw.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-6jGSiw.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-6jGSiw.webp" loading="lazy"/>
  </picture>

> 在上述过程中，首先分别启动了`keepalived、nginx`服务，然后通过手动停止`nginx`的方式模拟了`Nginx`宕机情况，过了片刻后再次查询后台进程，我们会发现`nginx`依旧存活。

从这个过程中不难发现，`keepalived`已经为我们实现了`Nginx`宕机后自动重启的功能，那么接着再模拟一下服务器出现故障时的情况：
 <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wNGI39.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wNGI39.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wNGI39.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-wNGI39.webp" loading="lazy"/>
  </picture>

> 在上述过程中，我们通过手动关闭`keepalived`服务模拟了机器断电、硬件损坏等情况（因为机器断电等情况=主机中的`keepalived`进程消失），然后再次查询了一下本机的`IP`信息，很明显会看到`VIP`消失了！

现在再切换到另外一台机器：`192.168.12.130`来看看情况： <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tlwyXM.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tlwyXM.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tlwyXM.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-tlwyXM.webp" loading="lazy"/>
  </picture>

> 此刻我们会发现，在主机`192.168.12.129`宕机后，VIP自动从主机飘移到了从机`192.168.12.130`上，而此时客户端的请求就最终会来到`130`这台机器的`Nginx`上。



#### Nginx性能优化

主要就简单说说收益最高的几个优化项

##### 优化一：打开长连接配置

  通常Nginx作为代理服务，负责分发客户端的请求，那么建议开启`HTTP`长连接，用户减少握手的次数，降低服务器损耗，具体如下：

```shell
shell
复制代码upstream xxx {
    # 长连接数
    keepalive 32;
    # 每个长连接提供的最大请求数
    keepalived_requests 100;
    # 每个长连接没有新的请求时，保持的最长时间
    keepalive_timeout 60s;
}
```

##### 优化二、开启零拷贝技术

  零拷贝这个概念，在大多数性能较为不错的中间件中都有出现，例如`Kafka、Netty`等，而`Nginx`中也可以配置数据零拷贝技术，如下：

```shell
shell
复制代码sendfile on; # 开启零拷贝机制
```

零拷贝读取机制与传统资源读取机制的区别：

- 传统方式：**硬件-->内核-->用户空间-->程序空间-->程序内核空间-->网络套接字**
- 零拷贝方式：**硬件-->内核-->程序内核空间-->网络套接字**

从上述这个过程对比，很轻易就能看出两者之间的性能区别。

##### 优化三、开启无延迟或多包共发机制

  在`Nginx`中有两个较为关键的性能参数，即`tcp_nodelay、tcp_nopush`，开启方式如下：

```shell
shell
复制代码tcp_nodelay on;
tcp_nopush on;
```

`TCP/IP`协议中默认是采用了[Nagle算法](https://link.juejin.cn?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2FNagle%E7%AE%97%E6%B3%95%2F5645172)的，即在网络数据传输过程中，每个数据报文并不会立马发送出去，而是会等待一段时间，将后面的几个数据包一起组合成一个数据报文发送，但这个算法虽然提高了网络吞吐量，但是实时性却降低了。

> 因此你的项目属于交互性很强的应用，那么可以手动开启`tcp_nodelay`配置，让应用程序向内核递交的每个数据包都会立即发送出去。但这样会产生大量的`TCP`报文头，增加很大的网络开销。

相反，有些项目的业务对数据的实时性要求并不高，追求的则是更高的吞吐，那么则可以开启`tcp_nopush`配置项，这个配置就类似于“塞子”的意思，首先将连接塞住，使得数据先不发出去，等到拔去塞子后再发出去。设置该选项后，内核会尽量把小数据包拼接成一个大的数据包（一个`MTU`）再发送出去.

> 当然若一定时间后（一般为`200ms`），内核仍然没有积累到一个`MTU`的量时，也必须发送现有的数据，否则会一直阻塞。

`tcp_nodelay、tcp_nopush`两个参数是“互斥”的，如果追求响应速度的应用推荐开启`tcp_nodelay`参数，如`IM`、金融等类型的项目。如果追求吞吐量的应用则建议开启`tcp_nopush`参数，如调度系统、报表系统等。

> 注意：
> ①`tcp_nodelay`一般要建立在开启了长连接模式的情况下使用。
> ②`tcp_nopush`参数是必须要开启`sendfile`参数才可使用的。

##### 优化四、调整Worker工作进程

  `Nginx`启动后默认只会开启一个`Worker`工作进程处理客户端请求，而我们可以根据机器的CPU核数开启对应数量的工作进程，以此来提升整体的并发量支持，如下：

```shell
shell
复制代码# 自动根据CPU核心数调整Worker进程数量
worker_processes auto;
```

> 工作进程的数量最高开到`8`个就OK了，`8`个之后就不会有再大的性能提升。

同时也可以稍微调整一下每个工作进程能够打开的文件句柄数：

```shell
shell
复制代码# 每个Worker能打开的文件描述符，最少调整至1W以上，负荷较高建议2-3W
worker_rlimit_nofile 20000;
```

> 操作系统内核（`kernel`）都是利用文件描述符来访问文件，无论是打开、新建、读取、写入文件时，都需要使用文件描述符来指定待操作的文件，因此该值越大，代表一个进程能够操作的文件越多（但不能超出内核限制，最多建议`3.8W`左右为上限）。

##### 优化五、开启CPU亲和机制

  对于并发编程较为熟悉的伙伴都知道，因为进程/线程数往往都会远超出系统CPU的核心数，因为操作系统执行的原理本质上是采用时间片切换机制，也就是一个CPU核心会在多个进程之间不断频繁切换，造成很大的性能损耗。

而CPU亲和机制则是指将每个`Nginx`的工作进程，绑定在固定的CPU核心上，从而减小CPU切换带来的时间开销和资源损耗，开启方式如下：

```shell
shell
复制代码worker_cpu_affinity auto;
```

##### 优化六、开启epoll模型及调整并发连接数

  在最开始就提到过：`Nginx、Redis`都是基于多路复用模型去实现的程序，但最初版的多路复用模型`select/poll`最大只能监听`1024`个连接，而`epoll`则属于`select/poll`接口的增强版，因此采用该模型能够大程度上提升单个`Worker`的性能，如下：

```shell
shell
复制代码events {
    # 使用epoll网络模型
    use epoll;
    # 调整每个Worker能够处理的连接数上限
    worker_connections  10240;
}
```

> 这里对于`select/poll/epoll`模型就不展开细说了，后面的IO模型文章中会详细剖析。





##### Nginx资源压缩

在`Nginx`也提供了三个支持资源压缩的模块`ngx_http_gzip_module、ngx_http_gzip_static_module、ngx_http_gunzip_module`，其中`ngx_http_gzip_module`属于内置模块，代表着可以直接使用该模块下的一些压缩指令，后续的资源压缩操作都基于该模块，先来看看压缩配置的一些参数/指令：

| 参数项              | 释义                                             | 参数值                      |
| ------------------- | ------------------------------------------------ | --------------------------- |
| `gzip`              | 开启或关闭压缩机制                               | `on/off;`                   |
| `gzip_types`        | 根据文件类型选择性开启压缩机制                   | `image/png、text/css...`    |
| `gzip_comp_level`   | 用于设置压缩级别，级别越高越耗时                 | `1~9`（越高压缩效果越好）   |
| `gzip_vary`         | 设置是否携带`Vary:Accept-Encoding`头域的响应头部 | `on/off;`                   |
| `gzip_buffers`      | 设置处理压缩请求的缓冲区数量和大小               | 数量 大小，如`16 8k;`       |
| `gzip_disable`      | 针对不同客户端的请求来设置是否开启压缩           | 如 `.*Chrome.*;`            |
| `gzip_http_version` | 指定压缩响应所需要的最低`HTTP`请求版本           | 如`1.1;`                    |
| `gzip_min_length`   | 设置触发压缩的文件最低大小                       | 如`512k;`                   |
| `gzip_proxied`      | 对于后端服务器的响应结果是否开启压缩             | `off、expired、no-cache...` |

了解了`Nginx`中的基本压缩配置后，接下来可以在`Nginx`中简单配置一下：

```shell
shell
复制代码http{
    # 开启压缩机制
    gzip on;
    # 指定会被压缩的文件类型(也可自己配置其他类型)
    gzip_types text/plain application/javascript text/css application/xml text/javascript image/jpeg image/gif image/png;
    # 设置压缩级别，越高资源消耗越大，但压缩效果越好
    gzip_comp_level 5;
    # 在头部中添加Vary: Accept-Encoding（建议开启）
    gzip_vary on;
    # 处理压缩请求的缓冲区数量和大小
    gzip_buffers 16 8k;
    # 对于不支持压缩功能的客户端请求不开启压缩机制
    gzip_disable "MSIE [1-6]\."; # 低版本的IE浏览器不支持压缩
    # 设置压缩响应所支持的HTTP最低版本
    gzip_http_version 1.1;
    # 设置触发压缩的最小阈值
    gzip_min_length 2k;
    # 关闭对后端服务器的响应结果进行压缩
    gzip_proxied off;
}
```

在上述的压缩配置中，最后一个`gzip_proxied`选项，可以根据系统的实际情况决定，总共存在多种选项：

- `off`：关闭`Nginx`对后台服务器的响应结果进行压缩。
- `expired`：如果响应头中包含`Expires`信息，则开启压缩。
- `no-cache`：如果响应头中包含`Cache-Control:no-cache`信息，则开启压缩。
- `no-store`：如果响应头中包含`Cache-Control:no-store`信息，则开启压缩。
- `private`：如果响应头中包含`Cache-Control:private`信息，则开启压缩。
- `no_last_modified`：如果响应头中不包含`Last-Modified`信息，则开启压缩。
- `no_etag`：如果响应头中不包含`ETag`信息，则开启压缩。
- `auth`：如果响应头中包含`Authorization`信息，则开启压缩。
- `any`：无条件对后端的响应结果开启压缩机制。



> 注意点：
> ①对于图片、视频类型的数据，会默认开启压缩机制，因此一般无需再次开启压缩。
> ②对于`.js`文件而言，需要指定压缩类型为`application/javascript`，而并非`text/javascript、application/x-javascript`。





##### Nginx缓冲

接入`Nginx`的项目一般请求流程为：“客户端→`Nginx`→服务端”，在这个过程中存在两个连接：“客户端→`Nginx`、`Nginx`→服务端”，那么两个不同的连接速度不一致，就会影响用户的体验（比如浏览器的加载速度跟不上服务端的响应速度）。
 其实也就类似电脑的内存跟不上`CPU`速度，所以对于用户造成的体验感极差，因此在`CPU`设计时都会加入三级高速缓冲区，用于缓解`CPU`和内存速率不一致的矛盾。在`Nginx`也同样存在缓冲区的机制，主要目的就在于：**用来解决两个连接之间速度不匹配造成的问题**，有了缓冲后，`Nginx`代理可暂存后端的响应，然后按需供给数据给客户端。先来看看一些关于缓冲区的配置项：

- `proxy_buffering`：是否启用缓冲机制，默认为`on`关闭状态。

- `client_body_buffer_size`：设置缓冲客户端请求数据的内存大小。

- `proxy_buffers`：为每个请求/连接设置缓冲区的数量和大小，默认`4 4k/8k`。

- `proxy_buffer_size`：设置用于存储响应头的缓冲区大小。

- `proxy_busy_buffers_size`：在后端数据没有完全接收完成时，`Nginx`可以将`busy`状态的缓冲返回给客户端，该参数用来设置`busy`状态的`buffer`具体有多大，默认为`proxy_buffer_size*2`。

- proxy_temp_path：当内存缓冲区存满时，可以将数据临时存放到磁盘，该参数是设置存储缓冲数据的目录。

  - 语法：

    ```
    proxy_temp_path path;
    ```

    - `path`是临时目录的路径。

- `proxy_temp_file_write_size`：设置每次写数据到临时文件的大小限制。

- `proxy_max_temp_file_size`：设置临时的缓冲目录中允许存储的最大容量。

- 非缓冲参数项：

  - `proxy_connect_timeout`：设置与后端服务器建立连接时的超时时间。
  - `proxy_read_timeout`：设置从后端服务器读取响应数据的超时时间。
  - `proxy_send_timeout`：设置向后端服务器传输请求数据的超时时间。

具体的`nginx.conf`配置如下：

```shell
shell
复制代码http{
    proxy_connect_timeout 10;
    proxy_read_timeout 120;
    proxy_send_timeout 10;
    proxy_buffering on;
    client_body_buffer_size 512k;
    proxy_buffers 4 64k;
    proxy_buffer_size 16k;
    proxy_busy_buffers_size 128k;
    proxy_temp_file_write_size 128k;
    proxy_temp_path /soft/nginx/temp_buffer;
}
```

上述的缓冲区参数，是基于每个请求分配的空间，而并不是所有请求的共享空间。当然，具体的参数值还需要根据业务去决定，要综合考虑机器的内存以及每个请求的平均数据大小。

> 最后提一嘴：使用缓冲也可以减少即时传输带来的带宽消耗。





##### Nginx缓存

###### 作用

  对于性能优化而言，缓存是一种能够大幅度提升性能的方案，Nginx的缓存属于代理缓存的一种。加入缓存带来的优势额外明显：

- 减少了再次向后端或文件服务器请求资源的带宽消耗。
- 降低了下游服务器的访问压力，提升系统整体吞吐。
- 缩短了响应时间，提升了加载速度，打开页面的速度更快。



###### 配置

那么在`Nginx`中，又该如何配置代理缓存呢？先来看看缓存相关的配置项：

- proxy_cache_path：代理缓存的路径。

  - 语法：`proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=on|off] [purger_files=number] [purger_sleep=time] [purger_threshold=time];`
  - 是的，你没有看错，就是这么长....，解释一下每个参数项的含义：
    - `path`：缓存的路径地址。
    - `levels`：缓存存储的层次结构，最多允许三层目录。
    - `use_temp_path`：是否使用临时目录。
    - `keys_zone`：指定一个共享内存空间来存储热点`Key`(`1M`可存储`8000`个`Key`)。
    - `inactive`：设置缓存多长时间未被访问后删除（默认是十分钟）。
    - `max_size`：允许缓存的最大存储空间，超出后会基于`LRU`算法移除缓存，`Nginx`会创建一个`Cache manager`的进程移除数据，也可以通过`purge`方式。
    - `manager_files`：`manager`进程每次移除缓存文件数量的上限。
    - `manager_sleep`：`manager`进程每次移除缓存文件的时间上限。
    - `manager_threshold`：`manager`进程每次移除缓存后的间隔时间。
    - `loader_files`：重启`Nginx`载入缓存时，每次加载的个数，默认`100`。
    - `loader_sleep`：每次载入时，允许的最大时间上限，默认`200ms`。
    - `loader_threshold`：一次载入后，停顿的时间间隔，默认`50ms`。
    - `purger`：是否开启`purge`方式移除数据。
    - `purger_files`：每次移除缓存文件时的数量。
    - `purger_sleep`：每次移除时，允许消耗的最大时间。
    - `purger_threshold`：每次移除完成后，停顿的间隔时间。

- proxy_cache：开启或关闭代理缓存，开启时需要指定一个共享内存区域。

  - 语法：

    ```
    proxy_cache zone | off;
    ```

    - `zone`为内存区域的名称，即上面中`keys_zone`设置的名称。

- proxy_cache_key：定义如何生成缓存的键。

  - 语法：

    ```
    proxy_cache_key string;
    ```

    - `string`为生成`Key`的规则，如`$scheme$proxy_host$request_uri`。

- proxy_cache_valid：缓存生效的状态码与过期时间。

  - 语法：

    ```
    proxy_cache_valid [code ...] time;
    ```

    - `code`为状态码，`time`为有效时间，可以根据状态码设置不同的缓存时间。
    - 例如：`proxy_cache_valid 200 302 30m;`

- proxy_cache_min_uses：设置资源被请求多少次后被缓存。

  - 语法：

    ```
    proxy_cache_min_uses number;
    ```

    - `number`为次数，默认为`1`。

- proxy_cache_use_stale：当后端出现异常时，是否允许Nginx返回缓存作为响应。

  - 语法：

    ```
    proxy_cache_use_stale error;
    ```

    - `error`为错误类型，可配置`timeout|invalid_header|updating|http_500...`。

- proxy_cache_lock：对于相同的请求，是否开启锁机制，只允许一个请求发往后端。

  - 语法：`proxy_cache_lock on | off;`

- proxy_cache_lock_timeout：配置锁超时机制，超出规定时间后会释放请求。

  - `proxy_cache_lock_timeout time;`

- proxy_cache_methods：设置对于那些HTTP方法开启缓存。

  - 语法：

    ```
    proxy_cache_methods method;
    ```

    - `method`为请求方法类型，如`GET、HEAD`等。

- proxy_no_cache：定义不存储缓存的条件，符合时不会保存。

  - 语法：

    ```
    proxy_no_cache string...;
    ```

    - `string`为条件，例如`$cookie_nocache $arg_nocache $arg_comment;`

- proxy_cache_bypass：定义不读取缓存的条件，符合时不会从缓存中读取。

  - 语法：proxy_cache_bypass string...;
    - 和上面`proxy_no_cache`的配置方法类似。

- add_header：往响应头中添加字段信息。

  - 语法：`add_header fieldName fieldValue`;

- `$upstream_cache_status`：记录了缓存是否命中的信息，存在多种情况：

  - `MISS`：请求未命中缓存。
  - `HIT`：请求命中缓存。
  - `EXPIRED`：请求命中缓存但缓存已过期。
  - `STALE`：请求命中了陈旧缓存。
  - `REVALIDDATED`：`Nginx`验证陈旧缓存依然有效。
  - `UPDATING`：命中的缓存内容陈旧，但正在更新缓存。
  - `BYPASS`：响应结果是从原始服务器获取的。
  - PS：这个和之前的不同，之前的都是参数项，这个是一个`Nginx`内置变量。

接着来配置一下`Nginx`代理缓存：

```shell
http{
    # 设置缓存的目录，并且内存中缓存区名为hot_cache，大小为128m，
    # 三天未被访问过的缓存自动清楚，磁盘中缓存的最大容量为2GB。
    proxy_cache_path /soft/nginx/cache levels=1:2 keys_zone=hot_cache:128m inactive=3d max_size=2g;
    
    server{
        location / {
            # 使用名为nginx_cache的缓存空间
            proxy_cache hot_cache;
            # 对于200、206、304、301、302状态码的数据缓存1天
            proxy_cache_valid 200 206 304 301 302 1d;
            # 对于其他状态的数据缓存30分钟
            proxy_cache_valid any 30m;
            # 定义生成缓存键的规则（请求的url+参数作为key）
            proxy_cache_key $host$uri$is_args$args;
            # 资源至少被重复访问三次后再加入缓存
            proxy_cache_min_uses 3;
            # 出现重复请求时，只让一个去后端读数据，其他的从缓存中读取
            proxy_cache_lock on;
            # 上面的锁超时时间为3s，超过3s未获取数据，其他请求直接去后端
            proxy_cache_lock_timeout 3s;
            # 对于请求参数或cookie中声明了不缓存的数据，不再加入缓存
            proxy_no_cache $cookie_nocache $arg_nocache $arg_comment;
            # 在响应头中添加一个缓存是否命中的状态（便于调试）
            add_header Cache-status $upstream_cache_status;
        }
    }
}
```

接着来看一下效果，如下：
 <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-01-f464660086884d6eb2939176f9b5275a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-01-f464660086884d6eb2939176f9b5275a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-01-f464660086884d6eb2939176f9b5275a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-12-01-f464660086884d6eb2939176f9b5275a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" loading="lazy"/>
  </picture>
 第一次访问时，因为还没有请求过资源，所以缓存中没有数据，因此没有命中缓存。第二、三次，依旧没有命中缓存，直至第四次时才显示命中，这是为什么呢？因为在前面的缓存配置中，我们配置了加入缓存的最低条件为：**资源至少要被请求三次以上才会加入缓存。** 这样可以避免很多无效缓存占用空间。

###### 缓存清理

  当缓存过多时，如果不及时清理会导致磁盘空间被“吃光”，在之前的`proxy_cache_path`参数中有`purger`相关的选项，开启后可以帮我们自动清理缓存，但遗憾的是：**`purger`系列参数只有商业版的`NginxPlus`才能使用，因此需要付费才可使用。**

所以我们可以通过强大的第三方模块`ngx_cache_purge`来替代，先来安装一下该插件：
 ①首先去到`Nginx`的安装目录下，创建一个`cache_purge`目录：

```shell
shell
复制代码[root@localhost]# mkdir cache_purge && cd cache_purge
```

②通过`wget`指令从`github`上拉取安装包的压缩文件并解压：

```shell
shell
复制代码[root@localhost]# wget https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz
[root@localhost]# tar -xvzf 2.3.tar.gz
```

③再次去到之前`Nginx`的解压目录下：

```shell
shell
复制代码[root@localhost]# cd /soft/nginx/nginx1.21.6
```

④重新构建一次`Nginx`，通过`--add-module`的指令添加刚刚的第三方模块：

```shell
shell
复制代码[root@localhost]# ./configure --prefix=/soft/nginx/ --add-module=/soft/nginx/cache_purge/ngx_cache_purge-2.3/
```

⑤重新根据刚刚构建的`Nginx`，再次编译一下，**但切记不要`make install`**：

```shell
shell
复制代码[root@localhost]# make
```

⑥删除之前`Nginx`的启动文件，不放心的也可以移动到其他位置：

```shell
shell
复制代码[root@localhost]# rm -rf /soft/nginx/sbin/nginx
```

⑦从生成的`objs`目录中，重新复制一个`Nginx`的启动文件到原来的位置：

```shell
shell
复制代码[root@localhost]# cp objs/nginx /soft/nginx/sbin/nginx
```

至此，第三方缓存清除模块`ngx_cache_purge`就安装完成了，接下来稍微修改一下`nginx.conf`配置，再添加一条`location`规则：

```shell
shell
复制代码location ~ /purge(/.*) {
  # 配置可以执行清除操作的IP（线上可以配置成内网机器）
  # allow 127.0.0.1; # 代表本机
  allow all; # 代表允许任意IP清除缓存
  proxy_cache_purge $host$1$is_args$args;
}
```

然后再重启`Nginx`，接下来即可通过`http://xxx/purge/xx`的方式清除缓存。





#### 其它实践功能

##### Nginx实现IP黑白名单

某些接口只能开放给对应的合作商，或者购买/接入`API`的合作伙伴，那么此时就需要实现类似于`IP`白名单的功能。而有时候有些恶意攻击者或爬虫程序，被识别后需要禁止其再次访问网站，因此也需要实现`IP`黑名单。

`Nginx`做黑白名单机制，主要是通过`allow、deny`配置项来实现：

```bash
allow xxx.xxx.xxx.xxx; # 允许指定的IP访问，可以用于实现白名单。
deny xxx.xxx.xxx.xxx; # 禁止指定的IP访问，可以用于实现黑名单。
```

要同时屏蔽/开放多个`IP`访问时，如果所有`IP`全部写在`nginx.conf`文件中定然是不显示的，这种方式比较冗余，那么可以新建两个文件`BlocksIP.conf、WhiteIP.conf`：

```shell
shell
复制代码# --------黑名单：BlocksIP.conf---------
deny 192.177.12.222; # 屏蔽192.177.12.222访问
deny 192.177.44.201; # 屏蔽192.177.44.201访问
deny 127.0.0.0/8; # 屏蔽127.0.0.1到127.255.255.254网段中的所有IP访问

# --------白名单：WhiteIP.conf---------
allow 192.177.12.222; # 允许192.177.12.222访问
allow 192.177.44.201; # 允许192.177.44.201访问
allow 127.45.0.0/16; # 允许127.45.0.1到127.45.255.254网段中的所有IP访问
deny all; # 除开上述IP外，其他IP全部禁止访问
```

分别将要禁止/开放的`IP`添加到对应的文件后，可以再将这两个文件在`nginx.conf`中导入：

```shell
shell
复制代码http{
    # 屏蔽该文件中的所有IP
    include /soft/nginx/IP/BlocksIP.conf; 
 server{
    location xxx {
        # 某一系列接口只开放给白名单中的IP
        include /soft/nginx/IP/blockip.conf; 
    }
 }
}
```

对于文件具体在哪儿导入，这个也并非随意的，如果要整站屏蔽/开放就在`http`中导入，如果只需要一个域名下屏蔽/开放就在`sever`中导入，如果只需要针对于某一系列接口屏蔽/开放`IP`，那么就在`location`中导入。

> 当然，上述只是最简单的`IP`黑/白名单实现方式，同时也可以通过`ngx_http_geo_module、ngx_http_geo_module`第三方库去实现（这种方式可以按地区、国家进行屏蔽，并且提供了`IP`库）。







##### Nginx防盗链设计

 何谓盗链：**盗链即是指外部网站引入当前网站的资源对外展示**，来举个简单的例子理解：

> 好比壁纸网站`X`站、`Y`站，`X`站是一点点去购买版权积累了海量的壁纸素材，但`Y`站直接通过`<picture>
    <source type="image/avif" srcset="X站/xxx.jpg?imageMogr2/format/avif">
    <source type="image/webp" srcset="X站/xxx.jpg?imageMogr2/format/webp">
    <img src="X站/xxx.jpg" loading="lazy"/>
  </picture>`这种方式照搬了`X`站的所有壁纸资源。

> 		PS：防盗链机制也无法解决爬虫伪造`referers`信息的这种方式抓取数据。

`Nginx`的防盗链机制实现，跟`Referer`有关，判断是否为本站的资源引用请求，如果不是则不允许访问。`Nginx`中存在一个配置项为`valid_referers`，正好可以满足前面的需求，语法如下：

- ```
  valid_referers none | blocked | server_names | string ...;
  ```

  - `none`：表示接受没有`Referer`字段的`HTTP`请求访问。
  - `blocked`：表示允许`http://`或`https//`以外的请求访问。
  - `server_names`：资源的白名单，这里可以指定允许访问的域名。
  - `string`：可自定义字符串，支配通配符、正则表达式写法。

简单了解语法后，接下来的实现如下：

```shell
shell
复制代码# 在动静分离的location中开启防盗链机制
location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css){
    # 最后面的值在上线前可配置为允许的域名地址
    valid_referers blocked 192.168.12.129;
    if ($invalid_referer) {
        # 可以配置成返回一张禁止盗取的图片
        # rewrite   ^/ http://xx.xx.com/NO.jpg;
        # 也可直接返回403
        return   403;
    }
    
    root   /soft/nginx/static_resources;
    expires 7d;
}
```

根据上述中的内容配置后，就已经通过`Nginx`实现了最基本的防盗链机制。也有专门的第三方模块`ngx_http_accesskey_module`实现了更为完善的设计，感兴趣的小伙伴可以自行去看看。





##### Nginx大文件传输配置

 大文件传输时往往都会会出现一些`Bug`，比如文件超出限制、文件传输过程中请求超时等，那么此时就可以在`Nginx`稍微做一些配置，先来了解一些关于大文件传输时可能会用的配置项：

| 配置项                  | 释义                                              |
| ----------------------- | ------------------------------------------------- |
| `client_max_body_size`  | 设置请求体允许的最大体积                          |
| `client_header_timeout` | 等待客户端发送一个请求头的超时时间                |
| `client_body_timeout`   | 设置读取请求体的超时时间                          |
| `proxy_read_timeout`    | 设置请求被后端服务器读取时，`Nginx`等待的最长时间 |
| `proxy_send_timeout`    | 设置后端向`Nginx`返回响应时的超时时间             |

在传输大文件时，`client_max_body_size、client_header_timeout、proxy_read_timeout、proxy_send_timeout`这四个参数值都可以根据自己项目的实际情况来配置。

> 上述配置仅是作为代理层需要配置的，因为最终客户端传输文件还是直接与后端进行交互，这里只是把作为网关层的`Nginx`配置调高一点，调到能够“容纳大文件”传输的程度。
> 当然，`Nginx`中也可以作为文件服务器使用，但需要用到一个专门的第三方模块`nginx-upload-module`，如果项目中文件上传的作用处不多，那么建议可以通过`Nginx`搭建，毕竟可以节省一台文件服务器资源。但如若文件上传/下载较为频繁，那么还是建议额外搭建文件服务器，并将上传/下载功能交由后端处理。





### 根据cookie用Nginx实现灰度系统&AB实验

这就是个简单方案，工业上肯定不是这么搞，这个方案有个很痛的问题是用户第一次的访问没法控制，必须种过cookie之后的访问才能控流量分发。

灰度系统可以把流量划分成多份，一份走新版本代码，一份走老版本代码。而且灰度系统不止这一个用途， AB 实验也一样，把流量分成两份，一份走 A 版本代码，一份走 B 版本代码。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-45-154bff9a93964729acd72bae62f45815~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-45-154bff9a93964729acd72bae62f45815~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-45-154bff9a93964729acd72bae62f45815~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>



添加这么一行配置：

```nginx
location ^~ /api {
    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://192.168.1.6:3001;
}
```

这行就是加了一个路由，把 /api/ 开头的请求转发给 [http://宿主机IP:3001](https://link.juejin.cn/?target=http%3A%2F%2F%E5%AE%BF%E4%B8%BB%E6%9C%BAIP%3A3001) 这个服务。

用 rewrite 把 url 重写了，比如 /api/xxx 变成了 /xxx。

跑个docker容器，指定数据卷，挂载本地的 ～/nginx-config 目录到容器内的 /etc/nginx/conf.d 目录。

看下 files 部分：可以看到容器内的 /etc/nginx/conf.d 目录标识为了 mounted。



现在我们不是直接访问 nest 服务了，而是经历了一层 nginx 反向代理或者说网关层。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-54-629d676511b249fb86b480515cc1c30e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-54-629d676511b249fb86b480515cc1c30e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-54-629d676511b249fb86b480515cc1c30e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

我们可以在这一层实现流量控制的功能。

前面我们讲负载均衡的时候，是这么配的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-55-f828c9da88a64fbb847d18f76a82857e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-55-f828c9da88a64fbb847d18f76a82857e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-16-55-f828c9da88a64fbb847d18f76a82857e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

默认会轮询把请求发给 upstream 下的 server。

现在需要有多组 upstream：

```nginx
upstream version1.0_server {
    server 192.168.1.6:3000;
}
 
upstream version2.0_server {
    server 192.168.1.6:3001;
}

upstream default {
    server 192.168.1.6:3000;
}
```

有版本 1.0 的、版本 2.0 的，默认的 server 列表。

然后需要根据某个条件来区分转发给哪个服务。

我们这里根据 cookie 来区分：

```nginx
set $group "default";
if ($http_cookie ~* "version=1.0"){
    set $group version1.0_server;
}

if ($http_cookie ~* "version=2.0"){
    set $group version2.0_server;
}

location ^~ /api {
    rewrite ^/api/(.*)$ /$1 break;
    proxy_pass http://$group;
}
```

如果包含 version=1.0 的 cookie，那就走 version1.0_server 的服务，有 version=2.0 的 cookie 就走 version2.0_server 的服务，否则，走默认的。

这样就实现了流量的划分，也就是灰度的功能。





什么时候设置的这个 cookie 呢？

比如我想实现 80% 的流量走版本 1.0，20% 的流量走版本 2.0

其实公司内部一般都有灰度配置系统，可以配置不同的版本的比例，然后流量经过这个系统之后，就会返回 Set-Cookie 的 header，里面按照比例来分别设置不同的 cookie。

比如随机数在 0 到 0.2 之间，就设置 version=2.0 的 cookie，否则，设置 version=1.0 的 cookie。

这也叫做流量染色。

完整的灰度流程是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-17-04-60249ce21c284c928086815fec6801e9~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-17-04-60249ce21c284c928086815fec6801e9~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-17-04-60249ce21c284c928086815fec6801e9~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

第一次请求的时候，会按照设定的比例随机对流量染色，也就是设置不同 cookie。

再次访问的时候会根据 cookie 来走到不同版本的代码。

其中，后端代码会根据 cookie 标识来请求不同的服务（或者同一个服务走不同的 if else），前端代码可以根据 cookie 判断走哪段逻辑。







## swagger

### OpenAPI schema

OpenAPI 3.0 规范由 8 个根对象组成：

1. openapi
2. info
3. servers
4. paths
5. components
6. security
7. tags
8. externalDocs

OpenAPI 的其余功能都是基于这 8 根对象扩展而成，凡是包含以上对象并且扩展名为 `json`，`yaml` 的文件，我们可以将其视为符合 **OpenAPI 规范的描述文件** 

下面介绍几个常用的对象，抄这里的https://www.cnblogs.com/xiao2shiqi/p/16412813.html，没介绍到的话也去刚刚网址看吧



#### paths 对象

`paths` 对象包含真正的 API 信息内容，它的每个项都包含一个可操作的 `endpoint` 操作对象。

看一个简单示例：

```yaml
paths:
  /pet:
    get:
```

以上信息描述一个 `/pet` 的 `endpoint` ，它只包含一个 `get` 操作对象，类似 `get` 操作对象（也称 Operation Objects）也包含以下属性（不需要声明所有属性）：

- `tags`：用于对 endpoint 进行分组的组名

- `summary`：操作对象的摘要信息，最好限制在 5-10 字以内，主要作为概览展示

- `description`：操作对象的描述信息，尽可能的详细，展示细节信息

- `operationId`：操作对象的唯一 ID

- `parameters`该端点的请求参数对象，描述如下，（requestBody描述不在此列包含系列属）

  - name：参数名称

  - in：参数出现的位置，通常是 `header`，`path`，`query`，`cookie`

  - description：参数的描述（支持 markdown）

  - required：必填项

  - deprecated：是否弃用

  - allowEmptyValue：允许提交空值

  - style：参数序列化方式

  - explode：与数组相关的参数

  - schema：参数的模型

  - example：媒体类型的示例

    - `parameters` 的示例用法（包含一个参数的 `get` 方法）：

    ```yaml
    paths:
      /weather:
        get:
          tags:
          - Current Weather Data
          summary: "Call current weather data for one location."
          description: "^_^"
          operationId: CurrentWeatherData
          parameters:
          - name: q
            in: query
            description: "^_^"
            schema:
              type: string
    ```

- `requestBody`：请求主体的描述，还可以包含一个指向 `components` 的 `$ref` 指针

- `response`：响应主体的描述，通常使用标准的 HTTP 状态码，可以包含指向 `components` 的 `$ref` 指针

  - responses 用于描述接口的响应对象，可以直接描述，如下：

    ```yaml
    responses:
      200:
        description: Successful response
        content:
          application/json:
            schema:
              title: Sample
              type: object
              properties:
                placeholder:
                  type: string
                  description: Placeholder description
    
      404:
        description: Not found response
        content:
          text/plain:
            schema:
              title: Weather not found
              type: string
              example: Not found
    ```

- `callbacks`：回调对象和回调信息的描述，较为少见，不过多介绍

- `deprecated`：标识该 `path` 是否被弃用

- `security`：仅用于覆盖全局的安全授权方法

- `servers`：仅用于覆盖全局的服务器访问对象







#### components 对象

在 `components` 中主要可以定义重复使用的对象，以便其他对象使用 `$ref` 关键字直接引用和声明

##### 在 parameters 中重用对象

我们可以把刚才对 parameters 的描述移动到 components 中来，如下：

```yaml
components:
  parameters:
    q:
      name: q
      in: query
      description: "………………"
      schema:
        type: string
    id:
      name: id
      in: query
      description: "…………"
      schema:
        type: string
```

然后我们可以在 paramters 中直接引用它，如下：

```yaml
paths:
  /weather:
    get:
     // ......
      parameters:
        - $ref: '#/components/parameters/q'
        - $ref: '#/components/parameters/id'
			// .......
```



##### 在 reponses 中重用对象

可在 reponses 中引用已经声明的对象，如下：

```yaml
responses:
  200:
    description: Successful response
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/200'
```

它在 yaml 中的描述如下：

```yaml
components:
  schemas:
    200:
      title: Successful response
      type: object
      properties:
        base:
          type: string
          description: Internal parameter
          example: cmc stations
        visibility:
          type: integer
          description: Visibility, meter
          example: 16093
```





通过 `components` 定义的对象都会在 Swagger UI 下方通过 `Schemas` 进行展示，如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-26-image-20231219112637229.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-26-image-20231219112637229.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-26-image-20231219112637229.png" alt="image-20231219112637229" style="zoom:50%;" loading="lazy"/>
  </picture>







#### security 对象

security 用于描述 API 的安全信息和访问授权协议等信息，OpenAPI 支持最常见的四种授权方案，如下：

- API key
- HTTP
- OAuth 2.0
- Open ID Connect

这里使用 API Key 作为演示，在 OpenAPI 文档的根目录添加安全对象：

```yaml
security:
  - app_id: []
```

这样所有的路径都会使用 `security` 描述的 `app_id` 安全方法，我们通常会在 `components` 中添加 `security` 对象，这样的描述信息会更加的详细，如下：

```yaml
components:
  ...
  securitySchemes:
    app_id:
      type: apiKey
      description: API key to authorize requests.
      name: appid
      in: query
```

security 对象的属性内容：

- type：授权协议，枚举值有：`apiKey`、`http`、`oauth2`、`openIdConnect`
- description：安全方法的描述，尽可能的详细，包含使用示例
- name：安全密钥 `apiKey` 在 HTTP Header 请求中的名字
- in：安全密钥 `apiKey` 在 HTTP 传输中的位置，枚举值有：`query`，`header`，`cookie`
- …………

在添加以上的描述信息后，Swagger UI 会显示安全任何的相关标识，如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-33-image-20231219113346640.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-33-image-20231219113346640.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-33-image-20231219113346640.png" alt="image-20231219113346640" style="zoom:50%;" loading="lazy"/>
  </picture>

点击 `Authorize` 会显示更多的安全信息：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-34-image-20231219113420425.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-34-image-20231219113420425.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-34-image-20231219113420425.png" alt="image-20231219113420425" style="zoom:25%;" loading="lazy"/>
  </picture>

当你在 `Value` 输入你的访问秘钥时，Swagger 会在访问 API 的时候，根据你的设定访问你的 API，如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-34-image-20231219113448939.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-34-image-20231219113448939.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-34-image-20231219113448939.png" alt="image-20231219113448939" style="zoom:25%;" loading="lazy"/>
  </picture>

#### tags 对象

该对象主要是对 OpenAPI 中的多个访问路径进行分组，使用示例如下：

我们为一个请求路径添加 `tags` 信息：

```yaml
paths:
  /pets:
    get:
      summary: List all pets
      operationId: listPets
      tags:
        - pets
```

这表示该请求路径属于 `pets` 分组，然后我们在根目录级别添加 `tags` 属性，来为分组信息进行描述：

```yaml
tags:
  - name: pets
    description: "Chimelong Animal Happy World"
```

然后我们来看看 Swagger UI 对于分组信息的展示，如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-36-image-20231219113627292.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-36-image-20231219113627292.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-19-11-36-image-20231219113627292.png" alt="image-20231219113627292" style="zoom:25%;" loading="lazy"/>
  </picture>









### 利用schema生成前端代码

明白了上面schema的数据结构含义，你想用来生成啥都没问题。

生成mock，可以参考这个https://reeli.github.io/blog/tools_swagger-to-mocks.html#%E7%94%9F%E6%88%90-mock-%E6%95%B0%E6%8D%AE。用到了faker.js这个库

生成ts类型，可以参考这个https://github.com/drwpow/openapi-typescript/blob/main/packages/openapi-typescript/README.md







## Server-side-render(ssr)

一个应用渲染静态页面的过程，其实可以分为以下三个步骤：

- 模板页面的渲染：即 HTML中 body 标签下的 dom 内容，像我们平时写一个基于 React(反应) 或是 Vue 的前后端分离项目，首先我们会去编写对应页面的模板模块，再写相关的数据请求，最后统一导出进行页面的渲染。

- 路由的匹配：一个 Web(网络) 工程下可能会有多个模板页面需要渲染，我们会使用路由去对应指定的模板页面进行渲染，体现在浏览器中，也就是我们域名后的后缀。

- header标签的修改：模板页面本身是没办法去修改页面的 header 标签的，但是修改 header 标签的需求其实并不少见，类似修改站点的标题， 或是进行多媒体适配，可能都需要对 header 标签有一定修改。







### CSR、SSR、SSG

预渲染是当今比较主流的优化手段，主要包括服务端渲染(SSR)和静态站点生成(SSG)这两种技术。

在选择上，如果我们的应用存在首屏加载优化需求，SEO需求时，就可以考虑SSR。

#### CSR

CSR 的工作流程：

客户端向服务器或 CDN 发送请求，获取静态的 HTML 页面。注意，此时获取的HTML 页面通常是空页面。在 HTML 页面中，会包含 `<style>`、`<link>` 和`<script>` 等标签。浏览器在得到该页面后，不会渲染出任何内容，所以从用户的视角看，此时页面处于“白屏”阶段。<mark>（所以 `白屏`问题就是CSR带来的，想根治就SSR吧或者SSG，反正就是返回的html得有东西，别就一个空的`<div id='app'/>`）</mark>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-12-18-01-image-20240112180138631.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-12-18-01-image-20240112180138631.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-12-18-01-image-20240112180138631.png" alt="image-20240112180138631" style="zoom:33%;" loading="lazy"/>
  </picture>





csr确实一般是单页应用，多页应用的话肯定有不同的html。

CSR应用只会首次请求html文件，后续只需要请求JSON数据即可，因此节约流量，服务端压力也较小。但是首屏加载的时间会变长，而且SEO不友好。

它的 HTML 产物一般是如下的结构:

```ts
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title></title>
  <link rel="stylesheet" href="xxx.css" />
</head>
<body>
  <!-- 一开始没有页面内容 -->
  <div id="root"></div>
  <!-- 通过 JS 执行来渲染页面 -->
  <script src="xxx.chunk.js"></script>
</body>
</html>
```

当浏览器拿到如上的 HTML 内容之后，并不能渲染完整的页面内容，因为此时的 body 中基本只有一个空的 div 节点，并没有填入真正的页面内容。而接下来浏览器开始下载并执行 JS 代码，经历了框架初始化、数据请求、DOM 插入等操作之后才能渲染出完整的页面。也就是说，在 CSR 中完整的页面内容本质上通过 JS 代码执行之后才能够渲染。这主要会导致两个方面的问题:

- **首屏加载速度比较慢**。首屏加载需要依赖 JS 的执行，下载和执行 JS 都可能是非常耗时的操作，尤其是在一些网络不佳的场景，或者性能敏感的低端机下。
- **对 SEO(搜索引擎优化) 不友好**。页面 HTML 没有具体的页面内容，导致搜索引擎爬虫无法获取关键词信息，导致网站排名受到影响。

#### SSR

<font color="red">服务端</font>生成好**完整的 HTML 内容**，直接返回给浏览器，浏览器能够根据 HTML 渲染出完整的首屏内容，而不需要依赖 JS 的加载，这样一方面能够降低首屏渲染的时间，另一方面也能将完整的页面内容展现给搜索引擎的爬虫，利于 SEO。而另一方面，由于服务端的网络环境更优，可以更快地获取到页面所需的数据，也能节省浏览器请求数据的时间。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-12-17-57-image-20240112175706981.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-12-17-57-image-20240112175706981.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-12-17-57-image-20240112175706981.png" alt="image-20240112175706981" style="zoom:33%;" loading="lazy"/>
  </picture>

(1) 用户通过浏览器请求站点。(2) 服务器请求 API 获取数据。(3) 接口返回数据给服务器。(4) 服务器根据模板和获取的数据拼接出最终的 HTML 字符串。(5) 服务器将 HTML 字符串发送给浏览器，浏览器解析 HTML 内容并渲染。

当用户再次通过超链接进行页面跳转，会重复上述 5 个步骤。





SSR 中只能生成页面的内容和结构，并不能完成事件绑定，因此需要在浏览器中执行 CSR 的 JS 脚本，完成事件绑定，让页面拥有交互的能力，这个过程被称作`hydrate`(翻译为`注水`或者`激活`)。同时，像这样服务端渲染 + 客户端 hydrate 的应用也被称为`同构应用`。

水合（hydrateRoot）
此处水合是指后端数据达到前端后，js绑定事件，才能够响应用户的操作或者DOM的更新。
组件在服务器拉取数据，并在服务端首次渲染。
脱水，对组件进行脱水，变成HTML字符串，脱去交互事件，成为风干标本快照。
注水，发送到客户端后，重新注入数据（交互的事件），重新变成可交互组件。



在 Vue 场景下，通常可以选择 [Nuxt.js](https://link.juejin.cn/?target=https%3A%2F%2Fnuxtjs.org%2F)、[Quasar](https://link.juejin.cn/?target=https%3A%2F%2Fquasar.dev%2F)、[`@vue/server-renderer`](https://link.juejin.cn/?target=https%3A%2F%2Fvuejs.org%2Fguide%2Fscaling-up%2Fssr.html) 等方案实现 SSR，这些技术的底层逻辑都包含三个大的步骤：

- 编译时，将同一组件构建为适合在客户端、服务器运行的两份副本；
- 服务端接收到请求时，调用 Render 工具将组件渲染为 HTML 字符串，并返回给客户端；
- 客户端运行 HTML，并再次执行组件代码，“激活(Hydrate)” 组件。






SSR 不是银弹，依然带来了不少新问题：

- 更高的架构复杂度，这意味着更高的维护、扩展、学习成本；
- Node 与浏览器环境不完全匹配，部分浏览器特定的代码，只能在某些生命周期钩子函数中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在 SSR 中运行；
- 组件要求更高，需要兼容 Node.js Server 运行环境；
- 服务端负载更高，毕竟相较于纯粹提供静态资源的 SPA 形式，SSR 需要在 Node 进程中执行大量 CPU 运算以渲染 HTML 片段。

#### SSG

 [Static Site Generation](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fchrisvfritz%2Fprerender-spa-plugin) (或叫 Pre-renderer) 方式

 SSG 可以在<font color="red">构建阶段</font>执行代码生成完整的 HTML 内容，它与 SSR 最大的不同在于 HTML 的生成在构建阶段完成，而不是在服务器的运行时。SSG 同样可以给浏览器完整的 HTML 内容，不依赖于 JS 的加载，可以有效提高页面加载性能。不过相比 SSR，SSG 的内容往往动态性不够，适合比较静态的站点，比如文档、博客等场景。

缺点是 会导致构建时长变慢。

在 Webpack4 环境下，可选择 [prerender-spa-plugin](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fchrisvfritz%2Fprerender-spa-plugin) 实现 SSG 功能，但实测发现该插件并不兼容 Webpack5

在vite下用vite-ssg，可到工程化的vite下看具体实现。



如果ssg里有一些依据接口的分支，比如如果接口返回的值是某某就展示a，如果是接口返回的是另一个值我就要展示b，那就按没有这个接口值的情况来处理。比如：

```js
 // HomePage.vue
<h1 v-if="coinBalance">有{{ coinBalance }}</h1>
        <h1 v-if="coinBalance && coinBalance > 1000">有大于{{ coinBalance }}</h1>
        <h1 v-else-if="coinBalance && coinBalance < 1000">有小于{{ coinBalance }}</h1>
        <h1 v-else>无{{ coinBalance }}</h1>
// 这个ssg打包出来的index.html里就只有 最下面那个 ‘无’
```



#### ISR（Incremental Static Regeneration）增量静态生成


ISR最早由 Next.js 在 9.5 版本中提出，它结合了 SSG 和 SSR 的优势。

核心思想是将内容区分为主要内容和次要内容。主要内容的静态页面采用SSG的方式在构建时生成。而对于次要内容则借鉴SSR得方式保持动态，在用户首次访问时进行渲染。一旦渲染完成，生成的静态页面被缓存，并在后续的请求中被直接提供，以提高性能和响应速度。

后续更新遵循 stale-while-revalidate 的逻辑，即始终返回 CDN 的缓存数据（无论是否过期）；如果数据已经过期，那么触发异步的预渲染，异步更新 CDN 的缓存。



#### DPR（Distributed Persistent Rendering）分布式的持续渲染

DPR是由Netlify提出个一个提案，详见Distributed Persistent Rendering: a new idea in the Jamstack to make deploys faster and bring a wider range of use cases.

DPR 本质上讲，是对 ISR 的模型做了几处改动，并且搭配上 CDN 的能力：

1、去除了 fallback 行为，而是直接用 On-demand Builder（按需构建器）来响应未经过预渲染的页面，然后将结果缓存至 CDN；

2、数据页面过期时，不再响应过期的缓存页面，而是 CDN 回源到 Builder 上，渲染出最新的数据；

3、每次发布新版本时，自动清除 CDN 的缓存数据。














### ssg/ssr的作用

#### Ssg/ssr解决SPA的首页加载慢(amp)和seo问题

Ssg: 客户端拿到html>发起请求(因为主接口预请求，不然这个得在js执行)->请求js->js执行->绘制页面中动态部分->fmp；

ssr: server执行js->请求接口->绘制html->客户端拿到html->fmp；由于前面都是在server做的会比较快，而且内网请求接口就几毫秒的事

所以为啥老说动态数据多的就用ssr，动态数据少的用ssg，原因一是ssr核心提速就在于首页的接口请求。原因二是没啥动态数据的话ssg直接构建就行了。你可以理解成ssg是ssr在动态数据少的时候的一种优化手段，当然动态数据多的时候也能用，就只渲染静态的部分，动态的都为空或loading呗，但页面太多动态数据就确实意义不大了，还导致你构建的时长变慢。

#### 解决不了tti慢的问题

ssg（static site generation）/ssr主要的问题在于这类方案仍然会下载`全量的客户端 JS `及执行`全量的组件 Hydrate 过程`，造成页面的首屏 TTI 劣化。

tti的话由于都要执行js之后才行，所以ssr对于ssg的提升就只在于加快了接口的响应时间。而ssg对于tti则没有什么提升。





## 同构

同构”一词指的是一份代码既在服务端运行，又在客户端运行。因此，在编写组件代码时，应该额外注意因代码运行环境的不同所导致的差异。

SSR 中只能生成页面的内容和结构，同构渲染仍然需要像 CSR 那样等待 JavaScript 资源加载完成，并且客户端激活完成后，完成事件绑定，让页面拥有交互的能力。因此，理论上同构渲染无法提升可交互时间。，这个过程被称作`hydrate`(翻译为`注水`或者`激活`)。像这样服务端渲染 + 客户端 hydrate 的应用也被称为`同构应用`。服务端渲染的是应用程序的快照，所谓快照，指的是在当前数据状态下页面应该呈现的内容。





### **同构的 生命周期**

借用一张Webpack官方的图来表示SSR应用的两大周期：**构建时** +  **运行时**。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-16-image-20231126171641522.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-16-image-20231126171641522.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-16-image-20231126171641522.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-16-image-20231126171641522.png" loading="lazy"/>
  </picture>

#### **构建时**

1. 构建出两套代码，分别用于客户端侧和服务端侧运行。

   <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-19-38-image-20231129193840125.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-19-38-image-20231129193840125.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-19-38-image-20231129193840125.png" alt="image-20231129193840125" style="zoom:50%;" loading="lazy"/>
  </picture>

2. **移除样式代码的引入**。直接引入一行 css 在服务端其实是无法执行的，因为 Node.js并不能解析 CSS 的内容。但 `CSS Modules` 的情况除外，如下所示:

```ts
import styles from './index.module.css'
// 这里的 styles 是一个对象，如{ "container": "xxx" }，而不是 CSS 代码
console.log(styles)
```

3. **依赖外部化(external(外部))**。对于某些第三方依赖我们并不需要使用构建后的版本，而是直接从 `node_modules` 中读取，比如 `react-dom`，这样在 `SSR 构建`的过程中将不会构建这些依赖，从而极大程度上加速 SSR 的构建。













#### **运行时**

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-20-23-image-20231129202303150.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-20-23-image-20231129202303150.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-20-23-image-20231129202303150.png" alt="image-20231129202303150" style="zoom:50%;" loading="lazy"/>
  </picture>

**加载 SSR 入口模块**。在这个阶段，我们需要确定 SSR 构建产物的入口，即组件的入口在哪里，并加载对应的模块。

**进行数据预取**。这时候 Node 侧会通过查询数据库或者网络请求来获取应用所需的数据。如何使服务端和客户端共享**数据模型**：服务端在输出html文件前**将请求获取的数据注入到window**某个属性上。客户端获取到html文件后，**获取了window上的数据，并将该数据存在客户端store中**。

**渲染组件**。这个阶段为 SSR 的核心，主要将第 `1` 步中加载的组件渲染成 HTML 字符串或者 Stream流。

**HTML 拼接**。在组件渲染完成之后，我们需要拼接完整的 HTML 字符串，并将其作为响应返回给浏览器。











#### 同构应用代码的执行过程：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-18-image-20231126171859153.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-18-image-20231126171859153.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-26-17-18-image-20231126171859153.png" alt="image-20231126171859153" style="zoom:50%;" loading="lazy"/>
  </picture>





### 工程化问题

vue官网上的一些成熟方案https://cn.vuejs.org/guide/scaling-up/ssr.html#higher-level-solutions

以上我们基本实现了 SSR 核心的`构建`和`运行时`功能，可以初步运行一个基于 Vite 的 SSR 项目，但在实际的场景中仍然是有不少的工程化问题需要我们注意。下面我就和你一起梳理一下到底需要考虑哪些问题，以及相应的解决思路是如何的。

#### 1. 路由管理

在 SPA 场景下，对于不同的前端框架，一般会有不同的路由管理方案，如 Vue 中的 `vue-router`、React 的`react-router`。不过归根结底，路由方案在 SSR 过程中所完成的功能都是差不多的:

1. 告诉框架现在渲染哪个路由。在 Vue 中我们可以通过 `router.push` 确定即将渲染的路由，React 中则通过 `StaticRouter` 配合`location`参数来完成。
2. 设置 `base` 前缀。规定路径的前缀，如`vue-router` 中 [base 参数](https://link.juejin.cn/?target=https%3A%2F%2Frouter.vuejs.org%2Fzh%2Fguide%2Fmigration%2F%23%E7%A7%BB%E5%8A%A8%E4%BA%86-base-%E9%85%8D%E7%BD%AE)、`react-router`中`StaticRouter`组件的 [basename](https://link.juejin.cn/?target=https%3A%2F%2Fv5.reactrouter.com%2Fweb%2Fapi%2FStaticRouter)。

#### 2. 全局状态管理

对于全局的状态管理而言，对于不同的框架也有不同的生态和方案，比如 Vue 中的 [Vuex](https://link.juejin.cn/?target=https%3A%2F%2Fvuex.vuejs.org%2F)、[Pinia](https://link.juejin.cn/?target=https%3A%2F%2Fpinia.vuejs.org%2F)，React 中的 [Redux](https://link.juejin.cn/?target=https%3A%2F%2Fredux.js.org%2Fintroduction%2Fgetting-started)、[Recoil](https://link.juejin.cn/?target=https%3A%2F%2Frecoiljs.org%2Fzh-hans%2F)。各个状态管理工具的用法并不是本文的重点，接入 SSR 的思路也比较简单，在`预取数据`阶段初始化服务端的 `store` ，将异步获取的数据存入 `store` 中，然后在 `拼接 HTML`阶段将数据从 store 中取出放到数据 script 标签中，最后在客户端 hydrate 的时候通过 window 即可访问到预取数据。

> 需要注意的服务端处理许多不同的请求，对于每个请求都需要**分别**初始化 store，即一个请求一个 store，不然会造成全局状态污染的问题。

#### 3. CSR 降级

在某些比较极端的情况下，我们需要降级到 CSR，也就是客户端渲染。一般而言包括如下的降级场景:

- 1. 服务器端**预取数据**失败，需要降级到客户端获取数据。
- 1. 服务器出现异常，需要返回**兜底的 CSR 模板**，完全降级为 CSR。
- 1. 本地**开发调试**，有时需要跳过 SSR，仅进行 CSR。

对于第一种情况，在客户端入口文件中需要有重新获取数据的逻辑，我们可以进行这样的补充:

```ts
ts
复制代码// entry-client.tsx
import React from 'react'
import ReactDOM from 'react-dom'
import './index.css'
import App from './App'

async function fetchData() {
  // 客户端获取数据
}


async fucntion hydrate() {
  let data;
  if (window.__SSR_DATA__) {
    data = window.__SSR_DATA__;
  } else {
    // 降级逻辑 
    data = await fetchData();
  }
  // 也可简化为 const data = window.__SSR_DATA__ ?? await fetchData();
  ReactDOM.hydrate(
    <React.StrictMode>
      <App data={data}/>
    </React.StrictMode>,
    document.getElementById('root')
  )
}
```

对于第二种场景，即`服务器执行出错`，我们可以在之前的 SSR 中间件逻辑追加 catch 逻辑:

```ts
ts
复制代码async function createSsrMiddleware(app: Express): Promise<RequestHandler> {
  return async (req, res, next) => {
    try {
      // SSR 的逻辑省略
    } catch(e: any) {
      vite?.ssrFixStacktrace(e);
      console.error(e);
      // 在这里返回浏览器 CSR 模板内容
    }
  }
}
```

对于第三种情况，我们可以通过通过 `?csr` 的 url query 参数来强制跳过 SSR，在 SSR 中间件添加如下逻辑:

```ts
ts
复制代码async function createSsrMiddleware(app: Express): Promise<RequestHandler> {
  return async (req, res, next) => {
    try {
      if (req.query?.csr) {
        // 响应 CSR 模板内容
        return;
      }
      // SSR 的逻辑省略
    } catch(e: any) {
      vite?.ssrFixStacktrace(e);
      console.error(e);
    }
  }
}
```

#### 4. 浏览器 API 兼容

由于 Node.js 中不能使用浏览器里面诸如 `window`、`document`之类的 API，因此一旦在服务端执行到这样的 API 会报如下的错误：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-K6xCXN.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-K6xCXN.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-K6xCXN.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-K6xCXN.webp" loading="lazy"/>
  </picture>

那么如何来解决这个问题呢？

首先我们可以通过`import.meta.env.SSR`这个 Vite 内置的环境变量来判断是否处于 SSR 环境，以此来规避业务代码在服务端出现浏览器的 API:

```ts
ts
复制代码if (import.meta.env.SSR) {
  // 服务端执行的逻辑
} else {
  // 在此可以访问浏览器的 API
}
```

当然，我们也可以通过 polyfill 的方式，在 Node 中注入浏览器的 API，使这些 API 能够正常运行起来，解决如上的问题。我推荐使用一个比较成熟的 polyfill 库 `jsdom`，使用方式如下:

```ts
ts
复制代码const jsdom = require('jsdom');
const { window } = new JSDOM(`<!DOCTYPE html><p>Hello world</p>`);
const { document } = window;
// 挂载到 node 全局
global.window = window;
global.document = document;
```

#### 5. 自定义 Head

在 SSR 的过程中，我们虽然可以在决定组件的内容，即`<div id="root"></div>`这个容器 div 中的内容，但对于 HTML 中`head`的内容我们无法根据**组件的内部状态**来决定，比如对于一个直播间的页面，我们需要在服务端渲染出 title 标签，title 的内容是不同主播的直播间名称，不能在代码中写死，这种情况怎么办？

React 生态中的 [react-helmet](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnfl%2Freact-helmet) 以及 Vue 生态中的 [vue-meta](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fnuxt%2Fvue-meta) 库就是为了解决这样的问题，让我们可以直接在组件中写一些 Head 标签，然后在服务端能够拿到组件内部的状态。这里我以一个`react-helmet`例子来说明:

```ts
ts
复制代码// 前端组件逻辑
import { Helmet } from "react-helmet";

function App(props) {
  const { data } = props;
  return {
    <div>
       <Helmet>
        <title>{ data.user }的页面</title>
        <link rel="canonical" href="http://mysite.com/example" />
      </Helmet>
    </div>
  }
}
// 服务端逻辑
import Helmet from 'react-helmet';

// renderToString 执行之后
const helmet = Helmet.renderStatic();
console.log("title 内容: ", helmet.title.toString());
console.log("link 内容: ", helmet.link.toString())
```

启动服务后访问页面，可以发现终端能打印出如下的信息:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Dsdl9r.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Dsdl9r.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Dsdl9r.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Dsdl9r.webp" loading="lazy"/>
  </picture>

如此一来，我们就能根据组件的状态确定 Head 内容，然后在`拼接 HTML`阶段将这些内容插入到模板中。

#### 6. 流式渲染

在不同前端框架的底层都实现了流式渲染的能力，即边渲染边响应，而不是等整个组件树渲染完毕之后再响应，这么做可以让响应提前到达浏览器，提升首屏的加载性能。Vue 中的 [renderToNodeStream](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2F@vue%2Fserver-renderer) 和 React 中的 [renderToNodeStream](https://link.juejin.cn/?target=https%3A%2F%2Freactjs.org%2Fdocs%2Freact-dom-server.html%23rendertonodestream) 都实现了流式渲染的能力, 大致的使用方式如下:

```ts
ts
复制代码import { renderToNodeStream } from 'react-dom/server';

// 返回一个 Nodejs 的 Stream 对象
const stream = renderToNodeStream(element);
let html = ''

stream.on('data', data => {
  html += data.toString()
  // 发送响应
})

stream.on('end', () => {
  console.log(html) // 渲染完成
  // 发送响应
})

stream.on('error', err => {
  // 错误处理
})
```

不过，流式渲染在我们带来首屏性能提升的同时，也给我们带来了一些限制: **如果我们需要在 HTML 中填入一些与组件状态相关的内容，则不能使用流式渲染**。比如`react-helmet`中自定义的 head 内容，即便在渲染组件的时候收集到了 head 信息，但在流式渲染中，此时 HTML 的 head 部分已经发送给浏览器了，而这部分响应内容已经无法更改，因此 `react-helmet` 在 SSR 过程中将会失效。

#### 7. SSR 缓存

SSR 是一种典型的 CPU 密集型操作，为了尽可能降低线上机器的负载，设置缓存是一个非常重要的环节。在 SSR 运行时，缓存的内容可以分为这么几个部分:

- `文件读取缓存`。尽可能避免多次重复读磁盘的操作，每次磁盘 IO 尽可能地复用缓存结果。如下代码所示:

```ts
ts
复制代码function createMemoryFsRead() {
  const fileContentMap = new Map();
  return async (filePath) => {
    const cacheResult = fileContentMap.get(filePath);
    if (cacheResult) {
      return cacheResult;
    }
    const fileContent = await fs.readFile(filePath);
    fileContentMap.set(filePath, fileContent);
    return fileContent;
  }
}

const memoryFsRead = createMemoryFsRead();
memoryFsRead('file1');
// 直接复用缓存
memoryFsRead('file1');
```

- `预取数据缓存`。对于某些实时性不高的接口数据，我们可以采取缓存的策略，在下次相同的请求进来时复用之前预取数据的结果，这样预取数据过程的各种 IO 消耗，也可以一定程度上减少首屏时间。
- `HTML 渲染缓存`。拼接完成的`HTML`内容是缓存的重点，如果能将这部分进行缓存，那么下次命中缓存之后，将可以节省 `renderToString`、`HTML 拼接`等一系列的消耗，服务端的性能收益会比较明显。

对于以上的缓存内容，具体的缓存位置可以是：

- 1. `服务器内存`。如果是放到内存中，需要考虑缓存淘汰机制，防止内存过大导致服务宕机，一个典型的缓存淘汰方案是 [lru-cache](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fisaacs%2Fnode-lru-cache) (基于 LRU 算法)。
- 1. [Redis 数据库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fredis%2Fnode-redis)，相当于以传统后端服务器的设计思路来处理缓存。
- 1. CDN 服务。我们可以将页面内容缓存到 CDN 服务上，在下一次相同的请求进来时，使用 CDN 上的缓存内容，而不用消费源服务器的资源。对于 CDN 上的 SSR 缓存，大家可以通过阅读[这篇文章](https://juejin.cn/post/6887884087915184141#heading-8)深入了解。

> 需要补充的是，Vue 中另外实现了[组件级别的缓存](https://link.juejin.cn/?target=https%3A%2F%2Fssr.vuejs.org%2Fzh%2Fguide%2Fcaching.html%23%E7%BB%84%E4%BB%B6%E7%BA%A7%E5%88%AB%E7%BC%93%E5%AD%98-component-level-caching)，这部分缓存一般放在内存中，可以实现更细粒度的 SSR 缓存。

#### 8. 性能监控

在实际的 SSR 项目中，我们时常会遇到一些 SSR 线上性能问题，如果没有一个完整的性能监控机制，那么将很难发现和排查问题。对于 SSR 性能数据，有一些比较通用的指标:

- SSR 产物加载时间
- 数据预取的时间
- 组件渲染的时间
- 服务端接受请求到响应的完整时间
- SSR 缓存命中情况
- SSR 成功率、错误日志

我们可以通过`perf_hooks`来完成数据的采集，如下代码所示:

```ts
ts
复制代码import { performance, PerformanceObserver } from 'perf_hooks';

// 初始化监听器逻辑
const perfObserver = new PerformanceObserver((items) => {
  items.getEntries().forEach(entry => { 
    console.log('[performance]', entry.name, entry.duration.toFixed(2), 'ms');
  });
  performance.clearMarks();
});

perfObserver.observe({ entryTypes: ["measure"] })

// 接下来我们在 SSR 进行打点
// 以 renderToString  为例
performance.mark('render-start');
// renderToString 代码省略
performance.mark('render-end');
performance.measure('renderToString', 'render-start', 'render-end');
```

接着我们启动服务后访问，可以看到如下的打点日志信息:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-qCGKdV.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-qCGKdV.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-qCGKdV.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-qCGKdV.webp" loading="lazy"/>
  </picture>

同样的，我们可以将其它阶段的指标通过上述的方式收集起来，作为性能日志；另一方面，在生产环境下，我们一般需要结合具体的性能监控平台，对上述的各项指标进行打点上报，完成线上的 SSR 性能监控服务。

#### 9. SSG/ISR/SPR

有时候对于一些静态站点(如博客、文档)，不涉及到动态变化的数据，因此我们并不需要用上服务端渲染。此时只需要在构建阶段产出完整的 HTML 进行部署即可，这种构建阶段生成 HTML 的做法也叫`SSG`(Static Site Generation，静态站点生成)。

SSG 与 SSR 最大的区别就是产出 HTML 的时间点从 SSR `运行时`变成了`构建时`，但核心的生命周期流程并没有发生变化:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-22-47-image-20231129224705612.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-22-47-image-20231129224705612.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-22-47-image-20231129224705612.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-11-29-22-47-image-20231129224705612.png" loading="lazy"/>
  </picture>

这里给一段简单的实现代码:

```ts
// scripts/ssg.ts
// 以下的工具函数均可以从 SSR 流程复用
async function ssg() {
  // 1. 加载服务端入口
  const { ServerEntry, fetchData } = await loadSsrEntryModule(null);
  // 2. 数据预取
  const data = await fetchData();
  // 3. 组件渲染
  const appHtml = renderToString(React.createElement(ServerEntry, { data }));
  // 4. HTML 拼接
  const template = await resolveTemplatePath();
  const templateHtml = await fs.readFileSync(template, 'utf-8');
  const html = templateHtml
  .replace('<!-- SSR_APP -->', appHtml)
  .replace(
    '<!-- SSR_DATA -->',
    `<script>window.__SSR_DATA__=${JSON.stringify(data)}</script>`
  ); 
  // 最后，我们需要将 HTML 的内容写到磁盘中，将其作为构建产物
  fs.mkdirSync('./dist/client', { recursive: true });
  fs.writeFileSync('./dist/client/index.html', html);
}

ssg();
```

接着你可以在`package.json`中加入这样一段 npm scripts:

```json
json
复制代码{
  "scripts": {
    "build:ssg": "npm run build && NODE_ENV=production esno scripts/ssg.ts"  
  }
}
```

这样我们便初步实现了 SSG 的逻辑。当然，除了 SSG，业界还流传着一些其它的渲染模式，诸如`SPR`、`ISR`，听起来比较高大上，但实际上只是 SSR 和 SSG 所衍生出来的新功能罢了，这里简单给大家解释一下:

- `SPR`即`Serverless Pre Render`，即把 SSR 的服务部署到 Serverless(FaaS) 环境中，实现服务器实例的自动扩缩容，降低服务器运维的成本。
- `ISR`即`Incremental Site Rendering`，即增量站点渲染，将一部分的 SSG 逻辑从构建时搬到了 `SSR` 运行时，解决的是大量页面 SSG 构建耗时长的问题。





### 孤岛架构

#### 同构存在的问题

能优化首屏时长但仍无法优化TTI。因为会下载`全量的客户端 JS `及执行`全量的组件 Hydration 过程`。



#### 什么是孤岛架构

孤岛架构就是为了解决上述问题：对于静态组件，即不可交互的组件，我们可以让其不参与 hydration 过程，直接复用服务端下发的 HTML 内容。可交互的组件就犹如整个页面中的孤岛(Island)，只对其进行hydration。对此又可以延伸出懒水合(按需水合)，首屏不进行任何水合，到点击了某个元素再拉取该元素的水合代码（貌似astro就是这么搞）。这样tti肯定有提升，因为把时机延迟到了用户点击之后。



而我的疑惑点就在于：哪怕对静态的内容进行了hydration，这里的开销有多大呢？

**DOM 元素数量**

- 对于含有大量 DOM 元素的静态内容，hydration 过程需要遍历和匹配更多的元素。即使这些元素不包含动态行为，这个过程仍然需要时间，特别是在较慢的设备上。

**内存占用**

- 在 hydration 过程中，即使是静态内容，Vue 也会创建相应的虚拟 DOM 表示。这会增加浏览器的内存占用。

 **组件实例化**

- Vue 会为每个组件实例化一个对象，即使是静态内容。这些实例化操作本身也有一定的开销。



#### 整体的流程

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-28-18-11-image-20240128181150153.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-28-18-11-image-20240128181150153.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-28-18-11-image-20240128181150153.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-28-18-11-image-20240128181150153.png" loading="lazy"/>
  </picture>

大家可以重点关注 ssr-entry 的打包，在 renderToString 之后，我们拿到所有 Islands 组件信息，然后打包所有的 Islands 组件信息，将组件挂载到全局的 window 对象上，这部分打包产物我们称之为 `islands bundle`。

最后，我们将 `islands bundle` 注入到 HTML 中，这样在客户端运行时就能够拿到各个 Islands 组件，然后分别对它们进行 hydration，实现部分 hydration 的效果，也就实现了完整的 Islands 架构了。



## 用户认证与授权

### Basic Authentication

基本认证（Basic Authentication）是一种在客户端与服务器之间进行身份验证的简单方式。它通常在 Web 应用程序中用于验证用户，使其能够访问受密码保护的资源或服务。基本认证使用 HTTP 协议的标准头部字段来传递用户名和密码。

基本认证的工作原理如下：

1. **客户端请求**： 客户端（通常是浏览器或应用程序）发送一个 HTTP 请求到服务器，要求访问需要认证的资源。在请求中，客户端在头部中添加了一个名为 "Authorization" 的字段。
2. **编码用户名和密码**： 在 "Authorization" 字段中，客户端将用户名和密码以 "用户名:密码" 的形式组合起来。然后将这个组合进行 Base64 编码。Base64 编码是一种编码方式，将二进制数据转换成可打印字符的方法。
3. **发送认证请求**： 客户端将 Base64 编码后的用户名和密码发送到服务器。注意，虽然这个过程中的用户名和密码是 Base64 编码的，但并没有进行加密，所以并不是安全的传输方式。
4. **服务器验证**： 服务器接收到请求后，会从 "Authorization" 头部中提取 Base64 编码的用户名和密码。然后服务器会对这些凭据进行验证，通常是与存储在服务器上的用户数据库中的凭据进行比较。
5. **返回响应**： 如果凭据是有效的，服务器将返回请求的资源。如果凭据无效，服务器将返回一个需要认证的错误响应，通常是 401 Unauthorized 响应，并要求客户端重新提供有效的凭据。

基本认证的主要特点是简单，但它也有一些安全和隐私方面的局限性：

- **明文传输**：虽然凭据进行了 Base64 编码，但没有进行加密，因此在传输过程中仍然是明文的。这使得凭据可能在网络上被窃取。
- **无法防止中间人攻击**：由于传输是明文的，中间人可以拦截请求并查看凭据，这使得基本认证容易受到中间人攻击。
- **安全性低**：基本认证不提供强大的安全性，因为用户名和密码很容易被窃取，攻击者可以使用暴力破解或其他攻击方法尝试访问资源。

由于这些局限性，基本认证在传输敏感数据时并不是最佳选择。更安全的方法包括使用 HTTPS 加密通信，使用更强大的身份验证方法，如 OAuth 或 JSON Web Token（JWT），以及使用更复杂的会话管理和权限控制机制。



### `Session`

#### 介绍

一句话总结：服务端生成session并存储，通过cookie的形式在客户端存储sessionID。

为了解决Cookie每次传输导致报文头大且前后端都可以修改的问题且cookie在浏览器是可见的，Session应运而生（session是一种方案）。Session的数据只保留在服务器端，客户端无法修改，数据也无须在协议中每次都被传递。Session信息一般是存储在服务端的，会给浏览器返回一个SessionID之类的标识，下次请求带上SessionID就可以解锁对应的会话信息。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HdqFbb.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HdqFbb.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HdqFbb.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HdqFbb.webp" loading="lazy"/>
  </picture>

- `工作原理`

  - 客户端带着用户名和密码去访问/login 接口，服务器端收到后校验用户名和密码，校验正确就会在服务器端存储一个 sessionId 和 session 的映射关系。
  - 服务器端返回 response，并且将 sessionId 以 set-cookie 的方式种在客户端，这样，sessionId 就存在了客户端。
  - 客户端发起非登录请求时，假如服务器给了 set-cookie，浏览器会自动在请求头中添加 cookie。
  - 服务器接收请求，分解 cookie，验证信息，核对成功后返回 response 给客户端。

- `优势`

  - 相比 JWT，最大的优势就在于可以主动清除 session 
  - session 保存在服务器端，相对较为安全
  - 结合 cookie 使用，较为灵活，兼容性较好（客户端服务端都可以清除，也可以加密）

- `劣势`

  - cookie+session cookie不能跨站

    - 解决方案：
      - 如果是资源请求，不同域名的请求只能服务端做个中转，保证让客户端请求的域名都是同一个。
      - 如果是ajax 请求，跨域的时候是不会挟带 cookie 的，除非手动设置 withCredentials 为 true 才可以。而且也要求后端代码设置了对应的 header：

    ```yaml
    Access-Control-Allow-Origin: "当前域名"; #不能设置 * ，必须指定具体的域名才能接收跨域 cookie。
    Access-Control-Allow-Credentials: true
    ```
  
    
  
  - 如果是分布式部署(多台服务器来提供服务)，需要做多机共享 Session 机制。
  
    - 两种解决方案：
      - 一种是 session 复制，也就是通过一种机制在各台机器自动复制 session，并且每次修改都同步下。这个有对应的框架来做，比如 java 的 spring-session。
      
      - 还有一种方案是把 session 保存在 redis，这样每台服务器都去那里查，只要一台服务器登录了，其他的服务器也就能查到 session。
      
        <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-25-image-20240206192501756.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-25-image-20240206192501756.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-25-image-20240206192501756.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-25-image-20240206192501756.png" loading="lazy"/>
  </picture>
  
  - 基于 cookie 的机制很容易被 CSRF。比如你在A网站登录了，再访问B网站，B网站有个按钮会请求A网站，那A的 cookie 依然能带上。
  
    - 解决方案：验证 referer，就是请求是哪个网站发起的。但依然不能完全解决问题，因为能伪造 referer 。所以一般会每次随机生成一个值返回，后面再发起的请求需要在 参数 或者 header 中包含这个值，否则就认为是非法的。
  
    
  
    
  
    



#### 实现

●第一种：基于Cookie来实现用户和数据的映射

将口令放在Cookie中。Session的有效期通常较短，普遍的设置是20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。由于数据过期时间较短，且在服务器端存储数据，因此安全性相对较高。那么口令是如何产生的呢？服务器将约定一个键值作为Session的口令，这个值可以随意约定，比如Connect默认采用connect_uid, Tomcat会采用jsessionid等。服务器检查到用户请求Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间。



●第二种：通过查询字符串来实现浏览器端和服务器端数据的对应

用户访问http://localhost/pathname时，如果服务器端发现查询字符串中不带session_id参数，就会将用户跳转到http://localhost/pathname?session_id=12344567这样一个类似的地址。如果浏览器收到302状态码和Location报头，就会重新发起新的请求。这样，新的请求到来时就能通过Session的检查，除非内存中的数据过期。

有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须在响应时设置Cookie。但是这种方案带来的风险远大于基于Cookie实现的风险，因为只要将地址栏中的地址发给另外一个人，那么他就拥有跟你相同的身份。



- 第三种：利用HTTP请求头中的ETag，自己上网搜





#### session的安全

##### 介绍

主要指如何让这个口令(key-value)更加安全。

尽管我们的数据都放置在后端了，但是Session的口令（key-value）依然保存在客户端，这里会存在口令被盗用的情况。

而且Web应用的用户十分多情况下如果自行设计的随机算法的一些口令值就有理论机会命中有效的口令值。





##### 解决方案

###### 方案一 私钥加密value

将这个口令的value通过私钥加密进行签名，使得伪造的成本较高。该方法被Connect中间件框架所使用，保护好私钥，就是在保障自己Web应用的安全。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-40-image-20230820154049153.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-40-image-20230820154049153.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-40-image-20230820154049153.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-40-image-20230820154049153.png" loading="lazy"/>
  </picture>

在响应时，设置session值到Cookie中或者跳转URL中：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-41-image-20230820154112931.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-41-image-20230820154112931.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-41-image-20230820154112931.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-41-image-20230820154112931.png" loading="lazy"/>
  </picture>

如果签名非法，我们将服务器端的数据立即过期即可



###### 方案二 添加进客户端独有信息到value里

将客户端的某些独有信息与口令作为原值，然后签名，这样攻击者一旦不在原始的客户端上进行访问，就会导致签名失败。这些独有信息包括用户IP和用户代理（User Agent）。







##### 如果是xss攻击

如果是xss攻击直接获取cookie，那么上面那些解决方案都是扯淡。

比如这样：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-45-image-20230820154500486.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-45-image-20230820154500486.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-45-image-20230820154500486.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-15-45-image-20230820154500486.png" loading="lazy"/>
  </picture>





#### session存储

- 如果session存在内存里的弊端：

  将数据存放在内存中将会带来极大的隐患，如果用户增多，我们很可能就接触到了内存限制的上限，并且内存中的数据量加大，必然会引起垃圾回收的频繁扫描，引起性能问题。

  如果开启多进程，用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存的，用户的Session可能会引起错乱。

  

- 采用第三方缓存来存储Session：目前常用的工具是Redis、Memcached等。

  通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存限制问题都可以迎刃而解，并且这些高速缓存设计的缓存过期策略更合理更高效，比在Node中自行设计缓存策略更好。

  存在的问题：

  会引起网络访问。访问本地磁盘中的数据速度要慢，因为涉及到握手、传输以及网络终端自身的磁盘I/O等，但依然会采用这些高速缓存的理由有以下几条：

  ❑ Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。

  ❑ 高速缓存直接在内存中进行数据存储和访问。

  ❑ 缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。











### `JWT`

#### 相关的概念介绍

> JWT 详细的介绍可以参考`https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html`

`JWT`全称是`JSON WEB TOKEN`，是一个开放标准，用于将各方数据信息作为JSON格式进行对象传递，可以对数据进行可选的数字加密，可使用`RSA`或`ECDSA`进行公钥/私钥签名。**token 完全由应用管理，所以它可以避开同源策略**



项目中采用的是比较流行的`jsonwebtoken`。具体使用方式可以参考`https://www.npmjs.com/package/jsonwebtoken`



#### JWT 的使用方式

- 客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。（我是把他存到localStorage里）。但存在cookie里就会跟session方案一样的受到cookie机制的限制



##### 方式一（我的做法）

- 当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。

  ```vbnet
  GET /calendar/v1/events
  Host: api.example.com
  Authorization: Bearer <token>
  ```

  - 用户的状态不会存储在服务端的内存中，这是一种 **无状态的认证机制**
  - 服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。
  - 由于 JWT 是自包含的，因此减少了需要查询数据库的需要
  - JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。
  - 因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而**不需要担心跨域资源共享问题**（CORS）



##### 方式二

- 跨域的时候，可以把 JWT 放在 POST 请求的数据体里。



##### 方式三

- 通过 URL 传输

```ini
http://www.example.com/user?token=xxx
```







#### JWT 的原理

服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样:

```json
{
  "姓名": "森林",
  "角色": "搬砖工",
  "到期时间": "2020年1月198日16点32分"
}
```

以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认证用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。

服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。

#### JWT 的格式

举例

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImxpdWppYW5naG9uZyIsImlhdCI6MTYzMDcyNTU0NiwiZXhwIjoxNjMwNzI5MTQ2fQ.tCZobphzBo0atE5cXLVI-9NxE-PUbs9dY1gPSrty5pw
```

它是字符串，中间用点（.）分隔成三个部分。



JWT 的三个部分依次如下:

第一部分为header：`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`。Base64解码后会变成一个JSON串 ：

```json
{"alg":"HS256","typ":"JWT"}
```

typ指的是类型，alg指的是加密算法。一般JWT的header部分只有这两个属性。



第二部分为payload：`eyJ1c2VybmFtZSI6ImxpdWppYW5naG9uZyIsImlhdCI6MTYzMDcyNTU0NiwiZXhwIjoxNjMwNzI5MTQ2fQ`。Base64解码后会变成一个JSON串 ：

```json
{"username":"liujianghong","iat":1630725546,"exp":1630729146}
```

在payload中是可以添加一些公共信息的，比如用户名。在JWT的标准里，payload有以下几处申明。

- iss：JWT签发者。
- sub：JWT所面向的用户。
- aud：接收JWT的一方。
- exp：JWT的过期时间，这个过期时间必须大于签发时间。
- nbf：定义在什么时间之前，该JWT都是不可用的。
- iat：JWT的签发时间。
- jti：JWT的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。



第三部分为signature：`tCZobphzBo0atE5cXLVI-9NxE-PUbs9dY1gPSrty5pw`。signature部分的生成是由Base64编码之后的header和payload通过小圆点连接起来，再通过加密算法（需要一个secret）生成的。过程可以用如下语句表述：

```stylus
HMACSHA256( base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```



#### JWT优劣

JWT相比Session优势：

- **CSRF**：因为不是通过自动带的 cookie 来关联服务端的 session 保存的状态，所以没有 CSRF 问题。
- **分布式 session**： 因为状态不是保存在服务端，所以无论访问哪台服务器都行，只要能从 token 里解析出状态数据就行。
- **跨域**：因为不是 cookie 那一套，自然也没有跨域的限制，只要手动带上 JWT 的 header 就行。



劣势：

- 安全性：因为 JWT 把数据直接 Base64 之后就放在了 header 里，那别人就可以轻易从中拿到状态数据，比如用户名等敏感信息，也能根据这个 JWT 去伪造请求。所以 JWT 要搭配 https 来用，让别人拿不到 header。
- 性能：JWT 把状态数据都保存在了 header 里，每次请求都会带上，比起只保存个 id 的 cookie 来说，请求的内容变多了
- 时效性，Session 能直接从服务端销毁，JWT 只能等到时效性到了才会销毁（所以用户修改了密码也无法阻止篡夺者的使用）。比如踢人、退出登录、改完密码下线这种功能就没法实现。
  - 解决方案：配合 redis 来解决，记录下每个 token 对应的生效状态，每次先去 redis 查下 jwt 是否是可用的，这样就可以让 jwt 失效。



#### 续签token方案

##### refresh token

- Access Token 的有效期比较短，比如30分钟，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。
- Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。



<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-06-16f523a04d1c887b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-06-16f523a04d1c887b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-06-16f523a04d1c887b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-06-16f523a04d1c887b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" loading="lazy"/>
  </picture>

两个Token，一个access_token用于访问资源，一个过期时间较长的refresh_token用于获取新的access_token。一般access_token会存有用户的机密信息，refresh_token就没那么机密。

根据上述流程可知，常用的app基本你就可以不用登陆了，很久没上的app就要登录。







##### 具体实现axios里拦截

利用`interceptors.response`，在业务代码获取到接口数据之前进行状态码`401`判断当前携带的`accessToken`是否失效。 如果本地有refreshtoken则把原请求中的配置提取出来，



下面是关于`interceptors.response`中异常阶段处理内容。

```typescript
// 最大重发次数
const MAX_ERROR_COUNT = 5;
// 当前重发次数
let currentCount = 0;
// 缓存请求队列
const queue: ((t: string) => any)[] = [];
// 当前是否刷新状态
let isRefresh = false;

export default async (error: AxiosError<ResponseDataType>) => {
  const statusCode = error.response?.status;
  const clearAuth = () => {
    console.log('身份过期，请重新登录');
    window.location.replace('/login');
    // 清空数据
    localStorage.clear();
    return Promise.reject(error);
  };
  // 为了节省多余的代码，这里仅展示处理状态码为401的情况
  if (statusCode === 401) {
    // accessToken失效
    // 判断本地是否有缓存有refreshToken
    const refreshToken = localStorage.get('refresh') ?? null;
    if (!refreshToken) {
      clearAuth();
    }
    // 提取请求的配置
    const { config } = error;
    // 判断是否refresh失败且状态码401，再次进入错误拦截器
    if (config.url?.includes('refresh')) {
    clearAuth();
    }
    // 判断当前是否为刷新状态中（防止多个请求导致多次调refresh接口）
    if (!isRefresh) {
      // 设置当前状态为刷新中
      isRefresh = true;
      // 如果重发次数超过，直接退出登录
      if (currentCount > MAX_ERROR_COUNT) {
        clearAuth();
      }
      // 增加重试次数
      currentCount += 1;

      try {
        const {
          data: { access },
        } = await UserAuthApi.refreshToken(refreshToken);
        // 请求成功，缓存新的accessToken
        sessionStorage.set('token', access);
        // 重置重发次数
        currentCount = 0;
        // 遍历队列，重新发起请求
        queue.forEach((cb) => cb(access));
        // 返回请求数据
        return ApiInstance.request(error.config);
      } catch {
        // 刷新token失败，直接退出登录
        console.log('请重新登录');
        localStorage.clear();
        window.location.replace('/login');
        return Promise.reject(error);
      } finally {
        // 重置状态
        isRefresh = false;
      }
    } else {
      // 当前正在尝试刷新token，先返回一个promise阻塞请求并推进请求列表中
      return new Promise((resolve) => {
        // 缓存网络请求，等token刷新后直接执行
        queue.push((newToken: string) => {
          Reflect.set(config.headers!, 'authorization', newToken);
          // @ts-ignore
          resolve(ApiInstance.request<ResponseDataType<any>>(config));
        });
      });
    }
  }

  return Promise.reject(error);
};
```

##### 抽离代码

把上面关于调用刷新`token`的代码抽离成一个`refreshToken`函数，单独处理这一情况。

```typescript
// refreshToken.ts
export default async function refreshToken(error: AxiosError<ResponseDataType>) {
    /* 
    将上面 if (statusCode === 401) 中的代码贴进来即可，这里就不重复啦
    代码仓库地址: https://github.com/QC2168/axios-bz/blob/main/Interceptors/hooks/refreshToken.ts
    */
}
```

经过上面的逻辑抽离，现在看下拦截器中的代码就很简洁了，后续如果要调整相关逻辑直接在`refreshToken.ts`文件中调整即可。

```typescript
import refreshToken from './refreshToken.ts'
export default async (error: AxiosError<ResponseDataType>) => {
  const statusCode = error.response?.status;

  // 为了节省多余的代码，这里仅展示处理状态码为401的情况
  if (statusCode === 401) {
    refreshToken()
  }

  return Promise.reject(error);
};
```













### 单点登录

实现单点登录的方式有很多，介绍3种实现方式：同域SSO、同父域SSO以及跨域SSO。

同域SSO 和 同父域SSO （都是利用cookie跨站的特点）。



#### 跨域SSO

##### 介绍

如果App之间的同级域不一样，父域也不一样，在Cookie不共享的情况下，该如何做到单点登录呢？集中式认证服务（Central Authentication Service，CAS）架构可以解决这样的问题。目前业界做SSO鉴权的方案多数是采用了CAS架构。

CAS架构分为两部分：一部分是CAS客户端；另一部分是CAS服务端。CAS客户端是受保护的应用，即需要鉴权的系统。CAS服务端负责鉴权工作，通常情况下，每个公司都有一个SSO统一平台，它就是CAS服务端。



##### ST、TGT和TGC

ST（Service Ticket）：CAS服务端生成的票据，可以理解为一张通行证。这个通行证只能用一次并且有过期时间。

TGT（Ticket Granting Ticket）：TGT就是SessionID，后续用它来验证是否需要创建新的Session，即是否需要再次跳转到SSO的登录界面，填写用户名和密码）。TGT是种在SSO域名下面的。

TGC（Ticket Granting Cookie）：Cookie中对应TGT的键值。



##### 第一次访问App时

假设现在有两个App，一个App，另一个App2。用户两个平台都没有登录过。

执行顺序如图所示。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-15-54-image-20231213155434107.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-15-54-image-20231213155434107.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-15-54-image-20231213155434107.png" alt="image-20231213155434107" style="zoom: 33%;" loading="lazy"/>
  </picture>



##### 第二次访问App时

当用户再次访问App时，由于已经在Cookie里种了token，请求会自动带上Cookie在App服务端进行验证，如果验证通过，则直接返回结果。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-09-image-20231213160910185.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-09-image-20231213160910185.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-09-image-20231213160910185.png" alt="image-20231213160910185" style="zoom:33%;" loading="lazy"/>
  </picture>





##### 登录App后，用户第一次访问App2

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-11-image-20231213161144620.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-11-image-20231213161144620.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-11-image-20231213161144620.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-11-image-20231213161144620.png" loading="lazy"/>
  </picture>



##### 用实际生活场景模拟CAS架构原理

假如我入职了一家新公司，进办公区和食堂都需要工卡。而工卡需要到公司前台去办理。

办理临时工卡的过程与CAS原理的对应关系如下：

- 我代表用户。
- 办公区域和食堂代表受保护的App和App2。
- 前台代表CAS服务。临时工卡代表ST，只能用一次的临时票据。
- Excel表代表CAS创建的Session，记录着TGT。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-23-image-20231213162307099.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-23-image-20231213162307099.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-23-image-20231213162307099.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-23-image-20231213162307099.png" loading="lazy"/>
  </picture>





### 授权协议OAuth 2.0

OAuth 2.0标准目前广泛应用于第三方平台授权场景。OAuth 2.0的授权及验证流程：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-31-image-20231213163143341.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-31-image-20231213163143341.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-31-image-20231213163143341.png" alt="image-20231213163143341" style="zoom:33%;" loading="lazy"/>
  </picture>

1）博客园跳转到QQ统一授权登录页面，URL会带有一些参数。

		<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-38-image-20231213163856823.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-38-image-20231213163856823.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-38-image-20231213163856823.png" alt="image-20231213163856823" style="zoom:33%;" loading="lazy"/>
  </picture>

2）用户扫码登录，表示同意授权。

3）QQ服务器收到同意授权后，生成一个授权码，返回给博客园。

4）博客园携带上一步返回的授权码，再次向QQ认证服务器发起请求，这次是索要token。

		<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-39-image-20231213163938228.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-39-image-20231213163938228.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-39-image-20231213163938228.png" alt="image-20231213163938228" style="zoom:33%;" loading="lazy"/>
  </picture>

5）QQ认证服务器返回token（一个是授权token，一个是刷新token）（QQ返回一些json数据）。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-40-image-20231213164008838.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-40-image-20231213164008838.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-16-40-image-20231213164008838.png" alt="image-20231213164008838" style="zoom:33%;" loading="lazy"/>
  </picture>

最后，博客园带着access_token向QQ索要用户信息。



#### 为什么第一步需要带上state

假如没有state参数，现在有两个用户，一个正常用户 和 一个攻击者，具体过程如下：

1）攻击者登录博客园网站时，选择用第三方平台QQ登录。由于他之前登录过QQ，因此QQ直接向询问是否授权博客园。李四在同意授权后，截获了授权码。

2）攻击者打造了一个Web页面，触发向QQ发起申请token的请求，而请求中的授权码，就是刚刚截获的授权码。攻击者把这个Web页面挂在了网上，等待被骗者。

3）正常用户 虽然已经登录了博客园，但是没有绑定第三方平台的账号。有一天 正常用户 无意间点击了攻击者的页面，触发了向QQ平台索要access_token的请求，因为请求中的授权码是攻击者的，所以拿回来的access_token也是攻击者的。这样正常用户的博客园就绑定了攻击者的QQ账号。

4）攻击者 可以用自己的账号冒充正常用户进行一系列操作了。

如果在请求中加了state参数，因为state参数具有唯一性、时效性、关联性，所以这种具有欺骗性的请求很容易被识别出来。











## 数据上传与安全

### 内存限制

#### 介绍

在解析表单、JSON和XML部分，我们采取的策略是先保存用户提交的所有数据，然后再解析处理，最后才传递给业务逻辑。这种策略存在潜在的问题是，它仅仅适合数据量小的提交请求，一旦数据量过大，将发生内存被占光的情况。哪怕每次提交1 MB的内容，只要并发请求数量一大，内存就会很快地被吃光。

#### 解决方案

❑ 限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。

❑ 通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据





### 防止CSRF -- 看浏览器CSRF那





## 存储

### OSS

#### 介绍

块存储就是把整块磁盘给你用，你需要自己格式化，存储容量有限。

文件存储就是有目录层次结构，你可以上传下载文件，存储容量有限。

对象存储就是 key-value 存储，分布式的方式实现的，存储容量无限。



本地文件存储是目录-文件的组织方式：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-44-image-20240204164416686.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-44-image-20240204164416686.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-44-image-20240204164416686.png" alt="image-20240204164416686" style="zoom:20%;" loading="lazy"/>
  </picture>

而 OSS 服务的存储结构是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-44-image-20240204164434902.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-44-image-20240204164434902.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-44-image-20240204164434902.png" alt="image-20240204164434902" style="zoom: 25%;" loading="lazy"/>
  </picture>

一个桶里放一些文件。

阿里云 OSS 的控制台也提到了对象存储没有目录层级结构：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-fYS3IW.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-fYS3IW.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-fYS3IW.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-fYS3IW.webp" loading="lazy"/>
  </picture>

但下面明明是支持目录的呀：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5MVSGc.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5MVSGc.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5MVSGc.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5MVSGc.webp" loading="lazy"/>
  </picture>

这其实只是模拟实现的。

Object 会存储 id、文件内容、元数据三部分信息：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-45-image-20240204164500504.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-45-image-20240204164500504.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-16-45-image-20240204164500504.png" alt="image-20240204164500504" style="zoom:33%;" loading="lazy"/>
  </picture>

阿里云 OSS 只是用元信息部分模拟实现了目录。

就像打了个 tag 一样，并不是说文件存储在这个 tag 下，只是你可以用这个 tag 来检索文件。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-vpL8Hk.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-vpL8Hk.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-vpL8Hk.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-vpL8Hk.webp" loading="lazy"/>
  </picture>



#### 用minio实现oss

用 minio 自己搭呢？

首先，我们需要安装 [docker 桌面端](https://link.juejin.cn/?target=https%3A%2F%2Fwww.docker.com%2F)：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Pqpdod.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Pqpdod.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Pqpdod.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Pqpdod.webp" loading="lazy"/>
  </picture>

打开后可以看到本地的所有镜像和容器：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5zCL6b.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5zCL6b.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5zCL6b.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-5zCL6b.webp" loading="lazy"/>
  </picture>

搜索下 minio（这步需要科学上网）：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Usi3GH.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Usi3GH.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Usi3GH.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Usi3GH.webp" loading="lazy"/>
  </picture>

填入一些信息：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ECiCNg.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ECiCNg.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ECiCNg.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ECiCNg.webp" loading="lazy"/>
  </picture>

name 是容器名。

port 是映射本地 9000 和 9001 端口到容器内的端口。

volume 是挂载本地目录到容器内的目录

这里挂载了一个本地一个目录到容器内的数据目录 /bitnami/minio/data，这样容器里的各种数据都保存在本地了。

还要指定两个环境变量，MINIO_ROOT_USER 和 MINIO_ROOT_PASSWORD，是用来登录的。

点击 run，跑起来之后可以看到数据目录被标记为 mounted，端口也映射成功了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Fv8Qzc.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Fv8Qzc.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Fv8Qzc.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Fv8Qzc.webp" loading="lazy"/>
  </picture>

访问下 [http://localhost:9001](https://link.juejin.cn/?target=http%3A%2F%2Flocalhost%3A9001)

输入刚才环境变量填的用户名密码：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-NuGM9R.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-NuGM9R.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-NuGM9R.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-NuGM9R.webp" loading="lazy"/>
  </picture>

进入管理界面：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-QCJLPa.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-QCJLPa.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-QCJLPa.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-QCJLPa.webp" loading="lazy"/>
  </picture>

这个 bucket 就是管理桶的地方，而 object browser 就是管理文件列表的地方。

和阿里云 OSS 用法一样。

我们创建个 bucket：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-gVPnvY.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-gVPnvY.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-gVPnvY.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-gVPnvY.webp" loading="lazy"/>
  </picture>

然后在这个 bucket 下上传一个文件：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-JBS2gn.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-JBS2gn.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-JBS2gn.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-JBS2gn.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pZuVGS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pZuVGS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pZuVGS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pZuVGS.webp" loading="lazy"/>
  </picture>

点击 share 就可以看到这个文件的 url：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-dLNcXn.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-dLNcXn.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-dLNcXn.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-dLNcXn.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-9qMTR0.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-9qMTR0.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-9qMTR0.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-9qMTR0.webp" loading="lazy"/>
  </picture>

现在倒是能在浏览器访问，只不过需要带后面的一长串东西：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-LeQfJ2.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-LeQfJ2.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-LeQfJ2.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-LeQfJ2.webp" loading="lazy"/>
  </picture>

不带的话会提示拒绝访问：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-lErp51.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-lErp51.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-lErp51.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-lErp51.webp" loading="lazy"/>
  </picture>

因为现在文件访问权限不是公开的。

我们设置下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Mu1coL.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Mu1coL.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Mu1coL.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-Mu1coL.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-2ZQwDd.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-2ZQwDd.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-2ZQwDd.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-2ZQwDd.webp" loading="lazy"/>
  </picture>

添加一个 / 的匿名的访问规则。

然后就可以直接访问了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-CRuGbe.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-CRuGbe.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-CRuGbe.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-CRuGbe.webp" loading="lazy"/>
  </picture>

是不是感觉用起来和阿里云的 OSS 差不多？

我们再来试试 sdk 的方式：

```
复制代码npm install minio
```

安装 minio 包。

然后创建 index2.js

```javascript
javascript
复制代码var Minio = require('minio')

var minioClient = new Minio.Client({
  endPoint: 'localhost',
  port: 9000,
  useSSL: false,
  accessKey: '',
  secretKey: '',
})

function put() {
    minioClient.fPutObject('aaa', 'hello.png', './smile.png', function (err, etag) {
        if (err) return console.log(err)
        console.log('上传成功');
    });
}

put();
```

创建用到的 accessKey： <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-3B6DH7.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-3B6DH7.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-3B6DH7.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-3B6DH7.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HfiMPA.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HfiMPA.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HfiMPA.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-HfiMPA.webp" loading="lazy"/>
  </picture>

跑一下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pSBzBM.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pSBzBM.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pSBzBM.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-pSBzBM.webp" loading="lazy"/>
  </picture>

可以看到，文件上传成功了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-1VxlPV.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-1VxlPV.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-1VxlPV.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-1VxlPV.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-0WIe7P.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-0WIe7P.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-0WIe7P.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-0WIe7P.webp" loading="lazy"/>
  </picture>

同样，也可以下载文件：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-OQ1CgN.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-OQ1CgN.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-OQ1CgN.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-OQ1CgN.webp" loading="lazy"/>
  </picture>

```javascript
javascript
复制代码const fs = require('fs');

function get() {
    minioClient.getObject('aaa', 'hello.png', (err, stream) => {
        if (err) return console.log(err)
        stream.pipe(fs.createWriteStream('./xxx.png'));
    });
}

get();
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ClqZHm.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ClqZHm.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ClqZHm.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-26-ClqZHm.webp" loading="lazy"/>
  </picture>

用起来和阿里云 OSS 几乎一毛一样。

更多的 api 用法可以看 [minio 文档](https://link.juejin.cn/?target=https%3A%2F%2Fmin.io%2Fdocs%2Fminio%2Flinux%2Fdevelopers%2Fjavascript%2Fminio-javascript.html)。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-URNwIU.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-URNwIU.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-URNwIU.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-URNwIU.webp" loading="lazy"/>
  </picture>

最后，还记得我们跑 docker 容器的时候指定了挂载目录么：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-fJxb2h.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-fJxb2h.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-fJxb2h.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-fJxb2h.webp" loading="lazy"/>
  </picture>

这样，数据就会保存在本地的那个目录下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-TM3Tik.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-TM3Tik.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-TM3Tik.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-TM3Tik.webp" loading="lazy"/>
  </picture>

那为什么 OSS 服务都这么相似呢？

因为它们都是遵循 AWS 的 Simple Storage Service（S3）规范的，简称 S3 规范。

所以不管哪家的 OSS，用起来都是差不多的。



## 路由

### 路由解析

就是对web请求的预处理，有很多种策略可以选择。

#### 文件路径模式

1．静态文件

URL的路径与网站目录的路径一致。这种路由的处理方式十分简单，将请求路径对应的文件发送给客户端即可。比如vite里用的mock插件就是这种模式。



2.动态文件（看不懂）

在MVC模式流行起来之前，根据文件路径执行动态脚本也是基本的路由方式，它的处理原理是Web服务器根据URL路径找到对应的文件，如/index.asp或/index.php。Web服务器根据文件名后缀去寻找脚本的解析器，并传入HTTP请求的上下文。解析器执行脚本，并输出响应报文，达到完成服务的目的。现今大多数的服务器都能很智能地根据后缀同时服务动态和静态文件。这种方式在Node中不太常见，主要原因是文件的后缀都是．js，分不清是后端脚本，还是前端脚本，这可不是什么好的设计。而且Node中Web服务器与应用业务脚本是一体的，无须按这种方式实现。



#### MVC模式

MVC模型的主要思想是将业务逻辑按职责分离

❑ 控制器（Controller），一组行为的集合。

❑ 模型（Model），数据相关的操作和封装。

❑ 视图（View），视图的渲染。

这是目前最为经典的分层模式：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-19-07-image-20230820190742270.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-19-07-image-20230820190742270.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-19-07-image-20230820190742270.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-08-20-19-07-image-20230820190742270.png" loading="lazy"/>
  </picture>

如何根据URL做路由映射，这里有两个分支实现：

一种方式是通过手工关联映射，比如`use('/user',userController)`

一种是自然关联映射，就是约定式路由。比如以/user/setting/12/1987为例，它会按约定去找controllers目录下的user文件，将其require出来后，调用这个文件模块的setting()方法，而其余的值作为参数直接传递给这个方法。









## 部署

### docker

#### 介绍

后端系统会部署很多服务，包括我们自己开发的服务，还有 mysql、redis 等中间件的服务，部署它们需要一系列依赖的安装、环境变量的设置等等。如果你要部署多台机器的话，同样的操作要重复多次，万一哪一步漏掉了，服务就跑不起来了。

而 Docker 就能完美解决这个问题：

它把系统的所有文件封装成一个镜像，镜像跑起来作为容器，它可以在一台机器上跑多个容器，每个容器都有独立的操作系统环境，比如文件系统、网络端口等，在容器内跑各种服务。

整个环境都保存在这个镜像里，部署多个实例只要通过这个镜像跑多个容器就行。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-14-image-20240204201438761.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-14-image-20240204201438761.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-14-image-20240204201438761.png" alt="image-20240204201438761" style="zoom:33%;" loading="lazy"/>
  </picture>

##### 容器与宿主机的关系

容器和宿主机还是有关联的，比如可以把宿主机的端口映射到容器内的端口、宿主机某个目录挂载到容器内的目录。比如映射了 3000 端口，那容器内 3000 端口的服务，就可以在宿主机的 3000 端口访问了。

比如挂载了 /aaa 到容器的 /bbb/ccc，那容器内读写 /bbb/ccc 目录的时候，改的就是宿主机的 /aaa 目录，反过来，改宿主机 /aaa 目录，容器内的 /bbb/ccc 也会改，这俩同一个。这分别叫做端口映射、数据卷（volume）挂载。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-16-image-20240204201642431.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-16-image-20240204201642431.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-16-image-20240204201642431.png" alt="image-20240204201642431" style="zoom:33%;" loading="lazy"/>
  </picture>



##### Docker Hub 镜像仓库

Docker 提供了 Docker Hub 镜像仓库，可以把本地镜像 push 到仓库或者从仓库 pull 镜像到本地。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QRSZ6F.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QRSZ6F.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QRSZ6F.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QRSZ6F.webp" loading="lazy"/>
  </picture>



##### 镜像&容器

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-19-image-20240204201904223.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-19-image-20240204201904223.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-19-image-20240204201904223.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-19-image-20240204201904223.png" loading="lazy"/>
  </picture>

在项目里维护 Dockerfile ，然后执行 docker build 构建出镜像、push 到镜像仓库，部署的时候 pull 下来用 docker run 跑起来。



#### 使用

##### 安装

安装 Docker，直接从[官网](https://link.juejin.cn/?target=https%3A%2F%2Fdocker.com)下载 docker desktop 就行，它内置了 docker 命令。

把它安装到系统之后，可以在命令行看下 docker 命令是否可用。





如果不可用，那要设置下这个：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QZtGLk.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QZtGLk.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QZtGLk.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-QZtGLk.webp" loading="lazy"/>
  </picture>

点击 Settings > Advanced，里面有两种安装路径，如果是 /usr/local/bin，那 docker 命令就是直接可用的，因为这个路径在 PATH 变量里。

如果是第二种，那就需要手动把它加到 PATH 环境变量里。



##### docker desktop

###### 界面介绍

images 是本地的所有镜像，containers 是镜像跑起来的容器。



###### pull 一个镜像

搜索 nginx 镜像，点击 pull（搜索这步需要翻墙，不然搜不到）。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-8DyXFF.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-8DyXFF.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-8DyXFF.webp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>



pull 下来之后，就可以在本地 images 看到了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-QQ3EUo.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-QQ3EUo.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-QQ3EUo.webp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

点击 run 会让你填一些参数：本机访问的时候访问左边的`host port`然后就会映射到右边的那个端口号，右边那个端口号是容器里的端口号。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-tkyy9r.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-tkyy9r.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-tkyy9r.webp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

首先是名字，如果不填，docker desktop 会给你生成随机的容器名字。

就是这种：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-HmKXh6.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-HmKXh6.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-HmKXh6.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-HmKXh6.webp" loading="lazy"/>
  </picture>

然后是端口，容器内跑的 nginx 服务是在 80 端口，你要把宿主机的某个端口映射到容器的 80 端口才可以访问。

接下来是数据卷 volume，这个是把宿主机某个目录挂到容器内。因为容器是镜像跑起来的，下次再用这个镜像跑的还是同样的容器，那你在容器内保存的数据就会消失。所以我们都是把某个宿主机目录，挂载到容器内的某个保存数据的目录，这样数据是保存在宿主机的，下次再用镜像跑一个新容器，只要把这个目录挂载上去就行。

我们分别设置一下：

挂载本地的 /tmp/aaa 到容器内的 /usr/share/nginx/html 目录。

这里的 /tmp/aaa 可以换成宿主机的任何目录，如果是 windows 系统，那就是类似 D://tmp/aaa 这种。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-XVLhwy.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-XVLhwy.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-XVLhwy.webp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>





点击 run：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-MaIoIy.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-MaIoIy.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-MaIoIy.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-MaIoIy.webp" loading="lazy"/>
  </picture>

可以看到容器内的 nginx 服务跑起来了。

我们在 /tmp/aaa 目录下添加一个 index.html:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-17-51-image-20240204175148084.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-17-51-image-20240204175148084.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-17-51-image-20240204175148084.png" alt="image-20240204175148084" style="zoom:50%;" loading="lazy"/>
  </picture>

浏览器访问`http://localhost`

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iYkChm.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iYkChm.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iYkChm.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iYkChm.webp" loading="lazy"/>
  </picture>

这就说明数据卷挂载成功了。

点击 files 标签就可以看到容器内的文件。

可以看到 /usr/share/nginx/html 被标识为 mounted，就是挂载目录的意思：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KiiuYa.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KiiuYa.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KiiuYa.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KiiuYa.webp" loading="lazy"/>
  </picture>



如果你挂载某些目录报错，是因为 docker desktop 挂载的目录是需要配置的，在 Settings > Resources > File Sharing 里加一下就行：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-umDt88.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-umDt88.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-umDt88.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-umDt88.webp" loading="lazy"/>
  </picture>

至于挂载到的目录，在镜像搜索结果页有写：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gX1PoZ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gX1PoZ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gX1PoZ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gX1PoZ.webp" loading="lazy"/>
  </picture>

通过命令行 docker run 来跑镜像， -v 是指定挂载的数据卷，后面的 :ro 代表 readonly，也就是容器内这个目录只读，:rw 表示容器内可以读写这个目录。

这就是数据卷的作用。

此外，你还可以进入到容器内执行各种命令：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XXYY9a.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XXYY9a.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XXYY9a.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XXYY9a.webp" loading="lazy"/>
  </picture>



##### 敲命令

###### pull拉取镜像

当然，在服务器上没有 Docker Desktop 这种东西，还是要敲命令的。

比如我们点击 pull 按钮，就相当于执行了 docker pull：

```sh
docker pull nginx:latest
```

latest 是标签，也就是这个：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-mAMw9X.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-mAMw9X.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-mAMw9X.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-mAMw9X.webp" loading="lazy"/>
  </picture>



###### run

```bash
docker run --name nginx-test2 -p 80:80 -v /tmp/aaa:/usr/share/nginx/html -e KEY1=VALUE1 -d nginx:latest 
```

-p 是端口映射

-v 是指定数据卷挂载目录

-e 是指定环境变量

-d 是后台运行

对照下前面可视化界面，是不是瞬间就懂了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-CwUj2c.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-CwUj2c.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-CwUj2c.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-CwUj2c.webp" loading="lazy"/>
  </picture>

docker run 会返回一个容器的 hash：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-4TtWrP.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-4TtWrP.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-4TtWrP.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-4TtWrP.webp" loading="lazy"/>
  </picture>

就是这里的 id：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-G5lYxw.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-G5lYxw.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-G5lYxw.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-G5lYxw.webp" loading="lazy"/>
  </picture>



###### docker ps 显示容器列表

默认显示运行中的

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ob8PRs.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ob8PRs.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ob8PRs.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ob8PRs.webp" loading="lazy"/>
  </picture>

想显示全部的，可以加个 -a

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Jlf1Ci.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Jlf1Ci.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Jlf1Ci.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Jlf1Ci.webp" loading="lazy"/>
  </picture>



###### docker images显示镜像列表

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Bnu2ZH.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Bnu2ZH.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Bnu2ZH.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Bnu2ZH.webp" loading="lazy"/>
  </picture>



###### docker exec 

我们在容器的 terminal 里执行命令，对应的是 docker exec 命令：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Q2CLBp.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Q2CLBp.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Q2CLBp.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Q2CLBp.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bMr2ED.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bMr2ED.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bMr2ED.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bMr2ED.webp" loading="lazy"/>
  </picture>

-i 是 terminal 交互的方式运行

-t 是 tty 终端类型

然后指定容器 id 和 shell 类型，就可以交互的方式在容器内执行命令了。



docker logs查看日志

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-YVKaQ9.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-YVKaQ9.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-YVKaQ9.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-YVKaQ9.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XpM7DA.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XpM7DA.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XpM7DA.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-XpM7DA.webp" loading="lazy"/>
  </picture>

输入 exit 退出：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-UsG9ci.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-UsG9ci.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-UsG9ci.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-UsG9ci.webp" loading="lazy"/>
  </picture>

###### docker inspect 查看容器的详情

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-vQHhOz.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-vQHhOz.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-vQHhOz.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-vQHhOz.webp" loading="lazy"/>
  </picture>

对应 desktop 里的 inspect 的 tab：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FxHXP6.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FxHXP6.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FxHXP6.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FxHXP6.webp" loading="lazy"/>
  </picture>

###### docker volume 管理数据卷

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-kHBVtK.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-kHBVtK.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-kHBVtK.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-kHBVtK.webp" loading="lazy"/>
  </picture>

对应 desktop 的这部分：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-tbDF4r.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-tbDF4r.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-tbDF4r.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-tbDF4r.webp" loading="lazy"/>
  </picture>



###### cp 复制文件

docker cp 这个命令就是用于在宿主机和容器之间复制文件和目录的。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-i5h34c.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-i5h34c.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-i5h34c.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-i5h34c.webp" loading="lazy"/>
  </picture>

比如我们把这个目录再复制到容器里：

```bash
docker cp  ~/nginx-html nginx1:/usr/share/nginx/html-xxx
```

可以看到容器内就多了这个目录。如果目标目录已经存在，docker 会把他复制到目标目录下面。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bU3vdt.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bU3vdt.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bU3vdt.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-bU3vdt.webp" loading="lazy"/>
  </picture>







###### 其它常用命令

- docker start：启动一个已经停止的容器
- docker rm：删除一个容器
- docker stop：停止一个容器



##### docker compose控制多个容器的启动

###### 介绍

每次想把项目跑起来都要 docker run 一堆镜像也太麻烦了，有没有什么简便方式呢？这么多的容器怎么保证启动顺序呢？解决方式就是 Docker Compose。



###### 先整个dockerfile

假设我们 nest 服务开发完了，想部署，那就要写这样的 dockerfile：

```docker
FROM node:18.0-alpine3.14 as build-stage

WORKDIR /app

COPY package.json .

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18.0-alpine3.14 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```



在根目录添加这个 Dockerfile，然后 docker build 一下：

```erlang
docker build -t eee .
```

在 docker desktop 里可以看到这个镜像：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jYK6eG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jYK6eG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jYK6eG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jYK6eG.webp" loading="lazy"/>
  </picture>

那假设在服务器上，要怎么部署这个 nest 应用呢？



###### 如果没用桥接网络

在根目录添加一个 docker-compose.yml

```yaml
services:
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    ports:
      - '3000:3000'
  mysql-container:
    image: mysql
    ports:
      - '3306:3306'
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
  redis-container:
    image: redis
    ports:
      - '6379:6379'
    volumes:
      - /Users/guang/aaa:/data
```

每个 services 都是一个 docker 容器，名字随便指定。

这里指定了 nest-app、mysql-container、reids-container 3 个service：

然后 nest-app 配置了 depends_on 其他两个 service。

这样 docker-compose 就会先启动另外两个，再启动这个，这样就能解决顺序问题。

然后 mysql-container、redis-container 的 service 指定了 image 和 ports、volumes 的映射，这些都很容易看懂。

nest-app 指定了 context 下的 dockerfile 路径，端口映射。

version 是指定 docker-compose.yml 的版本，因为不同版本配置不同。

然后我们通过 docker-compose 把它跑起来：

```shell
docker-compose up
```

docker-compose 和 docker 命令是一起的，docker 能用，docker-compose 就能用。

它会把所有容器的日志合并输出：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-SRv1G2.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-SRv1G2.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-SRv1G2.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-SRv1G2.webp" loading="lazy"/>
  </picture>

可以看到是先跑的 mysql、redis，再跑的 nest。

只不过 mysql 服务启动有点慢，会连接失败几次。最后是会成功的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-WxshPB.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-WxshPB.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-WxshPB.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-WxshPB.webp" loading="lazy"/>
  </picture>





我们只需要定义 docker-compose.yaml 来声明容器的顺序和启动方式，之后执行 docker-compose up 一条命令就能按照顺序启动所有的容器。

这时候如果你去 docker desktop 里看下，会发现它有专门的显示方式：多个容器可以一起管理。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-34-5ed7de84c738426caf96b938b8a8018e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-34-5ed7de84c738426caf96b938b8a8018e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-34-5ed7de84c738426caf96b938b8a8018e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-34-5ed7de84c738426caf96b938b8a8018e~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" loading="lazy"/>
  </picture>



###### 如果用了桥接网络

把docker-compose.yml改成这样：

```yml
version: '3.8'
services:
  nest-app:
    build:
      context: ./
      dockerfile: ./Dockerfile
    depends_on:
      - mysql-container
      - redis-container
    ports:
      - '3000:3000'
    networks:
      - common-network
  mysql-container:
    image: mysql
    volumes:
      - /Users/guang/mysql-data:/var/lib/mysql
    networks:
      - common-network
  redis-container:
    image: redis
    volumes:
      - /Users/guang/aaa:/data
    networks:
      - common-network
networks:
  common-network:
    driver: bridge
```

把 mysql-container、redis-container 的 ports 映射去掉，指定桥接网络为 common-network。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-47-c3e7e3da3d4448759bbf5a3e2978bc37~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-47-c3e7e3da3d4448759bbf5a3e2978bc37~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-47-c3e7e3da3d4448759bbf5a3e2978bc37~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-47-c3e7e3da3d4448759bbf5a3e2978bc37~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" loading="lazy"/>
  </picture>

然后下面通过 networks 指定创建的 common-network 桥接网络，网络驱动程序指定为 bridge。

其实我们一直用的网络驱动程序都是 bridge，它的含义是容器的网络和宿主机网络是隔离开的，但是可以做端口映射。比如 -p 3000:3000、-p 3306:3306 这样。



##### 自动重启

###### 介绍

docker run 的时候也可以指定重启策略：

```sh
docker run -d --restart=always --name=restart-test-container2 restart-test:first
```

有 4 种重启策略：

- no: 容器退出不自动重启（默认值）
- always：容器退出总是自动重启，除非 docker stop。
- on-failure：容器非正常退出才自动重启，还可以指定重启次数，如 on-failure:5
- unless-stopped：容器退出总是自动重启，除非 docker stop



###### Docker Compose中使用

Docker Compose 是用于同时跑多个 Docker 容器的，它自然也支持 restart 的配置：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iX3vz9.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iX3vz9.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iX3vz9.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iX3vz9.webp" loading="lazy"/>
  </picture>



###### 还需要用pm2吗

Docker 的自动重启功能和 PM2 的自动重启功能是重合的。那还有必要用 PM2 么？

其实 PM2 诞生的时候是没有 Docker 这种容器技术的，那时候都是直接部署在机器上，这时候自然需要一个进程管理工具来做进程的重启、负载均衡等功能。

但后来有了 Docker，里面跑的进程崩溃之后，Docker 容器支持自动重启。

<mark>大多数情况下，没必要再用 PM2 了。如果你用了 K8S 这种容器编排工具，那更没必要用 PM2 了，直接让 K8S 去调度、重启容器就可以。但也有另一种说法，Docker 重新跑容器的成本，是比容器内 PM2 重新跑进程的成本高的，所以用 PM2 来管理进程更好一点。</mark>





#### 制作一个镜像(写dockerfile)

##### 介绍

dockerfile 是在守护进程 docker daemon 里进行build的。

docker build 时，会先解析 .dockerignore，把该忽略的文件忽略掉，然后把剩余文件打包发送给 docker daemon 作为上下文来构建产生镜像。

可以通过 .dockerignore 指定哪些文件不发送，这样能加快构建时间，减小镜像体积。





##### 语法

###### 基础

在 dockerfile 里声明要做哪些事情，docker build 的时候就会根据这个 dockerfile 来自动化构建出一个镜像来。

比如这样：

```dockerfile
FROM node:latest
WORKDIR /worker
COPY . . # 通过 COPY 把 Dockerfile 同级目录下的内容复制到容器内
RUN npm config set registry https://registry.npmmirror.com/
RUN npm install -g http-server
EXPOSE 8080
VOLUME /app
CMD ["http-server", "-p", "8080"]
```

这些指令的含义如下：

- FROM：基于一个基础镜像来修改

- WORKDIR：指定容器内的工作目录

- COPY：把容器外的内容复制到容器内

- EXPOSE：声明当前容器要访问的网络端口，比如这里起服务会用到 8080

- RUN：在容器内执行命令

- CMD：容器启动的时候执行的命令

- VOLUME：容器内用于挂载券的目录。在 dockerfile 里指定 VOLUME 之后，如果你 docker run 的时候没有带 -v，那会放在一个临时的目录里。

  <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-6SnkHE.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-6SnkHE.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-6SnkHE.webp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

  inspect 可以看到这时候的路径是一个临时的目录：

  <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-JZi9JS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-JZi9JS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-JZi9JS.webp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>

  



通过 docker build 就可以根据这个 dockerfile 来生成镜像。

```sh
docker build -t aaa:ddd -f Dockerfile . # aaa 是镜像名，ccc 是镜像的标签。-t指定名字和标签，-f指定dockerfile的文件名
```

然后在 desktop 的 images 列表里就可以看到这个镜像了。





###### ARG&ENV

如果是想定义运行时可以访问的变量，可以通过 ENV 定义环境变量，值使用 ARG 传入。

```docker
FROM node:18-alpine3.14

ARG aaa
ARG bbb

WORKDIR /app

COPY ./test.js .

ENV aaa=${aaa} \
    bbb=${bbb}

CMD ["node", "/app/test.js"]
```

使用 ARG 声明构建参数，使用 ${xxx} 来取。ENV 声明环境变量。dockerfile 内换行使用 `\`。

之后构建的时候传入构建参数：

```sh
docker build --build-arg aaa=3 --build-arg bbb=4 -t arg-test -f 333.Dockerfile .
```

通过` --build-arg xxx=yyy` 传入 ARG 参数的值。



###### ENTRYPOINT

前面我们指定容器跑起来之后运行什么命令，用的是 CMD：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-39-79d7f94069c34283a00cfd510cb4d1bc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-39-79d7f94069c34283a00cfd510cb4d1bc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-39-79d7f94069c34283a00cfd510cb4d1bc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>

其实还可以写成 ENTRYPOINT：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-39-9e75546b3a464c80ae27b869291cd896~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-39-9e75546b3a464c80ae27b869291cd896~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-39-9e75546b3a464c80ae27b869291cd896~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>

用 CMD 的时候，启动命令是可以重写的，而用 ENTRYPOINT 就不会

一般还是 CMD 用的多点，可以灵活修改启动命令。

比如：

```docker
FROM node:18-alpine3.14

ENTRYPOINT ["echo", "光光"]

CMD ["到此一游"]
```

docker build：

```erlang
docker build -t cmd-test -f 444.Dockerfile .
```



docker run:

```arduino
docker run cmd-test
docker run cmd-test 66666
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-rYF3cj.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-rYF3cj.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-rYF3cj.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-rYF3cj.webp" loading="lazy"/>
  </picture>

当没传参数的时候，执行的是 ENTRYPOINT + CMD 组合的命令，而传入参数的时候，只有 CMD 会被覆盖。



###### COPY vs ADD

这俩都可以把宿主机的文件复制到容器内。

但有一点区别，就是对于 tar.gz 这种压缩文件的处理上：ADD 把 tar.gz 给解压然后复制到容器内，而 COPY 不会解压，它把文件整个复制过去了。

一般情况下，还是用 COPY 居多。





##### 分层存储

docker 是分层存储的，dockerfile 里的每一行指令是一层，会做缓存。

每次 docker build 的时候，只会从变化的层开始重新构建，没变的层会直接复用。

也就说现在这种写法，如果 package.json 没变，那么就不会执行 npm install，直接复用之前的。

那如果一开始就把所有文件复制进去呢？

那不管 package.json 变没变，任何一个文件变了，都会重新 npm install，这样没法充分利用缓存，性能不好。

我们试试看就知道了：

现在重新跑 docker build，不管跑多少次，速度都很快，因为文件没变，直接用了镜像缓存：

```sql
docker build -t dockerfile-test:second .
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-yrta1H.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-yrta1H.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-yrta1H.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-yrta1H.webp" loading="lazy"/>
  </picture>

现在我们改下 README.md：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ej7igd.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ej7igd.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ej7igd.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-ej7igd.webp" loading="lazy"/>
  </picture>

然后重新跑 build：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Ieq48H.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Ieq48H.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Ieq48H.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Ieq48H.webp" loading="lazy"/>
  </picture>

现在花了 25s，其实是没有重新 npm install 的。

然后改下 package.json：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-sda56t.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-sda56t.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-sda56t.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-sda56t.webp" loading="lazy"/>
  </picture>

再跑 docker build

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-p8svf5.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-p8svf5.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-p8svf5.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-p8svf5.webp" loading="lazy"/>
  </picture>

时间明显多了很多，过程中你可以看到在 npm install 那层停留了很长时间。



##### 减小构建的镜像文件体积

###### 多阶段构建

可用于减小镜像体积。比如一个阶段来执行 build，一个阶段把文件复制过去，跑起服务来，最后只保留最后一个阶段的镜像。这样使镜像内只保留运行需要的文件以及 dependencies。

```bash
# build stage
FROM node:18 as build-stage

WORKDIR /app

COPY package.json .

RUN npm config set registry https://registry.npmmirror.com/

RUN npm install

COPY . .

RUN npm run build

# production stage
FROM node:18 as production-stage

COPY --from=build-stage /app/dist /app
COPY --from=build-stage /app/package.json /app/package.json

WORKDIR /app

RUN npm install --production

EXPOSE 3000

CMD ["node", "/app/main.js"]
```

通过 FROM 继承镜像的时候，给当前镜像指定一个名字，比如 build-stage。然后第一个镜像执行 build。

之后再通过 FROM 继承 node 镜像创建一个新镜像。

通过 COPY --from-build-stage 从那个镜像内复制 /app/dist 的文件到当前镜像的 /app 下。

还要把 package.json 也复制过来，然后切到 /app 目录执行 npm install --production 只安装 dependencies 依赖。



###### 用alpine版本 的 linux

- 使用 alpine 的镜像，而不是默认的 linux 镜像，可以极大减小镜像体积，比如 node:18-alpine3.14 这种

```sh
FROM node:18.0-alpine3.14
```





##### 如果报错

如果你 build 的时候报这个错误：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KMRgrD.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KMRgrD.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KMRgrD.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-KMRgrD.webp" loading="lazy"/>
  </picture>

那需要加一行：

```bash
RUN ln -s /sbin/runc /usr/bin/runc
```

原因如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-oJ3Bjj.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-oJ3Bjj.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-03-04-11-22-oJ3Bjj.webp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>



#### 多个 docker 容器的通信

##### 方法一：指定宿主机 ip 和端口

涉及到多个 docker 容器的通信，我们是通过指定宿主机 ip 和端口的方式。

因为 mysql、redis 的 Docker 容器都映射到了宿主机的端口，那 nest 的容器就可以通过宿主机来实现和其他容器的通信。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-35-0ec74df386ed40b288a6dfad49189207~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-35-0ec74df386ed40b288a6dfad49189207~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-35-0ec74df386ed40b288a6dfad49189207~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>



##### 方法二：桥接网络(推荐)

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-42-image-20240205214237727.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-42-image-20240205214237727.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-42-image-20240205214237727.png" alt="image-20240205214237727" style="zoom:75%;" loading="lazy"/>
  </picture>

Docker 的实现原理那节我们讲过，Docker 通过 Namespace 的机制实现了容器的隔离，其中就包括 Network Namespace。

因为每个容器都有独立的 Network Namespace，所以不能直接通过端口访问其他容器的服务。

那如果这个 Network Namespace 不只包括一个 Docker 容器呢？？

可以创建一个 Network Namespace，然后设置到多个 Docker 容器，这样这些容器就在一个 Namespace 下了，不就可以直接访问对应端口了？

Docker 确实支持这种方式，叫做桥接网络。通过 docker network 来创建：

```lua
docker network create common-network
```



这次跑的时候要指定 --network：

```bash
docker run -d --network common-network -v /Users/guang/mysql-data:/var/lib/mysql --name mysql-container mysql
```

通过 --network 指定桥接网络为我们刚创建的 common-network。不需要指定和宿主机的端口映射。



然后跑 redis 容器：

```bash
docker run -d --network common-network -v /Users/guang/aaa:/data --name redis-container redis
```



然后 nest 的部分我们要改下代码：

修改 AppModule 的代码，改成用容器名来访问：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-41-bfd1c28f8d8f467398fdaae85387dab0~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-41-bfd1c28f8d8f467398fdaae85387dab0~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-21-41-bfd1c28f8d8f467398fdaae85387dab0~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

然后 docker build：

```erlang
docker build -t mmm .
```

之后 docker run：

```sh
docker run -d --network common-network -p 3000:3000 --name nest-container mmm
```

nest 容器是要指定和宿主机的端口映射的，因为宿主机要访问这个端口的网页。







#### 原理

##### 简述

如果网页上有两份 aaa、bbb 变量，我们怎么保证它们不冲突呢？

namespace 呀：变成 xxx.aaa、xxx.bbb 和 yyy.aaa、yyy.bbb 就不冲突了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-53-69b105d627b446a6a56c19770fb862ee~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-53-69b105d627b446a6a56c19770fb862ee~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-53-69b105d627b446a6a56c19770fb862ee~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>



Docker 在一个操作系统上实现多个独立的容器也是这种思路。

Docker 实现原理的三大基础技术：

- Namespace：实现各种资源的隔离
- Control Group：实现容器进程的资源访问限制
- UnionFS：实现容器文件系统的分层存储，镜像合并

都是缺一不可的。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-05-8aecb63016ab45c0bc2603071b65a420~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-05-8aecb63016ab45c0bc2603071b65a420~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-05-8aecb63016ab45c0bc2603071b65a420~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>



#####  namespace 做资源隔离

linux 操作系统提供了 namespace 机制，可以给进程、用户、网络等分配一个命名空间，这个命名空间下的资源都是独立命名的。

比如 PID namespace，也就是进程的命名空间，所有进程都是在命名空间内独立分配 id 的。

而 IPC namespace 能限制只有这个 namespace 内的进程可以相互通信，不能和 namespace 外的进程通信。

Mount namespace 会创建一个新的文件系统，namespace 内的文件访问都是在这个文件系统之上。

类似这样的 namespace 一共有 6 种：

- PID namespace： 进程 id 的命名空间
- IPC namespace： 进程通信的命名空间
- Mount namespace：文件系统挂载的命名空间
- Network namespace：网络的命名空间
- User namespace：用户和用户组的命名空间
- UTS namespace：主机名和域名的命名空间

通过这 6 种命名空间，Docker 就实现了独立的容器，在容器内运行的代码就像在一个独立的系统里跑一样。



##### Control Group 做资源限制

但是只有命名空间的隔离还不够，还得对资源做限制。比如一个容器占用了太多的资源，那就会导致别的容器受影响。

怎么能限制容器的资源访问呢？这就需要 linux 操作系统的另一种机制：Control Group。

创建一个 Control Group 可以给它指定参数，比如 cpu 用多少、内存用多少、磁盘用多少，然后加到这个组里的进程就会受到这个限制。

这样，创建容器的时候先创建一个 Control Group，指定资源的限制，然后把容器进程加到这个 Control Group 里，就不会有容器占用过多资源的问题了。



##### UnionFS分层存储

还有一个问题：每个容器都是独立的文件系统，相互独立，而这些文件系统之间可能很大部分都是一样的，同样的内容占据了很大的磁盘空间，会导致浪费。

所以 Docker 设计了一种分层机制：每一层都是不可修改的，也叫做镜像。通过 dockerfile 描述镜像构建的过程，每一条指令都是一个镜像层。

要修改就创建个新的层，然后通过一种叫做 UnionFS 的机制把这些层合并起来，变成一个文件系统：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-58-174a57adf33b4b99ab7a1ade26822ebc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-58-174a57adf33b4b99ab7a1ade26822ebc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-58-174a57adf33b4b99ab7a1ade26822ebc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:33%;" loading="lazy"/>
  </picture>

这样如果有多个容器内做了文件修改，只要创建不同的层即可，底层的基础镜像是一样的。

我们写的这个 Dockerfile，每一行指令都会生成一层镜像：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-59-a5d2b2a32ded4c8da31faec710b73613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-59-a5d2b2a32ded4c8da31faec710b73613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-59-a5d2b2a32ded4c8da31faec710b73613~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

点开 docker 镜像的详情可以看到：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-59-6a84a9935d4d4cfb958eb87809754b9b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-59-6a84a9935d4d4cfb958eb87809754b9b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-20-59-6a84a9935d4d4cfb958eb87809754b9b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

就上面这个 dockerfile，它对应的镜像就有 20 层。很多都是一层层通过 FROM 继承下来的。

Docker 通过这种分层的镜像存储，极大的减少了文件系统的磁盘占用。



比如 nest 的镜像有 1g 多，我本地两个 nest 镜像，它们都继承了 node 镜像，这两个合起来有 2g 的存储空间么？

没有，因为下面的镜像层是公用的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-01-61a61cc0cd084fd59c50902b27146fcc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-01-61a61cc0cd084fd59c50902b27146fcc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-01-61a61cc0cd084fd59c50902b27146fcc~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>





镜像是不可修改的，镜像通过 docker run 就可以跑起来，对外提供服务，这时会添加一个可写层（容器层），或者叫容器层，

而且再跑一个容器会创建一个新的可写层，另一个容器的可写层的数据就丢了。所以 Docker 设计了挂载机制，可以挂载数据卷到这个可写层上去。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-02-7b13c4403e844665b183c00ad4a9bd6c~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-02-7b13c4403e844665b183c00ad4a9bd6c~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-04-21-02-7b13c4403e844665b183c00ad4a9bd6c~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

这个数据卷是可以持久化的，再跑个新容器，依然可以把这个 volume 挂上去。



### pm2

如果你的 node 应用跑的时候突然抛了个错，崩溃了，是不是需要重新跑起来？这时候就需要另一个进程来自动做重启

node 应用的日志默认输出在控制台，如果想输出到不同的日志文件，是不是可以让另一个进程获取 node 应用的输出，然后写文件来实现？

node 是单线程的，而机器是多个 cpu 的，为了充分利用 cpu 的能力，我们会用多个进程来跑 node 应用，这种通用逻辑是不是也可以放到一个单独进程里来实现？

node 运行时的 cpu、内存等资源的占用，是不是需要监控？这时候是不是可以让另一个进程来做？

线上的 node 应用不只是跑起来就行了，还要做自动重启、日志、多进程、监控这些事情。

pm2 是 process manager，进程管理，它是第二个大版本，所以叫 pm2.

pm2 的主要功能就是**进程管理、日志管理、负载均衡、性能监控**。

一般都是 [docker 镜像](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FUnitech%2Fpm2%2Fblob%2Fmaster%2Fexamples%2Fdocker-pm2%2FDockerfile)内安装 pm2 来跑 node：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-11-44-b9ca3bdaf97a4532a29bf06490befd4d~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-11-44-b9ca3bdaf97a4532a29bf06490befd4d~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-11-44-b9ca3bdaf97a4532a29bf06490befd4d~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom: 50%;" loading="lazy"/>
  </picture>

具体使用可见：https://juejin.cn/book/7226988578700525605/section/7236156810393043005





### 静态部署&容器部署

1. **定义**:
   - 静态部署：部署到服务器或静态文件服务器。
   - 容器部署：容器是一种虚拟化技术，它可以在任何支持容器引擎的系统上运行，提供了一个隔离的运行环境。每个容器都包含了应用程序和其所需的运行时环境，使应用程序在不同的环境中具有相同的行为。
2. **灵活性**:
   - 静态部署：静态部署在部署时非常快速，因为只需要将编译后的静态文件上传到服务器。然而，每次更新应用程序时，都需要重新构建和部署整个应用程序，这可能会比较耗时。
   - 容器部署：容器部署具有更好的灵活性。一旦将应用程序打包到容器中，可以轻松地在不同的环境中部署和运行容器，而不必重新构建应用程序。容器还提供了更好的可移植性，因为可以将容器在开发、测试和生产环境之间无缝迁移。
3. **依赖性管理**:
   - 静态部署：静态部署需要确保在服务器上安装了所有应用程序所需的依赖项和运行时环境。这可能导致一些依赖冲突或版本问题，需要手动处理。
   - 容器部署：容器将应用程序及其依赖项隔离在一个独立的运行时环境中，避免了依赖冲突问题。容器中的所有依赖项都由容器镜像自带，不会受到宿主系统的影响。
4. **部署复杂性**:
   - 静态部署：静态部署相对较简单，只需要将静态文件上传到服务器即可。但是，每次更新都需要手动重新部署整个应用程序。
   - 容器部署：容器部署需要更多的配置和管理，但它提供了更好的自动化和持续集成/持续部署（CI/CD）支持。容器可以通过自动化工具（如Docker Compose和Kubernetes）进行自动化管理和部署。

选择静态部署还是容器部署取决于您的具体需求和项目要求。静态部署适用于简单的静态网站和轻量级应用程序，而容器部署更适用于复杂的应用程序和需要更好可移植性、扩展性和自动化管理的项目。







### 部署前端应用

#### 覆盖式发布

##### 存在的问题

1. 比如将修改后的两个文件上传到服务器，覆盖旧的文件。在上传的过程中，两个文件不可能同时被覆盖，必定存在着先后顺序，包括两种情况。index.html先被覆盖，style.css后被覆盖。在两个资源覆盖期间，如果有用户访问了页面，那么他访问的将是新的index.html和旧的style.css，结果就是页面上的bar没有样式修饰。style.css先被覆盖，index.html后被覆盖，在两个资源覆盖期间，如果有用户访问了页面，那么他访问的将是新的style.css和旧的index.html，结果就是页面上的foo没有样式修饰。

   以上仅列举了在文件数量和类型比较简单的情况下，使用覆盖式发布可能导致的问题。随着页面依赖的文件数量增加，不仅部署的时间会更长，部署时文件覆盖的先后顺序也更加多变。如果在页面依赖的某个.js文件里，某部分代码依赖了DOM结构，那么.html文件中的变更可能导致页面某个功能不可用，这是比样式错乱更为严重的问题。

   

2. 当部署的代码出现问题时，服务器上的资源不能直接回滚到上一次的状态。开发人员必须在本地将代码回退到之前的状态，然后重新进行构建打包，重新上传资源才能实现回滚。整个回滚期间会耗费大量的时间和精力，并且在回滚完成之前，生产环境的故障依然存在。

 



##### 解决方案：文件加hash值

先将style_v2.css文件上传到服务器，然后将index.html文件上传到服务器，更新入口页面。当style_v2.css文件被上传到服务器时，旧的index.html文件依赖的依然是style_v1.css文件，并不依赖style_v2.css文件；当新的index.html文件被上传到服务器时，style_v2.css文件已经被上传到服务器，不会出现资源无法访问的情况。因此，非覆盖式发布不会出现新旧文件交替依赖的情况，由此可以有效避免资源上传间隔导致的样式错乱问题。

 



index.html还是覆盖的

它的缺点是会在服务器上积累大量的无用资源，该问题只需要定时清理即可解决。当index.html作为入口页时，不能添加哈希值作为文件后缀，回滚机制并不完善

 

 

#### 静态资源部署

浏览器在进行资源加载时，会默认在请求报头中携带cookie，它会增大建立连接的请求体积，增加额外的带宽开销。同时，浏览器限制单个子域名的并发请求数量，这也会影响页面的加载速度。

 

<picture>
    <source type="image/avif" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/avif">
    <source type="image/webp" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/webp">
    <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" loading="lazy"/>
  </picture>

在浏览器向服务器请求加载静态资源时，需要与服务器建立连接。在资源下载期间不仅会占用浏览器的带宽，也会占用服务器的带宽。每个服务器可建立的链接数和带宽都是有限的。当下载资源的并发连接数超出负载后，不仅服务器有限的带宽会被瓜分，新增的接口和资源连接也没办法及时响应。

 

<picture>
    <source type="image/avif" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/avif">
    <source type="image/webp" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/webp">
    <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" loading="lazy"/>
  </picture>

为了解决上述问题，开发人员采用了动静分离的方案对网站进行优化。动静分离指将网站的静态资源托管到其他服务器上，与网站应用的服务器隔离开，提高用户访问静态代码的速度，降低源服务器的压力。用于托管静态资源的服务器叫内容分发网络（Content Delivery Network，CDN），它可以加快用户访问网络资源的速度和稳定性，减轻源服务器的访问压力。CDN的原理是在网络各处放置节点，在互联网的基础上构建一层智能虚拟网络，从而实时地根据网络流量、各节点的连接和负载状况以及响应时间等信息，将用户的请求重新导向离用户最近的服务节点，提高网站的访问速度。

 

<picture>
    <source type="image/avif" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/avif">
    <source type="image/webp" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/webp">
    <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" loading="lazy"/>
  </picture>

静态资源被托管到CDN上，资源的更新和缓存策略就由CDN服务商制定，从而引发了资源更新问题。不同的CDN服务商会有不同的资源管理策略

 

<picture>
    <source type="image/avif" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/avif">
    <source type="image/webp" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/webp">
    <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" loading="lazy"/>
  </picture>

协商缓存虽然也使用本地缓存，但在校验资源是否过期时依然会与服务建立连接。协商缓存虽然节约了资源下载时的带宽，但依然需要占用服务器资源进行资源的过期校验。部分CDN服务商为了降低服务器的开销，节约运营成本，会选择使用强缓存来代替协商缓存。同时，CDN边缘节点的资源更新在很大程度上依赖源站的资源下发。以上两点都会导致资源更新出现延迟。假设有一个名为style.css的资源，CDN服务商通过强缓存的方式将其缓存到了浏览器端，过期时间设置为1天。那么在1天之内，style.css无法进行更新。即使CDN服务商没有使用强缓存，或者用户手动清空了浏览器缓存重新加载，CDN的资源下发也会存在延迟。在最新的style.css由源站下发到边缘节点之前，用户访问CDN边缘节点时获取的依然是旧版的style.css。

 

<picture>
    <source type="image/avif" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/avif">
    <source type="image/webp" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/webp">
    <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" loading="lazy"/>
  </picture>

资源更新的延迟使得有时用户访问的页面并不是预期的页面，可能给用户造成困扰，可以借助前文提到的文件哈希值来解决这个问题

 

<picture>
    <source type="image/avif" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/avif">
    <source type="image/webp" srcset="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K?imageMogr2/format/webp">
    <img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" alt="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K" loading="lazy"/>
  </picture>

浏览器在从CDN边缘节点尝试加载style_2e87e.css时，会发生两种情况。一种是CDN边缘节点已经收到了源站下发的style_2e87e.css资源，此时直接返回该资源，浏览器就能获取最新的资源。另一种是CDN边缘节点尚未收到源站下发的style_2e87e.css资源，此时会触发CDN的回源机制，同样可以返回最新的资源。CDN的回源指CDN服务器在收到一个资源请求时，发现自己没有缓存该资源，从而从它的上层服务器或者根服务器加载该资源的过程。回源有效解决了在源站的资源下发间隔内，边缘节点资源缺失的问题，进一步提升了CDN的稳定性。通过为文件添加哈希后缀、利用浏览器资源的缓存机制和CDN的回源策略，开发人员可以有效解决资源更新延迟的问题。

 



## 权限管理

### ACL

记录每个用户有什么权限，这叫访问控制表（Access Control List）。直接给用户分配权限。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-20-52-image-20240205205220928.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-20-52-image-20240205205220928.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-20-52-image-20240205205220928.png" alt="image-20240205205220928" style="zoom:33%;" loading="lazy"/>
  </picture>









### rbac

[RBAC 以角色为基础的访问控制（英语：Role-based access control，RBAC）](https://link.juejin.cn/?target=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%9F%BA%E4%BA%8E%E8%A7%92%E8%89%B2%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%2F8795406%3Ffromtitle%3DRBAC%26fromid%3D1328788)，给角色分配权限，然后给用户分配角色。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-L8MYCe.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-L8MYCe.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-L8MYCe.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-L8MYCe.webp" loading="lazy"/>
  </picture>



##  微服务

### 介绍

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-02-image-20240206210215745.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-02-image-20240206210215745.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-02-image-20240206210215745.png" alt="image-20240206210215745" style="zoom:75%;" loading="lazy"/>
  </picture>



微服务和微服务之间一般不是用 http 来通信的。因为 http 的请求响应会携带大量的 header。直接用 tcp 就好了。

想抓 tcp 层的包需要用到 wireshark。在 [wireshark 官网](https://link.juejin.cn/?target=https%3A%2F%2Fwww.wireshark.org%2F)下载安装包。



### 配置中心和注册中心

#### 介绍

微服务架构的系统都会有配置中心和注册中心。

系统中会有很多微服务，它们会有一些配置信息，比如环境变量、数据库连接信息等。这些配置信息散落在各个服务中，以配置文件的形式存在。这样你修改同样的配置需要去各个服务下改下配置文件，然后重启服务就很麻烦。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-21-aa6b5b10705a4be0a7f108b79847ac25~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-21-aa6b5b10705a4be0a7f108b79847ac25~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-21-aa6b5b10705a4be0a7f108b79847ac25~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

如果有一个服务专门用来集中管理配置信息呢？

这样每个微服务都从这里拿配置，可以统一的修改，并且配置更改后也会通知各个微服务。

这个集中管理配置信息的服务就叫配置中心。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-24-6f6b92aa3e2648e3ba90bc7af6d7c9a5~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-24-6f6b92aa3e2648e3ba90bc7af6d7c9a5~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-24-6f6b92aa3e2648e3ba90bc7af6d7c9a5~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

再就是注册中心：

如果某个微服务挂掉了，那所有依赖它的服务就都不能工作了。为了避免这种情况，我们会通过集群部署的方式，每种微服务部署若干个节点，并且还可能动态增加一些节点。

那么问题来了：

微服务 A 依赖了微服务 B，写代码的时候 B 只有 3 个节点，但跑起来以后，某个节点挂掉了，并且还新增了几个微服务 B 的节点。

这时候微服务 A 怎么知道微服务 B 有哪些节点可用呢？

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-25-77fcd834120742ef941b28ca0e13f995~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-25-77fcd834120742ef941b28ca0e13f995~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-25-77fcd834120742ef941b28ca0e13f995~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

所以也需要一个单独的服务来管理，这个服务就是注册中心：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-26-3c180f988cb840288424905da566215b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-26-3c180f988cb840288424905da566215b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-21-26-3c180f988cb840288424905da566215b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

微服务在启动的时候，向注册中心注册，销毁的时候向注册中心注销，并且定时发心跳包来汇报自己的状态。

在查找其他微服务的时候，去注册中心查一下这个服务的所有节点信息，然后再选一个来用，这个叫做服务发现。



#### 实现

但是，虽然这是两种服务，功能确实很类似，完全可以在一个服务里实现。

可以做配置中心、注册中心的中间件还是挺多的，比如 nacos、apollo、etcd 等。

今天我们来学下 etcd 实现注册中心和配置中心。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-qwMXpP.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-qwMXpP.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-qwMXpP.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-qwMXpP.webp" loading="lazy"/>
  </picture>

它其实是一个 key-value 的存储服务。

k8s 就是用它来做的注册中心、配置中心：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-6Y4ZEf.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-6Y4ZEf.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-6Y4ZEf.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-6Y4ZEf.webp" loading="lazy"/>
  </picture>

我们通过 docker 把它跑起来。

在 docker desktop 搜索 etcd 的镜像，点击 run:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-NTMuyG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-NTMuyG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-NTMuyG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-NTMuyG.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-8Y844p.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-8Y844p.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-8Y844p.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-8Y844p.webp" loading="lazy"/>
  </picture>

输入容器名，映射 2379 端口到容器内的 2379 端口，设置 ETCD_ROOT_PASSWORD 环境变量，也就是指定 root 的密码。

然后就可以看到 etcd server 的 docker 镜像成功跑起来了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Zh2rA8.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Zh2rA8.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Zh2rA8.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Zh2rA8.webp" loading="lazy"/>
  </picture>

它带了一个 etcdctl 的命令行工具，可以作为客户端和 etcd server 交互。

常用的命令有这么几个：

```vbnet
vbnet
复制代码etcdctl put key value
etcdctl get key
etcdctl del key
etcdctl watch key
```

就是对 key value 的增删改查和 watch 变动，还是比较容易理解的。

但是现在执行命令要加上 --user、--password 的参数才可以：

```css
css
复制代码etcdctl get --user=root --password=guang key
```

如果不想每次都指定用户名密码，可以设置环境变量：

```ini
ini
复制代码export ETCDCTL_USER=root
export ETCDCTL_PASSWORD=guang
```

这里的 password 就是启动容器的时候指定的那个环境变量：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gOwuwr.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gOwuwr.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gOwuwr.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-gOwuwr.webp" loading="lazy"/>
  </picture>

我们设置几个 key：

```arduino
arduino
复制代码etcdctl put /services/a xxxx
etcdctl put /services/b yyyy
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Eg8F1e.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Eg8F1e.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Eg8F1e.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Eg8F1e.webp" loading="lazy"/>
  </picture>

之后可以 get 来查询他们的值：

```arduino
arduino
复制代码etcdctl get /services/a
etcdctl get /services/b
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Pk2Rb8.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Pk2Rb8.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Pk2Rb8.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-Pk2Rb8.webp" loading="lazy"/>
  </picture>

也可以通过 --prefix 查询指定前缀的 key 的值：

```sql
sql
复制代码etcdctl get --prefix /services 
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-U7oWNQ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-U7oWNQ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-U7oWNQ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-U7oWNQ.webp" loading="lazy"/>
  </picture>

删除也是可以单个删和指定前缀批量删：

```css
css
复制代码etcdctl del /servcies/a
etcdctl del --prefix /services
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iGa0JI.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iGa0JI.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iGa0JI.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-iGa0JI.webp" loading="lazy"/>
  </picture>

这样的 key-value 用来存储 服务名-链接信息，那就是注册中心，用来存储配置信息，那就是配置中心。

我们在 node 里面连接下 etcd 服务试试看：

创建个项目：

```bash
bash
复制代码mkdir etcd-test
cd etcd-test
npm init -y
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-5AXjmx.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-5AXjmx.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-5AXjmx.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-5AXjmx.webp" loading="lazy"/>
  </picture>

安装 etcd 的包：

```css
css
复制代码npm install --save etcd3
```

创建 index.js

使用 etcd 官方提供的 npm 包 etcd3:

```javascript
javascript
复制代码const { Etcd3 } = require('etcd3');
const client = new Etcd3({
    hosts: 'http://localhost:2379',
    auth: {
        username: 'root',
        password: 'guang'
    }
});
 
(async () => { 
  const services = await client.get('/services/a').string();
  console.log('service A:', services);

  const allServices = await client.getAll().prefix('/services').keys();
  console.log('all services:', allServices);
 
  const watcher = await client.watch().key('/services/a').create();
  watcher.on('put', (req) => {
    console.log('put', req.value.toString())
  })
  watcher.on('delete', (req) => {
    console.log('delete')
  })
})();
```

get、getAll、watch 这些 api 和 ectdctl 命令行差不多，很容易搞懂。

get(xx) 是查询某个 key 的值。

getAll().prefix(xx).keys() 是查询某个字符串开头的 key。

watch().key(xx).create 则是创建某个 key 的监听器，监听他的 put 和 delete 事件。

我们再 put 几个 key：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jJKAXS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jJKAXS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jJKAXS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-jJKAXS.webp" loading="lazy"/>
  </picture>

```arduino
arduino
复制代码etcdctl put /services/a xxx

etcdctl put /services/b yyy
```

然后执行上面的 node 脚本：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-3eYnEs.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-3eYnEs.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-3eYnEs.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-3eYnEs.webp" loading="lazy"/>
  </picture>

确实取到了 etcd server 中的值。

然后在 etcdctl 里 put 修改下 /services/a 的值：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FMWyVG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FMWyVG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FMWyVG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-27-FMWyVG.webp" loading="lazy"/>
  </picture>

```arduino
arduino
复制代码etcdctl put /services/a zzz
```

在 node 脚本这里收到了通知：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-0wOjOu.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-0wOjOu.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-0wOjOu.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-0wOjOu.webp" loading="lazy"/>
  </picture>

再 del 试下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rrg2jc.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rrg2jc.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rrg2jc.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rrg2jc.webp" loading="lazy"/>
  </picture>

```css
css
复制代码etcdctl del /services/a
```

也收到了通知：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gSkfaF.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gSkfaF.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gSkfaF.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gSkfaF.webp" loading="lazy"/>
  </picture>

这样，在 node 里操作 etcd server 就跑通了。

然后我们封装下配置中心和注册中心的工具函数：

配置中心的实现比较简单，就是直接 put、get、del 对应的 key：

```javascript
javascript
复制代码// 保存配置
async function saveConfig(key, value) {
    await client.put(key).value(value);
}

// 读取配置
async function getConfig(key) {
    return await client.get(key).string();
}

// 删除配置
async function deleteConfig(key) {
    await client.delete().key(key);
}
```

使用起来也很简单；

```javascript
javascript
复制代码(async function main() {
    await saveConfig('config-key', 'config-value');
    const configValue = await getConfig('config-key');
    console.log('Config value:', configValue);
})();
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-4PBVMs.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-4PBVMs.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-4PBVMs.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-4PBVMs.webp" loading="lazy"/>
  </picture>

你可以在这里存各种数据库连接信息、环境变量等各种配置。

然后是注册中心：

服务注册：

```javascript
javascript
复制代码// 服务注册
async function registerService(serviceName, instanceId, metadata) {
    const key = `/services/${serviceName}/${instanceId}`;
    const lease = client.lease(10);
    await lease.put(key).value(JSON.stringify(metadata));
    lease.on('lost', async () => {
        console.log('租约过期，重新注册...');
        await registerService(serviceName, instanceId, metadata);
    });
}
```

注册的时候我们按照 /services/服务名/实例id 的格式来指定 key。

也就是一个微服务可以有多个实例。

设置了租约 10s，这个就是过期时间的意思，然后过期会自动删除。

我们可以监听 lost 事件，在过期后自动续租。

当不再续租的时候，就代表这个服务挂掉了。

然后是服务发现：

```javascript
javascript
复制代码// 服务发现
async function discoverService(serviceName) {
    const instances = await client.getAll().prefix(`/services/${serviceName}`).strings();
    return Object.entries(instances).map(([key, value]) => JSON.parse(value));
}
```

服务发现就是查询 /services/服务名 下的所有实例，返回它的信息。

```javascript
javascript
复制代码// 监听服务变更
async function watchService(serviceName, callback) {
    const watcher = await client.watch().prefix(`/services/${serviceName}`).create();
    watcher .on('put', async event => {
        console.log('新的服务节点添加:', event.key.toString());
        callback(await discoverService(serviceName));
    }).on('delete', async event => {
        console.log('服务节点删除:', event.key.toString());
        callback(await discoverService(serviceName));
    });
}
```

通过 watch 监听 /services/服务名下所有实例的变动，包括添加节点、删除节点等，返回现在的可用节点。

我们来测试下：

```javascript
javascript
复制代码(async function main() {
    const serviceName = 'my_service';
    
    await registerService(serviceName, 'instance_1', { host: 'localhost', port:3000 });
    await registerService(serviceName, 'instance_2', { host: 'localhost', port:3002 });

    const instances = await discoverService(serviceName);
    console.log('所有服务节点:', instances);

    watchService(serviceName, updatedInstances => {
        console.log('服务节点有变动:', updatedInstances);
    });
})();
```

跑起来确实能获得服务的所有节点信息：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-6rdfTq.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-6rdfTq.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-6rdfTq.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-6rdfTq.webp" loading="lazy"/>
  </picture>

当在 etcdctl 里 del 一个服务节点的时候，这里也能收到通知：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-o6Yfx7.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-o6Yfx7.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-o6Yfx7.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-o6Yfx7.webp" loading="lazy"/>
  </picture>

```bash
bash
复制代码etcdctl del /services/my_service/instance_2
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-z0ncOf.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-z0ncOf.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-z0ncOf.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-z0ncOf.webp" loading="lazy"/>
  </picture>

这样，我们就实现了服务注册、服务发现功能。

有的同学可能问了：redis 不也是 key-value 存储的么？为什么不用 redis 做配置中心和注册中心？

因为 redis 没法监听不存在的 key 的变化，而 etcd 可以，而配置信息很多都是动态添加的。

当然，还有很多别的原因，毕竟 redis 只是为了缓存设计的，不是专门的配置中心、注册中心的中间件。

专业的事情还是交给专业的中间件来干。

案例代码在[小册仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FQuarkGluonPlasma%2Fnestjs-course-code%2Ftree%2Fmain%2Fetcd-test)





### 跨语言微服务通信

#### 介绍

跨语言调用服务一般会用 gRPC，它是 google 出的一种跨语言的远程方法调用的方案。RPC 是 Remote Procedure Call，远程过程调用。



#### 实现

安装用到的微服务的包：

```css
npm install --save @nestjs/microservices
```

grpc 的包：

```scss
scss
复制代码npm install --save @grpc/grpc-js @grpc/proto-loader
```

修改下 grpc-server 的 main.ts

```javascript
javascript
复制代码import { NestFactory } from '@nestjs/core';
import { GrpcOptions, Transport } from '@nestjs/microservices';
import { GrpcServerModule } from './grpc-server.module';
import { join } from 'path';

async function bootstrap() {
  const app = await NestFactory.createMicroservice<GrpcOptions>(GrpcServerModule, {
    transport: Transport.GRPC,
    options: {
      url: 'localhost:8888',
      package: 'book',
      protoPath: join(__dirname, 'book/book.proto'),
    },
  });

  await app.listen();
}
bootstrap();
```

和我们前面创建微服务的方式一样，只不过传输方式 transport 改为 GRPC，然后指定微服务监听端口为 8888。

然后在 options 指定 protoPath。

在 src 下创建这个对应的文件：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-bDnq9x.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-bDnq9x.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-bDnq9x.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-bDnq9x.webp" loading="lazy"/>
  </picture>

```javascript
javascript
复制代码syntax = "proto3";

package book;

service BookService {
  rpc FindBook (BookById) returns (Book) {}
}

message BookById {
  int32 id = 1;
}

message Book {
  int32 id = 1;
  string name = 2;
  string desc = 3;
}
```

这是一种叫做 protocol buffer 的语法。

我们安装个语法高亮插件

搜索 ext:proto，也就是处理 .proto 文件的插件：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zihpPG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zihpPG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zihpPG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zihpPG.webp" loading="lazy"/>
  </picture>

安装之后就有语法高亮了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VJGUun.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VJGUun.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VJGUun.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VJGUun.webp" loading="lazy"/>
  </picture>

为什么要有一种 protocol buffer 的语法呢？

因为要跨语言通信，不同语言的语法又不一样，那怎么通信呢？

定义一种用于通信的语言，各种语言都支持这种语法的解析不就行了？

这就是为什么会有 protocol buffer。

这些语法也很容易看懂：

```ini
ini
复制代码syntax = "proto3"
```

是使用 proto3 版本的语法。

```go
go
复制代码package book;
```

是当前包为 book，也就是一种命名空间。

```scss
scss
复制代码service BookService {
  rpc FindBook (BookById) returns (Book) {}
}
```

这个就是定义当前服务可以远程调用的方法。

有一个 FindBook 方法，参数是 BookById，返回值是 Book

然后下面就是参数和返回值的消息格式：

```ini
ini
复制代码message BookById {
  int32 id = 1;
}

message Book {
  int32 id = 1;
  string name = 2;
  string desc = 3;
}
```

book.proto 只是定义了可用的方法和参数返回值的格式，我们还要在 controller 里实现对应的方法：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqRs7B.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqRs7B.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqRs7B.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqRs7B.webp" loading="lazy"/>
  </picture>

```javascript
javascript
复制代码@GrpcMethod('BookService', 'FindBook')
findBook(data: { id: number}) {
    const items = [
      { id: 1, name: '前端调试通关秘籍', desc: '网页和 node 调试' },
      { id: 2, name: 'Nest 通关秘籍', desc: 'Nest 和各种后端中间件' },
    ];
    return items.find(({ id }) => id === data.id);
}
```

实现了 findBook 方法，并通过 @GrpcMethod 把它标识为 grpc 的远程调用的方法。

在 nest-cli.json 添加 assets 配置，让 nest 在 build 的时候把 proto 也复制到 dist 目录下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-hE1fSg.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-hE1fSg.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-hE1fSg.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-hE1fSg.webp" loading="lazy"/>
  </picture>

```javascript
javascript
复制代码"assets": ["**/*.proto"],
"watchAssets": true,
```

把它跑起来：

```arduino
arduino
复制代码npm run start:dev grpc-server
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-ySUEp6.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-ySUEp6.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-ySUEp6.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-ySUEp6.webp" loading="lazy"/>
  </picture>

这时 dist 下就有 grpc-server 的代码了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-yBWWXx.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-yBWWXx.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-yBWWXx.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-yBWWXx.webp" loading="lazy"/>
  </picture>

然后我们在 grpc-client 里连上它：

在 AppModule 里添加连接 grpc-server 的微服务的配置：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Rjkxsd.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Rjkxsd.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Rjkxsd.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Rjkxsd.webp" loading="lazy"/>
  </picture>

```javascript
javascript
复制代码import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { join } from 'path';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'BOOK_PACKAGE',
        transport: Transport.GRPC,
        options: {
          url: 'localhost:8888',
          package: 'book',
          protoPath: join(__dirname, 'book/book.proto'),
        },
      },
    ]),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

同样，客户端也是需要 proto 文件的，不然不知道怎么解析协议数据。

把 book/book.proto 文件复制过来：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-fMKNtr.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-fMKNtr.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-fMKNtr.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-fMKNtr.webp" loading="lazy"/>
  </picture>

然后在 AppController 里实现调用远程方法的逻辑：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-epconH.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-epconH.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-epconH.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-epconH.webp" loading="lazy"/>
  </picture>

注入 BOOK_PACKAGE 的 grpc 客户端对象。

在 onModuleInit 的时候调用 getService 方法，拿到 BookService 的实例。

然后调用它的 findBook 方法。

```javascript
javascript
复制代码import { Controller, Get, Inject, Param, Query } from '@nestjs/common';
import { AppService } from './app.service';
import { ClientGrpc } from '@nestjs/microservices';

interface FindById {
  id: number;
}
interface Book {
  id: number;
  name: string;
  desc: string;  
}
interface BookService {
  findBook(param: FindById): Book 
}
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Inject('BOOK_PACKAGE') 
  private client: ClientGrpc;

  private bookService: BookService;

  onModuleInit() {
    this.bookService = this.client.getService('BookService');
  }

  @Get('book/:id')
  getHero(@Param('id') id: number) {
    return this.bookService.findBook({
      id
    });
  }
}
```

把它跑起来：

```arduino
arduino
复制代码npm run start:dev grpc-client
```

浏览器访问下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-vYBPYo.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-vYBPYo.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-vYBPYo.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-vYBPYo.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-DBjdWW.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-DBjdWW.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-DBjdWW.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-DBjdWW.webp" loading="lazy"/>
  </picture>

可以看到，远程方法调用成功了。

这就是基于 grpc 的远程方法调用，用 java、python、go、c++ 等实现的微服务也是这样来通信。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Juv7VZ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Juv7VZ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Juv7VZ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-Juv7VZ.webp" loading="lazy"/>
  </picture>

通过 protocol buffer 的语法定义通信数据的格式，比如 package、service 等。

然后 server 端实现 service 对应的方法，client 端远程调用这个 service。

比如在 java 的 srping 里，需要安装这两个依赖：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-xYt3tW.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-xYt3tW.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-xYt3tW.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-xYt3tW.webp" loading="lazy"/>
  </picture>

然后也是定义这样的 proto 文件：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-maDCaL.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-maDCaL.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-maDCaL.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-maDCaL.webp" loading="lazy"/>
  </picture>

之后定义对应的 servie：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-muOFX7.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-muOFX7.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-muOFX7.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-muOFX7.webp" loading="lazy"/>
  </picture>

和 node 里差不多。







## 日志

#### log4js

官方地址：https://log4js-node.github.io/log4js-node/



##### 日志级别

log4js对日志级别进行详细分类，比如重要的日志，可以用error或者fatal级别，不重要的日志，可以用debug或者info级别。

log4js提供了9种级别的日志：<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-19-51-image-20231213195132375.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-19-51-image-20231213195132375.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-19-51-image-20231213195132375.png" alt="image-20231213195132375" style="zoom:33%;" loading="lazy"/>
  </picture>

##### 日志分类

通过getLogger()方法传入对应的模块名，即可对日志进行模块分类。

```js
const log4js = require('log4js');
log4js.configure({
  appenders: {
    out: { type: 'stdout' },
    app1: { type: 'file', filename: 'application1.log' },
    app2: { type: 'file', filename: 'application2.log' }
  },
  categories: {
    default: { appenders: [ 'out' ], level: 'trace' },
    app1: { appenders: ['app1'], level: 'trace' },
    app2: { appenders: ['app2'], level: 'info' }
  }
});

const logger = log4js.getLogger();
logger.trace('This will use the default category and go to stdout');

const app1Log = log4js.getLogger('app1');
app1Log.trace('This will go to a file');
const app2Log = log4js.getLogger('app2');
app2Log.info('This will go to a file');
```

执行代码后，会在同级目录下创建application1.log和application2.log两个日志文件，并且app1和app2的日志会落到对应的日志文件里。



##### 日志分割

日志分割在实际项目中也是经常遇到的。因为在业务场景比较复杂的情况下，需要按照不同纬度对日志进行分割，分割的标准有很多，比如类别、日期等，日志分割需要按照业务的实际场景进行。一般情况下，日志是通过日期来进行分割的，因为按照日期查看日志能够缩小日志范围。

```js
const log4js = require('log4js');
log4js.configure({
  appenders: {
    app: {
      type: 'dateFile',
      filename: 'application',
      alwaysIncludePattern: true,
      pattern: 'yyyy-MM-dd-hh.log'
    }
  },
  categories: {
    default: { appenders: [ 'app' ], level: 'trace' },
    app: { appenders: ['app'], level: 'trace' },
  }
});

const appLog = log4js.getLogger('app');
appLog.trace('This will go to a file');
```

运行代码后，可以看到生成了一个名为application. 2021-09-28-16.log的文件，日期是执行程序的时间。按照日期分割日志就是在设置日志类型时，将type设置为dateFile，这样落到磁盘的日志就是按照日期进行分类的。











# 数据库

在不同场景下，不同类型的数据存储的地方也不一样，比如一些重要数据需要长期存储，那么存储在数据库里比较合适；一些日志数据，存储在Elasticsearch中比较合适；一些数据存取需要速度更快一些，利用Redis进行存储最为合适。







## MySQL

### 介绍

下载地址：https://dev.mysql.com/downloads/mysql/下载后进行本地安装。

打开控制台，输入命令`mysql -u root -p`，接着输入登录密码，如果出现mysql命令行，说明安装成功。

（从 MySQL5.0 开始，官方文档中开始使用 schema 来代替 database 来描述 MySQL 中的数据库。但是，实际上 MySQL 中的数据库仍然可以使用 database 来称呼，两者是等价的）。每个数据库下存储着很多表、视图、存储过程和函数。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-19-b1551e10ee464e4aa12c041aa7d37bc2~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-19-b1551e10ee464e4aa12c041aa7d37bc2~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-19-b1551e10ee464e4aa12c041aa7d37bc2~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="img" style="zoom:50%;" loading="lazy"/>
  </picture>

按照 sql 分类，我们学的 table 的创建、删除、清空的 sql 都属于 DDL。table 数据的增删改属于 DML，而数据的查询属于 DQL。

sql 语句不区分大小写，用大写只是关键词更容易区分一些。



### 概念

#### 视图

视图有什么好处呢？

明显感受到的就是能简化查询，之前要写一堆 sql，现在只要查这个视图就好了。

再就是还可以控制权限，让开发者只能看到需要的字段，其余的给隐藏掉。

视图一般只用来做查询，因为它增删改的限制比较多，比如只有单表的视图可以增删改，并且要求不在视图里的字段都有默认值等。

```mysql
CREATE VIEW customer_orders AS 
    SELECT 
        c.name AS customer_name, 
        o.id AS order_id, 
        o.order_date, 
        o.total_amount
    FROM customers c
    JOIN orders o ON c.id = o.customer_id;
```



#### 存储过程

存储过程可以封装一些 sql，用的时候传入参数 CALL 一下就行。

```mysql
DELIMITER $$
CREATE PROCEDURE get_customer_orders(IN customer_id INT)
BEGIN
        SELECT o.id AS order_id, o.order_date, o.total_amount
        FROM orders o
		WHERE o.customer_id = customer_id;
END $$
DELIMITER ;

```





#### 函数

```mysql
DELIMITER $$
CREATE FUNCTION square(x INT)
RETURNS INT
BEGIN
    DECLARE result INT;
    SET result = x * x;
    RETURN result;
END $$
DELIMITER ;
```

默认 mysql 是不允许创建函数的。

需要先设置下这个变量：

```sql
sql
复制代码SET GLOBAL log_bin_trust_function_creators = 1;
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-sIR8jF.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-sIR8jF.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-sIR8jF.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-sIR8jF.webp" loading="lazy"/>
  </picture>

之后之后再创建 function：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-2OWEdz.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-2OWEdz.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-2OWEdz.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-2OWEdz.webp" loading="lazy"/>
  </picture>

创建成功之后就可以在 sql 里用它了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-oUuP4I.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-oUuP4I.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-oUuP4I.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-oUuP4I.webp" loading="lazy"/>
  </picture>







#### 事务

场景：一个把订单详情表数量修改了，一个把订单表的总金额修改了。但是改订单总金额的那个 sql 执行失败了。这时候怎么办？数量已经改了，但是总金额没改成功，就对不上了。



<mark>当你修改多个表的时候，并且这些表的数据是有关联的时候，事务是必须的。要不全部成功，要不全部不成功。</mark>

**START TRANSACTION 开启事务后所有的 sql 语句都可以 ROLLBACK，除非执行了 COMMIT 完成这段事务。**

**还可以设置几个 SAVEPOINT，这样可以 ROLLBACK TO 任何一个 SAVEPOINT 的位置。**

那如果事务还没有 COMMIT，但是它修改了一些表，这时候我们能查到它修改后的数据么？

这就涉及到事务的隔离级别的概念了。

MYSQL 有 4 种事务隔离级别：

- **READ UNCOMMITTED**：可以读到别的事务尚未提交的数据。

这就有个问题，你这个事务内第一次读的数据是 aaa，下次读可能就是 bbb 了，这个问题叫做**不可重复读**。

而且，万一你读到的数据人家又回滚了，那你读到的就是临时数据，这个问题叫做**脏读**。

- **READ COMMITTED**：只读取别的事务已提交的数据。

这样是没有脏读问题了，读到的不会是临时数据。

但是还是有可能你这个事务内第一次读的数据是 aaa，下次读可能是 bbb ，也就是不可重复读的问题依然存在。

不只是数据不一样，可能你两次读取到的记录行数也不一样，这叫做**幻读**。

- **REPEATABLE READ**：在同一事务内，多次读取数据将保证结果相同。

这个级别保证了读取到的数据一样，但是不保证行数一样，也就是说解决了不可重复读的问题，但仍然存在幻读的问题。

- **SERIALIZABLE**：在同一时间只允许一个事务修改数据。

事务一个个执行，各种问题都没有了。

但是负面影响就是性能很差，只能一个个的事务执行。

这 4 种级别主要是数据一致性和性能的差别，一致性越好，并发性能就越差。

需要根据实际情况来权衡。

可以这样查询当前的事务隔离级别：

```sql
sql
复制代码select @@transaction_isolation
```





### GUI

#### 安装

GUI 客户端有很多，这里我们用 mysql 官方的 GUI 客户端： [MySQL Workbench](https://link.juejin.cn/?target=https%3A%2F%2Fdev.mysql.com%2Fdownloads%2Fworkbench%2F)。也推荐一款名为Sequel Ace的数据库客户端，对数据的增删改查操作确实非常方便。



安装好后，打开 mysql workbench，点击这个 + 号：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-14-e6b8755152034d25bffb272c4a642c81~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-14-e6b8755152034d25bffb272c4a642c81~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-14-e6b8755152034d25bffb272c4a642c81~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-05-12-14-e6b8755152034d25bffb272c4a642c81~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" loading="lazy"/>
  </picture>

输入连接名，点击 store in keychain 输入密码：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-LSVXpv.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-LSVXpv.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-LSVXpv.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-LSVXpv.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VHepZd.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VHepZd.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VHepZd.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-VHepZd.webp" loading="lazy"/>
  </picture>

之后你可以点击下 Test Connection 测试连接是否成功：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-wLZchB.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-wLZchB.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-wLZchB.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-wLZchB.webp" loading="lazy"/>
  </picture>

然后点击 ok。

之后点击这个连接，进入操作 mysql server 的界面：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KSB6UE.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KSB6UE.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KSB6UE.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KSB6UE.webp" loading="lazy"/>
  </picture>

#### 基本操作

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-mjO7Jm.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-mjO7Jm.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-mjO7Jm.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-mjO7Jm.webp" loading="lazy"/>
  </picture>

点击 schemas 就可以看到 mysql 现在已有的数据库和它下面的表、视图、存储过程、函数等：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-cW7B8M.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-cW7B8M.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-cW7B8M.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-cW7B8M.webp" loading="lazy"/>
  </picture>



我们先点击这个图标看一下 sys_config 表中的数据，它会自动执行查询这个表全部数据的 sql：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iEeRrq.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iEeRrq.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iEeRrq.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iEeRrq.webp" loading="lazy"/>
  </picture>



点击第一个图标，会展示表的信息，比如多少列、多少行、占据了多大的空间等：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-th6xWu.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-th6xWu.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-th6xWu.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-th6xWu.webp" loading="lazy"/>
  </picture>

点击第二个图标是修改表的列的定义的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-CEPchT.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-CEPchT.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-CEPchT.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-CEPchT.webp" loading="lazy"/>
  </picture>

不要改这个数据库，我们新建一个来测试。



#### 新建

上面这 5 个按钮分别是创建 schema、table、view、stored procedure、function 的。

点击第一个，创建个 database（或者叫 schema）：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-MS0TMI.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-MS0TMI.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-MS0TMI.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-MS0TMI.webp" loading="lazy"/>
  </picture>

输入名字，指定字符集，点击右下角的 apply。

创建成功之后，就可以看到我们刚建的数据库了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-f4JG3Y.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-f4JG3Y.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-f4JG3Y.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-f4JG3Y.webp" loading="lazy"/>
  </picture>

选中 hello-mysql 数据库，点击创建 table 的按钮，我们来建个表：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zzdtMG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zzdtMG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zzdtMG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-zzdtMG.webp" loading="lazy"/>
  </picture>

输入表名 student。

先建立 id 列：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HXG27o.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HXG27o.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HXG27o.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HXG27o.webp" loading="lazy"/>
  </picture>

输入描述，选中 primary key、 auto increment 的约束。

primary key 是主键，也就是区分每一行数据的那一列，这一列一般命名为 id。

primary key 自带了唯一（unique）和非空（not null）的约束。

再就是要勾选 auto increment 这样插入数据的时候，会自动设置 1、2、3、4、 的递增的 id。

然后依次创建 name、age、sex、email、create_time、status 列：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-445u3I.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-445u3I.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-445u3I.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-445u3I.webp" loading="lazy"/>
  </picture>

分别是名字、年龄、性别、邮箱、创建时间、是否删除的意思。

可以填入注释和默认值。

比如 status 用 0 表示未删除，1 表示已删除，这叫做逻辑删除。也就是删除的时候就是从 0 改成 1，但不会真正删除数据。

name 和 create_time 添加非空约束。

mysql 的数据类型有很多：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HUE0ce.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HUE0ce.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HUE0ce.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-HUE0ce.webp" loading="lazy"/>
  </picture>

整数类的有：TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT

看名字就可以看出来，就是存储空间的大小不同

浮点型数字的有 FLOAT、DOUBLE

定点型数字的有 DECIMAL、MUMARIC

字符串型的有 CHAR、VARCHAR、TEXT和 BLOB

日期型的有 DATE、TIME、DATETIME、TIMESTAMP

不过我们常用的也就这么几个：

**INT**：存储整数

**VARCHAR(100)**: 存储变长字符串，可以指定长度

**CHAR**：定长字符串，不够的自动在末尾填充空格

**DOUBLE**：存储浮点数

**DATE**：存储日期 2023-05-27

**TIME**：存储时间 10:13

**DATETIME**：存储日期和时间 2023-05-27 10:13

其余的类型用到再查也行。

这里还有个 TIMESTAMP 类型，它也是存储日期时间的，但是范围小一点，而且会转为中央时区 UTC 的时间来存储。

可以看到，mysql 设计了这么多的数据类型，一个目的自然是存储更丰富的信息，另一个目的就是尽可能的节省存储空间，比如 tiny、small、medinum、big 等各种 int。。。

点击右下角的 apply，就会生成建表 sql：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pSnW0P.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pSnW0P.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pSnW0P.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pSnW0P.webp" loading="lazy"/>
  </picture>

这就是建表语句的语法。

这里简单说一下 sql 的分类，sql 是分为好几种的，这种创建数据库、创建表等修改结构的 sql 叫做 DDL（Data Definition Language），而增删改那种叫做 DML（Data Manipulate Language），查询数据的叫做 DQL（Data Query Language）。

知道这个概念就好了。

然后我们继续：

创建成功之后点击第三个图标，就可以查询这个表的所有数据：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-aiUmnt.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-aiUmnt.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-aiUmnt.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-aiUmnt.webp" loading="lazy"/>
  </picture>

你可以新增几行数据，每一行数据叫做一个记录（Record）。

可以在下面直接编辑，然后点击 apply：

（这里不用设置 id，因为我们指定了它自增了，会自动设置）

（status 也不用设置，因为我们指定了默认值了）

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iWh2Ma.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iWh2Ma.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iWh2Ma.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-iWh2Ma.webp" loading="lazy"/>
  </picture>

他会生成 insert 语句，这是向表中插入数据的语法：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-GUYp0g.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-GUYp0g.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-GUYp0g.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-GUYp0g.webp" loading="lazy"/>
  </picture>

把它复制一下，之后我们用 insert 语句来插入数据吧，mysql workbench 这个可视化编辑功能不好用。

点击 apply 之后，mysql 会执行 sql，这时候就可以看到这条记录被插入了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gPNfF1.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gPNfF1.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gPNfF1.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-gPNfF1.webp" loading="lazy"/>
  </picture>

因为我之前测试的时候插入过几条，所以 id 自增到了 5，status 默认设置了 0。

接下来我们用 sql 的方式插入：

```sql
sql
复制代码INSERT INTO `hello-mysql`.`student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('bbb', '23', '1', 'bbb@qq.com', '2023-05-27 10:50:00');

INSERT INTO `hello-mysql`.`student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('ccc', '21', '0', 'ccc@qq.com', '2023-05-26 10:50:00');

INSERT INTO `hello-mysql`.`student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('ddd', '22', '1', 'ddd@qq.com', '2023-05-28 10:50:00');
```

在上面的输入框输入这几条 sql，选中它们，然后点击执行 sql 的按钮：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pweMX4.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pweMX4.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pweMX4.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-pweMX4.webp" loading="lazy"/>
  </picture>

下面是执行结果，可以看到都插入成功了，一共 3 行。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-86d3OX.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-86d3OX.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-86d3OX.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-86d3OX.webp" loading="lazy"/>
  </picture>

然后再选中上面的查询 sql 来执行：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-OCHwUO.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-OCHwUO.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-OCHwUO.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-OCHwUO.webp" loading="lazy"/>
  </picture>

下面也同样会展示查询 sql 的执行情况，一共返回了 4 行数据：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-8Y8Z5S.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-8Y8Z5S.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-8Y8Z5S.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-8Y8Z5S.webp" loading="lazy"/>
  </picture>





#### 修改和删除

我们同样可视化操作一下，然后看看 sql：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqrukd.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqrukd.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqrukd.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-dqrukd.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-EkqGrp.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-EkqGrp.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-EkqGrp.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-EkqGrp.webp" loading="lazy"/>
  </picture>

修改和删除的 sql 分别是这样的：

```sql
sql
复制代码UPDATE `hello-mysql`.`student` SET `email` = 'xxx@qq.com' WHERE (`id` = '10');
sql
复制代码DELETE FROM `hello-mysql`.`student` WHERE (`id` = '10');
```

更新 hello-mysql 数据库的 student 表，设置 email 列为 [xxx@qq.com](https://link.juejin.cn/?target=mailto%3Axxx@qq.com)，条件是 id 为 10。

是不是很容易理解？

毕竟 sql 就是设计出来给人用的嘛。

删除数据也同样很容易理解：

删除 hello-mysql 数据的 student 的 id 为 10 的列。

至此，我们已经学会 mysql 的数据库表的创建和增删改查了。

创建表是这样的（这个不用记，一般不会手动写 sql 创建表）：

```sql
sql
复制代码CREATE TABLE `student` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(45) NOT NULL COMMENT '名字',
  `age` int DEFAULT NULL COMMENT '年龄',
  `sex` int DEFAULT NULL COMMENT '性别',
  `email` varchar(60) DEFAULT NULL COMMENT '邮箱',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  `status` int DEFAULT '0' COMMENT '是否删除',
  PRIMARY KEY (`id`)
) CHARSET=utf8mb4
```

也就是指定创建的表的名字，然后括号内 , 分隔的每一列分别指定名字、类型、约束、注释、默认值等。

插入记录是这样的：

```sql
sql
复制代码INSERT INTO `student` (`name`, `age`, `sex`, `email`, `create_time`) VALUES ('bbb', '23', '1', 'bbb@qq.com', '2023-05-27 10:50:00');
```

更新记录是这样的：

```sql
sql
复制代码UPDATE `hello-mysql`.`student` SET `email` = 'xxx@qq.com' WHERE (`id` = '2');
```

删除记录是这样的：

```sql
sql
复制代码DELETE FROM `hello-mysql`.`student` WHERE (`id` = '2');
```

查询记录是这样的：

```sql
sql
复制代码SELECT * FROM `hello-mysql`.student;
```

增删改的 sql 都很简单，查询的 sql 可以写的很复杂，这个我们下节再讲。

最后再来学下删除和清空表的 sql：

清空是 truncate：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KwgYzg.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KwgYzg.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KwgYzg.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-KwgYzg.webp" loading="lazy"/>
  </picture>

点击 review sql <picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-XrbgEJ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-XrbgEJ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-XrbgEJ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-XrbgEJ.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rCwNxa.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rCwNxa.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rCwNxa.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-rCwNxa.webp" loading="lazy"/>
  </picture>

删除是 drop：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-edUUsT.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-edUUsT.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-edUUsT.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-edUUsT.webp" loading="lazy"/>
  </picture>

都很好理解。



### 命令行

可以先 use 数据库名 切换下数据库：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-UAv1Os.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-UAv1Os.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-UAv1Os.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-UAv1Os.webp" loading="lazy"/>
  </picture>



在 mysql workbench 里也是这样，先选中 use xx 那行执行，然后再选中其他 sql 执行。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-5ANuzv.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-5ANuzv.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-5ANuzv.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-28-5ANuzv.webp" loading="lazy"/>
  </picture>





### 项目中连接MySQL

#### 法一：直接写sql

在工程中安装一个mysql2包。



#### 法二：ORM

Node社区中流行着一种通过对象和关系类型的映射，使得操作数据库和操作对象一样。Object Relational Mapping，也就是对象和关系型数据库的映射的含义



##### prisma

Prisma 创造了一种 DSL（Domain Specific Language，领域特定语言）。

类似这样：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-7pNnoK.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-7pNnoK.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-7pNnoK.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-7pNnoK.webp" loading="lazy"/>
  </picture>

它是把表映射成了 DSL 里的 model，然后编译这个 DSL 会生成 prismaClient 的代码，之后就可以调用它的 find、delete、create 等 api 来做 CRUD 了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XuV5h1.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XuV5h1.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XuV5h1.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XuV5h1.webp" loading="lazy"/>
  </picture>





##### sequelize

安装依赖sequelize和mysql2，实现一个插入操作：实例化一个Sequelize对象，将表结构映射到一个User对象上，通过User对象就可以对数据库进行各种操作了。定义表结构时，tbl_user表其实就是实际数据库中的tbl_users表。

```js
const { Sequelize, DataTypes } = require('sequelize');
const sequelize = new Sequelize('koadb', 'root', '123456', {
  host: 'localhost',
  dialect: 'mysql',
});

const User = sequelize.define('tbl_user', {
  id: {
    type: Sequelize.STRING(50),
    primaryKey: true
  },
  username: {
    type: DataTypes.STRING,
    allowNull: true
  },
  nickname: {
    type: DataTypes.STRING,
    allowNull: true
  }
},{
  timestamps: false
});

User.create({
  username: 'liujianghong2',
  nickname: '刘江虹2'
}).then(res => {
    console.log(res)
}).catch(err => {
    console.log(err)
})
```





##### typeORM

###### 介绍

把表映射到 entity 类，把表的关联映射成 entity 类的属性关联。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-17-image-20240207151723082.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-17-image-20240207151723082.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-17-image-20240207151723082.png" alt="image-20240207151723082" style="zoom:75%;" loading="lazy"/>
  </picture>

###### 新建

新建一个 TypeORM 项目：

```kotlin
npx typeorm@latest init --name typeorm-all-feature --database mysql
```

然后改下用户名密码数据库，把连接 msyql 的驱动包改为 mysql2，并修改加密密码的方式：

```typescript
import "reflect-metadata"
import { DataSource } from "typeorm"
import { User } from "./entity/User"

export const AppDataSource = new DataSource({
    type: "mysql",
    host: "localhost",
    port: 3306,
    username: "root",
    password: "guang",
    database: "practice",
    synchronize: true,
    logging: true,
    entities: [User],
    migrations: [],
    subscribers: [],
    poolSize: 10,
    connectorPackage: 'mysql2',
    extra: {
        authPlugin: 'sha256_password',
    }
})
```

然后安装 mysql2:

```css
npm install --save mysql2
```

我们分别来过一遍这些配置：

type 是数据库的类型，因为 TypeORM 不只支持 MySQL 还支持 postgres、oracle、sqllite 等数据库。

host、port 是指定数据库服务器的主机和端口号。

user、password 是登录数据库的用户名和密码。

database 是要指定操作的 database，因为 mysql 是可以有多个 database 或者叫 schema 的。

synchronize 是根据同步建表，也就是当 database 里没有和 Entity 对应的表的时候，会自动生成建表 sql 语句并执行。当然，如果有对应的表就不会创建了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-8HQC0H.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-8HQC0H.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-8HQC0H.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-8HQC0H.webp" loading="lazy"/>
  </picture>



logging 是打印生成的 sql 语句。

entities 是指定有哪些和数据库的表对应的 Entity。

除了 class，还可以通过这种方式指定：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-A3a5t3.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-A3a5t3.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-A3a5t3.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-A3a5t3.webp" loading="lazy"/>
  </picture>

migrations 是修改表结构之类的 sql，暂时用不到，就不展开了。

subscribers 是一些 Entity 生命周期的订阅者，比如 insert、update、remove 前后，可以加入一些逻辑：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fzr8qf.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fzr8qf.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fzr8qf.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fzr8qf.webp" loading="lazy"/>
  </picture>

poolSize 是指定数据库连接池中连接的最大数量。

connectorPackage 是指定用什么驱动包。

extra 是额外发送给驱动包的一些选项。

这些配置都保存在 DataSource 里。

DataSource 会根据你传入的连接配置、驱动包，来创建数据库连接，并且如果制定了 synchronize 的话，会同步创建表。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ELky64.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ELky64.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ELky64.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ELky64.webp" loading="lazy"/>
  </picture>

而创建表的依据就是 Entity：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-3CXagS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-3CXagS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-3CXagS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-3CXagS.webp" loading="lazy"/>
  </picture>

比如这个 Entity 就会执行这样的 sql：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ANvkbp.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ANvkbp.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ANvkbp.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ANvkbp.webp" loading="lazy"/>
  </picture>

主键为 INT 自增、firstName 和 lastName 是 VARCHAR(255)，age 是 INT。

这是默认的映射关系。

那如果我 number 不是想映射到 INT 而是 DOUBLE 呢？

或者如果 string 不是想映射到 VARCHAR(255)，而是 TEXT （长文本）呢？

这样映射：

```javascript
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm"

@Entity({
    name: 't_aaa'
})
export class Aaa {

    @PrimaryGeneratedColumn({
        comment: '这是 id'
    })
    id: number

    @Column({
        name: 'a_aa',
        type: 'text',
        comment: '这是 aaa'
    })
    aaa: string

    @Column({
        unique: true,
        nullable: false,
        length: 10,
        type: 'varchar',
        default: 'bbb'
    })
    bbb: string

    @Column({
        type: 'double',
    })
    ccc: number
}
```

我们新增了一个 Entity Aaa。

@Entity 指定它是一个 Entity，name 指定表名为 t_aaa。

@PrimaryGeneratedColumn 指定它是一个自增的主键，通过 comment 指定注释。

@Column 映射属性和字段的对应关系。

通过 name 指定字段名，type 指定映射的类型，length 指定长度，default 指定默认值。

nullable 设置 NOT NULL 约束，unique 设置 UNIQUE 唯一索引。

type 这里指定的都是数据库里的数据类型。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-cZiXyZ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-cZiXyZ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-cZiXyZ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-cZiXyZ.webp" loading="lazy"/>
  </picture>

然后在 DataSource 的 entities 里引入下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfasrO.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfasrO.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfasrO.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfasrO.webp" loading="lazy"/>
  </picture>

重新跑 npm run start。

生成建表 sql 是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-MzYHS1.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-MzYHS1.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-MzYHS1.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-MzYHS1.webp" loading="lazy"/>
  </picture>

对比着 Entity 看下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-B9lvM8.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-B9lvM8.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-B9lvM8.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-B9lvM8.webp" loading="lazy"/>
  </picture>



###### 增删改查



在 index.ts 里创建个 user 对象，然后调用 AppDataSource.manager.save 来保存：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User()
    user.firstName = "aaa"
    user.lastName = "bbb"
    user.age = 25

    await AppDataSource.manager.save(user)

}).catch(error => console.log(error))
```

删除 User 表重新跑 npm run start。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-QJeiRn.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-QJeiRn.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-QJeiRn.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-QJeiRn.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fmq2K4.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fmq2K4.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fmq2K4.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-fmq2K4.webp" loading="lazy"/>
  </picture>

可以看到数据库插入了这条记录：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-p0gBh4.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-p0gBh4.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-p0gBh4.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-p0gBh4.webp" loading="lazy"/>
  </picture>

如果你指定了 id，那就变成修改了：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User()
    user.id = 1;
    user.firstName = "aaa111"
    user.lastName = "bbb"
    user.age = 25

    await AppDataSource.manager.save(user)

}).catch(error => console.log(error))
```

重新跑下 npm run start。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfuYnA.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfuYnA.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfuYnA.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-XfuYnA.webp" loading="lazy"/>
  </picture>

可以看到，生成的 sql 语句变成了 select 和 update：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-z46guT.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-z46guT.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-z46guT.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-z46guT.webp" loading="lazy"/>
  </picture>

当你指定了 id 的时候，typeorm 会先查询这个 id 的记录，如果查到了，那就执行 update。

在 mysql workbench 里看下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-zP9wSg.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-zP9wSg.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-zP9wSg.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-zP9wSg.webp" loading="lazy"/>
  </picture>

确实修改了。

那如果想批量插入和修改呢？

这样写：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    await AppDataSource.manager.save(User, [
        { firstName: 'ccc', lastName: 'ccc', age: 21},
        { firstName: 'ddd', lastName: 'ddd', age: 22},
        { firstName: 'eee', lastName: 'eee', age: 23}
    ]);


}).catch(error => console.log(error))
```

我们 npm run start 跑一下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-RvFeTV.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-RvFeTV.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-RvFeTV.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-RvFeTV.webp" loading="lazy"/>
  </picture>

可以看到确实生成了 3 条 insert into 的 sql 语句。

数据库中也能看到：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-hkD021.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-hkD021.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-hkD021.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-hkD021.webp" loading="lazy"/>
  </picture>

批量修改也很容易想到，是这样写：

```javascript
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    await AppDataSource.manager.save(User, [
        { id: 2 ,firstName: 'ccc111', lastName: 'ccc', age: 21},
        { id: 3 ,firstName: 'ddd222', lastName: 'ddd', age: 22},
        { id: 4, firstName: 'eee333', lastName: 'eee', age: 23}
    ]);

}).catch(error => console.log(error))
```

执行 npm run start，会看到一条 select 语句， 3 条 update 语句：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Sg6Lnt.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Sg6Lnt.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Sg6Lnt.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Sg6Lnt.webp" loading="lazy"/>
  </picture>

在 workbench 里也可以看到数据被修改了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-pLo774.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-pLo774.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-pLo774.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-pLo774.webp" loading="lazy"/>
  </picture>

这就是 typeorm 里新增和修改的方式，使用 save 方法。

其实 EntityManager 还有 update 和 insert 方法，分别是修改和插入的，但是它们不会先 select 查询一次。而 save 方法会先查询一次数据库来确定是插入还是修改。

删除和批量删除用 delete 方法：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    await AppDataSource.manager.delete(User, 1);
    await AppDataSource.manager.delete(User, [2,3]);

}).catch(error => console.log(error))
```

执行下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ws80BB.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ws80BB.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ws80BB.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ws80BB.webp" loading="lazy"/>
  </picture>

数据库了对应记录就被删除了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ceeako.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ceeako.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ceeako.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ceeako.webp" loading="lazy"/>
  </picture>

这里也可以用 remove 方法：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const user = new User();
    user.id = 1;

    await AppDataSource.manager.remove(User, user);

}).catch(error => console.log(error))
```

**delete 和 remove 的区别是，delete 直接传 id、而 remove 则是传入 entity 对象。**

而查询是使用 find 方法：

先插入几条数据：

```javascript
javascript
复制代码await AppDataSource.manager.save(User, [
    { firstName: 'ccc', lastName: 'ccc', age: 21},
    { firstName: 'ddd', lastName: 'ddd', age: 22},
    { firstName: 'eee', lastName: 'eee', age: 23}
]);
```

再查一下：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const users = await AppDataSource.manager.find(User);
    console.log(users);
    
}).catch(error => console.log(error))
```

控制台打印了查询出的数据：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-5uY0tX.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-5uY0tX.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-5uY0tX.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-5uY0tX.webp" loading="lazy"/>
  </picture>

也可以通过 findBy 方法根据条件查询：

```javascript
javascript
复制代码import { In } from "typeorm";
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const users = await AppDataSource.manager.findBy(User, {
        age: 23
    });
    console.log(users);
   
}).catch(error => console.log(error))
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-jCKDM0.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-jCKDM0.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-jCKDM0.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-jCKDM0.webp" loading="lazy"/>
  </picture>

此外，你还可以用 findAndCount 来拿到有多少条记录：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const [users, count] = await AppDataSource.manager.findAndCount(User);
    console.log(users, count);

}).catch(error => console.log(error))
```

会额外执行一个统计的 sql：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-uqEHtx.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-uqEHtx.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-uqEHtx.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-uqEHtx.webp" loading="lazy"/>
  </picture>

count 是可以指定条件的：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const [users, count] = await AppDataSource.manager.findAndCountBy(User, {
        age: 23
    })
    console.log(users, count);

}).catch(error => console.log(error))
```

可以看到，生成的 sql 里多了一个 where 条件：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ehHnJ3.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ehHnJ3.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ehHnJ3.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-ehHnJ3.webp" loading="lazy"/>
  </picture>

除了可以查询多条，还可以查询一条，使用 findOne：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const user = await AppDataSource.manager.findOne(User, {
        select: {
            firstName: true,
            age: true
        },
        where: {
            id: 4
        },
        order: {
            age: 'ASC'
        }
    });
    console.log(user);

}).catch(error => console.log(error))
```

指定查询的 where 条件是 id 为 4 ，指定 select 的列为 firstName 和 age，然后 order 指定根据 age 升序排列。

查询结果如下:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Rh02aL.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Rh02aL.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Rh02aL.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Rh02aL.webp" loading="lazy"/>
  </picture>

findOne 只是比 find 多加了个 LIMIT 1，其余的都一样。

```javascript
javascript
复制代码import { In } from "typeorm";
import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {

    const users = await AppDataSource.manager.find(User, {
        select: {
            firstName: true,
            age: true
        },
        where: {
            id: In([4, 8])
        },
        order: {
            age: 'ASC'
        }
    });
    console.log(users);

}).catch(error => console.log(error))
```

把它改为 find，id 改为 In([4, 8]) 之后，结果如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-TwGwYo.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-TwGwYo.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-TwGwYo.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-TwGwYo.webp" loading="lazy"/>
  </picture>

通过 findOneBy 也可以：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    const user = await AppDataSource.manager.findOneBy(User, {
        age: 23
    });
    console.log(user);

}).catch(error => console.log(error))
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wve83G.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wve83G.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wve83G.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wve83G.webp" loading="lazy"/>
  </picture>

此外，findOne 还有两个特殊的方法：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"
import { User } from "./entity/User"

AppDataSource.initialize().then(async () => {
    try {
        const user = await AppDataSource.manager.findOneOrFail(User, {
            where: {
                id: 666
            }
        });
        console.log(user);
    }catch(e) {
        console.log(e);
        console.log('没找到该用户');
    }

}).catch(error => console.log(error))
```

findOneOrFail 或者 findOneByOrFail，如果没找到，会抛一个 EntityNotFoundError 的异常：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-aH7klP.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-aH7klP.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-aH7klP.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-aH7klP.webp" loading="lazy"/>
  </picture>

此外，你还可以用 query 方法直接执行 sql 语句：

```javascript
javascript
复制代码import { AppDataSource } from "./data-source"

AppDataSource.initialize().then(async () => {

    const users = await AppDataSource.manager.query('select * from user where age in(?, ?)', [21, 22]);
    console.log(users);

}).catch(error => console.log(error))
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-sOsPyp.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-sOsPyp.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-sOsPyp.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-sOsPyp.webp" loading="lazy"/>
  </picture>

但复杂 sql 语句不会直接写，而是会用 query builder：

```javascript
javascript
复制代码const queryBuilder = await AppDataSource.manager.createQueryBuilder();

const user = await queryBuilder.select("user")
    .from(User, "user")
    .where("user.age = :age", { age: 21 })
    .getOne();

console.log(user);
```

生成的 sql 语句如下：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ej6REK.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ej6REK.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ej6REK.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ej6REK.webp" loading="lazy"/>
  </picture>

有同学说，用 query builder 和我用 find 指定 where 有什么区别么？

比如这种复杂的关联查询：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Y2mc1K.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Y2mc1K.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Y2mc1K.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Y2mc1K.webp" loading="lazy"/>
  </picture>

涉及到多个表，也就是多个 Entity 的关联查询，就得用 query builder 了。

简单点查询直接 find 指定 where 条件就行。

此外，多条有关联的数据的增删改都离不开事务，怎么开启事务呢？

用 transaction 方法包裹下就好了。

```javascript
javascript
复制代码await AppDataSource.manager.transaction(async manager => {
    await manager.save(User, {
        id: 4,
        firstName: 'eee',
        lastName: 'eee',
        age: 20
    });
});
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-AqiPTS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-AqiPTS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-AqiPTS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-AqiPTS.webp" loading="lazy"/>
  </picture>

还有，调用每个方法的时候都要先传入实体类，这也太麻烦了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-OCtdR2.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-OCtdR2.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-OCtdR2.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-OCtdR2.webp" loading="lazy"/>
  </picture>

有没有什么简便方法呢？

有，可以先调用 getRepository 传入 Entity，拿到专门处理这个 Entity 的增删改查的类，再调用这些方法：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-BNSlKG.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-BNSlKG.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-BNSlKG.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-BNSlKG.webp" loading="lazy"/>
  </picture>

具体的方法和 EntityManager 是一样的。











## mongodb

### 介绍

它的 database 下是 collection，collection 包含多个 document。

document 可以是任意结构的，这点和 mysql 的 table 不同。

mongo 是通过 api 来做 CRUD 的，不是用的 sql。





### 常用的命令和 api

```php
show dbs; // 显示 database
show databases;

use hello-mongo; // 切换或者创建 database

db; // 查看当前 database

db.dropDatabase(); // 删除 database

db.createCollection('aaa'); // 创建 collection

db.xxx.drop() //删除 collection

db.xxx.insertOne({ name: 'guang', age: 20, phone: '13222222222'});// 插入 document

db.xxx.insertMany([{ name: 'dong', age: 21}, {name: 'xxx', hobbies: ['writing']}]);

db.xxx.find({age: 20}); // 查询 collection

db.xxx.findOne({ age: 20});

db.xxx.findOne(); // 查询所有 collection

db.xxx.find({ age: { $in: [20, 21]}}) // 使用 in、nin 查询多个值

db.xxx.find({ $and: [{age: { $gte: 20 }}, { name: /dong\d/}]}) // 使用 and 指定多个条件同时成立

db.xxx.find({ $or: [{age: { $gt: 20 }}, { name: /dong*/}]}) // 使用 or 表示或者

db.xxx.find().skip(1).limit(2) // 使用 skip + limit 实现分页

db.xxx.updateOne({ name: 'guang'}, { $set: {age: 30}, $currentDate: { aaa: true } }) // updateOne、updateMany 更新

db.xxx.replaceOne({name: 'guang'}, { age: 30}) // 整体替换

db.xxx.deleteMany({ age: { $gt: 20 }}); // deleteOne、deleteMany 删除

db.xxx.count({ name: /guang/})

db.xxx.find().sort({ age: -1, name: 1})
```





### GUI

下载官方 GUI 工具 [Mongo Compass](https://link.juejin.cn/?target=https%3A%2F%2Fwww.mongodb.com%2Fproducts%2Ftools%2Fcompass)：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-LUeeq7.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-LUeeq7.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-LUeeq7.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-LUeeq7.webp" loading="lazy"/>
  </picture>

连接上 mongodb 的 server：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-K6LUKJ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-K6LUKJ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-K6LUKJ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-K6LUKJ.webp" loading="lazy"/>
  </picture>

在 GUI 工具里操作就很方便直观了：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-tAmhLH.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-tAmhLH.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-tAmhLH.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-tAmhLH.webp" loading="lazy"/>
  </picture>

可以看到所有的 database、collection、document。

在这里输入过滤条件后点击 find：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-6vx1fe.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-6vx1fe.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-6vx1fe.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-6vx1fe.webp" loading="lazy"/>
  </picture>

更新和删除也都很直观：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-CGSacp.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-CGSacp.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-CGSacp.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-CGSacp.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Eoc7je.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Eoc7je.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Eoc7je.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Eoc7je.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-YqlemQ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-YqlemQ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-YqlemQ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-YqlemQ.webp" loading="lazy"/>
  </picture>





## Elasticsearch

### 介绍

#### 介绍

官方文档：https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html

Elasticsearch可以简单理解为一个数据库，其对于大数据的搜索性能优势非常明显。在一些实际业务场景中，可能需要临时存储大量的数据，并且经常进行查询操作，比如项目中的各种日志，包括access-log、api-log、error-log等，甚至还需要进行各种分析。如果把这些数据存储到数据库里有些不妥，原因是日志具有时效性，最近存储的日志具有分析价值，如果日志久远，就会变成垃圾数据，那么这些垃圾数据就不应该占据磁盘空间了。数据库应该用于存储持久性数据。在这种情况下，使用Elasticsearch是最合适的，一般在公司内部，会将Elasticsearch部署到一台独立的服务器上，由OP人员维护，并且Elasticsearch上的日志是有保存期限的，一般是两个月（不同场景下，日志保存期限不一样），过了期限，日志将被删除。



#### 和数据库的对比

Elasticsearch是一个搜索引擎，虽然也有存储数据的功能，但是两者在使用场景以及能解决的问题方面都不相同。关系型数据库更适合OLTP（一种以事务元作为数据处理的单位、人机交互的计算机应用系统，最大优点是可以即时处理输入的数据并及时回答）业务场景。而Elasticsearch适合OLAP的场景（它使分析人员能够迅速、一致、交互地从各个方面观察信息，以达到深入理解数据的目的），比如海量日志分析和检索等。虽然Elasticsearch和关系型数据库在很多方面有所不同，但是对于开发人员来说，如果对于数据库比较熟悉，对于Elasticsearch比较陌生，也可以通过类比的方式进行学习。在关系型数据库中，有几个重要的概念：Table（表）、Schema（结构、定义）、Row（数据行）、Column（数据列）、SQL（查询等语句）。在Elasticsearch中也有几个重要概念：Index（索引）、Type（类型）、Mapping（索引定义）、Document（文档）、Field（字段）、DSL（查询等语句）。两者可以进行对比理解：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-17-59-image-20231213175925560.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-17-59-image-20231213175925560.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-12-13-17-59-image-20231213175925560.png" alt="image-20231213175925560" style="zoom:33%;" loading="lazy"/>
  </picture>



### 操作

下载地址：https://www.elastic.co/cn/downloads/elasticsearch。下载后将其解压，进入根目录下执行./bin/elasticsearch命令即可启动。如果看到started，说明启动成功了。

推荐一款ElasticSearch客户端，用于更直观地查看数据：名为ElasticSearch Head的Chrome插件。





### node接入

安装npm包elasticsearch，通过它来对Elasticsearch进行操作。

官方文档：https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/index.html



## Redis

### 介绍

mysql 是通过硬盘来存储信息的，并且还要解析并执行 sql 语句，这些决定了它会成为性能瓶颈。

也就是说服务端执行计算会很快，但是等待数据库查询结果就很慢了。

内存和硬盘的速度差距还是很大的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-izM4dI.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-izM4dI.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-izM4dI.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-izM4dI.webp" loading="lazy"/>
  </picture>



所以我们不会只用 mysql，一般会结合内存数据库来做缓存，最常用的是 redis。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-28-image-20240206192807661.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-28-image-20240206192807661.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-19-28-image-20240206192807661.png" alt="image-20240206192807661" style="zoom:50%;" loading="lazy"/>
  </picture>

因为需求就是缓存不同类型的数据，所以 redis 的设计是 key、value 的键值对的形式。并且值的类型有很多：

- **string**： 可以存数字、字符串，比如存验证码就是这种类型
- **hash**：存一个 map 的结构，比如文章的点赞数、收藏数、阅读量，就可以用 hash 存
- **set**：存去重后的集合数据，支持交集、并集等计算，常用来实现关注关系，比如可以用交集取出互相关注的用户
- **zset**：排序的集合，可以指定一个分数，按照分数排序。我们每天看的文章热榜、微博热榜等各种排行榜，都是 zset 做的
- **list**：存列表数据
- **geo**：存地理位置，支持地理位置之间的距离计算、按照半径搜索附近的位置。



所有的命令都可以在官方文档查： [redis.io/commands/](https://link.juejin.cn/?target=https%3A%2F%2Fredis.io%2Fcommands%2F)

可以查出数据来之后放到 redis 中缓存，下次如果 redis 有数据就直接用，没有的话就查数据库然后更新 redis 缓存。这是 redis 的第一种用途，作为数据库的缓存，也是主要的用途。

第二种用途就是直接作为存储数据的地方了，因为 redis 本身是会做持久化的，也可以把数据直接保存在 redis 里，不存到 mysql。

当然，因为 redis 在内存存储数据，这样成本还是比较高的，需要经常扩容。



### 使用

#### 用镜像跑一个

在 docker desktop 搜索框搜索 redis，点击 run，把 redis 官方镜像下载并跑起来。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-xX1Yuy.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-xX1Yuy.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-xX1Yuy.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-xX1Yuy.webp" loading="lazy"/>
  </picture>

它会让你填一些容器的信息：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-1IMjrX.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-1IMjrX.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-1IMjrX.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-1IMjrX.webp" loading="lazy"/>
  </picture>



跑起来之后是这样的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-oHuIAz.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-oHuIAz.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-oHuIAz.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-oHuIAz.webp" loading="lazy"/>
  </picture>



redis 服务跑起来之后，我们用 redis-cli 操作下。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-r6FDIj.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-r6FDIj.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-r6FDIj.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-r6FDIj.webp" loading="lazy"/>
  </picture>

在 terminal 输入 redis-cli，进入交互模式：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ffcdaq.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ffcdaq.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ffcdaq.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ffcdaq.webp" loading="lazy"/>
  </picture>

我们在这里做下 string 相关的操作：

[文档](https://link.juejin.cn/?target=https%3A%2F%2Fredis.io%2Fdocs%2Fdata-types%2Fstrings%2F)里的命令有这么几个：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-R1tQLf.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-R1tQLf.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-R1tQLf.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-R1tQLf.webp" loading="lazy"/>
  </picture>

set、get 都挺简单：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-GzFkkO.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-GzFkkO.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-GzFkkO.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-GzFkkO.webp" loading="lazy"/>
  </picture>

incr 是用于递增的：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ww06nQ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ww06nQ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ww06nQ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-Ww06nQ.webp" loading="lazy"/>
  </picture>

平时我们用的阅读量、点赞量等都是通过这个来计数的。

当我存了几个 key 后，可以通过 keys 来查询有哪些 key:

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wwYkZK.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wwYkZK.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wwYkZK.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-wwYkZK.webp" loading="lazy"/>
  </picture>

keys 后加一个模式串来过滤，常用的是 '*' 来查询所有 key。







#### GUI

我用的是官方的 [RedisInsight](https://link.juejin.cn/?target=https%3A%2F%2Fredis.com%2Fredis-enterprise%2Fredis-insight%2F%23insight-form)，它号称是最好的 Redis GUI 工具：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-DjfujR.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-DjfujR.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-DjfujR.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-DjfujR.webp" loading="lazy"/>
  </picture>

输入操作系统信息，还有邮箱、姓名、职业、手机号等信息，就可以下载安装包了。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-JWy7aR.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-JWy7aR.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-JWy7aR.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-JWy7aR.webp" loading="lazy"/>
  </picture>

安装后就是这个东西：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-rNnUAa.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-rNnUAa.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-rNnUAa.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-rNnUAa.webp" loading="lazy"/>
  </picture>

点击 add database：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-WjLurF.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-WjLurF.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-WjLurF.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-WjLurF.webp" loading="lazy"/>
  </picture>

连接信息用默认的就行：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-522Brv.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-522Brv.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-522Brv.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-29-522Brv.webp" loading="lazy"/>
  </picture>

然后就可以看到新建的这个链接：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-TuwBCw.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-TuwBCw.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-TuwBCw.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-TuwBCw.webp" loading="lazy"/>
  </picture>

点击它就可以可视化看到所有的 key 和值：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-r378Cc.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-r378Cc.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-r378Cc.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-r378Cc.webp" loading="lazy"/>
  </picture>

同样也可以执行命令：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-UFpKLK.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-UFpKLK.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-UFpKLK.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-UFpKLK.webp" loading="lazy"/>
  </picture>





#### 数据类型

##### list 类型的数据结构

文档中有这么几个命令：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EXxewx.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EXxewx.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EXxewx.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EXxewx.webp" loading="lazy"/>
  </picture>

我们试一下：

```
lpush list1 111
lpush list1 222
lpush list1 333
```

输入上面的命令，点击执行：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EovyKL.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EovyKL.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EovyKL.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EovyKL.webp" loading="lazy"/>
  </picture>

然后回到浏览页面，点击刷新，就可以看到新的 key 和它的值：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-I62dXQ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-I62dXQ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-I62dXQ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-I62dXQ.webp" loading="lazy"/>
  </picture>

这就是一个列表的结构。

lpush 是 left push 的意思，执行后会从左到右添加到列表中。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MyhHmz.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MyhHmz.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MyhHmz.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MyhHmz.webp" loading="lazy"/>
  </picture>

rpush 是 right push 的意思，执行后会从右往左添加到列表中：

```
rpush list1 444
rpush list1 555
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-l2loEg.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-l2loEg.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-l2loEg.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-l2loEg.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oTSQLW.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oTSQLW.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oTSQLW.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oTSQLW.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-hhWYkj.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-hhWYkj.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-hhWYkj.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-hhWYkj.webp" loading="lazy"/>
  </picture>

lpop 和 rpop 自然是从左边和从右边删除数据。

```
lpop list1
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-RFXDNp.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-RFXDNp.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-RFXDNp.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-RFXDNp.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-vYfJs0.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-vYfJs0.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-vYfJs0.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-vYfJs0.webp" loading="lazy"/>
  </picture>

```
rpop list1
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-jOyUWz.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-jOyUWz.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-jOyUWz.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-jOyUWz.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-nPhBjJ.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-nPhBjJ.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-nPhBjJ.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-nPhBjJ.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-dQQ1Cs.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-dQQ1Cs.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-dQQ1Cs.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-dQQ1Cs.webp" loading="lazy"/>
  </picture>

如果想查看 list 数据呢？

```
lrange list1 0 -1
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-CHMYCB.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-CHMYCB.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-CHMYCB.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-CHMYCB.webp" loading="lazy"/>
  </picture>

输入一段 range，结尾下标为 -1 代表到最后。lrange list1 0 -1 就是查询 list1 的全部数据。

##### set

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-H7fISS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-H7fISS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-H7fISS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-H7fISS.webp" loading="lazy"/>
  </picture>

set 的特点是无序并且元素不重复。

当我添加重复数据的时候：

```
sadd set1 111
sadd set1 111
sadd set1 111
sadd set1 222
sadd set1 222
sadd set1 333
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MuY9rw.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MuY9rw.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MuY9rw.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-MuY9rw.webp" loading="lazy"/>
  </picture>

刷新之后可以看到它只保留去重后的数据：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-5XJedx.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-5XJedx.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-5XJedx.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-5XJedx.webp" loading="lazy"/>
  </picture>

可以通过 sismember 判断是否是集合中的元素：

```
sismember set1 111
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-c9RDpj.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-c9RDpj.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-c9RDpj.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-c9RDpj.webp" loading="lazy"/>
  </picture>

```
sismember set1 444
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-1DikFa.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-1DikFa.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-1DikFa.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-1DikFa.webp" loading="lazy"/>
  </picture>

set 只能去重、判断包含，不能对元素排序。

如果排序、去重的需求，比如排行榜，可以用 sorted set，也就是 zset，：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-wPQbtN.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-wPQbtN.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-wPQbtN.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-wPQbtN.webp" loading="lazy"/>
  </picture>

它每个元素是有一个分数的：

```
复制代码zadd zset1 5 guang
zadd zset1 4 dong
zadd zset1 3 xxx
zadd zset1 6 yyyy
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-w1cCyn.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-w1cCyn.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-w1cCyn.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-w1cCyn.webp" loading="lazy"/>
  </picture>

会按照分数来排序：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-0Uo6Lt.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-0Uo6Lt.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-0Uo6Lt.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-0Uo6Lt.webp" loading="lazy"/>
  </picture>

通过 zrange 命令取数据，比如取排名前三的数据：

```
zrange zset1 0 2
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oXbw7u.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oXbw7u.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oXbw7u.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-oXbw7u.webp" loading="lazy"/>
  </picture>





##### hash

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-3tHa1n.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-3tHa1n.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-3tHa1n.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-3tHa1n.webp" loading="lazy"/>
  </picture>

和我们用的 map 一样，比较容易理解：

```
hset hash1 key1 1
hset hash1 key2 2
hset hash1 key3 3
hset hash1 key4 4
hset hash1 key5 5
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-QyiJE0.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-QyiJE0.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-QyiJE0.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-QyiJE0.webp" loading="lazy"/>
  </picture>

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-X09vJS.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-X09vJS.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-X09vJS.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-X09vJS.webp" loading="lazy"/>
  </picture>

```
hget hash1 key3
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-Za7y8X.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-Za7y8X.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-Za7y8X.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-Za7y8X.webp" loading="lazy"/>
  </picture>

##### geo 的数据结构

就是经纬度信息，根据距离计算周围的人用的。

我们试一下：

```arduino
geoadd loc 13.361389 38.115556 "guangguang" 15.087269 37.502669 "dongdong" 
```

用 loc 作为 key，分别添加 guangguang 和 dongdong 的经纬度

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-VOje53.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-VOje53.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-VOje53.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-VOje53.webp" loading="lazy"/>
  </picture>

你会发现 redis 实际使用 zset 存储的，把经纬度转化为了二维平面的坐标：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-GGqvTc.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-GGqvTc.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-GGqvTc.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-GGqvTc.webp" loading="lazy"/>
  </picture>

你可以用 geodist 计算两个坐标点的距离：

```
复制代码geodist loc guangguang dogndong
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-ECFype.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-ECFype.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-ECFype.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-ECFype.webp" loading="lazy"/>
  </picture>

用 georadius 搜索某个半径内的其他点，传入经纬度、半径和单位：

```
复制代码georadius loc 15 37 100 km
georadius loc 15 37 200 km
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-51FQvm.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-51FQvm.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-51FQvm.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-51FQvm.webp" loading="lazy"/>
  </picture>

平时我们查找周围的人、周围的 xxx 都可以通过 redis 的 geo 数据结构实现。



#### 过期时间

一般 redis 的 key 我们会设置过期时间，通过 expire 命令。

比如我设置 dong1 的 key 为 30 秒过期：

```
expire dogn1 30
```

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EJHbya.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EJHbya.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EJHbya.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-EJHbya.webp" loading="lazy"/>
  </picture>

等到了过期时间就会自动删除：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-gOjcUO.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-gOjcUO.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-gOjcUO.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-gOjcUO.webp" loading="lazy"/>
  </picture>

想查剩余过期时间使用 ttl：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-A6pf9T.webp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-A6pf9T.webp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-A6pf9T.webp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-30-A6pf9T.webp" loading="lazy"/>
  </picture>

一些有时效的数据可以设置个过期时间。



### Node接入

redis 有很多的 [node 客户端的包](https://link.juejin.cn/?target=https%3A%2F%2Fredis.io%2Fresources%2Fclients%2F%23nodejs)：

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-44-2024-02-07-15-43-0ee372edb494479a868020cda99a4a0b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-44-2024-02-07-15-43-0ee372edb494479a868020cda99a4a0b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-44-2024-02-07-15-43-0ee372edb494479a868020cda99a4a0b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-15-44-2024-02-07-15-43-0ee372edb494479a868020cda99a4a0b~tplv-k3u1fbpfcp-jj-mark:1512:0:0:0:q75.awebp" loading="lazy"/>
  </picture>

最流行的就是 redis 和 ioredis 这两个。



### 实践

#### 计算附近的充电宝

https://juejin.cn/book/7226988578700525605/section/7269694290422169652





#### 计算文章阅读量

- 在 redis 中存储 user 和 article 的关系，比如 user_111_article_222 为 key，10 分钟后删除，如果存在这个 key，就说明该用户看过这篇文章，就不更新阅读量，否则才更新

  10 分钟后，这个人再看这篇文章，就可以算是新的一次阅读量了。

- 访问文章时把阅读量加载到 redis，之后的阅读量计数只更新 redis，不更新数据库，等业务低峰期再把最新的阅读量写入数据库

  这里在业务低峰期，比如凌晨 4 点的时候写入数据库，可以用定时任务来做。



# 一些工业上的功能实现

## 基于邮件验证码的登录

https://juejin.cn/book/7226988578700525605/section/7255223264820068392

就是请求发送验证码的时候服务端生成一码发邮件给用户同时响应给客户端，然后验证用户输入的跟服务端返回是否一致即可。





## 短链服务

就是存短链跟原链的映射关系，返回302进行重定向。302是因为便于记录短链的访问，不然直接301让他永久重定向了。

https://juejin.cn/book/7226988578700525605/section/7279592024737923087





## 实现二维码登录

服务端有个 qrcode/generate 接口，会生成一个随机的二维码 id，存到 redis 里，并返回二维码。

还有个 qrcode/check 接口，会返回 redis 里的二维码状态，浏览器里可以轮询这个接口拿到二维码状态。

手机 APP 扫码之后，如果没登录，会先跳转到登录页面，登录之后会进入登录确认页面。

这个时候就从二维码中拿到了 id，然后调用 qrcode/scan、qrcode/cancel、qrcode/confirm 就是修改二维码为不同的状态。

这时候用户是登录了的，jwt 的登录认证方式会携带 token，服务端只要从 token 中取出用户信息，存入 redis 即可。

然后另一边的轮询接口发现是确认状态，会根据用户信息生成 jwt 返回。

这样，手机 APP 里确认之后，pc 的浏览器就自动登录了该用户账号。

<picture>
    <source type="image/avif" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-20-45-image-20240206204517314.png?imageMogr2/format/avif">
    <source type="image/webp" srcset="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-20-45-image-20240206204517314.png?imageMogr2/format/webp">
    <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-20-45-image-20240206204517314.png" alt="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-06-20-45-image-20240206204517314.png" loading="lazy"/>
  </picture>







## 导出excel

一般用 exceljs 来实现。excel 文件分为 workbook、worksheet、row、cell 这 4 层，解析和生成都是按照这个层次结构来。

解析就是 readFile 之后，遍历 worksheet、row，拿到 cell 中的数据 。

生成就是 addWorkSheet、addRow 添加数据，然后 writeFile 来写入文件。

如果是在浏览器里，就把 readFile 换成 load，把 writeFile 换成 writeBuffer 就好了。

浏览器里生成 excel 之后，可以通过 a 标签触发下载，设置 download 属性之后，触发点击就好了。

https://juejin.cn/book/7226988578700525605/section/7318306151834255369
