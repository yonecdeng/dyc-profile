# 共识

3G的网络加载3mb的资源需要5s



# 开发时构建速度优化

webpack ： 

- cache-loader：如果两次构建源代码没有发生变化则使用缓存，不调用loader
- thread-loader： 开启多线程去构建



vite： 按需加载

# 浏览器卡顿

浏览器卡顿，原因可能是很多种：

1. 内存占用过高，导致GC、IO等卡顿
2. long task执行，导致JS线程执行时间过长
3. 线程上下文切换被锁住了
4. 渲染异常



# **[Chrome性能优化相关工具](https://mp.weixin.qq.com/s/wJxj5QbOHwH9cKmqU5eSQw)**

## Chrome Performance(性能)

Performance既是一个Chrome工具，可用于性能检测。

同样又是一套JS API，可在Chrome中执行。





### **Performance API介绍**

js中存在Performance API，可用于性能检测，具体如下

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-VXBJ9K.jpg)

![image-20240106144039561](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-06-14-40-image-20240106144039561.png)

- 【Process Unload Event】等待上一个页面卸载。在我们输入url后浏览器需要卸载上一个页面的内容然后再去执行`navigationStart`导航开始。
- 【Redirect】浏览器卸载完上一个页面后会执行`redirectStart`然后将当前页面重定向到用户新输入的url页面。完成重定向后会执行`redirectEnd`
- 【Service Worker Init】如果当前页面注册了Service Worker那么执行`workerStart`对Service Worker进行初始化操作。
- 【Service Worker Fecth Event 】浏览器准备好发送请求，在发送之前会执行`fetchStart`
- 【HTTP Cache】如果有缓存则直接取缓存，如果没有的话则继续解析
- 【DNS】如果没有缓存则执行`domainLookupStart` 然后去解析DNS，解析完会执行`domainLookupEnd`
- 【TCP】DNS解析完会执行`contentStart`，然后进行TCP三次握手，如果是HTTPS则执行`secureConnectionStart`进行SSL协商。完成后会执行`contentEnd`。
- 【Request】TCP连接创建完成后执行`requestStart`，然后开始真正的发送请求
- 【Response】请求被响应且首字节返回时会先执行`responseStart`，响应全部接收完毕后会执行`responseEnd`
- 【Processing】响应完执行`domLoading`开始加载dom，dom加载完毕后执行`domInteractive`，此时dom已经可以交互。然后执行`domContentLoadedEventStart`，当dom整个节点全部加载完毕并执行完`DOMContentLoaded`事件后会触发`domContentLoadedEventEnd`简称`DCL`当dom整个加载完成会执行`domComplete`，此时页面资源已经全部加载完毕。
- 【onLoad】当页面资源已经全部加载完毕后会执行`loadEventStart`，触发`window.onload`事件，`load`事件完成后会执行`loadEventEnd`。

### **使用Performance API获取性能指标**（web vitals）

- FP、FCP、LCP、CLS、FID、FMP 可通过 PerformanceObserver获取。
- TCP连接耗时、首字节到达时间、response响应耗时、DOM解析渲染的时间、TTI、DCL、L等可通过performance.timing获取。
- 长任务监听，PerformanceObserver 监听 longTask

#### TTFB 首字节时间

`TTFB（Time To First Byte）`: 从发送请求到数据返回第一个字节所消耗的时间

可以通过 performance api 计算出来：

```javascript
const { responseStart, requestStart } = performance.timing
const TTFB = responseStart - requestStart
```

或者通过 PerformanceObserver api：

```javascript
new PerformanceObserver((entryList) => {  
    const entries = entryList.getEntries();  
  
    for (const entry of entries) {  
        if (entry.responseStart > 0) {  
            console.log(`TTFB: ${entry.responseStart}`, entry.name);  
        }  
    }  
}).observe({  
    type: 'resource',  
    buffered: true  
});
```







#### FP 首次绘制（白屏时间）

`FP (First Paint) 首次绘制`: 第一个像素绘制到页面上的时间。

```js
const paint = performance.getEntriesByType('paint')
const FP = paint[0].startTime
```

`FP` 又称之为 First Non-Blank Pain，==白屏时间==，表示用户首次访问网站时，页面出现第一个文字或图像所花费的时间。白屏阶段的主要任务，包括解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面。通常情况下的瓶颈主要体现在**下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript**。

改善方式

- 生成骨架屏：

1. 手写 HTML、CSS 的方式为目标页定制骨架屏。
2. 使用图片作为骨架屏。
3. 自动生成并自动插入静态骨架屏，可以使用插件 [page-skeleton-webpack-plugin](https://github.com/ElemeFE/page-skeleton-webpack-plugin)、[vue-skeleton-webpack-plugin](https://github.com/lavas-project/vue-skeleton-webpack-plugin)。





#### FCP 首次内容绘制

`FCP (First Contentful Paint) 首次内容绘制` 从开始加载网页到第一个文本、图像、svg、非白色的 canvas 渲染完成之间的耗时。

可以通过 performance 的 api 计算出来：

```javascript
const paint = performance.getEntriesByType('paint')
const FCP = paint[1].startTime
```

也可以通过 PerformanceObserver 的 api 拿到：

```javascript
new PerformanceObserver((entryList) => {  
    for (const entry of entryList.getEntriesByName('first-contentful-paint')) {  
        console.log('FCP candidate:', entry.startTime, entry);  
    }  
}).observe({type: 'paint', buffered: true});
```



如何改善 FCP

- 加速或减少 HTTP 请求消耗
- 延迟加载
- 压缩体积
- 浏览器渲染原理，减少阻塞渲染 的 JS、CSS

字体加载是影响 FCP 的一个重要因素，字体通常是需要一段时间才能加载的大文件，有些浏览器在加载字体之前会隐藏文本。

```css
@font-face {
  font-family: "Pacifico";
  font-style: normal;
  font-weight: 400;
  src: local("Pacifico Regular"), localp("Pacifico-Regular"),
    url(https://fonts.gstatic.com/s/pacifico/v12/FwZY7-Qmy14u9lezJ-6H6MmBp0u-.woff2)
      format("woff2");
  font-display: swap;
}
```

对于自定义字体，还可以采用分段加载的方式，市面上可以使用 `.pbf` 格式，通常的字体库都是以 `ttf` 等格式的，但是 `ttf` 文件通常都比较大，比如宋体的 `ttf` 文件大小为 17.3 M，每次请求都要加载 17.3 M 的数据并且还要去解析，这个对于客户端以及服务端的压力都非常大。而 `pbf（protocol buffer` 是 google 的一个开源项目，用于结构化数据串行化。）分批请求，大大减小请求压力。



#### FMP 首次有效绘制

`FMP(First Meaningful Paint) 首次有效绘制`: 例如，在 YouTube 观看页面上，主视频就是主角元素.图片可以没加载完成，但整体的骨架已经加载完成了。

1秒内完成FMP的概率超过80%，那就代表这个网站是一个性能较好的网站 。`FMP` 时间过长一般意味着 `JavaScript` 阻塞了主线程，也有可能是后端/服务器的问题。

```js
let FMP = 0
const performanceObserverFMP = new PerformanceObserver((entryList, observer) => {
  const entries = entryList.getEntries()
  observer.disconnect()
  FMP = entries[0].startTime
})
// 需要在元素中添加 elementtiming="meaningful"
// 比如： <video elementtiming="meaningful" />
performanceObserverFMP.observe({ entryTypes: ['element'] })
```



#### LCP  最大内容渲染

`LCP (Largest Contentful Paint) 最大内容渲染`: 代表在viewport中最大的页面元素加载的时间。计算方式是从网页开始渲染到渲染完成，每次渲染内容都对比下大小，如果是更大的内容，就更新下 LCP 的值。LCP的数据会通过PerformanceEntry对象记录, 每次出现更大的内容渲染, 则会产生一个新的PerformanceEntry对象.(2019年11月新增)

```js
let LCP = 0

const performanceObserver = new PerformanceObserver((entryList, observer) => {
  const entries = entryList.getEntries()
  observer.disconnect()
  
  LCP = entries[entries.length - 1].startTime
})

performanceObserver.observe({ entryTypes: ['largest-contentful-paint'] })
```

为了提供良好的用户体验，LCP 应该在页面首次开始加载后的 2.5 秒内发生。

通常关注下面的元素：

- `<img>` 元素
- `<image>` 元素内的 `<svg>` 元素
- 通过 `url()` 函数加载背景图片的元素
- 包含文本节点或其他内联文本元素子级的块级元素。





#### TTI 可交互时间

`TTI (Time to Interactive) 可交互时间`: DOM树构建完毕，可以绑定事件的时间

计算方式为：

- 从 FCP 后开始计算
- 持续 5 秒内无长任务（大于 50ms） 且无两个以上正在进行中的 GET 请求
- 往前回溯至 5 秒前的最后一个长任务结束的时间，没有长任务的话就是 FCP 的时间

```js
const { domInteractive, fetchStart } = performance.timing
const TTI = domInteractive - fetchStart
```











#### DCL(HTML 文档被完全加载和解析)

`DCL (DomContentloaded)`: 当 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，无需等待样式表、图像和子框架（stylesheet、img 和 iframe ）的完成加载，有 async 加载的脚本也不一定完成。

```js
const { domContentLoadedEventEnd, fetchStart } = performance.timing
const DCL = domContentLoadedEventEnd - fetchStart
```

随着 Vue 和 React 等前端框架盛行， `DOMContentLoaded` 的值已不能表示首屏时间，因为其值只能表示**空白页**（当前页面 body 标签里面没有内容）加载花费的时间。浏览器需要先加载 JS , 然后再通过 JS 来渲染页面内容，这个时候**单页面类型**首屏才算渲染完成。





#### L 全部加载完毕

`L (onLoad)`, 页面上所有的 `DOM`，样式表，脚本，图片都已经加载完成了才会触发（渲染完毕了）

```js
const { loadEventStart, fetchStart } = performance.timing
const L = loadEventStart - fetchStart
```

它跟 `DOMContentLoaded` 很类似，我们也可以在 js 脚本中监听：

```js
window.addEventListener("DOMContentLoaded", (event) => {
  console.log("DOM fully loaded and parsed");
});
window.addEventListener("load", (event) => {
  console.log("page is fully loaded");
});
```

`DomContentloaded`事件与 `onLoad` 事件的区别是，浏览器解析 `HTML` 这个操作完成后立刻触发 `DomContentloaded` 事件，而只有页面所有资源都加载完毕后（比如图片，CSS），才会触发 `onLoad` 事件。



#### TBT 页面阻塞总时长

`TBT (Total Blocking Time) 页面阻塞总时长`: TBT汇总所有加载过程中阻塞用户操作的时长，在FCP和TTI之间任何long task（超过 50ms 的）中阻塞部分都会被汇总。

FID 是首次输入延迟，是从首次内容渲染（FCP）到可交互（TTI）之间，用户输入到页面响应的时间。

TBT 是阻塞总时长，是从首次内容渲染（FCP）到可交互（TTI）之间，所有 longtask 的总时长。

这俩指标很接近，所以可以用 TBT 代替 FID。



#### SI

`SI (Speed Index)`: 指标用于显示页面可见部分的显示速度, 单位是时间。

这个指标也有快、适度、慢的区间，用性能测试工具测量时会转为相应的分数：

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-4OYewh.webp)





#### FID 首次输入延迟

`FID (First Input Delay) 首次输入延迟`: 指标衡量的是从用户首次与您的网站进行交互（即当他们单击链接，点击按钮等）到浏览器实际能够访问之间的时间。页面的 FID 应当小于 100 毫秒。记录在 FCP 和 TTI 之间用户首次与页面交互时响应的延迟。

FID 是首次输入延迟，是从首次内容渲染（FCP）到可交互（TTI）之间，用户输入到页面响应的时间。

TBT 是阻塞总时长，是从首次内容渲染（FCP）到可交互（TTI）之间，所有 longtask 的总时长。

这俩指标很接近，所以可以用 TBT 代替 FID。（lighthouse里没有FID指标，因为没有用户输入）

```js
let FID = 0
const performanceObserverFID = new PerformanceObserver((entryList, observer) => {
  const entries = entryList.getEntries()
  observer.disconnect()
  FID = entries[0].processingStart - entries[0].startTime
})
performanceObserverFID.observe({ type: ['first-input'], buffered: true })
```



#### CLS 累积布局偏移

`CLS (Cumulative Layout Shift) 累积布局偏移`:记录了页面上非预期的位移波动。计算方式为：位移影响的面积 * 位移距离。

 总结起来就是一个元素初始时和其hidden之间的任何时间。如果元素偏移了, 则会被计算进去, 具体的计算方法可看这篇文章 https://web.dev/cls/。衡量视觉稳定性，比如页面内容的意外移动，在阅读文章的同时文字突然移动了、你突然找不到你阅读的位置了、点按钮的时候按钮被移动到其他地方了，这些原因通常是由于异步加载资源或将 DOM 元素动态添加到现有内容上方的页面而发生的。举个例子，比如一个图片没加载完的时候是 50 * 50 的大小，但是加载完之后变为了 100 * 100，这就是布局的波动，会影响体验。

为了提供良好的用户体验，页面的 CLS 应保持小于 0.1。可以监测尺寸未知的图像或视频、渲染后的字体等。

#### 以上两个指标的查看方式

- 可以安装 web-vitals npm 包
- 也可以使用 chrome 插件 web-vitals。





### Core Web Vitals

谷歌从上面的 Web Vitals 里选出了 3 个核心的，分别是 LCP、FID、CLS。

LCP 是最大内容渲染时间，代表页面已经完成了主要内容的渲染，这个指标可以用来衡量加载到渲染的性能。（FMP 是有意义的渲染，那个比较难定义）

FID 是衡量页面内容首次渲染（FCP）之后，到可交互（TTI）的这段时间内，用户点击按钮或者输入内容到页面响应的时间。是从用户交互角度衡量页面性能的指标。

CLS 是布局稳定性，是能反应用户体验的一个指标。

这三个核心指标分别代表了**加载性能、交互性能、视觉稳定性**。比较有代表性。





### 其他指标

#### FSP 首屏时间

`首屏时间`：也称**用户完全可交互时间**，即整个页面首屏完全渲染出来，用户完全可以交互，一般首屏时间小于页面完全加载时间，该指标值可以衡量页面访问速度

Chrome Performance 中的 Timing 没有记录 FSP（First Screen Paint）这个指标。因为这个首屏的记录灵活性很大，由应用自身来确定。

#### FPS （frame per second）

网页内容在不断变化之中，这些变化发生在首屏渲染以及用户的操作交互的时候。网页的 FPS 是指浏览器在渲染这些变化时的帧率。帧率越高，用户感觉网页越流畅，反之则会感觉卡顿。最优的帧率是 60，即 16.5ms 左右渲染一次。

##### 浏览器查看帧率

##### 第一种方法

打开 chrome 浏览器控制台，点击左上角工具栏，找到 `More Tools` 中的 `rendering`，勾选上 `FPS meter`。

![more-tools 打开 fps](https://naluduo.vip/Web-Performance-Optimization/assets/img/open-fps.6b18eac9.png)

即可看到左上觉出现帧率的面板显示。注意，网页不是随时都需要刷新帧，这个工具看到的是每次更新的 `FPS` 值。

可以配合通过以下的操作，进一步观察进行帧率。

- 修改 DOM
- 修改样式表
- 用户事件（比如鼠标悬停、页面滚动、输入框输入文字、改变窗口大小等等）

##### 第二种方法

1. 打开 `performance` 面板工具，看到 `reload` 后，进行点击。
2. 等待加载完毕后，即可查看记录。

![performance 查看 fps](https://naluduo.vip/Web-Performance-Optimization/assets/img/open-fps-2.a728ef2e.png)

绿色的直方图即代表在页面重新绘制时的帧率，Frames 为每一帧渲染所花的时间。



##### 如何改善 FPS

![img](https://naluduo.vip/Web-Performance-Optimization/assets/img/fps-3.3129dc85.png)

如果想达到 60 帧的刷新率，就意味着 JavaScript 线程每个任务的耗时，**必须少于 16 毫秒**。一个解决办法就是使用 [Web Worker，主线程只用于 UI 渲染，然后跟 UI 渲染不相干的任务，都放在 Worker 线程里







## **Coverage(覆盖率)**

获取代码未使用占比

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-biQEiW.png)





## **Lighthouse**



获取性能报告并查看推荐优化项

可以在本地安装命令行工具来使用，也可以通过Chrome来使用。

*命令行方式使用*

```
npm install -g lighthouse
lighthouse --view https://m.baidu.com
```

*在Chrome中使用*

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-YXEZlZ.png)



## **Network(网络)**

### **网络请求中的Timing(时间)**

能获取网络请求的时间消耗细节，可以根据耗时来决定优化策略。优先优化耗时最长的

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-B2cgAn.png)

【正在排队】网络请求队列的排队时间

【已停止】阻塞住用于处理其他事情的时间

【DNS查找】用于DNS解析IP地址的时间

【初始连接】创建TCP连接时间

【SSL】用于SSL协商的时间

【已发送请求】用于发送请求的时间

【等待中】请求发出至接收响应的时间也可以理解为服务端处理请求的时间

【下载内容】下载响应的时间

### **网络请求的优先级**

浏览器会根据资源的类型决定优先请求哪些资源，优先级高的请求能够优先被加载。

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-63IGH6.png)

右击此处勾选优先级可打开优先级功能，在请求中便可看到网络请求的优先级

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-ygTwPG.png)

不同资源类型的优先级排序如下

【最高】html、style

【高】font、fetch、script

【低】image、track

### **网页总资源信息**

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-hSwp1V.png)

【58个请求】网页一共多少个请求

【6.9 MB 项资源】网页资源一共6.9MB大小

【DOMContentLoaded：454 毫秒】DOM加载完毕的时长

【加载时间：1.02 秒】onload完毕的时长

### **Network配置**

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-37-pXgHgc.png)

# **[网页性能优化](https://mp.weixin.qq.com/s/wJxj5QbOHwH9cKmqU5eSQw)**

雅虎军规

等待资源加载时间和大部分情况下浏览器单线程执行是影响web性能的两大主要原因。

## **网络优化策略**

### **减少HTTP请求数**

合并JS、合并CSS、合理内嵌JS和CSS、使用雪碧图

### **使用HTTP缓存**

使用强制缓存可以不走网络请求，直接走本地缓存数据来加载资源。

使用协商缓存可以减少数据传输，当不需要更新数据时可通知客户端直接使用本地缓存。

### **使用 HTTP/2.0**

传统的 `HTTP 1.1` 存在**队头阻塞**的问题，同一个 TCP 管道中同一时刻只能处理一个 HTTP 请求，也就是说如果当前请求没有处理完，其它的请求都处于阻塞状态，另外浏览器对于同一域名下的并发请求数量都有限制，比如 Chrome 中只允许 `6` 个请求并发（这个数量不允许用户配置），也就是说请求数量超过 6 个时，多出来的请求只能**排队**、等待发送。

因此，在 HTTP 1.1 协议中，**队头阻塞**和**请求排队**问题很容易成为网络层的性能瓶颈。而 HTTP 2 的诞生就是为了解决这些问题，它主要实现了如下的能力：

- **多路复用**。将数据分为多个二进制帧，多个请求和响应的数据帧在同一个 TCP 通道进行传输，解决了之前的队头阻塞问题。而与此同时，在 HTTP2 协议下，浏览器不再有同域名的并发请求数量限制，因此请求排队问题也得到了解决。
- **Server Push**，即服务端推送能力。可以让某些资源能够提前到达浏览器，比如对于一个 html 的请求，通过 HTTP 2 我们可以同时将相应的 js 和 css 资源推送到浏览器，省去了后续请求的开销。

HTTP/2.0会将所有以`:`开头的请求头做一个映射表，然后使用`hpack`进行压缩，使用这种方式会使请求头更小。

使用上 HTTP2 之后，在某些情况下大量并行请求的问题会得到明显的改善，这里有一个多请求的示例项目，我已经放到了小册的[Github 仓库](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsanyuan0704%2Fjuejin-book-vite%2Ftree%2Fmain%2F19-performace%2Fmulti-request)中，在仓库中执行:

```js
npm run generate
```

即可生成 `100` 个 jsx 文件，我们在弱网环境下测试，这样对比的效果更加明显，实际情况如下:

> 由于某些预编译后的依赖体积比较大(如 react-dom)，为了避免影响测试的准确性，这里我们在二次刷新的情况下测试，此时预编译产物会被强缓存。

![image.png](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-w1pzSv.webp)

以页面首屏绘制的时间(FCP)来看，在开启了 HTTP2 之后，页面性能可以优化 60% 以上。而反观 HTTP 1.1 下的表现，不难发现大部分的时间开销用用在了请求排队上面，在并发请求很多的情况下性能直线下降。



### **避免重定向**

301、302 重定向会降低响应速度

### **使用 dns-prefetch**

DNS请求虽然占用的带宽较少，但会有很高的延迟，由其在移动端网络会更加明显。使用dns-prefetch可以对网站中使用到的域名提前进行解析。提高资源加载速度。

通过dns预解析技术可以很好的降低延迟，在访问以图片为主的移动端网站时，使用DNS预解析的情形中下页面加载时间可以减少5%。

```html
<link rel="dns-prefetch" href="https://a.hagan.com/">
```



一般情况下 `dns-prefetch`会与`preconnect` 搭配使用，前者用来解析 DNS，而后者用来会建立与服务器的连接，建立 TCP 通道及进行 TLS 握手，进一步降低请求延迟。使用方式如下所示:

```html
<link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>
<link rel="dns-prefetch" href="https://fonts.gstatic.com/">
```

> 值得注意的是，对于 preconnect 的 link 标签一般需要加上 crorssorigin(跨域标识)，否则对于一些字体资源 `preconnect` 会失效。



### **使用域名分片**

在HTTP/1.1中，一个域名同时最多创建6个TCP连接，将资源放在多个域名下可提高请求的并发数

### **CDN**

静态资源全上CDN，CDN能非常有效的加快网站静态资源的访问速度。减少每次 RTT 时长。

### **压缩**

服务端开启gzip压缩、html压缩、js压缩、css压缩、图片压缩。移除 HTML、CSS、JavaScript 文件中一些注释内容。

### **使用contenthash**

contenthash可以根据文件内容在文件名中加hash，可用于浏览器缓存文件，当文件没有改变时便直接取本地缓存数据

### **合理使用preload、prefetch**

#### 使用

preload预加载。prefetch空闲时间加载，它相当于告诉浏览器空闲的时候去预加载其它页面的资源，比如对于 A 页面中插入了这样的 `link` 标签:

```ts
<link rel="prefetch" href="https://B.com/index.js" as="script">
```

这样浏览器会在 A 页面加载完毕之后去加载`B`这个域名下的资源，如果用户跳转到了`B`页面中，浏览器会直接使用预加载好的资源，从而提升 B 页面的加载速度。



浏览器在页面 `onload` 完成一段时间后，发现还没有引用预加载的资源时，浏览器会在控制台输出下图的提示信息

<img src="https://mmbiz.qpic.cn/mmbiz_png/EibZvicb0pyanTibQrlYSYsNkgpCuC4nrA7U5oibU6iaGicmZIuzRGvzYCyKTy00ArLVlicQRFuA5PIfqfJJZx2um7kIQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />





#### 区别

两者都不会阻塞`onload`事件，`prefetch` 会在页面空闲时候再进行加载，是提前预加载之后可能要用到的资源，不一定是当前页面使用的，`preload` 预加载的是当前页面的资源。

#### 优先级

preload和prefetch可根据资源类型决定资源加载的优先级，详细优先级如代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- 最高 -->
  <link rel="preload" as="style" href="./file.xxx">

  <!-- 高 -->
  <link rel="preload" as="font" href="./file.xxx">
  <link rel="preload" as="fetch" href="./file.xxx">
  <link rel="preload" as="script" href="./file.xxx">

  <!-- 低 -->
  <link rel="preload" as="image" href="./file.xxx">
  <link rel="preload" as="track" href="./file.xxx">
  <title>Document</title>
</head>
<body>
  <article></article>
</body>
</html>
```

<img src="https://mmbiz.qpic.cn/mmbiz_png/EibZvicb0pyanTibQrlYSYsNkgpCuC4nrA7HzxoGrDxqcfTyAvaCohVjcO6iayKTunCKtspKk84bsl9rGicyv3vU01g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

#### 对于原生 ESM 模块

与普通 script 标签不同的是，对于原生 ESM 模块，浏览器提供了`modulepreload`来进行预加载:

```html
<link rel="modulepreload" href="/src/app.js" />
```

在 Vite 中我们可以通过配置一键开启 `modulepreload` 的 Polyfill，从而在使所有支持原生 ESM 的浏览器([占比 90% 以上](https://link.juejin.cn/?target=https%3A%2F%2Fcaniuse.com%2F%3Fsearch%3Dtype%3D%22%20module%22))都能使用该特性，配置方式如下:

```ts
// vite.config.ts
export default {
  build: {
    polyfillModulePreload: true
  }
}
```





## **浏览器渲染优化策略**

### **关键渲染路径**

当通过JS或者其他任意方式修改DOM后，浏览器会进入如下流程

【JS通过API修改DOM】>【计算样式】>【布局(重排)】>【绘制(重绘)】>【合成】

`Reflow 重排`：重排在Chrome Performance中叫做布局，通常添加或删除元素、修改元素大小、移动元素位置、获取位置信息都会触发页面的重排，因为重排可能会改变元素的大小位置等信息，这样的改变会影响到页面大量其它元素的大小位置信息，会耗费掉大量的性能，所以在实际应用中我们应该尽可能的减少重排

`Repaint 重绘`：重绘在Chrome Performance中叫做绘制，通常样式改变但没有影响位置时会触发重绘操作，重绘性能还好，但我们也需要尽量减少重绘，如果需要做一些动画，我们尽量使用CSS3动画，CSS3动画只需要在初始化时绘制一次，之后的动画都不会触发重绘操作。



### JS非阻塞加载

defer async 或者把script放body下面



### 减少 JavaScript 脚本执行时间

- 一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。
- 另一种是采用 Web Workers。Web Workers 中没有 DOM、CSSOM 环境，我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。





### **强制同步布局问题**

在==同一个函数内，修改元素后又获取元素的位置时会触发强制同步布局==，影响渲染性能

强制同步布局会使js强制将【计算样式】和【布局(重排)】操作提前到当前函数任务中，这样会导致每次运行时执行一次【计算样式】和【重排】，而正常情况下【计算样式】和【重排】操作会在函数结束后统一执行。

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <article id="article"></article>

  <script>
    const domArticle = document.querySelector('#article')
    // const { offsetTop } = domArticle

    function reflow () {
      const domH1 = document.createElement('h1')
      domH1.innerHTML = 'h1'

      domArticle.appendChild(domH1)

      /**
       * 强制同步布局
       * 在修改元素后又获取元素的位置时会触发强制同步布局，影响渲染性能
       * 解决办法是采用读写分离的原则，同一个函数内只读、只写
       */
      const { offsetTop } = domArticle
      console.log(offsetTop)
    }

    window.onload = () => {
      for (let i = 0; i < 10; i++) {
        reflow()
      }
    }
  </script>
</body>
</html>
```

在函数运行时执行了10次【计算样式】和【重排】

反复触发强制同步布局也叫**布局抖动**

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-wPJbWw.png)

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <article id="article"></article>

  <script>
    const domArticle = document.querySelector('#article')
    const { offsetTop } = domArticle

    function reflow () {
      const domH1 = document.createElement('h1')
      domH1.innerHTML = 'h1'

      domArticle.appendChild(domH1)

      /**
       * 强制同步布局
       * 在修改元素后又获取元素的位置时会触发强制同步布局，影响渲染性能
       * 解决办法是采用读写分离的原则，同一个函数内只读、只写
       */
      // const { offsetTop } = domArticle
      console.log(offsetTop)
    }

    window.onload = () => {
      for (let i = 0; i < 10; i++) {
        reflow()
      }
    }
  </script>
</body>
</html>
```

我们遵循读写分离的原则，将读取位置操作放到函数外，我们可以发现就算循环插入10个dom节点，也只需要执行一次【计算样式】和【重排】。

![图片](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-3KMoDf.png)

### **如何减少重排与重绘**

重绘不一定引起回流，但回流一定引起重绘。

- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 脱离文档流(绝对定位、固定定位)，脱离文档流的元素进行重排不会影响到其他元素。
- 图片渲染时增加宽高属性，宽高固定后，图片不会根据内容动态改变高度，便不会触发重排。
- 尽量用CSS3动画，CSS3动画能最大程度减少重排与重绘。
- 使用`will-change: transform;`将元素独立为一个单独的图层。（定位、透明、transform、clip都会产生独立图层）
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
- 为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。用一次回流替代多次回流
- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层

浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**。**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。



### 合理利用 CSS 合成动画

对某个元素做几何形状变换、透明度变换或者一些缩放操作时，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：

```css
.box {
will-change: transform, opacity;
}
```

这时候渲染引擎会将该元素单独实现一层（它占用的内存也会大大增加），等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。**这也是 CSS 动画比 JavaScript 动画高效的原因**。

注意：能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影，旋转等，这些变换都不会影响到图层的内容。比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。



### 离屏渲染

开辟一段内存，把我们要渲染的东西现在内存里渲染好，再添加到显示器上



### 避免频繁的垃圾回收

如果在一些函数中频繁创建临时对象，那么垃圾回收器会频繁地去执行垃圾回收策略。当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行。可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。





## **静态文件优化策略**



### **图片优化**

- 减少图片资源的尺寸和大小，节约用户流量
- 设置`alt="xxx"`属性，图像无法显示时会显示`alt`内容
- 图片懒加载， `loading="lazy"`为原生，建议使用`IntersectionObserver`自己做懒加载
- 不同环境加载不同尺寸和像素的图片`srcset`与`sizes`的使用。
- 采用渐进式加载 先加载占位图，然后加载模糊小图，最后加载真正清晰的图
- 使用Base64URL 减少图片请求数
- 采用雪碧图合并图片，减少请求数。HTTP2 的多路复用设计可以解决大量 HTTP 的请求导致的网络加载性能问题，因此雪碧图技术在 HTTP2 并没有明显的优化效果，这个技术更适合在传统的 HTTP 1.1 场景下使用(比如本地的 Dev Server)。

### **HTML优化**

- 语义化HTML，代码简洁清晰，利于SEO，便于开发维护。
- 减少HTML嵌套关系，减少DOM节点数量。
- 提前声明字符编码，让浏览器快速确定如何渲染网页内容`<html lang="en">` `<meta charset="UTF-8">`
- 删除多余空格、空行、注释、无用属性
- 减少iframe，子iframe会阻塞父级的onload事件。可以使用js动态给iframe赋值，就能解决这个问题。
- 避免table布局

### **CSS优化**

- 减少伪类选择器，减少选择器层数、减少通配符选择器、减少正则选择器
- 避免css表达式`background-color: expression(...)`
- 删除空格、空行、注释、减少无意义的单位、css压缩
- css外链，能走缓存
- 添加媒体字段，只加载有效的css文件

```html
<link rel="stylesheet" href="./small.css" media="screen and (max-width:600px)" />
<link rel="stylesheet" href="./big.css" media="screen and (min-width:601px)"/>
```

- 使用css `contain`属性，能控制对应元素是否根据子集元素的改变进行重排
- 减少`@import`使用，因为它使用串行加载

### **JS优化**

- 通过script的async、defer属性异步加载，不阻塞DOM渲染
- 减少DOM操作，缓存访问过的元素。
- 不直接操作真实DOM，可以先修改，然后一次性应用到DOM上。（虚拟DOM、DOM碎片节点）
- 使用webworker解决复杂运算，避免复杂运算阻塞主线程，webworker线程位于渲染进程
- 图片懒加载，使用`IntersectionObserver`实现

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      img {
        height: 200px;
        display: block;
      }
    </style>
    <title>Document</title>
  </head>
  <body>
    <img src="./loading.gif" data-src="./01.jpg" />
    <img src="./loading.gif" data-src="./02.jpg" />
    <img src="./loading.gif" data-src="./03.jpg" />
    <img src="./loading.gif" data-src="./04.jpg" />
    <img src="./loading.gif" data-src="./05.jpg" />
    <img src="./loading.gif" data-src="./06.jpg" />
    <img src="./loading.gif" data-src="./07.jpg" />
    <img src="./loading.gif" data-src="./08.jpg" />
    <img src="./loading.gif" data-src="./09.jpg" />
    <img src="./loading.gif" data-src="./10.jpg" />

    <script>
      const intersectionObserver = new IntersectionObserver((changes) => {
        changes.forEach((item, index) => {
          if (item.intersectionRatio > 0) {
            intersectionObserver.unobserve(item.target)
            item.target.src = item.target.dataset.src
          }
        })
      });

      const domImgList = document.querySelectorAll("img");
      domImgList.forEach((domImg) => intersectionObserver.observe(domImg));
    </script>
  </body>
</html>
```

- 虚拟滚动
- 使用`requestAnimationFrame`来做动画，使用`requestIdleCallback`来进行空闲时的任务处理
- 尽量避免使用eval，性能差。
- 使用事件委托，能减少事件绑定个数。事件越多性能越差。
- 尽量使用canvas、css3动画。
- 通过chrome覆盖率（Coverage）工具排查代码中未使用过的代码并将其删除
- 通过chrome性能（Performance）工具查看每个函数的执行性能并优化

### **字体优化**

FOUT(Flash of Unstyled Text）等待一段时间，如果没加载完成，先显示默认。加载 后再进行切换。

FOIT(F1ash of Invisib1e Text） 字体加载完毕后显示，加载超时降级系统字体（白 屏

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    @font-face {
      font-family: 'hagan';
      src: url('./font.ttc');
      font-display: swap;
      /* b1ock 35 内不显示，如果没加载完毕用默认的 */
      /* swap 显示老字体 在替换*/
      /* fa11back 缩短不显示时间，如果没加载完毕用默认的，和b1ock类似*
      /* optional 替换可能用字体 可能不替换*/
    }
    article {
      font-family: hagan;
    }
  </style>
  <title>Document</title>
</head>
<body>
  <article>ABC abc</article>  
</body>
</html>
```



## **浏览器储存优化策略**

### **Cookie**

`cookie`在过期之前一直有效，最大储存大小为4k，限制字段个数，不适合大量的数据储存，每次请求会携带`cookie`，主要用来做身份校验。

优化方式：

1. 需要合理设置`cookie`有效期
2. 根据不同子域划分`cookie`来减少`cookie`传输
3. 静态资源域名和`cookie`域名采用不同域名，避免静态资源请求携带`cookie`。

### **LocalStorage**

Chrome下最多储存5M，除非手动清除，否则一直存在。可以利用`localStorage`储存静态资源。比如储存网页的`.js`、`.css`，这样会使页面打开速度非常快。例如 https://m.baidu.com

*/index.js*

```js
const name = 'hagan'
function showName () {
  console.log(name)
}
showName()
```

*/index.html*

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script src="https://lib.baomitu.com/axios/0.26.1/axios.js"></script>
  <script>
    cacheFile('/index.js')

    async function cacheFile (url) {
      const fileContent = localStorage.getItem(url)
      if (fileContent) {
        eval(fileContent)
      } else {
        const { data } = await axios.get(url)
        eval(data)
        localStorage.setItem(url, data)
      }
    }
  </script>
</body>
</html>
```

### **SessionStorage**

会话级别储存，可用于页面间的传值

### **IndexDB**

浏览器的本地数据库，大小几乎无上限



## 编码优化

- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载



## 打包优化

- 压缩代码、图片资源压缩
- 分包
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包happypack
- splitChunks抽离公共文件
- sourceMap优化
- 按需加载





## **其他优化策略**

- 关键资源个数越多，首次页面加载时间就会越长
- 关键资源的大小，内容越小下载时间越短。
- 优化白屏，合理使用内联css、js，骨架屏
- 预渲染，打包时进行预渲染，生成静态HTML文件，用户访问时直接返回静态HTML（优化SEO）。
- 服务端渲染同构，加速首屏速度（耗费服务端资源），有利于SEO优化。首屏使用服务端渲染，后续交互使用客户端渲染。

## **使用PWA提高用户体验**

webapp用户体验差的一大原因是不能离线访问。用户粘性低的一大原因是无法保存入口，PWA就是为了解决webapp的用户体验问题而诞生的。使用PWA能令站点拥有快速、可靠、安全等特性。

1. Web App Manifest 将网站添加到电脑桌面、手机桌面，类似Native的体验。
2. Service Worker 配合Cache API，能做到离线缓存各种内容。
3. Push API 配合 Notification API，能做到类似Native的消息推送与实时提醒。
4. App Shell 配合 App Skeleton，能做App壳与骨架屏







## webpack 

《前端工程质量保障体系实践》

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

既然要优化构建速度，那么第一步就是分析出每个构建流程花费的时间，从而找到当前构建速度的性能瓶颈。开源社区提供了speed-measure-webpack-plugin（SMP）作为分析工具，开发人员可以使用它来测量webpack构建期间各个阶段花费的时间。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

webpack在进行打包构建时以entry配置的文件为入口，递归解析出文件中的import语句，来构建其内部依赖图。开发人员在使用import语句导入模块时，通常不会携带文件类型后缀。[插图]webpack会根据resolve.extensions中的配置，按照数组顺序来确定优先级，自动为文件添加类型后缀，尝试引入。resolve.extensions的默认值如下。[插图]

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

resolve.extensions数组越长，需要匹配的文件类型的后缀越靠后，webpack尝试的次数就越多，会导致构建时间变长，影响构建性能。开发人员在配置resolve.extensions时应尽可能缩减数组长度，将出现频次更高的文件类型后缀排在前面。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

webpack中规定exclude的优先级高于include。开发人员应该尽量避免使用exclude，直接使用include确定搜索范围。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

开发人员在设置resolve.mainFields时应该和resolve.extensions保持一个原则，尽可能缩减数组长度，将出现频次更高的入口字段排列在前。由于大部分npm包采用main字段描述入口文件的位置，因此可以直接显示声明mainFields为main，减少webpack检索的次数，提高解析效率。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

webpack在解析一些大型模块时会耗费大量的时间。例如，Lodash、jQuery和React，它们有成百上千个依赖文件。如果webpack对这些模块进行递归解析和依赖处理，那么将是一个极为耗时的操作。大型模块一般都提供了构建后的压缩版本，开发人员可以使用webpack提供的resolve.alias和module.noParse配置来跳过这部分解析构建工作。resolve.alias配置项可以将文件中的原导入路径替换成配置的导入路径。针对React、Lodash等大型模块，可以直接将导入文件替换成构建后的结果，避免递归解析文件引用浪费时间。[插图]module.noParse配置项可以让webpack跳过相关文件的解析工作，开发人员需要确定被跳过的文件中不含有import、require和define等命令或其他导入机制的调用。跳过这些大型模块的解析工作，可以有效提高构建性能。[插图]在一般情况下，每个项目中都有许多基础模块不会轻易变动。例如，react、react-router等基础功能库，这些基础库通常在项目搭建初期就确定了版本号，在后续迭代周期内进行更新。对于这些基础模块，webpack提供了dll能力，把这些基础库抽离出来单独打包。如果webpack开启了dll能力，那么在每次导入模块时都会扫描该模块是否在dll文件中。如果存在，则直接从dll中获取。配置DllPlugin插件，打包生成对应的dll文件。在dll文件生成后，如果依赖的基础模块没有更新，那么通常不会更新dll文件。[插图]当需要使用dll文件时，需要配置DllReferencePlugin插件。[插图]在使用dll文件时，需要确保已经通过DllPlugin插件生成了dll的json描述文件，此时再进行构建就会直接读取dll的构建结果，速度将大大提升。webpack解析完所有文件应用和模块后，就会进入打包环节。在这一环节中，可以通过环境变量区分是开发环境还是生产环境。如果处于开发环境中，就可以关闭代码压缩、CSS样式抽离等功能，进一步提高构建速度。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

cache-loader自身也有额外的性能开销，所以建议只对性能开销较大的loader使用此loader。如果项目里使用了TypeScript，那么可以更改tsconfig.json配置，开启增量编译模式。[插图]当每次tsc编译成功后都会生成tsbuildinfo文件，在下次编译时就会基于上次的构建结果进行增量编译，从而大大提高构建速度

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

webpack官方提供了thread-loader支持并行构建。开发人员只需在配置时将thread-loader放置在其他loader之前，后面的loader就会在一个单独的worker池中运行。[插图]开发人员在使用thread-loader时需要注意，在worker池中运行的loader会受到以下限制。• 不能产生新的文件。• 不能使用定制的loader API。• 不能读取webpack的选项设置。除此之外，thread-loader的worker本身也存在性能开销。每个worker都是一个独立的Node.js进程，在创建时会花费约600ms的时间。进程之间进行通信也会带来性能开销，开发人员应该将thread-loader用于处理一些性能开销比较大的loader。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

如果开发人员未进行自定义设置，那么webpack将根据以下条件自动拆分chunks。• 新的chunk可以被共享，或者模块来自node_modules文件夹。• 新的chunk体积大于20kb（min+gz之前的体积）。• 当按需加载chunks时，并行请求的最大数量小于或等于30。• 当加载初始化页面时，并发请求的最大数量小于或等于30。开发人员可以自定义模块抽离的逻辑。根据上述分析结果，自定义拆分逻辑。[插图]此时，使用webpack-bundle-analyzer重新分析，发现公共模块已经被抽离成common.j

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

Tree Shaking目前还存在一定的局限性，对需要处理的代码有严格要求。• 不能处理动态的模块化规范，例如CommonJS。• 不能处理异步加载的代码模块，因为Tree Shaking不知道这些代码何时会被加载。• 在处理第三方代码模块时，需要第三方模块提供符合ES6 Module语法的构建产物，并在package.json中通过module或者jsnext：main指定文件入口。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

在实际开发中，由于第三方模块没有提供符合ES6 Module语法的构建产物或其他原因，Tree Shaking往往不能生效，但是开发人员能确定某部分的代码不需要被引用。当遇见这种情况时，可以使用webpack内置的IgnorePlugin解决。通过IgnorePlugin指定需要忽略的文件的路径，webpack在打包时会直接跳过。以moment为例。通过webpack-bundle-analyzer进行分析，发现三分之二的代码都是用于国际化配置的，如图12-6所示。[插图]图12-6 moment 组成分析在实际开发中，通常只需要一种国际化配置即可，其余的国际化配置代码都可以直接删除。此时只需要为webpack.config.js添加以下代码即可。[插图]此时，再次进行构建，构建后的文件总体积缩减为原来的三分之一，结果如图12-7所示。[插图]图12-7 再次进行构建当使用IgnorePlugin插件忽略指定路径文件时，开发人员需要特别慎重。建议对新生成的代码进行回归测试，避免产生新的问题。

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

作用域提升（Scope Hoisting）

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

在webpack打包后的文件中，各个模块之间的变量和函数是隔离开的，模块内部的导出和导入分别通过__webpack_exports__和__webpack_require__实现。以下面两个文件的代码为例。[插图]在webpack不开启Scope Hoisting时，build.js打包结果如下。[插图][插图]修改webpack.config.js配置，开启optimization.concatenateModules，启用Scope Hoisting功能，重新打包后的build.js结果如下。[插图]对比两次的打包结果可以发现：从代码体积来看，代码量明显减少。foo函数直接打包在了b.js模块内部，并通过注释标明了此处的代码来源于a.js。从性能来看，减少了函数声明以及__webpack_exports__和__webpack_require__的调用，运行速度也会有所提升。和Tree Shaking一样，并不是所有模块都能使用Scope Hoisting。对于不支持ES6 Module的模块，webpack不会对其进行Scope Hoisting处理，可以通过stats.optimizationBailout来查看有哪些文件不满足条件。调整上述示例如下。[插图][插图]对上述示例进行构建，生成的build.js并不会进行Scope Hoisting优化，同时控制台会输出提示信息。[插图]

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

Categories用于配置需要分析的事项，Device用于配置本次测试设备类型。在所有配置完成后，单击“Generate Report”按钮即可对当前页面进行分析测试。







# JS优化实操

## 逻辑优化

1. 注意副作用的清除：比如setTimeout记得清除，不然下次再次挂载的时候就会开了两个重复的。

2. 节流、防抖

3. 使用事件委托

4. 尽量不要使用[JS动画](https://link.juejin.cn/?target=https%3A%2F%2Fzh.javascript.info%2Fjs-animation)，[css3动画](https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fcss3%2Fcss3-animations.html)和[canvas动画](https://juejin.cn/post/7008811592733655077)都比JS动画性能好

5. 对作用域的控制，比如：

   ```js
   const arr = [1,2,3]
   for(let i=0, len = arr.length; i<len;i++)}{} //这样比用 i<arr.length好，这样就不用每次访问都要到外面的作用域
   ```













## 加快首屏加载



### [懒加载](https://blog.csdn.net/qq_42136832/article/details/124251410)

#### 旧方案

##### 原理

- 获取图片元素，图片的`src`属性改为`data-src`，即`src`属性为空
- 添加==滚动事件监听==，判断图片位置和当前位置来给`src`赋值
- 判断元素是否出现在可视区有两种方法：



###### 方案一：通过整体距离来判断

`window.innerHeight` 是浏览器可视区的高度；

`document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动过的距离；

`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；

内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

![例图](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-ETx7Cy.webp)

```js
const images = document.querySelectorAll('img')
n = 0
let lazyload = (e) => {
  const clientHeight = document.documentElement.clientHeight
  const scrollTop = document.documentElement.scrollTop
  for (let i = n; i < images.length; i++) {
    if (images[i].offsetTop < clientHeight + scrollTop) { //内容达到显示区域
      images[i].setAttribute('src', images[i].getAttribute('data-src'))
      n = i + 1
    }
  }
  console.log('scroll触发');
}
```



###### 方案二：通过getBoundingClientRect()方法

- 在 scroll 事件处理程序中利用` Element.getBoundingClientRect().top`判断目标元素与视口的交叉状态；

- 当目标元素与视口的交叉状态大于0时，将真实的图片链接赋给目标元素 src 属性或者 backgroundImage 属性。

  ![](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-RhwwPT.png)

  ```js
  const images = document.querySelectorAll('img')
  let n = 0
  let lazyload = (e) => {
    for (let i = n; i < images.length; i++) {
      const imageTop = images[i].getBoundingClientRect().top //获取元素到视口顶部的距离
      if (imageTop < window.innerHeight) { //如果元素到视口顶部的距离小于视口的高度则加载
        images[i].setAttribute('src', images[i].getAttribute('data-src'))
        n = i + 1
      }
    }
    console.log('scroll触发');
  }
  ```



  JavaScript 提供 Element.getBoundingClientRect() 方法返回元素的大小以及相对于视口的位置信息，接下来会用到返回对象的四个属性：

- top 和 left 是目标元素左上角坐标与网页左上角坐标的偏移值；
- width 和 height 是目标元素自身的宽度和高度。

  再结合视口的高度和宽度，即可判断元素是否出现在视口区域内：

```css
function isElementInViewport (el) {
  const { top, height, left, width } = el.getBoundingClientRect()
  const w = window.innerWidth || document.documentElement.clientWidth
  const h = window.innerHeight || document.documentElement.clientHeight
  return (
    top <= h &&
    (top + height) >= 0 &&
    left <= w &&
    (left + width) >= 0
  )
```



##### 缺点

1. 滚动事件会一直触发，需要节流或者window.requestAnimationFrame()，做了节流之后就会有误差，刚好错过了那一次。
2. 都加载完了滚动事件还是会触发，其实已经不需要滚动事件了，要判断已经没有要监听的元素了就取消监听
3. 因为scroll 事件只有在滚动行为发生时才会被触发，所以刚打开页面时需要手动调用一次那个回调函数；
4. 运行scroll事件会占用主线程。



#### IntersectionObserver方案

##### `IntersectionObserver`是什么

它可以异步监听目标元素与其祖先或视窗的交叉状态，它不随着目标元素的滚动同步触发所以它并不会影响页面的滚动性能。

IntersectionObserver 构造函数接收两个参数，回调函数以及配置项。

###### 1、配置项

  配置项中的参数有以下三个：

- root：所监听对象的具体祖先元素，默认是 viewport ；
- rootMargin：计算交叉状态时，将 margin 附加到祖先元素上，从而有效的扩大或者缩小祖先元素判定区域；
- threshold：设置一系列的阈值，当交叉状态达到阈值时，会触发回调函数。

###### 2、回调函数

  IntersectionObserver 实例执行回调函数时，会传递一个包含 IntersectionObserverEntry 对象的数组，该对象一共有七大属性：

- time：返回一个记录从 IntersectionObserver 的时间原点到交叉被触发的时间的时间戳；
- target：目标元素；
- rootBounds：祖先元素的矩形区域信息；
- boundingClientRect：目标元素的矩形区域信息，与前面提到的 Element.getBoundingClientRect() 方法效果一致；
- intersectionRect：祖先元素与目标元素相交区域信息；
- intersectionRatio：返回intersectionRect 与 boundingClientRect 的比例值；
- isIntersecting：目标元素是否与祖先元素相交。

###### 3、实例方法

- observe：开始监听一个目标元素；
- unobserve：停止监听特定的元素；
- disconnect：使 IntersectionObserver 对象停止监听工作；
- takeRecords：为所有监听目标返回一个 IntersectionObserverEntry 对象数组并且停止监听这些目标。



##### 简易实现（用于了解原理）

```js
const images = document.querySelectorAll('img') //获取所有图片
const observer = new IntersectionObserver(callback) //传入回调函数
images.forEach(image => { //给所有图片添加监听
  observer.observe(image)
})

function callback(entries){
   entries.forEach(entry => {
     console.log(entry)
     if (entry.isIntersecting) {            // 监听到出现
       const image = entry.target           // 获取目标
       image.setAttribute('src', image.getAttribute('data-src'))
       observer.unobserve(image)            // 取消监听
       console.log('触发');
     }
   })
 }
```

##### [完整实现](https://juejin.cn/post/6844903688390049800#heading-4)

```js
class LazyImage {    
    constructor(selector) {      
    // 懒记载图片列表，将伪数组转为数组，以便可以使用数组的api      
        this.imageElements = Array.prototype.slice.call(document.querySelectorAll(selector))
        this.init()    
    }      
    inViewShow() {      
        let len = this.imageElements.length      
        for(let i = 0; i < len; i++) {        
            let imageElement = this.imageElements[i]        
            const rect = imageElement.getBoundingClientRect()        
            // 出现在视野的时候加载图片        
            if(rect.top < document.documentElement.clientHeight) {          
                imageElement.src = imageElement.dataset.src          
                // 移除掉已经显示的          
                this.imageElements.splice(i, 1)          
                len--          
                i--          
                if(this.imageElements.length === 0) {            
                   // 如果全部都加载完 则去掉滚动事件监听            
                    document.removeEventListener('scroll', this._throttleFn)         
                 }        
            }      
        }    
    }      
    throttle(fn, delay = 15, mustRun = 30) {      
        let t_start = null     
        let timer = null      
        let context = this      
        return function() {        
            let t_current = +(new Date())        
            let args = Array.prototype.slice.call(arguments)        
            clearTimeout(timer)        
            if(!t_start) {          
                t_start = t_current        
            }        
            if(t_current - t_start > mustRun) {          
                fn.apply(context, args)          
                t_start = t_current        
            } else {          
                timer = setTimeout(() => {            
                    fn.apply(context, args)          
                }, delay)        
            }      
        }    
    }      
    init() {      
       // 通过IntersectionObserver api判断图片是否出现在可视区域内，不需要监听Scroll来判断      
       if ("IntersectionObserver" in window) {        
            let lazyImageObserver = new IntersectionObserver((entries, observer) => { 
                 entries.forEach((entry, index) => {            
                    // 如果元素可见            
                    if (entry.isIntersecting) {              
                        let lazyImage = entry.target              
                        lazyImage.src = lazyImage.dataset.src              
                        lazyImage.classList.remove("lazy-image")              
                        lazyImageObserver.unobserve(lazyImage)              
                        // this.lazyImages.splice(index, 1)            
                    }          
                })        
            })        
            this.lazyImages.forEach(function(lazyImage) {          
                lazyImageObserver.observe(lazyImage);        
            })      
    } else {        
        this.inViewShow()        
        this._throttleFn = this.throttle(this.inViewShow)        
        document.addEventListener('scroll', this._throttleFn.bind(this))      
    }
  }  
}
// 调用例子
new LazyImage('.lazy-image')

```





## 一次性插入(渲染)大量数据

对于一次性插入大量数据的情况，一般有两种做法：

1. 时间分片
2. 虚拟列表



### 暴力做法

假设我们的长列表需要展示10000条记录，我们同时将10000条记录渲染到页面中，先来看看需要花费多长时间：

```xml
<button id="button">button</button><br>
<ul id="container"></ul>  

document.getElementById('button').addEventListener('click',function(){
    // 记录任务开始时间
    let now = Date.now();
    // 插入一万条数据
    const total = 10000;
    // 获取容器
    let ul = document.getElementById('container');
    // 将数据插入容器中
    for (let i = 0; i < total; i++) {
        let li = document.createElement('li');
        li.innerText = ~~(Math.random() * total)
        ul.appendChild(li);
    }
    console.log('JS运行时间：',Date.now() - now);
    setTimeout(()=>{
      console.log('总运行时间：',Date.now() - now);
    },0)

    // print JS运行时间： 38
    // print 总运行时间： 957 
  })
```

当我们点击按钮，会同时向页面中加入一万条记录，通过控制台的输出，我们可以粗略的统计到，JS的运行时间为`38ms`,但渲染完成后的总时间为`957ms`。

如何简单来统计`JS运行时间`和`总渲染时间`：

- 在 JS 的`Event Loop`中，当JS引擎所管理的执行栈中的事件以及所有微任务事件全部执行完后，才会触发渲染线程对页面进行渲染
- 第一个`console.log`的触发时间是在页面进行渲染之前，此时得到的间隔时间为JS运行所需要的时间
- 第二个`console.log`是放到 setTimeout 中的，它的触发时间是在渲染完成，在下一次`Event Loop`中执行的



然后，我们通过`Chrome`的`Performance`工具来详细的分析这段代码的性能瓶颈在哪里：

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-PKyVWB.gif)



从`Performance`可以看出，代码从执行到渲染结束，共消耗了`960.8ms`,其中的主要时间消耗如下：

- Event(click) : `40.84ms`
- Recalculate Style : `105.08ms`
- Layout : `731.56ms`
- Update Layer Tree : `58.87ms`
- Paint : `15.32ms`

从这里我们可以看出，我们的代码的执行过程中，消耗时间最多的两个阶段是`Recalculate Style`和`Layout`。

- `Recalculate Style`：样式计算，浏览器根据css选择器计算哪些元素应该应用哪些规则，确定每个元素具体的样式。
- `Layout`：布局，知道元素应用哪些规则之后，浏览器开始计算它要占据的空间大小及其在屏幕的位置。

在实际的工作中，列表项必然不会像例子中仅仅只由一个li标签组成，必然是由复杂DOM节点组成的。

那么可以想象的是，当列表项数过多并且列表项结构复杂的时候，同时渲染时，会在`Recalculate Style`和`Layout`阶段消耗大量的时间。

而`虚拟列表`就是解决这一问题的一种实现。



依照两次`console.log`的结果，可以得出结论：

<font color="red">对于大量数据渲染的时候，JS运算并不是性能的瓶颈，性能的瓶颈主要在于渲染阶段</font>







### 时间分片

`时间分片`适用于列表项的DOM结构十分简单的情况。

#### 使用`setTimeout`来实现分批渲染

```html
<ul id="container"></ul>

//需要插入的容器
let ul = document.getElementById('container');
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    setTimeout(()=>{
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)
            ul.appendChild(li)
        }
        loop(curTotal - pageCount,curIndex + pageCount)
    },0)
}
loop(total,index);

```

用一个gif图来看一下效果

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-QnpYUu.gif)

我们可以看到，页面加载的时间已经非常快了，每次刷新时可以很快的看到第一屏的所有数据，但是当我们快速滚动页面的时候，会发现页面出现闪屏或白屏的现象

##### 为什么会出现闪屏现象呢

`FPS`表示的是每秒钟画面更新次数。我们平时所看到的连续画面都是由一幅幅静止画面组成的，每幅画面称为一`帧`，`FPS`是描述`帧`变化速度的物理量。

大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次，`FPS`为60frame/s，为这个值的设定受屏幕分辨率、屏幕尺寸和显卡的影响。

因此，当你对着电脑屏幕什么也不做的情况下，大多显示器也会以每秒60次的频率正在不断的更新屏幕上的图像。

为什么你感觉不到这个变化？

那是因为人的眼睛有视觉停留效应，即前一副画面留在大脑的印象还没消失，紧接着后一副画面就跟上来了， 这中间只间隔了16.7ms(1000/60≈16.7)，所以会让你误以为屏幕上的图像是静止不动的。

大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。 



##### setTimeout 导致闪屏现象

- `setTimeout`的执行时间并不是确定的。在JS中，`setTimeout`任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此`setTimeout`的实际执行时间可能会比其设定的时间晚一些。
- 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而`setTimeout`只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。

以上两种情况都会导致setTimeout的执行步调和屏幕的刷新步调不一致。

在`setTimeout`中对dom进行操作，必须要等到屏幕下次绘制时才能更新到屏幕上，如果两者步调不一致，就可能导致中间某一帧的操作被跨越过去，而直接更新下一帧的元素，从而导致丢帧现象。



#### 使用 requestAnimationFrame

##### 初版

与`setTimeout`相比，`requestAnimationFrame`最大的优势是由系统来决定回调函数的执行时机。

我们使用`requestAnimationFrame`来进行分批渲染：

```html
<ul id="container"></ul>

//需要插入的容器
let ul = document.getElementById('container');
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    window.requestAnimationFrame(function(){
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)
            ul.appendChild(li)
        }
        loop(curTotal - pageCount,curIndex + pageCount)
    })
}
loop(total,index);
```

看下效果

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-z5UkU6.gif)

我们可以看到，页面加载的速度很快，并且滚动的时候，也很流畅没有出现闪烁丢帧的现象。



##### 结合 DocumentFragment

先解释一下什么是 DocumentFragment ，文献引用自[MDN](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FDocumentFragment)

> ```
> DocumentFragment`，文档片段接口，表示一个没有父级文件的最小文档对象。它被作为一个轻量版的`Document`使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为`DocumentFragment`不是真实DOM树的一部分，它的变化不会触发DOM树的（重新渲染) ，且不会导致性能等问题。
> 可以使用`document.createDocumentFragment`方法或者构造函数来创建一个空的`DocumentFragment
> ```

`DocumentFragments`是DOM节点，但并不是DOM树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。

当`append`元素到`document`中时，被`append`进去的元素的样式表的计算是同步发生的，此时调用 getComputedStyle 可以得到样式的计算值。 而`append`元素到`documentFragment` 中时，是不会计算元素的样式表，所以`documentFragment` 性能更优。当然现在浏览器的优化已经做的很好了， 当`append`元素到`document`中后，没有访问 getComputedStyle 之类的方法时，现代浏览器也可以把样式表的计算推迟到脚本执行之后。

最后修改代码如下：

```html
<ul id="container"></ul>

//需要插入的容器
let ul = document.getElementById('container');
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total/once
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal,curIndex){
    if(curTotal <= 0){
        return false;
    }
    //每页多少条
    let pageCount = Math.min(curTotal , once);
    window.requestAnimationFrame(function(){
        let fragment = document.createDocumentFragment();
        for(let i = 0; i < pageCount; i++){
            let li = document.createElement('li');
            li.innerText = curIndex + i + ' : ' + ~~(Math.random() * total)
            fragment.appendChild(li)
        }
        ul.appendChild(fragment)
        loop(curTotal - pageCount,curIndex + pageCount)
    })
}
loop(total,index);
```





#### 与虚拟列表的区别

1. 分片渲染最终还是会有所有dom，内存占用比较大。









### 虚拟列表(只渲染可见部分)

#### 为什么要虚拟列表

1. 首次渲染的时候只渲染可视部分。
2. 避免页面上有大量的dom结构，**`浏览器的回流和重绘的开销将会越来越大`**。
3. 滚动的时候可以跨越加载，比如我一下子滚到100，就先加载100，而不是要把前面99个都加载完才能滚到100继而渲染100。

#### 什么是虚拟列表

`虚拟列表`其实是按需显示的一种实现，即只对`可见区域`进行渲染，对`非可见区域`中的数据不渲染或部分渲染的技术。

假设有1万条记录需要同时渲染，我们屏幕的`可见区域`的高度为`500px`,而列表项的高度为`50px`，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-uHGF1u.png)



当滚动发生时，我们可以通过<font color="red">计算当前滚动值</font>得知此时在屏幕`可见区域`应该显示的列表项。假设滚动发生，滚动条距顶部的位置为`150px`,则我们可得知在`可见区域`内的列表项为`第4项`至`第13项。

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-trdtOI.png)



#### 可见区域和列表项定高

虚拟列表的实现，实际上就是在首屏加载的时候，只加载`可视区域`内需要的列表项，当滚动发生时，动态通过计算获得`可视区域`内的列表项，并将`非可视区域`内存在的列表项删除。

- 计算当前`可视区域`起始数据索引(`startIndex`)
- 计算当前`可视区域`结束数据索引(`endIndex`)
- 计算当前`可视区域的`数据，并渲染到页面中
- 计算`startIndex`对应的数据在整个列表中的偏移位置`startOffset`并设置到列表上

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-YBtPM3.png)



由于只是对`可视区域`内的列表项进行渲染，所以为了保持列表容器的高度并可正常的触发滚动，将Html结构设计成如下结构：

```xml
<div class="infinite-list-container">
    <div class="infinite-list-phantom"></div>
    <div class="infinite-list">
      <!-- item-1 -->
      <!-- item-2 -->
      <!-- ...... -->
      <!-- item-n -->
    </div>
</div>
```

- `infinite-list-container` 为`可视区域`的容器
- `infinite-list-phantom` 为容器内的占位，高度为总列表高度，用于形成滚动条
- `infinite-list` 为列表项的`渲染区域`

接着，监听`infinite-list-container`的`scroll`事件，获取滚动位置`scrollTop`

- 假定`可视区域`高度固定，称之为`screenHeight`
- 假定`列表每项`高度固定，称之为`itemSize`
- 假定`列表数据`称之为`listData`
- 假定`当前滚动位置`称之为`scrollTop`

则可推算出：

- 列表总高度`listHeight` = listData.length * itemSize
- 可显示的列表项数`visibleCount` = Math.ceil(screenHeight / itemSize)
- 数据的起始索引`startIndex` = Math.floor(scrollTop / itemSize)
- 数据的结束索引`endIndex` = startIndex + visibleCount
- 列表显示数据为`visibleData` = listData.slice(startIndex,endIndex)

当滚动后，由于`渲染区域`相对于`可视区域`已经发生了偏移，此时我需要获取一个偏移量`startOffset`，通过样式控制将`渲染区域`偏移至`可视区域`中。

- 将渲染区域往下平移的偏移量`startOffset` = startIndex * itemSize - itemSize * 预留的上面渲染的条数

  



最终的`简易代码`如下：

```ruby
<template>
  <div ref="list" class="infinite-list-container" @scroll="scrollEvent($event)">
    <div class="infinite-list-phantom" :style="{ height: listHeight + 'px' }"></div>
    <div class="infinite-list" :style="{ transform: getTransform }">
      <div ref="items"
        class="infinite-list-item"
        v-for="item in visibleData"
        :key="item.id"
        :style="{ height: itemSize + 'px',lineHeight: itemSize + 'px' }"
      >{{ item.value }}</div>
    </div>
  </div>
</template>

export default {
  name:'VirtualList',
  props: {
    //所有列表数据
    listData:{
      type:Array,
      default:()=>[]
    },
    //每项高度
    itemSize: {
      type: Number,
      default:200
    }
  },
  computed:{
    //列表总高度
    listHeight(){
      return this.listData.length * this.itemSize;
    },
    //可显示的列表项数
    visibleCount(){
      return Math.ceil(this.screenHeight / this.itemSize)
    },
    //偏移量对应的style
    getTransform(){
      return `translate3d(0,${this.startOffset}px,0)`;
    },
    //获取真实显示列表数据
    visibleData(){
      return this.listData.slice(this.start, Math.min(this.end,this.listData.length));
    }
  },
  mounted() {
    this.screenHeight = this.$el.clientHeight;
    this.start = 0;
    this.end = this.start + this.visibleCount;
  },
  data() {
    return {
      //可视区域高度
      screenHeight:0,
      //偏移量
      startOffset:0,
      //起始索引
      start:0,
      //结束索引
      end:null,
    };
  },
  methods: {
    scrollEvent() {
      //当前滚动位置
      let scrollTop = this.$refs.list.scrollTop;
      //此时的开始索引
      this.start = Math.floor(scrollTop / this.itemSize);
      //此时的结束索引
      this.end = this.start + this.visibleCount;
      //此时的偏移量
      this.startOffset = scrollTop - (scrollTop % this.itemSize);
    }
  }
};
```

[点击查看在线DEMO及完整代码](https://link.juejin.cn?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fvirtuallist-1-rp8pi)

最终效果如下：

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-434vWt.gif)



#### 可见区域定高和列表项不定高

当列表中包含文本之类的可变内容，会导致列表项的高度并不相同。比如这种情况：

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-XOBdj3.png)



在虚拟列表中应用动态高度的解决方案一般有如下三种：

1. 对组件属性`itemSize`进行扩展，支持传递类型为`数字`、`数组`、`函数`

- 可以是一个固定值，如 100，此时列表项是固高的
- 可以是一个包含所有列表项高度的数据，如 [50, 20, 100, 80, ...]
- 可以是一个根据列表项索引返回其高度的函数：(index: number): number

这种方式虽然有比较好的灵活度，但仅适用于可以预先知道或可以通过计算得知列表项高度的情况，依然无法解决列表项高度由内容撑开的情况。



2. 将列表项`渲染到屏幕外`，对其高度进行测量并缓存，然后再将其渲染至可视区域内。

由于预先渲染至屏幕外，再渲染至屏幕内，这导致渲染成本增加一倍，这对于数百万用户在低端移动设备上使用的产品来说是不切实际的。



3. 以`预估高度`先行渲染，然后获取真实高度并缓存。

这是我选择的实现方式，可以避免前两种方案的不足。预估高度的设置其实是有技巧的，列表项预估高度设置的越大，展现出来的数据就会越少，所以当预估高度比实际高度大很多的时候，很容易出现可视区域数据量太少而引起的可视区域出现部分空白。为了避免这种情况，我们的预估高度应该设置为列表项产生的最小值，这样尽管可能会多渲染出几条数据，但能保证首次呈现给用户的画面中没有空白

来看如何简易的实现：

定义组件属性`estimatedItemSize`,用于接收`预估高度`

```scss
props: {
  //预估高度
  estimatedItemSize:{
    type:Number
  }
}
```

定义`positions`，用于列表项渲染后存储`每一项的高度以及位置`信息，

```kotlin
this.positions = [
  // {
  //   top:0,
  //   bottom:100,
  //   height:100
  // }
];
```

并在初始时根据`estimatedItemSize`对`positions`进行初始化。

```kotlin
initPositions(){
  this.positions = this.listData.map((item,index)=>{
    return {
      index,
      height:this.estimatedItemSize,
      top:index * this.estimatedItemSize,
      bottom:(index + 1) * this.estimatedItemSize
    }
  })
}
```

由于列表项高度不定，并且我们维护了`positions`，用于记录每一项的位置，而`列表高度`实际就等于列表中最后一项的底部 距离列表顶部的位置。

```kotlin
//列表总高度
listHeight(){
  return this.positions[this.positions.length - 1].bottom;
}
```

在`渲染完成`后，获取列表每项的实际位置信息并缓存，使用钩子函数`updated`来实现：

```ini
    onUpdated(() => {
      if (!props.isFixedHeight) {
        const nodes = Array.from(listRef.value?.children as HTMLCollection)
        nodes!.forEach((node, index) => {
          const rect = node.getBoundingClientRect()
          const height = rect.height
          const oldHeight = positions[index].height
          const dValue = oldHeight - height
          //存在差值
          if (dValue) {
            positions[index].bottom = positions[index].bottom - dValue
            positions[index].height = height
            for (let k = index + 1; k < positions.length; k++) {
              positions[k].top = positions[k - 1].bottom
              positions[k].bottom = positions[k].bottom - dValue
            }
          }
        })
      }
    })
```

滚动后获取列表`开始索引`的方法修改为通过`缓存`获取：

```javascript
//获取列表起始索引
getStartIndex(scrollTop = 0){
  let item = this.positions.find(i => i && i.bottom > scrollTop);
  return item.index;
}
```

由于我们的缓存数据本身就是有顺序的，所以获取`开始索引`的方法可以考虑通过`二分查找`的方式来降低检索次数：

```ini
//获取列表起始索引
getStartIndex(scrollTop = 0){
  //二分法查找
  return this.binarySearch(this.positions,scrollTop)
},
//二分法查找
binarySearch(list,value){
  let start = 0;
  let end = list.length - 1;
  let tempIndex = null;
  while(start <= end){
    let midIndex = parseInt((start + end)/2);
    let midValue = list[midIndex].bottom;
    if(midValue === value){
      return midIndex + 1;
    }else if(midValue < value){
      start = midIndex + 1;
    }else if(midValue > value){
      if(tempIndex === null || tempIndex > midIndex){
        tempIndex = midIndex;
      }
      end = end - 1;
    }
  }
  return tempIndex;
},
```

滚动后将`偏移量`的获取方式变更：

```kotlin
scrollEvent() {
  //...省略
  if(this.start >= 1){
    this.startOffset = this.positions[this.start - 1].bottom
  }else{
    this.startOffset = 0;
  }
}
```

通过[faker.js](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmarak%2FFaker.js%2F) 来创建一些`随机数据`

```
pnpm install -D @faker-js/faker
```

```bash
let data = [];
for (let id = 0; id < 10000; id++) {
  data.push({
    id,
    value: faker.lorem.sentences() // 长文本
  })
}
```

[点击查看在线DEMO及完整代码](https://link.juejin.cn?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fvirtuallist2-1bqk6)

最终效果如下：



![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-OzCfyK.gif)

#### 遇到的问题

##### 当滚动过快时，会出现短暂的`白屏现象`。

##### 上下多渲染一些

为了使页面平滑滚动，我们还需要在`可见区域`的上方和下方渲染额外的项目，在滚动时给予一些`缓冲`，所以将屏幕分为三个区域：

- 可视区域上方：`above`
- 可视区域：`screen`
- 可视区域下方：`below`



![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-9KVWMq.png)



定义组件属性`bufferScale`,用于接收`缓冲区数据`与`可视区数据`的`比例`

```scss
props: {
  //缓冲区比例
  bufferScale:{
    type:Number,
    default:1
  }
}
```

可视区上方渲染条数`aboveCount`获取方式如下：

```kotlin
aboveCount(){
  return Math.min(this.start,this.bufferScale * this.visibleCount)
}
```

可视区下方渲染条数`belowCount`获取方式如下：

```kotlin
belowCount(){
  return Math.min(this.listData.length - this.end,this.bufferScale * this.visibleCount);
}
```

真实渲染数据`visibleData`获取方式如下：

```kotlin
visibleData(){
  let start = this.start - this.aboveCount;
  let end = this.end + this.belowCount;
  return this._listData.slice(start, end);
}
```

[点击查看在线DEMO及完整代码](https://link.juejin.cn?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fvirtuallist-3-i3h9v)

最终效果如下：

![img](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-02-07-17-38-D10o8k.gif)





##### 把节流设置成30ms。

我当时设置1000的节流还是有白屏。

*将滚动触发的回调函数进行节流处理。这里的等待时间不宜设置过长，不然会出现滑动到空白占位区域的情况*

​     ** 因为间隔时间过长的话，太久没有触发滚动更新事件，下滑就会到padding-bottom的空白区域*

​     ** 电脑屏幕的刷新频率一般是60HZ，渲染的间隔时间为16.6ms，我们的时间间隔最好小于两次渲染间隔16.6\*2=33.2ms，一般情况下30ms左右*



##### 在滚动的过程中，因为数据是重新计算并重绘上去的，所以在滚动过程中会出现细微抖动

一种解决方式就是劫持表格上的滚动事件，无论鼠标滚动多快，最终滚动条是慢慢的滚动到目标位置，给表格数据的渲染腾出时间，这样会解决上面的问题，但缺点是滚动的效果跟原生的滚动不一样，部分用户会不接受。这个推荐一个虚拟表格的组件，vxe-table，两种滚动模式都有实现。最后就是，表格中的数据尽量的使用文字和图片， 不要用svg，降低渲染压力，可以在滚动效果上有一定改善。

还有一种方法是 滚动到底之后加载数据，这样就不会滚动太快了，因为我是有那么多数据才可以滚动那么多。



#### 继续优化

##### 列表项不定高的会有抖动

可以看这两篇文章重新写一个：

[字节前端的做法](https://zhuanlan.zhihu.com/p/366416646)

[一个大学生的做法](https://juejin.cn/post/7085941958228574215#heading-13)

[某人的做法](https://juejin.cn/post/6844903959828627464)

##### IntersectionObserver 和 ResizeObserver

在前文中我们使用`监听scroll事件`的方式来触发可视区域中数据的更新，当滚动发生后，scroll事件会频繁触发，很多时候会造成`重复计算`的问题，从性能上来说无疑存在浪费的情况。可以使用[IntersectionObserver](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FIntersectionObserver)替换监听scroll事件，`IntersectionObserver`可以监听目标元素是否出现在可视区域内，在监听的回调事件中执行可视区域数据的更新，并且`IntersectionObserver`的监听回调是异步触发，不随着目标元素的滚动而触发，性能消耗极低。或者使用节流的方式。

我们虽然实现了根据列表项动态高度下的虚拟列表，但如果列表项中包含图片，并且列表高度由图片撑开，由于图片会发送网络请求，此时无法保证我们在获取列表项真实高度时图片是否已经加载完成，从而造成计算不准确的情况。但是这种任意由图片来撑开盒子大小的场景很少见，因为这样会显得整个列表很不规则。大多数展示图片的列表场景，其实都是提前确定要展示图片的尺寸的，比如微博，1张图片的尺寸是多少，2x2，3x3的尺寸是多少都是提前设计好的，只要我们给img标签加了固定高度，这样就算图片还没有加载出来，但是我们也能够准确的知道列表项的高度是多少。

如果你真的遇到了这种列表项会由图片任意撑开的场景，可以给图片绑定`onload`事件，等到它加载完之后再重新计算一下列表的高度，然后把它更新到缓存数据中，这是一种方法。其次我们可以使用[ResizeObserver](https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FResizeObserver)来监听列表项内容区域的高度改变，从而实时获取每一列表项的高度。



#### 比较好用的现成的虚拟列表

https://github.com/Akryum/vue-virtual-scroller/blob/master/packages/vue-virtual-scroller/README.md

https://github.com/tnfe/vue3-infinite-list/blob/main/README.zh-CN.md







# CSS优化实操

### CSS 优化和提高性能的方法

**加载性能：**

（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。

（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。

（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。

**选择器性能：**

（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；

（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。

（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。

（4）尽量少的去对标签进行选择，而是用class。

（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。

（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。

**渲染性能：**

（1）慎重使用高性能属性：浮动、定位。

（2）尽量减少页面重排、重绘。

（4）属性值为0时，不加单位。

（5）属性值为浮动小数0.**，可以省略小数点之前的0。

（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。

（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。

（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。

（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。



### 精灵图使用步骤

后来，图标字体（icon fonts）开始流行起来。这种解决方案不再把图标嵌入精灵图，而是把每个图标都作为字符放入自定义的字体文件。通过使用Web字体，单个字符将被渲染成图标。这样的服务类似于Font-Awesome，提供了几百个常见的图标，图标使用变得非常简单。以上这些技术还在使用，但我还是建议你使用SVG图标。SVG功能更强大，性能更好。SVG可以作为<img>源使用，本章就这么用过，但SVG还有其他用法。我们可以创建SVG精灵图，而且因为SVG是基于XML的文件格式，所以可以直接在HTML中使用它。

![image-20220506113600764](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com//css/知识/精灵图使用步骤.png)

```css
/*示例：*/
.xtx-service .container a::before {
  content: "";
  display: inline-block;
  width: 58px;
  height: 58px;
  background: url(../images/sprites.jpeg) -16px -28px;
  margin-right: 19px;
  vertical-align: middle;
}
```

默认盒子里展示的是精灵图的左上角

用到图片一般都要调整`vertical-align:middle`



## 优化图片

### 总览

1. 使用CSS3代替图片：有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好
2. 图片懒加载：在图片即将进入可视区域的时候进行加载
3. 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。
4. 小图使用 *base64* 格式
5. 将多个图标文件整合到一张图片中（雪碧图）
6. 选择正确的图片格式：

- 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好
- 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替
- 照片使用 JPEG



### 雪碧图

一般把首页用到的小图片才放到雪碧图中，不然会影响首页加载的时间。而且也就首页加载的时候可能请求许多图片，其他模块加载没必要再弄成雪碧图（看情况吧，反正一次性把这个模块用到的请求过来就行）。

