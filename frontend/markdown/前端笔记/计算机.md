



# 术语

## 元数据

可以理解成schema。

以文件的数据和元数据举例：

●数据：用户创建的文档、图片、视频和程序等数据内容

●元数据：文件的名称、文件在外部存储器中的位置和文件大小等辅助信息

## DSL（领域特定语言）

## QPS

QPS  "每秒查询率"（Queries Per Second），用来衡量系统、服务或应用程序在一秒内能够处理的查询或请求的数量的指标。 通常用于评估系统的吞吐量和响应能力。





## PV

用户的每一次页面浏览会被看作一个 PV，逐渐累计成为 PV 总数（同一个用户的多次访问不会去重）。







## 拓扑

拓扑 [Topological Order](https://link.juejin.cn/?target=https%3A%2F%2Fturborepo.org%2Fdocs%2Fglossary%23topological-order) 是一种排序 拓扑排序是依赖优先的术语， 如果 A 依赖于 B，B 依赖于 C，则拓扑顺序为 C、B、A。

## 笛卡尔积

笛卡尔积（Cartesian product）是集合论中的一个概念，它用来表示两个或多个集合的所有可能的有序对组合。

数学上，笛卡尔积 A × B 可以用以下方式表示：

`A × B = {(a, b) | a ∈ A, b ∈ B}`

举例来说，如果集合 A 包含{1, 2}，集合 B 包含{a, b}，那么它们的笛卡尔积 A × B 就是：

`A × B = {(1, a), (1, b), (2, a), (2, b)}`

这个结果集合包含了 A 和 B 的所有可能的有序对组合。笛卡尔积在数学、计算机科学和其他领域中都有广泛的应用，特别是在关系数据库中，用于描述表之间的关联关系。

# mac电脑

## 快捷键

原生的

编辑相关：

shift + ↑←→↓为 选中

opt + ↑↓ 为 移动这一行

opt + ←→ 为 将光标跳过这个单词



其它：

ctrl+↑←→↓ 为 切屏







## 路径

`~` 是指 `/Users/yonecdeng`

`$HOME`也是指 `/Users/yonecdeng`

pnpm全局安装的包貌似放到这里：`/Users/yonecdeng/Library/pnpm`



## 查看隐藏文件&目录

快捷键 ： `command + shift + . `



## 现在打开终端node的默认版本16

因为我在`.zshrc`文件中加入了 `nvm use 16` 这行代码。



# 编码

## base64

base64 就是 26 个大写字母、26 个小写字母、10 个数字、2 个特殊字符，一共 64 个字符。

而 base62 则是去掉了两个特殊字符，一共 62 个字符。做短链一般用base62。





# 软件工程

API（Application Programming Interface）和SDK（Software Development Kit）



# 计算机组成原理

## 计算机五大单元组成

控制器、运算器（可理解成控制器+运算器=CPU）、存储器单元（内存与外存（磁盘+光驱））、输入单元、输出单元

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-02-17-05-image-20240102170530445.png" alt="image-20240102170530445" style="zoom:25%;" />



计算机系统运行时，在硬件设备上会重复执行以下步骤。

① 通过输入设备或网络适配器，向计算机发起请求。

② 读取内存中的命令，并在CPU上执行，把结果写入负责保存数据的内存区域中。

③ 将内存中的数据写入HDD（Hard Disk Drive，硬盘驱动器）、SDD（Solid State Disk，固态硬盘）等存储器，或者通过网络发送给其他计算机，或者通过输出设备提供给用户。

④回到步骤①。

由这些重复执行的步骤整合而成的对用户有意义的处理，就称为程序



## 性能指标

吞吐量 = 处理完成的进程数量 / 耗费的时间

●延迟 = 结束处理的时间 – 开始处理的时间

对于吞吐量，基本上可以简单地理解为，CPU的计算资源消耗得多，或者说空闲状态的时间占比越低，吞吐量就越大。



## 计算机单位

计算机数据存储数据的**基本单位是****[字节](https://baike.baidu.com/item/字节/1096318)**(Byte)，**最小单位是****[位](https://baike.baidu.com/item/位/7202673)**(bit)。8个bit组成一个Byte([字节](https://baike.baidu.com/item/字节))，能够容纳一个英文[字符](https://baike.baidu.com/item/字符)，一个汉字需要两个字节的存储空间





## 编码

### 字符编码

计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有`0`和`1`两种状态，因此八个二进制位就可以组合出256种状态）。也就是说，一个字节一共可以用来表示256种不同的字符。

UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示）

UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号

UTF-8 的编码规则很简单，只有二条：

1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2）对于`n`字节的符号（`n > 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

下表总结了编码规则，字母`x`表示可用编码的位。

> ```
> Unicode符号范围     |        UTF-8编码方式
> (十六进制)        |              （二进制）
> ----------------------+---------------------------------------------
> 0000 0000-0000 007F | 0xxxxxxx
> 0000 0080-0000 07FF | 110xxxxx 10xxxxxx
> 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
> 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
> ```

跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节。

下面，还是以汉字`严`为例，演示如何实现 UTF-8 编码。

`严`的 Unicode 是`4E25`（`100111000100101`），根据上表，可以发现`4E25`处在第三行的范围内（`0000 0800 - 0000 FFFF`），因此`严`的 UTF-8 编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`严`的最后一个二进制位开始，依次从后向前填入格式中的`x`，多出的位补`0`。这样就得到了，`严`的 UTF-8 编码是`11100100 10111000 10100101`，转换成十六进制就是`E4B8A5`。



### Base64

Base64编码是一种将二进制数据转换为可打印字符的编码方式。Base64编码可以用于任何二进制数据，包括图像、音频、视频等。











# <span id='shell'>shell编程(各种系统下的命令解释器)</span>



## 命令解析器

### 介绍

本质：对用户输入的命令进行解析，调用对应的执行程序。

通过命令操控计算机在 DOS、Linux 系统中最常用的方式。命令操作的核心便是命令解析器（如 Linux 中的 Shell）。命令解析器实现接收命令字符串，解析命令并执行相应操作。

常见命令解析器：

- shell：Unix操作系统下的命令解析器
- cmd：Windows 命令解释器
- PowerShell：一种跨平台的任务自动化和配置管理框架，由命令行管理程序和脚本语言组成。(win10 默认提供)



### 命令执行流程

当用户在终端键入一个命令后，系统的执行流程如下：

##### 判断命令路径

先判断该命令是否包含了路径，如果命令已经存在有路径，则会直接读取该路径下的命令文件以执行。

##### 判断是内部还是外部命令

当用户在终端键入一个字符后，命令解析器就需要判断该字符是系统内部命令还是系统外部命令。所谓内部命令，就是这该命令常驻内存，直接执行即可（例如：cd、ls），外部命令就是指命令的代码在磁盘中，在执行时需要先把磁盘中的命令代码读入内存才能执行。

##### 在 PATH 变量中查找命令

如果用户键入的命令不是内部命令，又没有包含命令路径的话，那么就需要去系统环境变量 PATH 中配置的目录中进行查找。我们平时很多软件需要配置 PATH 环境变量的原因也在于此。

##### 报错

输入的不是命令。





### 配置终端

#### 安装on my zsh

#### 设置zsh的主题

改`.zshrc`文件即可，所有主题https://github.com/ohmyzsh/ohmyzsh/wiki/Themes







## 概念

![image-20230428172137995](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-28-17-21-image-20230428172137995.png)

![image-20230428172308117](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-28-17-23-image-20230428172308117.png)



## 环境变量文件

- 如果使用 Bash Shell，编辑 `~/.bash_profile` 或 `~/.bashrc` 文件。
- 如果使用 Zsh Shell，编辑 `~/.zshrc` 文件





## 常用命令

https://www.runoob.com/linux/linux-command-manual.html

### 各种命令知识图谱

![image](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-23-10-33-image.png)

### `diff` 命令

`diff` 命令可以比较两个目录中的文件和子目录，并显示它们之间的差异。例如，`diff -r dir1 dir2` 可以比较 `dir1` 和 `dir2` 目录及其子目录之间的差异。

### 测量指令执行时所需消耗的时间及系统资源time

`time [options] COMMAND [arguments]`



### 在环境变量$PATH设置的目录里查找符合条件的文件which

which指令会在环境变量$PATH设置的目录里查找符合条件的文件。

#### 语法

```
which [文件...]
```

**参数**：

- -n<文件名长度> 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
- -p<文件名长度> 　与-n参数相同，但此处的<文件名长度>包括了文件的路径。
- -w 　指定输出时栏位的宽度。
- -V 　显示版本信息。

#### 实例

使用指令"which"查看指令"bash"的绝对路径，输入如下命令：

```
$ which bash
```

上面的指令执行后，输出信息如下所示：

```
/bin/bash                   #bash可执行程序的绝对路径 
```

或者 `which node`



### 打印(输出)

echo、printf 打印

### curl

用来请求 Web 服务器。名字就是客户端（client）的 URL 工具的意思。



#### **不带任何参数**

不带有任何参数时，curl 就是发出 GET 请求。就可以看到网页源码。`　　$ curl www.sina.com`



#### 参数

##### **构造 URL 的查询字符串 -G**

`-G`参数用来构造 URL 的查询字符串。

> ```bash
> $ curl -G -d 'q=kitties' -d 'count=20' https://google.com/search
> ```

上面命令会发出一个 GET 请求，实际请求的 URL 为`https://google.com/search?q=kitties&count=20`。如果省略`--G`，会发出一个 POST 请求。

如果数据需要 URL 编码，可以结合`--data--urlencode`参数。

> ```bash
> $ curl -G --data-urlencode 'comment=hello world' https://www.example.com
> ```





##### 网页保存下来 -o -O

`$ curl -o [文件名] www.sina.com`

`-O`参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。

> ```bash
> $ curl -O https://www.example.com/foo/bar.html
> ```

上面命令将服务器回应保存成文件，文件名为`bar.html`。





##### 自动跳转 -L

> 　　`$ curl -L www.sina.com`

键入上面的命令，结果就自动跳转为www.sina.com.cn。curl 默认不跟随重定向。



##### **显示头信息** -i -I(--head)

`-i`参数先输出http response的头信息，然后空一行，再输出网页的源码。`-I(--head)`参数则是只显示http response的头信息。

> 　　`$ curl -i www.sina.com`





##### 模拟慢网速的环境`--limit-rate`

用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境

> ```bash
> $ curl --limit-rate 200k https://google.com
> ```

上面命令将带宽限制在每秒 200K 字节。











##### **显示通信过程 -v** --trace --trace-ascii

`-v`参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。

> 　　`$ curl -v www.sina.com`

如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。

> 　　`$ curl --trace output.txt www.sina.com`

或者

> 　　`$ curl --trace-ascii output.txt www.sina.com`

运行后，请打开output.txt文件查看。



##### **HTTP动词** -X

curl默认的HTTP动词是GET，使用`-X`参数可以支持其他动词。

　`$ curl -X POST www.example.com`

　`$ curl -X DELETE www.example.com`



##### **发送表单信息** -d --data --data-urlencode

使用`-d`参数以后，HTTP 请求会自动加上标头`Content-Type : application/x-www-form-urlencoded`。并且会自动将请求转为 POST 方法，因此可以省略`-X POST`。

`-d`参数可以读取本地文本文件的数据，向服务器发送。

> ```bash
> $ curl -d '@data.txt' https://google.com/login
> ```

发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。

　　`$ curl example.com/form.cgi?data=xxx`

POST方法必须把数据和网址分开，curl就要用到--data参数。

　`$ curl -X POST --data "data=xxx" example.com/form.cgi`

如果你的数据没有经过url编码，还可以让curl为你编码(比如空格需要进行编码)，参数是`--data-urlencode`。

　　`$ curl -X POST--data-urlencode "date=April 1" example.com/form.cgi`



##### 错误信息 -S -s

`-s`参数将不输出错误和进度信息。

> ```bash
> $ curl -s https://www.example.com
> ```

上面命令一旦发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。

如果想让 curl 不产生任何输出，可以使用下面的命令。

> ```bash
> $ curl -s -o /dev/null https://google.com
> ```



`-S`参数指定只输出错误信息，通常与`-s`一起使用。

> ```bash
> $ curl -s -o /dev/null https://google.com
> ```

上面命令没有任何输出，除非发生错误。





##### 代理**-x** -X

`-x`参数指定 HTTP 请求的代理。

> ```bash
> $ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com
> ```

上面命令指定 HTTP 请求通过`myproxy.com:8080`的 socks5 代理发出。

如果没有指定代理协议，默认为 HTTP。

> ```bash
> $ curl -x james:cats@myproxy.com:8080 https://www.example.com
> ```

上面命令中，请求的代理使用 HTTP 协议。



`-X`参数指定 HTTP 请求的方法。

> ```bash
> $ curl -X POST https://www.example.com
> ```

上面命令对`https://www.example.com`发出 POST 请求。



##### **文件上传 **--form -F

假定文件上传的表单是下面这样：

> 　　<form method="POST" enctype='multipart/form-data' action="upload.cgi">
> 　　　　<input type=file name=upload>
> 　　　　<input type=submit name=press value="OK">
> 　　</form>

你可以用curl这样上传文件：

> 　　`$ curl --form upload=@localfilename --form press=OK [URL]`



`-F`参数用来向服务器上传二进制文件。

> ```bash
> $ curl -F 'file=@photo.png' https://google.com/profile
> ```

上面命令会给 HTTP 请求加上标头`Content-Type: multipart/form-data`，然后将文件`photo.png`作为`file`字段上传。

`-F`参数可以指定 MIME 类型。

> ```bash
> $ curl -F 'file=@photo.png;type=image/png' https://google.com/profile
> ```

上面命令指定 MIME 类型为`image/png`，否则 curl 会把 MIME 类型设为`application/octet-stream`。

`-F`参数也可以指定文件名。

> ```bash
> $ curl -F 'file=@photo.png;filename=me.png' https://google.com/profile
> ```

上面命令中，原始文件名为`photo.png`，但是服务器接收到的文件名为`me.png`。











##### **Referer字段 **--referer -e

有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。

> 　`　$ curl --referer http://www.example.com http://www.example.com`





##### **User Agent字段** -A  --user-agent

curl 的默认用户代理字符串是`curl/[version]`。这个字段是用来表示客户端的设备信息。

curl可以这样模拟：

> 　`　$ curl --user-agent "[User Agent]" [URL]`

> ```bash
> $ curl -A '' https://google.com
> ```

上面命令会移除`User-Agent`标头。





##### **cookie **--cookie -b       -c

使用`--cookie`参数，可以让curl发送cookie。

> 　　`$ curl --cookie "name=xxx" www.example.com`

至于具体的cookie的值，可以从http response头信息的`Set-Cookie`字段中得到。

`-c cookie-file`可以保存服务器返回的cookie到文件，`-b cookie-file`可以使用这个文件作为cookie信息，进行后续的请求。

> 　　`$ curl -c cookies http://example.com`
> 　　`$ curl -b cookies http://example.com`



> ```bash
> $ curl -b 'foo1=bar;foo2=bar2' https://google.com
> ```

上面命令发送两个 Cookie。



##### **增加头信息 **--header -H

有时需要在http request之中，自行增加一个头信息。`--header`参数就可以起到这个作用。

> 　　`$ curl --header "Content-Type:application/json" http://example.com`



> ```bash
> $ curl -H 'Accept-Language: en-US' -H 'Secret-Message: xyzzy' https://google.com
> ```

上面命令添加两个 HTTP 标头。





##### `-k`参数指定跳过 SSL 检测

> ```bash
> $ curl -k https://www.example.com
> ```

上面命令不会检查服务器的 SSL 证书是否正确。













##### **认证 **--user -u

`-u`参数用来设置服务器认证的用户名和密码。

> 　`　$ curl --user name:password example.com`





> ```bash
> $ curl -u 'bob:12345' https://google.com/login
> ```

上面命令设置用户名为`bob`，密码为`12345`，然后将其转为 HTTP 标头`Authorization: Basic Ym9iOjEyMzQ1`。

curl 能够识别 URL 里面的用户名和密码。

> ```bash
> $ curl https://bob:12345@google.com/login
> ```

上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。

> ```bash
> $ curl -u 'bob' https://google.com/login
> ```

上面命令只设置了用户名，执行后，curl 会提示用户输入密码。







### 查看端口占用(lsof)

`lsof -i:3000`





### 杀进程kill

`kill [pid]`

















### 波浪符号（~）

表示用户的主目录。在不同的操作系统中，波浪符号的具体含义可能有所不同：

**macOS 和 Linux**： 在 macOS 和大多数 Linux 发行版中，波浪符号（~）表示当前用户的主目录。例如，如果当前用户的用户名是 "john"，那么波浪符号表示路径 `/home/john` 或 `/Users/john`，具体取决于您使用的是 Linux 还是 macOS。



### 环境变量相关命令

#### 查看环境变量

1. 使用 `echo` 命令： 打开终端应用程序（Terminal.app 或 iTerm2），然后输入以下命令，按回车键执行：

   ```
   echo $PATH  	显示环境变量 `PATH` 的值
   echo $HOME		显示环境变量 `HOME` 的值
   ```

   

2. 使用 `env` 命令： `env` 命令也可以用于显示所有环境变量的名称及其值。在终端中输入以下命令并按回车键执行：

   ```
   env
   ```





### 执行文件相关的命令

#### 方法一：赋予可执行权限

1. **赋予可执行权限（仅需要一次）**： 在终端中导航到包含 `build.sh` 文件的目录，并使用以下命令为文件添加可执行权限：

   ```
   chmod +x build.sh
   ```

   这会将可执行权限授予 `build.sh` 文件，使其可以在命令行中执行。

2. **运行 `build.sh` 文件**： 一旦 `build.sh` 文件具有了可执行权限，您可以通过在终端中输入以下命令来执行它：

   ```
   ./build.sh
   ```

请注意，可以是任意类型的可执行文件，比如一个 Shell 脚本、Python 脚本等。



#### 方法二：sh



#### 方法三：source

##### **source命令用法**

```
source FileName1
```

##### **source命令作用**

在当前bash环境下读取并执行FileName中的命令。source命令通常用于执行刚修改的初始化文档(如`.zshrc`)。

***注：该命令通常用命令“.”来替代。**





#### source filename 与 sh filename 及./filename执行脚本的区别

- 当shell脚本具有可执行权限时，用sh filename与./filename执行脚本是没有区别得。
- sh filename 重新建立一个子shell，在子shell中执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell。
- source filename：这个命令其实只是简单地读取脚本里面的语句依次在当前shell里面执行，没有建立新的子shell。那么脚本里面所有新建、改变变量的语句都会保存在当前shell里面。
  





## vscode配置

![image-20230428174510496](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-28-17-45-image-20230428174510496.png)





![image-20230428174809183](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-28-17-48-image-20230428174809183.png)









# Linux

## 操作系统

### 简介

管理和控制计算机系统中的硬件和软件资源，用于在用户与系统硬件之间传递信息。

操作系统对计算机进行了抽象，将所有输入输出设备抽象为文件。内核在进行文件I/O操作时，通过文件描述符进行管理，而文件描述符类似于应用程序与系统内核之间的凭证。应用程序如果需要进行I/O调用，需要先打开文件描述符，然后再根据文件描述符去实现文件的数据读写。















### 操作系统启动流程 

操作系统本身也是一个程序，是通过写死在主板中的程序实现开机时就执行这个操作系统的。在启动系统时，首先需要做的就是从外部存储器中读取OS。

![image-20230422114537126](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-45-image-20230422114537126.png)

### 计算机运行流程

1. 从内存读取指令。
2. 根据指令，将数据从内存读取到寄存器。
3. 基于寄存器上的数据进行运算。
4. 把运算结果写入内存。



### 程序

程序大体上分为以下几种：

●应用程序：能让用户直接使用，为用户提供帮助的程序，例如计算机上的办公软件、智能手机和平板电脑上的应用

●中间件：将对大部分应用程序通用的功能分离出来，以辅助应用程序运行的程序，例如Web服务器、数据库系统

●OS：直接控制硬件设备，同时为应用程序与中间件提供运行环境的程序。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-02-17-14-image-20240102171427543.png" alt="image-20240102171427543" style="zoom:33%;" />



通常情况下，程序在OS上以进程为单位运行。每个程序由一个或者多个进程构成。包括Linux在内的大部分OS能同时运行多个进程。













### 操作系统在计算机中扮演的角色

#### 调用外部设备

调用外部设备（以下简称“设备”）是Linux的一个重要功能。如果没有Linux这样的OS，就不得不为每个进程单独编写调用设备的代码（调用外部设备就是按照外部设备的说明文档输入相关的电信号）。会存在以下缺点：

●应用程序开发人员必须精通调用各种设备的方法

●开发成本高

●当多个进程同时调用设备时，会引起各种预料之外的问题

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-02-17-21-image-20240102172103590.png" alt="image-20240102172103590" style="zoom:33%;" />

为了解决上述问题，Linux把设备调用处理整合成了一个叫作设备驱动程序的程序，使进程通过设备驱动程序访问设备（图1-5）。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-15-33-image-20240103153327407.png" alt="image-20240103153327407" style="zoom:50%;" />



虽然世界上存在各种设备，但对于同一类型的设备，Linux可以通过同一个接口进行调用（图1-6）。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-15-34-image-20240103153412031.png" alt="image-20240103153412031" style="zoom:50%;" />







## [shell编程](#shell)



## linux版本

### 介绍

![image-20230422105935571](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-10-59-image-20230422105935571.png)





### 查看版本的命令

方法一：➜  ~ uname -a

方法二：➜  ~ cat /proc/version







## Linux基本组成

![image-20230422110857927](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-08-image-20230422110857927.png)



### Linux体系结构(内核与用户)

![image-20230422112059418](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-20-image-20230422112059418.png)



系统中既有操作系统的程序， 也有普通用户程序 。 为了安全性和稳定性， 操作系统的程序不能随便访问， 这就是内核态 。 即需要执行操作系统的程序就必须转换到内核态才能执行！内核态可以使用计算机所有的硬件资源！

CPU存在内核模式和用户模式两种模式，只有处于内核模式时才允许访问设备。

还有许多不应被普通进程调用的处理程序：

●进程管理系统●进程调度器●内存管理系统这些程序也全都在内核模式下运行。把这些在内核模式下运行的OS的核心处理整合在一起的程序就叫作内核。

内核负责管理计算机系统上的CPU和内存等各种资源，然后把这些资源按需分配给在系统上运行的各个进程。





### 系统调用

#### 介绍

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-17-19-image-20240103171916088.png" alt="image-20240103171916088" style="zoom:33%;" />

进程的系统调用：

![image-20230422115823067](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-58-image-20230422115823067.png)





#### 系统调用的种类

●进程控制（创建和删除）●内存管理（分配和释放）●进程间通信●网络管理●文件系统操作●文件操作（访问设备）



#### 发起系统调用

系统调用需要通过执行特殊的CPU命令来发起。通常进程运行在用户模式下，当通过系统调用向内核发送请求时，CPU会发生名为中断的事件。这时，CPU将从用户模式切换到内核模式，然后根据请求内容进行相应的处理。当内核处理完所有系统调用后，将重新回到用户模式，继续运行进程（图2-2）。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-17-25-image-20240103172512365.png" alt="image-20240103172512365" style="zoom:33%;" />

内核在开始进行处理时验证来自进程的请求是否合理（例如，请求的内存量是否大于系统所拥有的内存量等）。如果请求不合理，系统调用将执行失败。需要注意的是，并不存在用户进程绕过系统调用而直接切换CPU运行模式的方法（假如有，内核就失去存在的意义了）。



OS提供了一系列被称为系统调用的包装函数的函数，用于在系统内部发起系统调用。各种架构上都存在着对应的包装函数。因此，使用高级编程语言编写的用户程序，只需调用由高级编程语言提供的包装函数即可（图2-6）。



#### 跟系统调用相关的一些命令

了解进程究竟发起了哪些系统调用，可以通过strace命令对进程进行追踪。 -o选项，令其输出保存到指定的文件内。在strace命令后加上 -T选项，就能以微秒级的精度来采集各种系统调用所消耗的实际时间。





## 进程与线程

### 进程

#### 简介

![image-20230422113156117](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-31-image-20230422113156117.png)





#### 创建进程

在Linux中，创建进程有如下两个目的：

●将同一个程序分成多个进程进行处理。

●创建另一个程序（例如，从bash启动一个新的程序）。



两个目的分别对应两个方法：

- fork()：创建新进程的流程如下所示。① 为子进程申请内存空间，并复制父进程的内存到子进程的内存空间。② 父进程与子进程分裂成两个进程，以执行不同的代码。这一点的实现依赖于fork() 函数分别返回不同的值给父进程与子进程。在发起fork() 系统调用时，并非把父进程的所有内存数据复制给子进程，而是仅复制父进程的页表

  <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-57-image-20240103215710666.png" alt="image-20240103215710666" style="zoom:30%;" />

- execve() ：启动另一个程序。首先，我们来看一下内核在运行进程时的流程。① 读取可执行文件，并读取创建进程的内存映像所需的信息。② 用新进程的数据覆盖当前进程的内存。③ 从最初的命令开始运行新的进程。

  <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-17-08-image-20240103170832109.png" alt="image-20240103170832109" style="zoom:33%;" />

- 在打算新建一个别的进程时，通常采用被称为fork and exec的方式，即由父进程调用fork() 创建子进程，再由子进程调用exec()。

  <img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-17-10-image-20240103171003959.png" alt="image-20240103171003959" style="zoom:33%;" />





#### 进程调度(控单个逻辑CPU)

linux系统如何实现系统中运行的程序远远大于CPU的核数，就是靠进程调度（本质是在控进程里的线程）。

![image-20230422115156292](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-51-image-20230422115156292.png)





进程在被创建后的整个生命周期中，会不断地在运行态、就绪态和睡眠态之间辗转，并非简单地使用完分配到的CPU时间后就立刻结束。<mark>睡眠态的进程不会占用CPU时间。</mark>

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-16-14-image-20240103161454876.png" alt="image-20240103161454876" style="zoom:50%;" />



- 一个CPU同时只运行一个进程
- 在同时运行多个进程时，每个进程都会获得适当的时长，轮流在CPU上执行处理。
- 上下文切换是指切换正在逻辑CPU上运行的进程。当一个时间片被消耗完后，不管进程正在执行什么代码，都一定会发生上下文切换





#### 进程负载均衡(控多个逻辑CPU)

Linux会将多核CPU（现在几乎都是这样的CPU）上的每一个核心都识别为一个CPU。我们将系统识别出来的CPU（这里是指CPU核心）称为逻辑CPU。另外，在开启了超线程功能时，每一个线程都会被识别为一个逻辑CPU。为了能够利用各个逻辑CPU，调度器会运行一个被称为**负载均衡**或**全局调度**的功能。负载均衡负责公平地把进程分配给多个逻辑CPU。与只有单个逻辑CPU时的情况相同，在各个逻辑CPU内，调度器为在逻辑CPU上运行的各个进程分配均等的CPU时间。下图所示为在CPU0和CPU1这2个逻辑CPU变为空闲状态后，按顺序开始运行4个进程（进程0 ~进程3）时的情形。（一个进程一般只会在一个逻辑CPU上运行）

![](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-16-37-image-20240103163709719.png)









#### 注意：单个进程是否能在多个逻辑CPU上运行

```
单个进程是否能在多个逻辑CPU上运行，取决于该进程是否是多线程的。
如果进程只有一个线程（单线程），那么它只能在一个逻辑CPU上运行，因为线程是操作系统调度的最小单位，一个线程不能被拆分到多个CPU上执行。
如果进程是多线程的，那么它的不同线程可以被操作系统调度到不同的逻辑CPU上并行运行。这就是所谓的并行计算或多线程并发执行。这种情况下，一个多线程的进程可以利用多核CPU的并行计算能力，提高程序的执行效率。
需要注意的是，多线程并发执行需要操作系统的支持，而且编写多线程程序需要处理一些复杂的同步和并发问题，如数据竞争、死锁等。
```







#### 查看进程信息

![image-20230422113655657](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-11-36-image-20230422113655657.png)

使用ps ax命令可以按照一行一个进程的格式列举出系统中当前正在运行的所有进程。然后，根据执行该命令而输出的行数，就能直接得知正在运行的进程总数。



#### 运行时间和执行时间

通过time命令运行进程，就能得到进程从开始到结束所经过的时间，以及实际执行处理所消耗的时间。real的值为运行时间，user+sys为执行时间。user表示进程在用户模式下耗费的CPU时间。sys表示内核为了响应用户模式发出的请求而执行系统调用所耗费的时间。

●运行时间：进程从开始运行到运行结束为止所经过的时间。

●执行时间：进程实际占用逻辑CPU的时长

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-16-21-image-20240103162140174.png" alt="image-20240103162140174" style="zoom:75%;" />

 



#### 结束进程

进程运行结束后，如图3-7所示，所有分配给进程的内存将被回收。



#### 进程间通信IPC(Inter-Process Communication)

进程间通信可以通过以下几种方式来实现：

1. 管道（Pipe）：管道是一种简单的进程间通信方式，用于将一个进程的输出直接传递到另一个进程的输入。这是一种单向通信，只能从一个进程发送数据到另一个进程。
2. 共享内存（Shared Memory）：共享内存是一种高效的进程间通信方式，它通过在多个进程之间共享一块内存区域来传递数据。多个进程可以直接读写这块共享内存，从而实现数据的共享。
3. 消息队列（Message Queue）：消息队列是一种进程间通信方式，它将消息存储在一个队列中，不同进程可以通过读取和写入队列来传递信息。每个消息都有一个特定的类型，接收者可以根据消息类型选择处理哪些消息。
4. 套接字（Socket）：套接字是一种通用的进程间通信方式，它可以在本地或远程主机之间传递数据。套接字提供了一种可靠的、双向的、面向连接的通信机制，可以用于各种应用场景。
5. 信号（Signal）：信号是一种异步的进程间通信方式，它用于通知进程发生了某些事件，如错误、中断等。一个进程可以向另一个进程发送信号，接收者可以注册信号处理函数来处理信号。
6. RPC（Remote Procedure Call）：远程过程调用是一种高级的进程间通信方式，它允许一个进程调用另一个进程的函数，就像本地调用一样。通过 RPC，不同的进程可以共享和调用彼此的代码，从而实现更高级别的协作。





### 线程

#### 创建线程

```
创建线程的主要目的是为了实现并发执行，提高程序的执行效率和响应性。以下是一些具体的原因：

利用多核处理器：现代计算机通常有多个CPU核心，通过创建多个线程，可以让这些核心同时执行不同的任务，从而提高程序的执行效率。

提高响应性：在一些交互式应用中，可以通过创建一个单独的线程来处理用户输入，而其他线程继续执行其他任务。这样，即使主任务很耗时，用户的输入也能立即得到响应。

提高资源利用率：在I/O密集型应用中，一个线程在等待I/O操作完成时，其他线程可以继续执行计算任务，从而提高CPU和I/O设备的利用率。
```



### 进程和线程的关系

**进程是资源分配的最小单位，线程是CPU调度的最小单位。**

启动一个程序的时候，操作系统会为该程序创建==一块内存==，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫**进程**。

进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。



我们可以把一列火车理解为一个进程，一节车厢理解为一个线程。也就是说，线程必须在进程上执行。进程与进程之间是互不干涉的，好比一列火车由于故障停运了，并不影响另一列火车正常运行。如果线程坏了，那么进程也就崩溃了，好比一节车厢坏掉了，那么火车也就不能正常运行了。

**1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。**

**2. 线程之间共享进程中的数据。**

**3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。**

**4. 进程之间的内容相互隔离。**



### 决策创建一个进程or线程

```
创建进程和创建线程的选择取决于应用的需求和特性。以下是一些考虑因素：

创建进程：进程是操作系统分配资源的基本单位，每个进程都有自己独立的内存空间，进程之间的隔离性较好，互不影响。如果你的应用需要执行一些与其他任务完全独立的工作，或者需要更好的隔离和安全性，那么创建新的进程可能是一个好选择。例如，大多数Web服务器为每个客户端请求创建一个新的进程。

创建线程：线程是进程内部的执行单元，同一进程内的线程共享相同的内存空间，线程之间的切换开销小于进程。如果你的应用需要执行一些并发的任务，而这些任务需要共享一些状态或数据，那么创建新的线程可能更合适。例如，图形用户界面应用通常使用一个线程来处理用户输入，另一个线程来执行后台任务。
```



## 内存

### 介绍

在进程运行的过程中，各种数据会以内存为中心，在CPU上的寄存器或外部存储器等各种存储器之间进行交换。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-15-56-image-20240103155640884.png" alt="image-20240103155640884" style="zoom:50%;" />

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-15-57-image-20240103155735277.png" alt="image-20240103155735277" style="zoom:50%;" />



Linux通过内核中名为内存管理系统的功能来管理系统上搭载的所有内存。除了各种进程以外，内核本身也需要使用内存。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-16-28-image-20240103162811468.png" alt="image-20240103162811468" style="zoom:75%;" />





### 内存相关的统计信息

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEzLjM1MDUgMTIuMDgzMkgxMi4xMDQ3TDExLjU3MzggMTAuNTM0SDguNTI5NjhMNy45OTg4NCAxMi4wODMySDYuNzUzMDFMOS41ODA1MSA0LjM2OTg3SDEwLjUyM0wxMy4zNTA1IDEyLjA4MzJaTTExLjI0ODggOS41MzczN0wxMC4wNzg4IDYuMTE0MDRMOC44NzYzNCA5LjUzNzM3SDExLjI0ODhaTTEzLjMzMzQgMTMuNzVINi42NjY3NVYxNUgxMy4zMzM0VjEzLjc1WiIgZmlsbD0iIzk5QTBBQSIvPgo8L3N2Zz4K)

可以通过free命令获取系统搭载的内存总量和已消耗的内存量。$ freetotal   used     free shared  buff/cache availableMem:  32942000 337640 30641272  18392     1963088  32000464Swap:        0      0        0$这里对Mem: 这一行中的重要字段进行说明。需要注意的是，上面的所有数值的单位都为千字节（KB）。●total字段：系统搭载的物理内存总量。在上面的例子中约为32GB●free字段：表面上的可用内存量（详情请参考下面的available字段的说明）●buff/cache字段：缓冲区缓存与页面缓存（详见第6章）占用的内存。当系统的可用内存量（free字段的值）减少时，可通过内核将它们释放出来●available字段：实际的可用内存量。本字段的值为free字段的值加上当内存不足时内核中可释放的内存量。“可释放的内存”指缓冲区缓存与页面缓存中的大部分内存，以及内核中除此以外的用于其他地方的部分内存

 

![underline](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTAiIGN5PSIxMCIgcj0iMTAiIGZpbGw9IiM3Nzc3NzciIGZpbGwtb3BhY2l0eT0iMC4xNyIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTYuMjUgOC44MzkxOUM2LjI0OTUxIDYuMzM5MTkgOC4yNzM4MSA1LjAyOTY2IDEwLjA1OTUgNS4wMjk2NkMxMS44NDUyIDUuMDI5NjYgMTMuNjMxIDYuNjk2MzMgMTMuNjMxIDguMTI0OUMxMy42MzEgOC40MzQ3MyAxMy42NzkzIDguOTYyMjkgMTMuNzc2MSA5LjcwNzU2QzEzLjgyNzQgMTAuMTAzIDEzLjU5MTUgMTAuNDc5MyAxMy4yMTMyIDEwLjYwNTRMMTIuNzk3NiAxMC43NDM5VjEwLjkwNjhDMTIuNzk3NiAxMi4wNjY5IDExLjk5OTUgMTMuMDc0NiAxMC44NzAyIDEzLjM0MDNMMTAuNzczOCAxMy4zNjNWMTQuNTUzNUM5LjA3NDEzIDE0LjY3MTMgNy44ODM2NSAxNC4yNzQ1IDcuMjAyMzggMTMuMzYzQzcuMjAyMzggMTIuMTEyIDYuODg0OTIgMTAuNjA0MSA2LjI1IDguODM5MTlaTTkuNTIzODEgMTIuMzczTDEwLjU4MzkgMTIuMTIzNUMxMS4xNDg2IDExLjk5MDcgMTEuNTQ3NiAxMS40ODY4IDExLjU0NzYgMTAuOTA2OFY5Ljg0M0wxMi40OTM3IDkuNTI3NjRDMTIuNDE4OCA4LjkwNzM2IDEyLjM4MSA4LjQ0NjcgMTIuMzgxIDguMTI0OUMxMi4zODEgNy4zODE5NCAxMS4xNDA5IDYuMjc5NjYgMTAuMDU5NSA2LjI3OTY2QzguNzI0OSA2LjI3OTY2IDcuNjAwOTMgNy4yMTUyNSA3LjUwNjQzIDguNjQyMzVDOC4wNTcxOSAxMC4yMTk1IDguMzcwMjYgMTEuNjIyMiA4LjQzODI1IDEyLjg1ODlDOC42OTU5NCAxMy4wNjk0IDkuMDUyMDIgMTMuMjEzNCA5LjUyMzgxIDEzLjI4MDhWMTIuMzczWk0xMS45NjI0IDE0LjI3MDZDMTEuOTkyNSAxNC42MTQ1IDEyLjI5NTcgMTQuODY4OSAxMi42Mzk1IDE0LjgzODhDMTMuOTAwNCAxNC43Mjg1IDE0LjgzMyAxMy42MTY5IDE0LjcyMjcgMTIuMzU2MUMxNC42OTI3IDEyLjAxMjIgMTQuMzg5NSAxMS43NTc5IDE0LjA0NTYgMTEuNzg3OUMxMy43MDE4IDExLjgxOCAxMy40NDc0IDEyLjEyMTIgMTMuNDc3NSAxMi40NjVDMTMuNTI3NiAxMy4wMzgxIDEzLjEwMzcgMTMuNTQzNCAxMi41MzA2IDEzLjU5MzVDMTIuMTg2NyAxMy42MjM2IDExLjkzMjMgMTMuOTI2OCAxMS45NjI0IDE0LjI3MDZaIiBmaWxsPSIjOTlBMEFBIi8+Cjwvc3ZnPgo=)

转: kbmemfree：可用于使用的空闲内存量，单位为千字节。 kbmemused：已被系统使用的内存量，单位为千字节。 %memused：系统已使用的内存量占总内存量的百分比。 kbbuffers：用于缓存块设备的内存数量，单位为千字节。 kbcached：用于缓存文件系统的内存数量，单位为千字节。 kbcommit：已经提交的内存总量，单位为千字节。 %commit：已提交的内存总量占物理内存总量的百分比。 kbactive：当前正在使用且最近活跃的内存量，单位为千字节。 kbinact：最近未被访问的内存量，单位为千字节。 kbdirty：已被修改但尚未写回磁盘的内存量，单位为千字节。

5-2 可以通过free命令确认的信息 另外，使用sar -r命令，即可通过其第2个参数指定采集周期（在下面的例子中为1秒），对内存的相关信息进行采集。 $ sar -r 1 ( 略 ) 08:19:40 kbmemfree  kbmemused  %memused kbbuffers  kbcached ↵ kbcommit   %commit   kbactive   kbinact   kbdirty

![image-20240103163144977](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-16-31-image-20240103163144977.png)









### 内存不足（Out Of Memory，OOM）

随着内存使用量增加，可用内存变得越来越少。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-16-48-image-20240103164806775.png" alt="image-20240103164806775" style="zoom:67%;" />

在变成上图状态后，内存管理系统将回收内核中可释放的内存。如果内存使用量继续增加，系统就会陷入做什么都缺乏足够的内存，以至于无法运行的内存不足（Out Of Memory，OOM）状态。

如果是个人计算机，这可能并非什么大问题（而且个人计算机你也管不了，什么奇葩都有）；但如果是商用服务器，则完全不知道结束的是哪一个进程，这种状态非常令人困扰。虽然有办法令特定进程排除在OOM killer的选择范围之外，但是要在业务用的进程中筛选出允许强制结束的进程是非常困难的。因此，也有将服务器上的sysctl的vm.panic_on_oom参数从默认的0（在发生OOM时运行OOM killer）变更为1（在发生OOM时强制关闭系统）这样的做法。





### 分配内存

#### 分配内存的时机

内核为进程分配内存的时机大体上分为以下两种。●在创建进程时●在创建完进程后，动态分配内存时。



#### 虚拟内存

##### 介绍

虚拟内存使进程无法直接访问系统上搭载的内存，取而代之的是通过虚拟地址间接访问。进程可以看见的是**虚拟地址**，系统上搭载的内存的实际地址称为**物理地址**。此外，可以通过地址访问的范围称为**地址空间**。（我们在第3章中通过readelf命令或者cat /proc/[插图]/maps输出的地址也是虚拟地址。另外，进程无法直接访问真实的内存，也就是说不存在直接访问物理地址的方法。）

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-17-57-image-20240103175707296.png" alt="image-20240103175707296" style="zoom:33%;" />



如果没有虚拟内存则会：

- 内存碎片化：缺内存了就再要点、缺内存了就再要点，内存被切的很散不连续，通过虚拟内存，虽然落到物理内存上还是不连续的，但是在虚拟内存上即进程感知的还是连续的。
- 能访问到用于其他用途的内存区域





##### 页表

页表：用于从虚拟地址到物理地址的转换。

页表·被保存在内核使用的内存中。

在虚拟内存中，所有内存以页为单位划分并进行管理，地址转换也以页为单位进行。在页表中，一个页面对应的数据条目称为页表项。页表项记录着虚拟地址与物理地址的对应关系。页面大小取决于CPU架构。在x86_64架构中，页面大小为4KB。但为了便于说明，本书假设一个页面的大小为100字节。虚拟地址0 ~ 300映射到物理地址500 ~ 800的情形如图5-13所示。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-21-image-20240103212109825.png" alt="image-20240103212109825" style="zoom:33%;" />



访问300以后的虚拟地址，会发生什么呢？实际上，虚拟地址空间的大小是固定的，并且页表项中存在一个表示页面是否关联着物理内存的数据。虚拟地址空间的大小为500字节时的情形如图5-14所示。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-22-image-20240103212247867.png" alt="image-20240103212247867" style="zoom:30%;" />

如果进程访问地址300 ~ 500，则在CPU上会发生缺页中断。缺页中断可以中止正在执行的命令，并启动内核中的缺页中断机构的处理。内核的缺页中断机构检测到非法访问，向进程发送SIGSEGV信号。接收到该信号的进程通常会被强制结束运行。例如，在图5-14的状态下访问地址300时的情形如图5-15所示。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-23-image-20240103212346581.png" alt="image-20240103212346581" style="zoom:33%;" />





##### 给进程分配内存

###### 创建进程时

读取程序的可执行文件，以及第3章中说明过的辅助信息。假设可执行文件的结构如下表所示：

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-28-image-20240103212833080.png" alt="image-20240103212833080" style="zoom:50%;" />

运行程序所需的内存大小为：代码段的大小 + 数据段的大小 = 100 + 200= 300 。因此，在物理内存上划分出大小为300的区域，将其分配给进程，并把代码和数据复制过去（图5-16）。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-33-image-20240103213357127.png" alt="image-20240103213357127" style="zoom:30%;" />

在复制完成后，创建进程的页表，并把虚拟地址映射到物理地址。





实际上：首先，在创建进程时，在其虚拟地址空间中的与代码段和数据段对应的页面上，添加“已为进程分配该区域（页面）”这样的信息，但暂时不会分配物理内存。然后，在从入口点开始运行进程时，为入口点所属的页面分配物理内存。此时的处理流程如下所示。① 进程访问入口点。② CPU参照页表，筛选出入口点所属的页面中哪些虚拟地址未关联物理地址。③ 在CPU中引发缺页中断。④ 内核中的缺页中断机构为步骤①中访问的页面分配物理内存，并更新其页表。⑤ 回到用户模式，继续运行进程。另外，进程并不会感知到自身在运行时曾发生过缺页中断。此后，每当访问新的区域时，都如上述流程所示，先触发缺页中断，然后分配物理内存，并更新对应的页表



###### 动态分配内存

如果进程请求更多内存，内核将为其分配新的内存，创建相应的页表，然后把与新分配的内存（的物理地址）对应的虚拟地址返回给进程。在图5-17的状态下请求新的100字节内存时的情形如图5-19所示。

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-21-36-image-20240103213626742.png" alt="image-20240103213626742" style="zoom:30%;" />



## 存储层次

### 简介

<img src="https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2024-01-03-22-09-image-20240103220936029.png" alt="image-20240103220936029" style="zoom:30%;" />

计算机的运作流程（省略了从内存读取指令的部分）。① 根据指令，将数据从内存读取到寄存器。② 基于寄存器上的数据进行运算。③ 把运算结果写入内存。





### 高速缓存

高速缓存的存在，正是为了抹平寄存器与内存之间的性能差距。从高速缓存到寄存器的访问速度比从内存到寄存器的访问速度快了几倍甚至几十倍。高速缓存通常内置于CPU内，但也有位于CPU外的。





## 文件系统

### 简介

![image-20230422120437075](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-12-04-image-20230422120437075.png) 

文件系统以文件为单位管理所有对用户有实际意义的数据块，并为这些数据块添加上名称、位置和大小等辅助信息。它还规范了数据结构，以确定什么文件应该保存到什么位置，内核中的文件系统将依据该规范处理数据。多亏了文件系统的存在，用户不再需要记住所有数据在外部存储器中的位置与大小等繁杂的信息，只需要记住数据（即文件）的名称即可。



文件系统上存在两种数据类型，分别是数据与元数据。●数据：用户创建的文档、图片、视频和程序等数据内容●元数据：文件的名称、文件在外部存储器中的位置和文件大小等辅助信息

### 目录结构

![image-20230422120619065](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-12-06-image-20230422120619065.png)





### 虚拟文件系统（VFS）

#### 介绍

这么多不同的文件系统，实现对用户提供统一调用接口

![image-20230422131140369](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-13-11-image-20230422131140369.png)



### 文件读取流程

![image-20230422131831514](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-22-13-18-image-20230422131831514.png)











## 权限管理

### 用户权限 

用户账户：

- 普通用户账户：在系统中进行普通作业
- 超级用户账户：在系统中对普通用户和整个系统进行管理

用户组：

- 标准组： 可以容纳多个用户
- 私有组：只有用户自己







### 文件权限

![image-20230423101451672](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-23-10-14-image-20230423101451672.png)



## 软件包

![image-20230423102317561](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-23-10-23-image-20230423102317561.png)

![image-20230423102409735](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-23-10-24-image-20230423102409735.png)





### debian配置软件源

![image-20230423102745034](https://picbed-1306720359.cos.ap-guangzhou.myqcloud.com/upic/2023-04-23-10-27-image-20230423102745034.png)











# 软连接和硬连接

## [Linux](https://www.cnblogs.com/itech/archive/2009/04/10/1433052.html)

### 概念

Linux链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln命令产生硬链接。

【硬连接】
硬连接指通过索引节点来进行连接。在Linux的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。

【软连接】
另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于Windows的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。



###  软链接和硬链接的区别

硬链接只能链接文件，而软链接可以链接文件和目录。硬链接只能链接同一个文件系统中的文件，而软链接可以链接不同文件系统中的文件。删除源文件后，硬链接仍然可以使用，并且只有删除所有硬链接后，源文件才会真正被删除；而软链接在删除源文件后，链接会失效。

### 通过实验加深理解

```bash
[oracle@Linux]$ touch f1          #创建一个测试文件f1
[oracle@Linux]$ ln f1 f2          #创建f1的一个硬连接文件f2
[oracle@Linux]$ ln -s f1 f3       #创建f1的一个符号连接文件f3
[oracle@Linux]$ ls -li            # -i参数显示文件的inode节点信息
total 0
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2
9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -> f1

#从上面的结果中可以看出，硬连接文件f2与原文件f1的inode节点相同，均为9797648，然而符号连接文件的inode节点不同。

[oracle@Linux]$ echo "I am f1 file" >>f1
[oracle@Linux]$ cat f1
I am f1 file
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
I am f1 file
[oracle@Linux]$ rm -f f1
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
cat: f3: No such file or directory
#通过上面的测试可以看出：当删除原始文件f1后，硬连接f2不受影响，但是符号连接f1文件无效
```

## [window](https://www.cnblogs.com/Naylor/p/7597869.html)









# vim

## 退出

- 如果你没有做任何改变，输入 `:q`，然后按 Enter/return
- 如果你做了一些改变，并希望**保留**它们，输入 `:wq` 并按 Enter/return
- 如果你做了一些修改，并希望**放弃**它们，请输入 `:q!` 并按 Enter/return
